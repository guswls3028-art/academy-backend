====================================================================================================
# BACKEND APP: domains__assets
# ROOT PATH: C:\academy\apps\domains\assets
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/assets/apps.py
from django.apps import AppConfig


class AssetsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.assets"
    label = "assets"


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/domains/assets/urls.py
from django.urls import path, include

urlpatterns = [
    path("omr/", include("apps.domains.assets.omr.urls")),
]


==========================================================================================
# FILE: omr/__init__.py
==========================================================================================
# apps/domains/assets/omr/__init__.py


==========================================================================================
# FILE: omr/constants.py
==========================================================================================
from reportlab.lib.pagesizes import A4, landscape
from reportlab.lib.units import mm

# =========================
# PAGE
# =========================
PAGE_SIZE = landscape(A4)
PAGE_WIDTH, PAGE_HEIGHT = PAGE_SIZE

MARGIN_X = 12 * mm
MARGIN_Y = 12 * mm

# =========================
# GRID: LEFT 1 + RIGHT 3
# =========================
COL_COUNT = 4
COL_GAP = 6 * mm

COL_WIDTH = (PAGE_WIDTH - (MARGIN_X * 2) - (COL_GAP * (COL_COUNT - 1))) / COL_COUNT

COL1_X = MARGIN_X
COL2_X = COL1_X + COL_WIDTH + COL_GAP
COL3_X = COL2_X + COL_WIDTH + COL_GAP
COL4_X = COL3_X + COL_WIDTH + COL_GAP

# =========================
# LEFT COLUMN SECTIONS
# (left column is independent; just consumes its own width/height)
# =========================
LEFT_PAD = 3 * mm

LOGO_BOX_H = 28 * mm
EXAMINFO_BOX_H = 22 * mm
NAME_BOX_H = 18 * mm

# gap between left blocks
LEFT_BLOCK_GAP_1 = 6 * mm   # logo -> examinfo
LEFT_BLOCK_GAP_2 = 4 * mm   # examinfo -> name
LEFT_BLOCK_GAP_3 = 6 * mm   # name -> identifier

# =========================
# IDENTIFIER (8 digits, 0~9 bubbles)
# =========================
IDENT_TITLE_FONT_SIZE = 9
IDENT_NUM_FONT_SIZE = 8

IDENT_DIGITS = 8
IDENT_ROWS = 10  # 0~9
IDENT_BUBBLE_R = 2.4 * mm

# the identifier area auto-fills remaining height (computed in layout)
IDENT_DIGIT_RIGHT_PAD = 2 * mm
IDENT_EXTRA_RIGHT_GAP = 10 * mm  # same philosophy: labels left, marking right

# =========================
# OBJECTIVE QUESTIONS
# =========================
QUESTION_MAX = 45
ALLOWED_QUESTION_COUNTS = tuple(range(1, QUESTION_MAX + 1))

Q_FONT_SIZE = 9
Q_HEADER_FONT_SIZE = 9

Q_BUBBLE_R = 2.4 * mm
Q_CHOICE_COUNT = 5
Q_CHOICE_GAP = 9.0 * mm

Q_LEFT_PAD = 2 * mm
Q_RIGHT_PAD = 2 * mm

Q_ROWS_PER_COL = 15  # fixed: 1~15 / 16~30 / 31~45
Q_GROUP_SIZE = 5     # separator each 5

# question area vertical anchors (layout will fit exactly to bottom)
Q_HEADER_Y_PAD = 6 * mm    # header baseline from top margin
Q_TOP_PAD = 14 * mm        # top padding inside content area
Q_BOTTOM_PAD = 6 * mm      # bottom padding inside content area

# =========================
# LOGO UPLOAD VALIDATION
# =========================
ALLOWED_LOGO_CONTENT_TYPES = (
    "image/png",
    "image/jpeg",
    "image/jpg",
    "image/webp",
)


==========================================================================================
# FILE: omr/urls.py
==========================================================================================
# PATH: apps/domains/assets/omr/urls.py
from django.urls import path

from apps.domains.assets.omr.views.omr_pdf_views import (
    ObjectiveOMRPdfView,
    ObjectiveOMRMetaView,
)
from apps.domains.assets.omr.views.omr_save_views import ObjectiveOMRSaveView
from apps.domains.assets.omr.views.omr_list_views import ObjectiveOMRTemplateListView

urlpatterns = [
    path("objective/pdf/", ObjectiveOMRPdfView.as_view(), name="assets-omr-objective-pdf"),
    path("objective/meta/", ObjectiveOMRMetaView.as_view(), name="assets-omr-objective-meta"),
    path("objective/save/", ObjectiveOMRSaveView.as_view(), name="assets-omr-objective-save"),
    path(
        "objective/templates/",
        ObjectiveOMRTemplateListView.as_view(),
        name="assets-omr-objective-template-list",
    ),
]


==========================================================================================
# FILE: omr/layouts/__init__.py
==========================================================================================
# apps/domains/assets/omr/layouts/__init__.py


==========================================================================================
# FILE: omr/layouts/objective_v2_45.py
==========================================================================================
from __future__ import annotations

from reportlab.lib.units import mm

from apps.domains.assets.omr import constants as C


def draw(
    c,
    *,
    question_count: int,
    logo_reader=None,
    exam_title: str = "3월 모의고사",
    subject_round: str = "수학 (1회)",
) -> None:
    """
    Front page (Objective OMR)
    - 4 columns: left(logo/exam/name/identifier) + right 3 columns (1~15 / 16~30 / 31~45)
    - 5-question separators
    - print bubbles ONLY up to question_count; rest is blank
    """
    _draw_outer_frame(c)
    _draw_vertical_dividers(c)

    _draw_left_column(
        c,
        logo_reader=logo_reader,
        exam_title=exam_title,
        subject_round=subject_round,
    )

    _draw_objective_columns(c, question_count=question_count)


# =========================
# FRAME
# =========================
def _draw_outer_frame(c) -> None:
    c.setLineWidth(0.8)
    c.rect(
        C.MARGIN_X,
        C.MARGIN_Y,
        C.PAGE_WIDTH - 2 * C.MARGIN_X,
        C.PAGE_HEIGHT - 2 * C.MARGIN_Y,
    )


def _draw_vertical_dividers(c) -> None:
    # boundaries are at the midpoint of the gaps between columns
    c.setLineWidth(0.8)
    xs = [
        (C.COL2_X - (C.COL_GAP / 2)),
        (C.COL3_X - (C.COL_GAP / 2)),
        (C.COL4_X - (C.COL_GAP / 2)),
    ]
    for x in xs:
        c.line(x, C.MARGIN_Y, x, C.PAGE_HEIGHT - C.MARGIN_Y)


# =========================
# LEFT COLUMN (independent)
# =========================
def _draw_left_column(c, *, logo_reader, exam_title: str, subject_round: str) -> None:
    top = C.PAGE_HEIGHT - C.MARGIN_Y

    # --- Logo box
    logo_y = top - C.LOGO_BOX_H
    c.setLineWidth(0.8)
    c.rect(C.COL1_X, logo_y, C.COL_WIDTH, C.LOGO_BOX_H)

    c.setFont("Helvetica-Bold", 9)
    c.drawString(C.COL1_X + C.LEFT_PAD, logo_y + C.LOGO_BOX_H - 10, "로고")

    if logo_reader is not None:
        # preserve aspect ratio, fit inside box with padding
        c.drawImage(
            logo_reader,
            C.COL1_X + C.LEFT_PAD,
            logo_y + C.LEFT_PAD,
            width=C.COL_WIDTH - 2 * C.LEFT_PAD,
            height=C.LOGO_BOX_H - 2 * C.LEFT_PAD,
            preserveAspectRatio=True,
            anchor="c",
            mask="auto",
        )

    # --- Exam info box
    exam_y = logo_y - C.LEFT_BLOCK_GAP_1 - C.EXAMINFO_BOX_H
    c.rect(C.COL1_X, exam_y, C.COL_WIDTH, C.EXAMINFO_BOX_H)

    c.setFont("Helvetica-Bold", 9)
    c.drawString(C.COL1_X + C.LEFT_PAD, exam_y + C.EXAMINFO_BOX_H - 10, "시험명 / 과목")

    c.setFont("Helvetica", 10)
    c.drawString(C.COL1_X + C.LEFT_PAD, exam_y + C.EXAMINFO_BOX_H - 24, str(exam_title))
    c.drawString(C.COL1_X + C.LEFT_PAD, exam_y + C.EXAMINFO_BOX_H - 38, str(subject_round))

    # --- Name box
    name_y = exam_y - C.LEFT_BLOCK_GAP_2 - C.NAME_BOX_H
    c.rect(C.COL1_X, name_y, C.COL_WIDTH, C.NAME_BOX_H)

    c.setFont("Helvetica-Bold", 9)
    c.drawString(C.COL1_X + C.LEFT_PAD, name_y + C.NAME_BOX_H - 10, "이름")

    # writing line (right side is the “input area”)
    c.setLineWidth(0.6)
    c.line(
        C.COL1_X + C.LEFT_PAD,
        name_y + 6 * mm,
        C.COL1_X + C.COL_WIDTH - C.LEFT_PAD,
        name_y + 6 * mm,
    )
    c.setLineWidth(0.8)

    # --- Identifier area fills to bottom margin
    ident_top = name_y - C.LEFT_BLOCK_GAP_3
    ident_bottom = C.MARGIN_Y
    ident_h = ident_top - ident_bottom

    c.rect(C.COL1_X, ident_bottom, C.COL_WIDTH, ident_h)

    c.setFont("Helvetica-Bold", C.IDENT_TITLE_FONT_SIZE)
    c.drawString(
        C.COL1_X + C.LEFT_PAD,
        ident_top - 10,
        "수험번호 OMR (휴대폰 8자리, 010 제외)",
    )

    # compute row gap to fill area nicely
    # reserve a small title area at the top of identifier box
    title_reserved = 12 * mm
    usable_h = max(1.0, ident_h - title_reserved - 6 * mm)
    row_gap = usable_h / (C.IDENT_ROWS - 1)

    # right-aligned digit columns (marking area)
    bubble_right = C.COL1_X + C.COL_WIDTH - C.IDENT_DIGIT_RIGHT_PAD
    col_gap = (C.COL_WIDTH - 22 * mm) / max(1, (C.IDENT_DIGITS - 1))
    total_digits_w = (C.IDENT_DIGITS - 1) * col_gap
    digits_left = bubble_right - total_digits_w - C.IDENT_EXTRA_RIGHT_GAP

    c.setFont("Helvetica", C.IDENT_NUM_FONT_SIZE)
    for n in range(10):
        y = ident_bottom + 6 * mm + (9 - n) * row_gap
        # labels (left aligned)
        c.drawString(C.COL1_X + C.LEFT_PAD, y - 2 * mm, str(n))
        # bubbles (right aligned)
        for d in range(C.IDENT_DIGITS):
            x = digits_left + d * col_gap
            c.circle(x, y, C.IDENT_BUBBLE_R)


# =========================
# RIGHT 3 COLUMNS (objective)
# =========================
def _question_bubbles_start_x(col_x: float) -> float:
    right_edge = col_x + C.COL_WIDTH - C.Q_RIGHT_PAD
    total_choice_width = (C.Q_CHOICE_COUNT - 1) * C.Q_CHOICE_GAP
    return right_edge - total_choice_width


def _question_area_y_bounds() -> tuple[float, float]:
    top = C.PAGE_HEIGHT - C.MARGIN_Y - C.Q_TOP_PAD
    bottom = C.MARGIN_Y + C.Q_BOTTOM_PAD
    return top, bottom


def _draw_objective_columns(c, *, question_count: int) -> None:
    c.setFont("Helvetica", C.Q_FONT_SIZE)

    _draw_objective_one_col(c, col_x=C.COL2_X, start_q=1, question_count=question_count)
    _draw_objective_one_col(c, col_x=C.COL3_X, start_q=16, question_count=question_count)
    _draw_objective_one_col(c, col_x=C.COL4_X, start_q=31, question_count=question_count)


def _draw_objective_one_col(c, *, col_x: float, start_q: int, question_count: int) -> None:
    # header
    c.setFont("Helvetica-Bold", C.Q_HEADER_FONT_SIZE)
    header = f"{start_q} ~ {start_q + (C.Q_ROWS_PER_COL - 1)}"
    c.drawCentredString(col_x + C.COL_WIDTH / 2, C.PAGE_HEIGHT - C.MARGIN_Y - C.Q_HEADER_Y_PAD, header)

    # row geometry (fills down to bottom with no weird leftover)
    top, bottom = _question_area_y_bounds()
    row_gap = (top - bottom) / (C.Q_ROWS_PER_COL - 1)

    bx0 = _question_bubbles_start_x(col_x)

    c.setFont("Helvetica", C.Q_FONT_SIZE)

    y = top
    for idx in range(C.Q_ROWS_PER_COL):
        qnum = start_q + idx

        # only draw up to question_count; rest stays blank
        if qnum <= question_count:
            # number (left aligned)
            c.drawString(col_x + C.Q_LEFT_PAD, y - 2 * mm, str(qnum))
            # bubbles (right aligned)
            for k in range(C.Q_CHOICE_COUNT):
                c.circle(bx0 + k * C.Q_CHOICE_GAP, y, C.Q_BUBBLE_R)

        # separator after each 5 questions (except after last)
        if idx in (C.Q_GROUP_SIZE - 1, 2 * C.Q_GROUP_SIZE - 1):
            c.setLineWidth(0.6)
            c.line(col_x + C.Q_LEFT_PAD, y - (row_gap / 2), col_x + C.COL_WIDTH - C.Q_LEFT_PAD, y - (row_gap / 2))
            c.setLineWidth(0.8)

        y -= row_gap


==========================================================================================
# FILE: omr/layouts/subjective_v2.py
==========================================================================================
from __future__ import annotations

from reportlab.lib.units import mm

from apps.domains.assets.omr import constants as C


def draw(c, *, line_count: int = 10, title: str = "서술형 답안지") -> None:
    """
    Back page (Subjective)
    - label left aligned
    - writing area right aligned
    - fixed A4 landscape, black&white
    """
    # frame
    c.setLineWidth(0.8)
    c.rect(
        C.MARGIN_X,
        C.MARGIN_Y,
        C.PAGE_WIDTH - 2 * C.MARGIN_X,
        C.PAGE_HEIGHT - 2 * C.MARGIN_Y,
    )

    c.setFont("Helvetica-Bold", 14)
    c.drawString(C.MARGIN_X, C.PAGE_HEIGHT - C.MARGIN_Y - 18, title)

    c.setFont("Helvetica", 10)
    top = C.PAGE_HEIGHT - C.MARGIN_Y - 32
    bottom = C.MARGIN_Y + 10 * mm

    # distribute evenly
    gap = (top - bottom) / max(1, line_count)

    y = top
    for i in range(1, line_count + 1):
        c.setFont("Helvetica-Bold", 10)
        c.drawString(C.MARGIN_X, y, f"{i}.")  # label left

        # writing line right
        c.setLineWidth(0.6)
        c.line(C.MARGIN_X + 12 * mm, y, C.PAGE_WIDTH - C.MARGIN_X, y)
        c.setLineWidth(0.8)

        y -= gap


==========================================================================================
# FILE: omr/services/__init__.py
==========================================================================================
# apps/domains/assets/omr/services/__init__.py


==========================================================================================
# FILE: omr/services/meta_generator.py
==========================================================================================
from __future__ import annotations

from typing import Dict, List

from reportlab.lib.units import mm

from apps.domains.assets.omr import constants as C


def _pt_to_mm(v_pt: float) -> float:
    return float(v_pt) / float(mm)


def _mm_point(x_pt: float, y_pt: float) -> Dict[str, float]:
    return {"x": _pt_to_mm(x_pt), "y": _pt_to_mm(y_pt)}


def _mm_box(x_pt: float, y_pt: float, w_pt: float, h_pt: float) -> Dict[str, float]:
    return {"x": _pt_to_mm(x_pt), "y": _pt_to_mm(y_pt), "w": _pt_to_mm(w_pt), "h": _pt_to_mm(h_pt)}


def _choices_labels() -> List[str]:
    return ["A", "B", "C", "D", "E"]


def _question_bubbles_start_x(col_x: float) -> float:
    right_edge = col_x + C.COL_WIDTH - C.Q_RIGHT_PAD
    total_choice_width = (C.Q_CHOICE_COUNT - 1) * C.Q_CHOICE_GAP
    return right_edge - total_choice_width


def _question_area_y_bounds() -> tuple[float, float]:
    top = C.PAGE_HEIGHT - C.MARGIN_Y - C.Q_TOP_PAD
    bottom = C.MARGIN_Y + C.Q_BOTTOM_PAD
    return top, bottom


def build_objective_template_meta(*, question_count: int) -> Dict:
    """
    Objective meta for the NEW layout:
    - units: mm
    - 4 columns: left identifier + right 3 objective columns
    - objective questions are laid out as:
      col2: 1~15, col3: 16~30, col4: 31~45
    - IMPORTANT: only includes questions up to question_count; others are omitted.
    """
    if question_count not in C.ALLOWED_QUESTION_COUNTS:
        raise ValueError("invalid question_count")

    # -------------------------
    # Identifier bubbles (computed same philosophy: labels left, marking right)
    # -------------------------
    # We mirror layout math:
    # ident area is dynamic; for meta we compute using same formula as layout
    # so worker can rely on it for grading.
    top = C.PAGE_HEIGHT - C.MARGIN_Y
    logo_y = top - C.LOGO_BOX_H
    exam_y = logo_y - C.LEFT_BLOCK_GAP_1 - C.EXAMINFO_BOX_H
    name_y = exam_y - C.LEFT_BLOCK_GAP_2 - C.NAME_BOX_H

    ident_top = name_y - C.LEFT_BLOCK_GAP_3
    ident_bottom = C.MARGIN_Y
    ident_h = ident_top - ident_bottom

    title_reserved = 12 * mm
    usable_h = max(1.0, ident_h - title_reserved - 6 * mm)
    row_gap = usable_h / (C.IDENT_ROWS - 1)

    bubble_right = C.COL1_X + C.COL_WIDTH - C.IDENT_DIGIT_RIGHT_PAD
    col_gap = (C.COL_WIDTH - 22 * mm) / max(1, (C.IDENT_DIGITS - 1))
    total_digits_w = (C.IDENT_DIGITS - 1) * col_gap
    digits_left = bubble_right - total_digits_w - C.IDENT_EXTRA_RIGHT_GAP

    ident_bubbles: List[Dict] = []
    for n in range(10):
        y_pt = ident_bottom + 6 * mm + (9 - n) * row_gap
        for d in range(C.IDENT_DIGITS):
            x_pt = digits_left + d * col_gap
            ident_bubbles.append(
                {
                    "digit_index": int(d + 1),  # 1..8
                    "number": int(n),           # 0..9
                    "center": _mm_point(x_pt, y_pt),
                    "r": _pt_to_mm(C.IDENT_BUBBLE_R),
                }
            )

    identifier_meta = {
        "digits": int(C.IDENT_DIGITS),
        "numbers": list(range(10)),
        "bubbles": ident_bubbles,
    }

    # -------------------------
    # Questions bubbles + ROI
    # -------------------------
    top_y, bottom_y = _question_area_y_bounds()
    row_gap_q = (top_y - bottom_y) / (C.Q_ROWS_PER_COL - 1)

    roi_pad_pt = 2 * mm
    labels = _choices_labels()

    def build_col(col_x: float, start_q: int, rows: int) -> List[Dict]:
        bx0 = _question_bubbles_start_x(col_x)
        y_pt = top_y
        out: List[Dict] = []

        for i in range(rows):
            qnum = start_q + i
            if qnum > question_count:
                y_pt -= row_gap_q
                continue

            xs = []
            ys = []
            choice_bubbles = []
            for k, label in enumerate(labels):
                cx = bx0 + k * C.Q_CHOICE_GAP
                cy = y_pt
                xs.append(cx)
                ys.append(cy)
                choice_bubbles.append(
                    {
                        "label": label,
                        "center": _mm_point(cx, cy),
                        "r": _pt_to_mm(C.Q_BUBBLE_R),
                    }
                )

            left = min(xs) - C.Q_BUBBLE_R - roi_pad_pt
            right = max(xs) + C.Q_BUBBLE_R + roi_pad_pt
            bottom = min(ys) - C.Q_BUBBLE_R - roi_pad_pt
            topb = max(ys) + C.Q_BUBBLE_R + roi_pad_pt

            out.append(
                {
                    "question_number": int(qnum),
                    "axis": "x",
                    "choices": choice_bubbles,
                    "roi": _mm_box(left, bottom, right - left, topb - bottom),
                }
            )

            y_pt -= row_gap_q

        return out

    questions: List[Dict] = []
    questions += build_col(C.COL2_X, 1, C.Q_ROWS_PER_COL)
    questions += build_col(C.COL3_X, 16, C.Q_ROWS_PER_COL)
    questions += build_col(C.COL4_X, 31, C.Q_ROWS_PER_COL)

    meta = {
        "version": "objective_v2_45",
        "units": "mm",
        "question_count": int(question_count),
        "page": {
            "orientation": "landscape",
            "size": {"width": _pt_to_mm(C.PAGE_WIDTH), "height": _pt_to_mm(C.PAGE_HEIGHT)},
        },
        "identifier": identifier_meta,
        "questions": questions,
    }
    return meta


==========================================================================================
# FILE: omr/services/pdf_generator.py
==========================================================================================
from __future__ import annotations

from io import BytesIO
from typing import Optional

from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader

from apps.domains.assets.omr import constants as C
from apps.domains.assets.omr.layouts.objective_v2_45 import draw as draw_objective
from apps.domains.assets.omr.layouts.subjective_v2 import draw as draw_subjective


class LogoValidationError(Exception):
    pass


def _build_logo_reader(logo_file) -> Optional[ImageReader]:
    if logo_file is None:
        return None
    try:
        try:
            logo_file.seek(0)
        except Exception:
            pass
        reader = ImageReader(logo_file)
        _ = reader.getSize()
        return reader
    except Exception as e:
        raise LogoValidationError("logo must be a valid image file") from e


def generate_objective_pdf(
    *,
    question_count: int,
    logo_file=None,
    exam_title: str = "3월 모의고사",
    subject_round: str = "수학 (1회)",
) -> bytes:
    """
    Generates 2-page PDF:
      - Page1: objective OMR (new agreed layout)
      - Page2: subjective lines (simple back page)
    """
    if question_count not in C.ALLOWED_QUESTION_COUNTS:
        raise ValueError("invalid question_count")

    logo_reader = _build_logo_reader(logo_file)

    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=C.PAGE_SIZE)

    # page 1
    draw_objective(
        c,
        question_count=question_count,
        logo_reader=logo_reader,
        exam_title=exam_title,
        subject_round=subject_round,
    )
    c.showPage()

    # page 2
    draw_subjective(c, line_count=10, title="서술형 답안지")
    c.save()

    buf.seek(0)
    return buf.read()


==========================================================================================
# FILE: omr/views/__init__.py
==========================================================================================
# apps/domains/assets/omr/views/__init__.py


==========================================================================================
# FILE: omr/views/omr_list_views.py
==========================================================================================
# PATH: apps/domains/assets/omr/views/omr_list_views.py
from __future__ import annotations

from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from apps.domains.exams.models import ExamAsset


class ObjectiveOMRTemplateListView(APIView):
    """
    GET /api/v1/assets/omr/objective/templates/

    query params (optional):
      - exam_id: int

    response:
      [
        {
          "asset_id": number,
          "exam_id": number,
          "question_count": 10 | 20 | 30,
          "version": "objective_v1",
          "has_logo": bool,
          "file_url": string
        }
      ]

    책임:
    - assets 범위 내 "저장된 OMR 양식" 조회만 담당
    - 시험/채점/결과 로직 관여 ❌
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        qs = ExamAsset.objects.filter(asset_type="OMR_TEMPLATE").order_by("-id")

        exam_id_raw = request.query_params.get("exam_id")
        if exam_id_raw:
            try:
                exam_id = int(str(exam_id_raw).strip())
                qs = qs.filter(exam_id=exam_id)
            except Exception:
                return Response({"exam_id": "must be an integer"}, status=400)

        items = []
        for asset in qs:
            meta = asset.meta or {}
            items.append(
                {
                    "asset_id": asset.id,
                    "exam_id": asset.exam_id,
                    "question_count": meta.get("question_count"),
                    "version": meta.get("version"),
                    "has_logo": bool(meta.get("has_logo")),
                    "file_url": asset.file.url if asset.file else None,
                }
            )

        return Response(items, status=200)


==========================================================================================
# FILE: omr/views/omr_pdf_views.py
==========================================================================================
from __future__ import annotations

from django.http import HttpResponse
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from apps.domains.assets.omr import constants as C
from apps.domains.assets.omr.services.pdf_generator import (
    generate_objective_pdf,
    LogoValidationError,
)
from apps.domains.assets.omr.services.meta_generator import build_objective_template_meta


class ObjectiveOMRPdfView(APIView):
    """
    POST /api/v1/assets/omr/objective/pdf/
    multipart/form-data:
      - question_count: 1..45 (required)
      - logo: optional image
    response:
      - application/pdf (download)
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        qc_raw = request.data.get("question_count", None)
        if qc_raw is None:
            return Response({"question_count": "required"}, status=400)

        try:
            question_count = int(str(qc_raw).strip())
        except Exception:
            return Response({"question_count": "must be an integer (1~45)"}, status=400)

        if question_count not in C.ALLOWED_QUESTION_COUNTS:
            return Response({"question_count": "must be between 1 and 45"}, status=400)

        logo = request.FILES.get("logo")
        if logo is not None:
            ctype = getattr(logo, "content_type", "") or ""
            if ctype and ctype not in C.ALLOWED_LOGO_CONTENT_TYPES:
                return Response({"logo": f"unsupported content_type: {ctype}"}, status=415)

        try:
            pdf_bytes = generate_objective_pdf(question_count=question_count, logo_file=logo)
        except LogoValidationError as e:
            return Response({"logo": str(e)}, status=400)
        except ValueError:
            return Response({"question_count": "must be between 1 and 45"}, status=400)

        resp = HttpResponse(pdf_bytes, content_type="application/pdf")
        resp["Content-Disposition"] = f'attachment; filename="omr_objective_v2_{question_count}.pdf"'
        return resp


class ObjectiveOMRMetaView(APIView):
    """
    GET /api/v1/assets/omr/objective/meta/?question_count=1..45
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        qc_raw = request.query_params.get("question_count")
        if qc_raw is None:
            return Response({"question_count": "required"}, status=400)

        try:
            question_count = int(str(qc_raw).strip())
        except Exception:
            return Response({"question_count": "must be an integer (1~45)"}, status=400)

        if question_count not in C.ALLOWED_QUESTION_COUNTS:
            return Response({"question_count": "must be between 1 and 45"}, status=400)

        try:
            meta = build_objective_template_meta(question_count=question_count)
        except ValueError:
            return Response({"question_count": "must be between 1 and 45"}, status=400)

        return Response(meta, status=200)


==========================================================================================
# FILE: omr/views/omr_save_views.py
==========================================================================================
from __future__ import annotations

from django.core.files.base import ContentFile
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from apps.domains.assets.omr import constants as C
from apps.domains.assets.omr.services.pdf_generator import (
    LogoValidationError,
    generate_objective_pdf,
)

from apps.domains.exams.models import Exam, ExamAsset


class ObjectiveOMRSaveView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        exam_id_raw = request.data.get("exam_id")
        qc_raw = request.data.get("question_count")

        if exam_id_raw is None:
            return Response({"exam_id": "required"}, status=400)
        if qc_raw is None:
            return Response({"question_count": "required"}, status=400)

        try:
            exam_id = int(str(exam_id_raw).strip())
        except Exception:
            return Response({"exam_id": "must be an integer"}, status=400)

        try:
            question_count = int(str(qc_raw).strip())
        except Exception:
            return Response({"question_count": "must be an integer (1~45)"}, status=400)

        if question_count not in C.ALLOWED_QUESTION_COUNTS:
            return Response({"question_count": "must be between 1 and 45"}, status=400)

        try:
            exam = Exam.objects.get(id=exam_id)
        except Exam.DoesNotExist:
            return Response({"exam_id": "not found"}, status=404)

        logo = request.FILES.get("logo")
        if logo is not None:
            ctype = getattr(logo, "content_type", "") or ""
            if ctype and ctype not in C.ALLOWED_LOGO_CONTENT_TYPES:
                return Response({"logo": f"unsupported content_type: {ctype}"}, status=415)

        try:
            pdf_bytes = generate_objective_pdf(question_count=question_count, logo_file=logo)
        except LogoValidationError as e:
            return Response({"logo": str(e)}, status=400)

        filename = f"omr_objective_v2_{question_count}.pdf"

        asset = ExamAsset.objects.create(
            exam=exam,
            asset_type="OMR_TEMPLATE",
            meta={
                "version": "objective_v2_45",
                "question_count": int(question_count),
                "has_logo": bool(logo is not None),
            },
        )

        asset.file.save(filename, ContentFile(pdf_bytes), save=True)

        return Response(
            {"asset_id": asset.id, "asset_type": asset.asset_type, "exam_id": exam.id},
            status=201,
        )
