====================================================================================================
# BACKEND APP: domains__staffs
# ROOT PATH: C:\academy\apps\domains\staffs
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig

class StaffsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.staffs"  # âœ…


==========================================================================================
# FILE: filters.py
==========================================================================================
import django_filters
from django.db.models import Q

from .models import Staff, WorkRecord, ExpenseRecord


class StaffFilter(django_filters.FilterSet):
    search = django_filters.CharFilter(method="filter_search")
    is_active = django_filters.BooleanFilter()
    is_manager = django_filters.BooleanFilter()
    pay_type = django_filters.CharFilter()

    class Meta:
        model = Staff
        fields = ["is_active", "is_manager", "pay_type"]

    def filter_search(self, queryset, name, value):
        return queryset.filter(
            Q(name__icontains=value) |
            Q(phone__icontains=value)
        )


class WorkRecordFilter(django_filters.FilterSet):
    date_from = django_filters.DateFilter(field_name="date", lookup_expr="gte")
    date_to = django_filters.DateFilter(field_name="date", lookup_expr="lte")

    class Meta:
        model = WorkRecord
        fields = ["staff", "work_type", "date_from", "date_to"]


class ExpenseRecordFilter(django_filters.FilterSet):
    date_from = django_filters.DateFilter(field_name="date", lookup_expr="gte")
    date_to = django_filters.DateFilter(field_name="date", lookup_expr="lte")
    status = django_filters.CharFilter()

    class Meta:
        model = ExpenseRecord
        fields = ["staff", "status", "date_from", "date_to"]


==========================================================================================
# FILE: models.py
==========================================================================================
# PATH: apps/domains/staffs/models.py
from datetime import datetime, timedelta
from decimal import Decimal

from django.conf import settings
from django.db import models
from django.core.exceptions import ValidationError

from apps.api.common.models import TimestampModel
from apps.core.models import Tenant
from apps.core.db import TenantQuerySet


# ======================================================
# Payroll Calculation Policies (Enterprise Level)
# ======================================================

class WorkHourCalculationPolicy:
    """
    ê·¼ë¬´ ì‹œê°„ ê³„ì‚° ì •ì±…
    - ì‹œê°„ ì™œê³¡ ê¸ˆì§€
    - íœ´ê²Œì‹œê°„ì€ ë¶„ ë‹¨ìœ„ë¡œ ì°¨ê°
    """

    @staticmethod
    def calculate(date, start_time, end_time, break_minutes) -> Decimal:
        start_dt = datetime.combine(date, start_time)
        end_dt = datetime.combine(date, end_time)
        if end_dt < start_dt:
            end_dt += timedelta(days=1)

        total_minutes = (end_dt - start_dt).total_seconds() / 60
        total_minutes = max(0, total_minutes - break_minutes)

        return Decimal(total_minutes / 60).quantize(Decimal("0.01"))


class WageResolutionPolicy:
    """
    ë‹¨ê°€ ê²°ì • ì •ì±…
    """

    @staticmethod
    def resolve(*, tenant, staff, work_type) -> int:
        from .models import StaffWorkType

        try:
            swt = StaffWorkType.objects.get(
                tenant=tenant,
                staff=staff,
                work_type=work_type,
            )
            return swt.effective_hourly_wage
        except StaffWorkType.DoesNotExist:
            return work_type.base_hourly_wage


class PayrollAmountPolicy:
    """
    ê¸ˆì•¡ ê³„ì‚° ì •ì±…
    """

    @staticmethod
    def calculate(hours: Decimal, hourly_wage: int) -> int:
        return int(hours * Decimal(hourly_wage))


# ======================================================
# Domain Models
# ======================================================

class Staff(TimestampModel):
    """
    ì§ì› / ê°•ì‚¬
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="staffs",
    )

    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="staff_profile",
    )

    name = models.CharField(max_length=100)
    phone = models.CharField(max_length=20, blank=True)

    is_active = models.BooleanField(default=True)
    is_manager = models.BooleanField(default=False)

    PAY_TYPE_CHOICES = (
        ("HOURLY", "ì‹œê¸‰"),
        ("MONTHLY", "ì›”ê¸‰"),
    )
    pay_type = models.CharField(
        max_length=20,
        choices=PAY_TYPE_CHOICES,
        default="HOURLY",
    )

    def __str__(self) -> str:
        return self.name


class WorkType(TimestampModel):
    """
    ê¸‰ì—¬ ë¸”ë¡
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="work_types",
    )

    name = models.CharField(max_length=100)
    base_hourly_wage = models.PositiveIntegerField(default=0)

    color = models.CharField(
        max_length=7,
        default="#4CAF50",
        help_text="HEX ìƒ‰ìƒ ì½”ë“œ",
    )
    description = models.TextField(blank=True)
    is_active = models.BooleanField(default=True)

    def __str__(self) -> str:
        return self.name


class StaffWorkType(TimestampModel):
    """
    Staff â†” WorkType ì—°ê²°
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="staff_work_types",
    )

    staff = models.ForeignKey(
        Staff,
        on_delete=models.CASCADE,
        related_name="staff_work_types",
    )
    work_type = models.ForeignKey(
        WorkType,
        on_delete=models.CASCADE,
        related_name="staff_work_types",
    )

    hourly_wage = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="ë¹„ìš°ë©´ WorkType ê¸°ë³¸ ë‹¨ê°€",
    )

    class Meta:
        unique_together = ("tenant", "staff", "work_type")

    @property
    def effective_hourly_wage(self) -> int:
        return self.hourly_wage or self.work_type.base_hourly_wage

    def __str__(self) -> str:
        return f"{self.staff.name} - {self.work_type.name}"


class WorkRecord(TimestampModel):
    """
    ê·¼ë¬´ ì‚¬ì‹¤(Fact)
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="work_records",
    )

    staff = models.ForeignKey(
        Staff,
        on_delete=models.CASCADE,
        related_name="work_records",
    )
    work_type = models.ForeignKey(
        WorkType,
        on_delete=models.PROTECT,
        related_name="work_records",
    )

    date = models.DateField()
    start_time = models.TimeField()
    end_time = models.TimeField(null=True, blank=True)
    break_minutes = models.PositiveIntegerField(default=0)

    # âœ… ì›ë³¸ì— ìˆì—ˆë˜ í•„ë“œ ë³µêµ¬
    current_break_started_at = models.DateTimeField(null=True, blank=True)

    work_hours = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
    )
    amount = models.PositiveIntegerField(
        null=True,
        blank=True,
    )

    # âœ… ì›ë³¸ì— ìˆì—ˆë˜ í•„ë“œ ë³µêµ¬
    resolved_hourly_wage = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="ê¸‰ì—¬ ê³„ì‚°ì— ì‹¤ì œ ì‚¬ìš©ëœ ì‹œê¸‰",
    )

    memo = models.TextField(blank=True)

    class Meta:
        ordering = ["-date", "-start_time"]

    def calculate_payroll(self):
        hours = WorkHourCalculationPolicy.calculate(
            self.date,
            self.start_time,
            self.end_time,
            self.break_minutes,
        )

        wage = WageResolutionPolicy.resolve(
            tenant=self.tenant,
            staff=self.staff,
            work_type=self.work_type,
        )

        amount = PayrollAmountPolicy.calculate(hours, wage)
        return hours, amount, wage

    def save(self, *args, **kwargs):
        if self.end_time and (self.work_hours is None or self.amount is None):
            self.work_hours, self.amount, self.resolved_hourly_wage = self.calculate_payroll()
        super().save(*args, **kwargs)


# ======================================================
# â†“â†“â†“ ì›ë³¸ì— ìˆì—ˆë˜ í•˜ë‹¨ ëª¨ë¸ë“¤ ë³µêµ¬ â†“â†“â†“
# ======================================================

class ExpenseRecord(TimestampModel):
    """
    ê¸°íƒ€ ë¹„ìš© (ìŠ¹ì¸ ì›Œí¬í”Œë¡œìš° í¬í•¨)
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="expense_records",
    )

    staff = models.ForeignKey(
        Staff,
        on_delete=models.CASCADE,
        related_name="expense_records",
    )

    date = models.DateField()
    title = models.CharField(max_length=255)
    amount = models.PositiveIntegerField()
    memo = models.TextField(blank=True)

    STATUS_CHOICES = (
        ("PENDING", "ëŒ€ê¸°"),
        ("APPROVED", "ìŠ¹ì¸"),
        ("REJECTED", "ë°˜ë ¤"),
    )
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default="PENDING",
    )

    approved_at = models.DateTimeField(null=True, blank=True)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="approved_expenses",
    )

    class Meta:
        ordering = ["-date", "-created_at"]

    def __str__(self) -> str:
        return f"{self.staff.name} - {self.title}"


class WorkMonthLock(TimestampModel):
    """
    ê·¼ë¬´ ì›” ë§ˆê°
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="work_month_locks",
    )

    staff = models.ForeignKey(
        Staff,
        on_delete=models.CASCADE,
        related_name="work_month_locks",
    )
    year = models.PositiveIntegerField()
    month = models.PositiveIntegerField()
    is_locked = models.BooleanField(default=True)

    locked_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="locked_work_months",
    )

    class Meta:
        unique_together = ("tenant", "staff", "year", "month")
        ordering = ["-year", "-month"]

    def __str__(self):
        return f"{self.staff.name} - {self.year}-{self.month:02d}"


class PayrollSnapshot(TimestampModel):
    """
    ì›”ë³„ ê¸‰ì—¬ ì •ì‚° ìŠ¤ëƒ…ìƒ· (ë¶ˆë³€)
    """

    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="payroll_snapshots",
    )

    staff = models.ForeignKey(
        Staff,
        on_delete=models.CASCADE,
        related_name="payroll_snapshots",
    )

    year = models.PositiveIntegerField()
    month = models.PositiveIntegerField()

    work_hours = models.DecimalField(max_digits=6, decimal_places=2, default=0)
    work_amount = models.PositiveIntegerField(default=0)
    approved_expense_amount = models.PositiveIntegerField(default=0)
    total_amount = models.PositiveIntegerField(default=0)

    generated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="generated_payroll_snapshots",
    )

    class Meta:
        unique_together = ("tenant", "staff", "year", "month")
        ordering = ["-year", "-month"]

    def save(self, *args, **kwargs):
        if self.pk:
            raise ValidationError("PayrollSnapshotì€ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.staff.name} {self.year}-{self.month:02d}"


==========================================================================================
# FILE: serializers.py
==========================================================================================
# PATH: apps/domains/staffs/serializers.py
from rest_framework import serializers
from django.contrib.auth import get_user_model

from apps.domains.teachers.models import Teacher
from .models import (
    Staff,
    WorkType,
    StaffWorkType,
    WorkRecord,
    ExpenseRecord,
    WorkMonthLock,
    PayrollSnapshot,
)

User = get_user_model()

# ---------------------------
# WorkType
# ---------------------------

class WorkTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = WorkType
        fields = [
            "id",
            "name",
            "base_hourly_wage",
            "color",
            "description",
            "is_active",
            "created_at",
            "updated_at",
        ]
        ref_name = "StaffWorkTypeDefinition"


# ---------------------------
# StaffWorkType
# ---------------------------

class StaffWorkTypeSerializer(serializers.ModelSerializer):
    work_type = WorkTypeSerializer(read_only=True)
    work_type_id = serializers.PrimaryKeyRelatedField(
        source="work_type",
        queryset=WorkType.objects.all(),
        write_only=True,
    )
    effective_hourly_wage = serializers.IntegerField(read_only=True)

    class Meta:
        model = StaffWorkType
        fields = [
            "id",
            "staff",
            "work_type",
            "work_type_id",
            "hourly_wage",
            "effective_hourly_wage",
            "created_at",
            "updated_at",
        ]
        read_only_fields = ["staff", "created_at", "updated_at"]
        ref_name = "StaffWorkType"


# ---------------------------
# Staff (LIST / DETAIL)
# ---------------------------

class StaffListSerializer(serializers.ModelSerializer):
    staff_work_types = StaffWorkTypeSerializer(many=True, read_only=True)

    class Meta:
        model = Staff
        fields = [
            "id",
            "name",
            "phone",
            "is_active",
            "is_manager",
            "pay_type",
            "staff_work_types",
            "created_at",
            "updated_at",
        ]
        ref_name = "StaffList"


class StaffDetailSerializer(serializers.ModelSerializer):
    staff_work_types = StaffWorkTypeSerializer(many=True, read_only=True)

    # ğŸ”¥ CHANGED: ê³„ì • ì •ë³´ read-only
    user_username = serializers.CharField(
        source="user.username",
        read_only=True,
    )
    user_is_staff = serializers.BooleanField(
        source="user.is_staff",
        read_only=True,
    )

    class Meta:
        model = Staff
        fields = [
            "id",
            "user",
            "user_username",   # ğŸ”¥ CHANGED
            "user_is_staff",   # ğŸ”¥ CHANGED
            "name",
            "phone",
            "is_active",
            "is_manager",
            "pay_type",
            "staff_work_types",
            "created_at",
            "updated_at",
        ]
        ref_name = "StaffDetail"


# ======================================================
# ğŸ”¥ Staff CREATE / UPDATE / DELETE (ROLE í¬í•¨)
# ======================================================

class StaffCreateUpdateSerializer(serializers.ModelSerializer):
    role = serializers.ChoiceField(
        choices=[("TEACHER", "ê°•ì‚¬"), ("ASSISTANT", "ì¡°êµ")],
        write_only=True,
        required=True,
    )

    class Meta:
        model = Staff
        fields = [
            "user",
            "name",
            "phone",
            "is_active",
            "is_manager",
            "pay_type",
            "role",
        ]
        ref_name = "StaffWrite"

    # =========================
    # CREATE
    # =========================
    def create(self, validated_data):
        role = validated_data.pop("role")
        staff = super().create(validated_data)

        if role == "TEACHER":
            self._create_teacher(staff)
            self._grant_user_staff_permission(staff)

        return staff

    # =========================
    # UPDATE (is_active sync)
    # =========================
    def update(self, instance, validated_data):
        is_active_before = instance.is_active
        staff = super().update(instance, validated_data)

        if is_active_before and staff.is_active is False:
            Teacher.objects.filter(
                name=staff.name,
                phone=staff.phone,
            ).update(is_active=False)

        return staff

    # =========================
    # DELETE (Staff + Teacher + User)
    # =========================
    def delete(self, instance):
        user = instance.user

        # ğŸ”¥ Teacher ì‚­ì œ
        Teacher.objects.filter(
            name=instance.name,
            phone=instance.phone,
        ).delete()

        # ğŸ”¥ Staff ì‚­ì œ
        instance.delete()

        # ğŸ”¥ User ì‚­ì œ
        if user:
            user.delete()

    # =========================
    # Helpers
    # =========================
    def _create_teacher(self, staff: Staff):
        Teacher.objects.create(
            name=staff.name,
            phone=staff.phone,
            is_active=True,
        )

    def _grant_user_staff_permission(self, staff: Staff):
        if not staff.user:
            return

        user: User = staff.user
        if not user.is_staff:
            user.is_staff = True
            user.save(update_fields=["is_staff"])


# ---------------------------
# WorkRecord
# ---------------------------

class WorkRecordSerializer(serializers.ModelSerializer):
    staff_name = serializers.CharField(source="staff.name", read_only=True)
    work_type_name = serializers.CharField(source="work_type.name", read_only=True)

    class Meta:
        model = WorkRecord
        fields = [
            "id",
            "staff",
            "staff_name",
            "work_type",
            "work_type_name",
            "date",
            "start_time",
            "end_time",
            "break_minutes",
            "work_hours",
            "amount",
            "memo",
            "created_at",
            "updated_at",
        ]
        read_only_fields = ["work_hours", "amount", "created_at", "updated_at"]
        ref_name = "StaffWorkRecord"


# ---------------------------
# ExpenseRecord
# ---------------------------

class ExpenseRecordSerializer(serializers.ModelSerializer):
    staff_name = serializers.CharField(source="staff.name", read_only=True)
    approved_by_name = serializers.CharField(
        source="approved_by.username",
        read_only=True,
    )

    class Meta:
        model = ExpenseRecord
        fields = [
            "id",
            "staff",
            "staff_name",
            "date",
            "title",
            "amount",
            "memo",
            "status",
            "approved_at",
            "approved_by",
            "approved_by_name",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "approved_at",
            "approved_by",
            "created_at",
            "updated_at",
        ]
        ref_name = "StaffExpenseRecord"


# ---------------------------
# WorkMonthLock / Payroll
# ---------------------------

class WorkMonthLockSerializer(serializers.ModelSerializer):
    staff_name = serializers.CharField(source="staff.name", read_only=True)
    locked_by_name = serializers.CharField(source="locked_by.username", read_only=True)

    class Meta:
        model = WorkMonthLock
        fields = [
            "id",
            "staff",
            "staff_name",
            "year",
            "month",
            "is_locked",
            "locked_by",
            "locked_by_name",
            "created_at",
        ]
        read_only_fields = ["locked_by", "created_at"]
        ref_name = "WorkMonthLock"


class PayrollSnapshotSerializer(serializers.ModelSerializer):
    staff_name = serializers.CharField(source="staff.name", read_only=True)
    generated_by_name = serializers.CharField(source="generated_by.username", read_only=True)

    class Meta:
        model = PayrollSnapshot
        fields = [
            "id",
            "staff",
            "staff_name",
            "year",
            "month",
            "work_hours",
            "work_amount",
            "approved_expense_amount",
            "total_amount",
            "generated_by",
            "generated_by_name",
            "created_at",
        ]
        read_only_fields = fields
        ref_name = "PayrollSnapshot"


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/staffs/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    WorkTypeViewSet,
    StaffViewSet,
    StaffWorkTypeViewSet,
    WorkRecordViewSet,
    ExpenseRecordViewSet,
    WorkMonthLockViewSet,
    PayrollSnapshotViewSet,
)

router = DefaultRouter()

# ===========================
# ì„œë¸Œ ë¦¬ì†ŒìŠ¤
# ===========================
router.register(r"work-types", WorkTypeViewSet, basename="work-type")
router.register(r"staff-work-types", StaffWorkTypeViewSet, basename="staff-work-type")
router.register(r"work-records", WorkRecordViewSet, basename="work-record")
router.register(r"expense-records", ExpenseRecordViewSet, basename="expense-record")
router.register(r"work-month-locks", WorkMonthLockViewSet, basename="work-month-lock")
router.register(
    r"payroll-snapshots",
    PayrollSnapshotViewSet,
    basename="payroll-snapshot",
)

# ===========================
# Staff (ë£¨íŠ¸)
# ===========================
router.register(r"", StaffViewSet, basename="staff")

urlpatterns = [
    path("", include(router.urls)),
]


==========================================================================================
# FILE: views.py
==========================================================================================
# PATH: apps/domains/staffs/views.py
from io import BytesIO

from django.db import transaction
from django.db.models import Sum
from django.utils import timezone
from django.http import HttpResponse
from django.contrib.auth import get_user_model

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter, OrderingFilter
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, BasePermission
from rest_framework.exceptions import PermissionDenied, ValidationError
from rest_framework.viewsets import ReadOnlyModelViewSet

from openpyxl import Workbook
from openpyxl.styles import Font, Alignment

from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table
from reportlab.lib.styles import getSampleStyleSheet

from .models import (
    Staff,
    WorkType,
    StaffWorkType,
    WorkRecord,
    ExpenseRecord,
    WorkMonthLock,
    PayrollSnapshot,
)
from .serializers import (
    WorkTypeSerializer,
    StaffWorkTypeSerializer,
    StaffListSerializer,
    StaffDetailSerializer,
    StaffCreateUpdateSerializer,
    WorkRecordSerializer,
    ExpenseRecordSerializer,
    WorkMonthLockSerializer,
    PayrollSnapshotSerializer,
)
from .filters import StaffFilter, WorkRecordFilter, ExpenseRecordFilter
from apps.domains.teachers.models import Teacher

User = get_user_model()

# ===========================
# Permissions
# ===========================

class IsPayrollManager(BasePermission):
    def has_permission(self, request, view):
        user = request.user
        if not user or not user.is_authenticated:
            return False
        if user.is_superuser or user.is_staff:
            return True
        return getattr(getattr(user, "staff_profile", None), "is_manager", False)

# ===========================
# Helpers
# ===========================

def is_month_locked(staff, date):
    return WorkMonthLock.objects.filter(
        tenant=staff.tenant,
        staff=staff,
        year=date.year,
        month=date.month,
        is_locked=True,
    ).exists()


def can_manage_payroll(user) -> bool:
    if not user or not user.is_authenticated:
        return False
    if user.is_superuser or user.is_staff:
        return True
    return getattr(getattr(user, "staff_profile", None), "is_manager", False)


def generate_payroll_snapshot(staff, year, month, user):
    if PayrollSnapshot.objects.filter(
        tenant=staff.tenant,
        staff=staff,
        year=year,
        month=month,
    ).exists():
        raise ValidationError("ì´ë¯¸ ê¸‰ì—¬ ìŠ¤ëƒ…ìƒ·ì´ ìƒì„±ëœ ì›”ì…ë‹ˆë‹¤.")

    with transaction.atomic():
        wr_qs = WorkRecord.objects.filter(
            tenant=staff.tenant,
            staff=staff,
            date__year=year,
            date__month=month,
        )

        er_qs = ExpenseRecord.objects.filter(
            tenant=staff.tenant,
            staff=staff,
            date__year=year,
            date__month=month,
            status="APPROVED",
        )

        work_hours = wr_qs.aggregate(total=Sum("work_hours"))["total"] or 0
        work_amount = wr_qs.aggregate(total=Sum("amount"))["total"] or 0
        approved_expense_amount = er_qs.aggregate(total=Sum("amount"))["total"] or 0

        PayrollSnapshot.objects.create(
            tenant=staff.tenant,
            staff=staff,
            year=year,
            month=month,
            work_hours=work_hours,
            work_amount=work_amount,
            approved_expense_amount=approved_expense_amount,
            total_amount=work_amount + approved_expense_amount,
            generated_by=user,
        )

# ===========================
# WorkType
# ===========================

class WorkTypeViewSet(viewsets.ModelViewSet):
    serializer_class = WorkTypeSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    filter_backends = (DjangoFilterBackend, SearchFilter, OrderingFilter)
    filterset_fields = ["is_active"]
    search_fields = ["name", "description"]
    ordering_fields = ["name", "base_hourly_wage", "created_at"]

    def get_queryset(self):
        return WorkType.objects.filter(
            tenant=self.request.tenant
        ).order_by("name")

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.tenant)

# ===========================
# Staff
# ===========================

class StaffViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated, IsPayrollManager]

    filter_backends = (DjangoFilterBackend, SearchFilter, OrderingFilter)
    filterset_class = StaffFilter
    search_fields = ["name", "phone"]
    ordering_fields = ["name", "created_at", "is_active"]

    def get_queryset(self):
        return (
            Staff.objects.filter(tenant=self.request.tenant)
            .select_related("user")
            .prefetch_related("staff_work_types__work_type")
            .order_by("name")
        )

    def get_serializer_class(self):
        if self.action == "list":
            return StaffListSerializer
        if self.action == "retrieve":
            return StaffDetailSerializer
        return StaffCreateUpdateSerializer

    def perform_destroy(self, instance):
        serializer = self.get_serializer(instance)
        serializer.delete(instance)

    @action(detail=False, methods=["get"], url_path="me", permission_classes=[IsAuthenticated])
    def me(self, request):
        return Response(
            {
                "is_authenticated": True,
                "is_superuser": bool(request.user.is_superuser),
                "is_staff": bool(request.user.is_staff),
                "is_payroll_manager": can_manage_payroll(request.user),
            }
        )

    def create(self, request, *args, **kwargs):
        data = request.data

        username = data.get("username")
        password = data.get("password")
        role = data.get("role")

        if not username or not password or not role:
            raise ValidationError("username, password, role ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")

        if role not in ("TEACHER", "ASSISTANT"):
            raise ValidationError("role ì€ TEACHER ë˜ëŠ” ASSISTANT ì—¬ì•¼ í•©ë‹ˆë‹¤.")

        if User.objects.filter(username=username).exists():
            raise ValidationError("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” username ì…ë‹ˆë‹¤.")

        with transaction.atomic():
            user = User.objects.create(
                username=username,
                name=data.get("name", ""),
                phone=data.get("phone", ""),
                is_staff=(role == "TEACHER"),
            )
            user.set_password(password)
            user.save()

            staff = Staff.objects.create(
                tenant=request.tenant,
                user=user,
                name=data.get("name", ""),
                phone=data.get("phone", ""),
                is_active=True,
                is_manager=False,
                pay_type="MONTHLY" if role == "TEACHER" else "HOURLY",
            )

            if role == "TEACHER":
                Teacher.objects.create(
                    tenant=request.tenant,
                    name=staff.name,
                    phone=staff.phone,
                    is_active=True,
                )

        return Response(
            StaffDetailSerializer(staff).data,
            status=status.HTTP_201_CREATED,
        )

    @action(detail=True, methods=["get", "post"], url_path="work-types")
    def work_types(self, request, pk=None):
        staff = self.get_object()

        if request.method.lower() == "get":
            qs = staff.staff_work_types.select_related("work_type").all()
            return Response(StaffWorkTypeSerializer(qs, many=True).data)

        serializer = StaffWorkTypeSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        StaffWorkType.objects.create(
            tenant=staff.tenant,
            staff=staff,
            work_type=serializer.validated_data["work_type"],
            hourly_wage=serializer.validated_data.get("hourly_wage"),
        )

        qs = staff.staff_work_types.select_related("work_type").all()
        return Response(
            StaffWorkTypeSerializer(qs, many=True).data,
            status=status.HTTP_201_CREATED,
        )

    @action(detail=True, methods=["get"], url_path="summary")
    def summary(self, request, pk=None):
        staff = self.get_object()
        date_from = request.query_params.get("date_from")
        date_to = request.query_params.get("date_to")

        wr_qs = staff.work_records.all()
        er_qs = staff.expense_records.all()

        if date_from:
            wr_qs = wr_qs.filter(date__gte=date_from)
            er_qs = er_qs.filter(date__gte=date_from)
        if date_to:
            wr_qs = wr_qs.filter(date__lte=date_to)
            er_qs = er_qs.filter(date__lte=date_to)

        work_hours = wr_qs.aggregate(total=Sum("work_hours"))["total"] or 0
        work_amount = wr_qs.aggregate(total=Sum("amount"))["total"] or 0
        expense_amount = er_qs.aggregate(total=Sum("amount"))["total"] or 0

        return Response(
            {
                "staff_id": staff.id,
                "work_hours": work_hours,
                "work_amount": work_amount,
                "expense_amount": expense_amount,
                "total_amount": work_amount + expense_amount,
            }
        )

# ===========================
# StaffWorkType
# ===========================

class StaffWorkTypeViewSet(viewsets.ModelViewSet):
    serializer_class = StaffWorkTypeSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    filter_backends = (DjangoFilterBackend, OrderingFilter)
    filterset_fields = ["staff", "work_type"]
    ordering_fields = ["created_at"]

    def get_queryset(self):
        return StaffWorkType.objects.filter(
            tenant=self.request.tenant
        ).select_related("staff", "work_type")

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.tenant)

# ===========================
# ExpenseRecord
# ===========================

class ExpenseRecordViewSet(viewsets.ModelViewSet):
    serializer_class = ExpenseRecordSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    filter_backends = (DjangoFilterBackend, OrderingFilter)
    filterset_class = ExpenseRecordFilter
    ordering_fields = ["date", "amount", "created_at"]

    def get_queryset(self):
        return ExpenseRecord.objects.filter(
            tenant=self.request.tenant
        ).select_related("staff", "approved_by")

    def perform_update(self, serializer):
        instance = self.get_object()

        if instance.status == "APPROVED":
            raise ValidationError("ìŠ¹ì¸ëœ ë¹„ìš©ì€ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

        new_status = serializer.validated_data.get("status", instance.status)

        if new_status != instance.status:
            user = self.request.user
            if not can_manage_payroll(user):
                raise PermissionDenied("ë¹„ìš© ìŠ¹ì¸/ë°˜ë ¤ëŠ” ê´€ë¦¬ìë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.")

            if instance.status != "PENDING":
                raise ValidationError("ì´ë¯¸ ì²˜ë¦¬ëœ ë¹„ìš©ì€ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

            if new_status not in ("APPROVED", "REJECTED"):
                raise ValidationError("ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœ ì „ì´ì…ë‹ˆë‹¤.")

            serializer.save(
                approved_at=timezone.now(),
                approved_by=user,
            )
            return

        serializer.save()

# ===========================
# WorkMonthLock
# ===========================

class WorkMonthLockViewSet(viewsets.ModelViewSet):
    serializer_class = WorkMonthLockSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    def get_queryset(self):
        return WorkMonthLock.objects.filter(
            tenant=self.request.tenant
        ).select_related("staff", "locked_by")

    def create(self, request, *args, **kwargs):
        staff = Staff.objects.get(id=request.data.get("staff"), tenant=request.tenant)
        year = int(request.data.get("year"))
        month = int(request.data.get("month"))

        obj, _ = WorkMonthLock.objects.update_or_create(
            tenant=request.tenant,
            staff=staff,
            year=year,
            month=month,
            defaults={
                "is_locked": True,
                "locked_by": request.user,
            },
        )

        generate_payroll_snapshot(
            staff=staff,
            year=year,
            month=month,
            user=request.user,
        )

        return Response(
            WorkMonthLockSerializer(obj).data,
            status=status.HTTP_201_CREATED,
        )

# ===========================
# PayrollSnapshot (ReadOnly + Export)
# ===========================

class PayrollSnapshotViewSet(ReadOnlyModelViewSet):
    serializer_class = PayrollSnapshotSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    def get_queryset(self):
        return PayrollSnapshot.objects.filter(
            tenant=self.request.tenant
        ).select_related("staff", "generated_by")

    def list(self, request, *args, **kwargs):
        year = request.query_params.get("year")
        month = request.query_params.get("month")
        staff = request.query_params.get("staff")

        qs = self.get_queryset()
        if staff:
            qs = qs.filter(staff_id=staff)
        if year:
            qs = qs.filter(year=year)
        if month:
            qs = qs.filter(month=month)

        return Response(self.get_serializer(qs, many=True).data)

    @action(detail=False, methods=["get"], url_path="export-excel")
    def export_excel(self, request):
        year = request.query_params.get("year")
        month = request.query_params.get("month")

        if not year or not month:
            return Response({"detail": "year, month í•„ìš”"}, status=400)

        qs = self.get_queryset().filter(year=year, month=month)

        wb = Workbook()
        ws = wb.active
        ws.title = f"{year}-{month} ê¸‰ì—¬ì •ì‚°"

        headers = [
            "ì§ì›ëª…", "ì—°ë„", "ì›”", "ê·¼ë¬´ì‹œê°„",
            "ê¸‰ì—¬", "ìŠ¹ì¸ëœ ë¹„ìš©", "ì´ ì§€ê¸‰ì•¡", "í™•ì •ì", "í™•ì •ì¼ì‹œ"
        ]
        ws.append(headers)

        for c in ws[1]:
            c.font = Font(bold=True)
            c.alignment = Alignment(horizontal="center")

        for s in qs:
            ws.append([
                s.staff.name,
                s.year,
                s.month,
                float(s.work_hours),
                s.work_amount,
                s.approved_expense_amount,
                s.total_amount,
                getattr(s.generated_by, "username", "") if s.generated_by else "",
                s.created_at.strftime("%Y-%m-%d %H:%M:%S") if s.created_at else "",
            ])

        response = HttpResponse(
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        response["Content-Disposition"] = (
            f'attachment; filename="payroll_{year}_{month}.xlsx"'
        )
        wb.save(response)
        return response

    @action(detail=False, methods=["get"], url_path="export-pdf")
    def export_pdf(self, request):
        staff_id = request.query_params.get("staff")
        year = request.query_params.get("year")
        month = request.query_params.get("month")

        if not staff_id or not year or not month:
            return Response({"detail": "staff, year, month í•„ìš”"}, status=400)

        snap = self.get_queryset().filter(
            staff_id=staff_id,
            year=year,
            month=month,
        ).first()

        if not snap:
            return Response({"detail": "ê¸‰ì—¬ ìŠ¤ëƒ…ìƒ· ì—†ìŒ"}, status=404)

        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []

        story.append(Paragraph("ê¸‰ì—¬ ëª…ì„¸ì„œ", styles["Title"]))
        story.append(Spacer(1, 12))

        meta = [
            ["ì§ì›ëª…", snap.staff.name],
            ["ì •ì‚°ì›”", f"{snap.year}-{snap.month:02d}"],
            ["í™•ì •ì", getattr(snap.generated_by, "username", "-") if snap.generated_by else "-"],
        ]
        story.append(Table(meta, colWidths=[120, 360]))
        story.append(Spacer(1, 16))

        rows = [
            ["ê·¼ë¬´ì‹œê°„", f"{snap.work_hours} h"],
            ["ê¸‰ì—¬", f"{snap.work_amount:,} ì›"],
            ["ìŠ¹ì¸ ë¹„ìš©", f"{snap.approved_expense_amount:,} ì›"],
            ["ì´ ì§€ê¸‰ì•¡", f"{snap.total_amount:,} ì›"],
        ]
        story.append(Table(rows, colWidths=[120, 360]))

        doc.build(story)
        pdf = buffer.getvalue()
        buffer.close()

        response = HttpResponse(content_type="application/pdf")
        response["Content-Disposition"] = (
            f'attachment; filename="payroll_{snap.staff.id}_{snap.year}_{snap.month:02d}.pdf"'
        )
        response.write(pdf)
        return response

# ===========================
# WorkRecord (í†µí•© + ì‹¤ì‹œê°„ ê·¼ë¬´)
# ===========================

class WorkRecordViewSet(viewsets.ModelViewSet):
    serializer_class = WorkRecordSerializer
    permission_classes = [IsAuthenticated, IsPayrollManager]

    filter_backends = (DjangoFilterBackend, OrderingFilter)
    filterset_class = WorkRecordFilter
    ordering_fields = ["date", "created_at", "amount"]

    def get_queryset(self):
        return (
            WorkRecord.objects
            .filter(tenant=self.request.tenant)
            .select_related("staff", "work_type")
            .order_by("-date", "-start_time")
        )

    @action(detail=True, methods=["get"], url_path="current")
    def current_status(self, request, pk=None):
        staff = Staff.objects.get(pk=pk, tenant=request.tenant)

        record = (
            WorkRecord.objects
            .filter(staff=staff, tenant=staff.tenant, end_time__isnull=True)
            .order_by("-start_time")
            .first()
        )

        if not record:
            return Response({"status": "OFF"})

        if record.current_break_started_at:
            return Response({
                "status": "BREAK",
                "work_record_id": record.id,
                "started_at": record.start_time,
                "break_started_at": record.current_break_started_at,
            })

        return Response({
            "status": "WORKING",
            "work_record_id": record.id,
            "started_at": record.start_time,
            "break_minutes": record.break_minutes,
        })

    @action(detail=True, methods=["post"])
    def start_work(self, request, pk=None):
        staff = Staff.objects.get(pk=pk, tenant=request.tenant)
        now = timezone.now()

        if WorkRecord.objects.filter(
            staff=staff,
            tenant=staff.tenant,
            end_time__isnull=True,
        ).exists():
            raise ValidationError("ì´ë¯¸ ê·¼ë¬´ ì¤‘ì…ë‹ˆë‹¤.")

        record = WorkRecord.objects.create(
            tenant=staff.tenant,
            staff=staff,
            work_type_id=request.data.get("work_type"),
            date=now.date(),
            start_time=now.time(),
        )

        return Response(WorkRecordSerializer(record).data, status=201)

    @action(detail=True, methods=["post"])
    def start_break(self, request, pk=None):
        record = WorkRecord.objects.get(pk=pk, tenant=request.tenant)

        if record.current_break_started_at:
            raise ValidationError("ì´ë¯¸ íœ´ê²Œ ì¤‘ì…ë‹ˆë‹¤.")

        record.current_break_started_at = timezone.now()
        record.save(update_fields=["current_break_started_at"])

        return Response({"status": "BREAK_STARTED"})

    @action(detail=True, methods=["post"])
    def end_break(self, request, pk=None):
        record = WorkRecord.objects.get(pk=pk, tenant=request.tenant)

        if not record.current_break_started_at:
            raise ValidationError("íœ´ê²Œ ì¤‘ì´ ì•„ë‹™ë‹ˆë‹¤.")

        now = timezone.now()
        delta = now - record.current_break_started_at
        record.break_minutes += int(delta.total_seconds() / 60)
        record.current_break_started_at = None
        record.save(update_fields=["break_minutes", "current_break_started_at"])

        return Response({"status": "BREAK_ENDED"})

    @action(detail=True, methods=["post"])
    def end_work(self, request, pk=None):
        record = WorkRecord.objects.get(pk=pk, tenant=request.tenant)

        if record.end_time:
            raise ValidationError("ì´ë¯¸ ì¢…ë£Œëœ ê·¼ë¬´ì…ë‹ˆë‹¤.")

        if record.current_break_started_at:
            now = timezone.now()
            delta = now - record.current_break_started_at
            record.break_minutes += int(delta.total_seconds() / 60)
            record.current_break_started_at = None

        record.end_time = timezone.now().time()
        record.save()

        return Response(WorkRecordSerializer(record).data)


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 02:52

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="WorkType",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("name", models.CharField(max_length=100)),
                ("base_hourly_wage", models.PositiveIntegerField(default=0)),
                (
                    "color",
                    models.CharField(
                        default="#4CAF50", help_text="HEX ìƒ‰ìƒ ì½”ë“œ", max_length=7
                    ),
                ),
                ("description", models.TextField(blank=True)),
                ("is_active", models.BooleanField(default=True)),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="Staff",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("name", models.CharField(max_length=100)),
                ("phone", models.CharField(blank=True, max_length=20)),
                ("is_active", models.BooleanField(default=True)),
                ("is_manager", models.BooleanField(default=False)),
                (
                    "pay_type",
                    models.CharField(
                        choices=[("HOURLY", "ì‹œê¸‰"), ("MONTHLY", "ì›”ê¸‰")],
                        default="HOURLY",
                        max_length=20,
                    ),
                ),
                (
                    "user",
                    models.OneToOneField(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        related_name="staff_profile",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="ExpenseRecord",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("date", models.DateField()),
                ("title", models.CharField(max_length=255)),
                ("amount", models.PositiveIntegerField()),
                ("memo", models.TextField(blank=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "ëŒ€ê¸°"),
                            ("APPROVED", "ìŠ¹ì¸"),
                            ("REJECTED", "ë°˜ë ¤"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                (
                    "staff",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="expense_records",
                        to="staffs.staff",
                    ),
                ),
            ],
            options={
                "ordering": ["-date", "-created_at"],
            },
        ),
        migrations.CreateModel(
            name="WorkRecord",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("date", models.DateField()),
                ("start_time", models.TimeField()),
                ("end_time", models.TimeField()),
                ("break_minutes", models.PositiveIntegerField(default=0)),
                (
                    "work_hours",
                    models.DecimalField(
                        blank=True, decimal_places=2, max_digits=5, null=True
                    ),
                ),
                ("amount", models.PositiveIntegerField(blank=True, null=True)),
                ("memo", models.TextField(blank=True)),
                (
                    "staff",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="work_records",
                        to="staffs.staff",
                    ),
                ),
                (
                    "work_type",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="work_records",
                        to="staffs.worktype",
                    ),
                ),
            ],
            options={
                "ordering": ["-date", "-start_time"],
            },
        ),
        migrations.CreateModel(
            name="StaffWorkType",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "hourly_wage",
                    models.PositiveIntegerField(
                        blank=True, help_text="ë¹„ìš°ë©´ WorkType ê¸°ë³¸ ì‹œê¸‰", null=True
                    ),
                ),
                (
                    "staff",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="staff_work_types",
                        to="staffs.staff",
                    ),
                ),
                (
                    "work_type",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="staff_work_types",
                        to="staffs.worktype",
                    ),
                ),
            ],
            options={
                "unique_together": {("staff", "work_type")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_workmonthlock.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-27 00:36

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("staffs", "0001_initial"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="WorkMonthLock",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("year", models.PositiveIntegerField()),
                ("month", models.PositiveIntegerField()),
                ("is_locked", models.BooleanField(default=True)),
                (
                    "locked_by",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        related_name="locked_work_months",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
                (
                    "staff",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="work_month_locks",
                        to="staffs.staff",
                    ),
                ),
            ],
            options={
                "ordering": ["-year", "-month"],
                "unique_together": {("staff", "year", "month")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0003_expenserecord_approved_at_expenserecord_approved_by.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-27 00:50

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("staffs", "0002_workmonthlock"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name="expenserecord",
            name="approved_at",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name="expenserecord",
            name="approved_by",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="approved_expenses",
                to=settings.AUTH_USER_MODEL,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0004_payrollsnapshot.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-27 01:07

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("staffs", "0003_expenserecord_approved_at_expenserecord_approved_by"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="PayrollSnapshot",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("year", models.PositiveIntegerField()),
                ("month", models.PositiveIntegerField()),
                (
                    "work_hours",
                    models.DecimalField(decimal_places=2, default=0, max_digits=6),
                ),
                ("work_amount", models.PositiveIntegerField(default=0)),
                ("approved_expense_amount", models.PositiveIntegerField(default=0)),
                ("total_amount", models.PositiveIntegerField(default=0)),
                (
                    "generated_by",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        related_name="generated_payroll_snapshots",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
                (
                    "staff",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="payroll_snapshots",
                        to="staffs.staff",
                    ),
                ),
            ],
            options={
                "ordering": ["-year", "-month"],
                "unique_together": {("staff", "year", "month")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0005_add_staffs_tenant.py
==========================================================================================
# PATH: apps/domains/staffs/migrations/0005_add_staffs_tenant.py
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
        ("staffs", "0004_payrollsnapshot"),
    ]

    operations = [
        migrations.AddField(
            model_name="staff",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="staffs",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="worktype",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_types",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="staffworktype",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="staff_work_types",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="workrecord",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_records",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="expenserecord",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="expense_records",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="workmonthlock",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_month_locks",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="payrollsnapshot",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="payroll_snapshots",
                null=True,
                blank=True,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0006_alter_payrollsnapshot_unique_together_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-04 19:33

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0005_make_attendance_expense_tenant_not_null"),
        ("staffs", "0005_add_staffs_tenant"),
    ]

    operations = [
        migrations.AlterUniqueTogether(
            name="payrollsnapshot",
            unique_together=set(),
        ),
        migrations.AlterUniqueTogether(
            name="staffworktype",
            unique_together=set(),
        ),
        migrations.AlterUniqueTogether(
            name="workmonthlock",
            unique_together=set(),
        ),
        migrations.AlterField(
            model_name="expenserecord",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="expense_records",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="payrollsnapshot",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="payroll_snapshots",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="staff",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="staffs",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="staffworktype",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="staff_work_types",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="workmonthlock",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_month_locks",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="workrecord",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_records",
                to="core.tenant",
            ),
        ),
        migrations.AlterField(
            model_name="worktype",
            name="tenant",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="work_types",
                to="core.tenant",
            ),
        ),
        migrations.AlterUniqueTogether(
            name="payrollsnapshot",
            unique_together={("tenant", "staff", "year", "month")},
        ),
        migrations.AlterUniqueTogether(
            name="staffworktype",
            unique_together={("tenant", "staff", "work_type")},
        ),
        migrations.AlterUniqueTogether(
            name="workmonthlock",
            unique_together={("tenant", "staff", "year", "month")},
        ),
    ]


==========================================================================================
# FILE: migrations/0007_workrecord_current_break_started_at_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-05 00:05

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("staffs", "0006_alter_payrollsnapshot_unique_together_and_more"),
    ]

    operations = [
        migrations.AddField(
            model_name="workrecord",
            name="current_break_started_at",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name="workrecord",
            name="resolved_hourly_wage",
            field=models.PositiveIntegerField(
                blank=True, help_text="ê¸‰ì—¬ ê³„ì‚°ì— ì‹¤ì œ ì‚¬ìš©ëœ ì‹œê¸‰", null=True
            ),
        ),
        migrations.AlterField(
            model_name="staffworktype",
            name="hourly_wage",
            field=models.PositiveIntegerField(
                blank=True, help_text="ë¹„ìš°ë©´ WorkType ê¸°ë³¸ ë‹¨ê°€", null=True
            ),
        ),
        migrations.AlterField(
            model_name="workrecord",
            name="end_time",
            field=models.TimeField(blank=True, null=True),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================

