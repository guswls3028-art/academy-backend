====================================================================================================
# BACKEND APP: support__analytics
# ROOT PATH: C:\academy\apps\support\analytics
====================================================================================================


==========================================================================================
# FILE: serializers.py
==========================================================================================
# apps/support/analytics/serializers.py
from __future__ import annotations

from rest_framework import serializers


class ExamSummarySerializer(serializers.Serializer):
    target_type = serializers.CharField()
    target_id = serializers.IntegerField()

    participant_count = serializers.IntegerField()
    average_score = serializers.FloatField()
    max_score = serializers.FloatField()


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct_count = serializers.IntegerField()
    wrong_count = serializers.IntegerField()
    answer_rate = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongAnswerDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    total = serializers.IntegerField()
    top = serializers.ListField(child=serializers.DictField())


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/support/analytics/urls.py
from django.urls import path

from apps.support.analytics.views import (
    ExamAnalyticsSummaryView,
    ExamAnalyticsQuestionStatsView,
    ExamAnalyticsTopWrongView,
    ExamAnalyticsWrongDistributionView,
)

urlpatterns = [
    path("analytics/exams/<int:exam_id>/summary/", ExamAnalyticsSummaryView.as_view()),
    path("analytics/exams/<int:exam_id>/questions/", ExamAnalyticsQuestionStatsView.as_view()),
    path("analytics/exams/<int:exam_id>/top-wrong/", ExamAnalyticsTopWrongView.as_view()),
    path(
        "analytics/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamAnalyticsWrongDistributionView.as_view(),
    ),
]


==========================================================================================
# FILE: views.py
==========================================================================================
# apps/support/analytics/views.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.support.analytics.serializers import (
    ExamSummarySerializer,
    QuestionStatSerializer,
    WrongAnswerDistributionSerializer,
)
from apps.support.analytics.services.exam_analytics import (
    get_exam_summary,
    get_question_stats,
    get_top_wrong_questions,
    get_wrong_answer_distribution,
)


class ExamAnalyticsSummaryView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        data = get_exam_summary(exam_id=int(exam_id))
        return Response(ExamSummarySerializer(data).data)


class ExamAnalyticsQuestionStatsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        rows = get_question_stats(exam_id=int(exam_id))
        return Response(QuestionStatSerializer(rows, many=True).data)


class ExamAnalyticsTopWrongView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        limit = int(request.query_params.get("limit") or 5)
        rows = get_top_wrong_questions(exam_id=int(exam_id), limit=limit)
        return Response(QuestionStatSerializer(rows, many=True).data)


class ExamAnalyticsWrongDistributionView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int, question_id: int):
        limit = int(request.query_params.get("limit") or 5)
        data = get_wrong_answer_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
            limit=limit,
        )
        return Response(WrongAnswerDistributionSerializer(data).data)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/exam_analytics.py
==========================================================================================
# apps/support/analytics/services/exam_analytics.py
from __future__ import annotations

from typing import Any, Dict, List
from collections import Counter

from django.db.models import Avg, Max, Count, Sum, Case, When, IntegerField

from apps.domains.results.models import Result, ResultItem, ResultFact


def get_exam_summary(*, exam_id: int) -> Dict[str, Any]:
    """
    results 기반 시험 요약 (읽기 전용)

    - Result 기준 집계
    - 채점/정답비교 없음
    """
    qs = Result.objects.filter(target_type="exam", target_id=exam_id)

    agg = qs.aggregate(
        participant_count=Count("id"),
        average_score=Avg("total_score"),
        max_score=Max("max_score"),
    )

    return {
        "target_type": "exam",
        "target_id": int(exam_id),
        "participant_count": int(agg["participant_count"] or 0),
        "average_score": float(agg["average_score"] or 0.0),
        "max_score": float(agg["max_score"] or 0.0),
    }


def get_question_stats(*, exam_id: int) -> List[Dict[str, Any]]:
    """
    results 기반 문항별 통계 (읽기 전용)

    기준:
    - ResultItem은 (result, question_id) 기준 snapshot 1개만 존재
    - 따라서 attempts = 해당 문항을 푼 학생 수
    """
    items = (
        ResultItem.objects
        .filter(result__target_type="exam", result__target_id=exam_id)
        .values("question_id")
        .annotate(
            attempts=Count("id"),
            correct_count=Sum(
                Case(
                    When(is_correct=True, then=1),
                    default=0,
                    output_field=IntegerField(),
                )
            ),
            wrong_count=Sum(
                Case(
                    When(is_correct=False, then=1),
                    default=0,
                    output_field=IntegerField(),
                )
            ),
            avg_score=Avg("score"),
            max_score=Max("max_score"),
        )
        .order_by("question_id")
    )

    rows: List[Dict[str, Any]] = []
    for r in items:
        attempts = int(r["attempts"] or 0)
        correct = int(r["correct_count"] or 0)
        wrong = int(r["wrong_count"] or 0)

        answer_rate = (correct / attempts) if attempts > 0 else 0.0

        rows.append(
            {
                "question_id": int(r["question_id"]),
                "attempts": attempts,
                "correct_count": correct,
                "wrong_count": wrong,
                "answer_rate": round(float(answer_rate), 4),
                "avg_score": float(r["avg_score"] or 0.0),
                "max_score": float(r["max_score"] or 0.0),
            }
        )
    return rows


def get_top_wrong_questions(*, exam_id: int, limit: int = 5) -> List[Dict[str, Any]]:
    """
    오답이 많은 문항 TOP N (snapshot 기반)
    """
    stats = get_question_stats(exam_id=exam_id)
    stats.sort(key=lambda x: x["wrong_count"], reverse=True)
    return stats[: max(1, int(limit))]


def get_wrong_answer_distribution(
    *, exam_id: int, question_id: int, limit: int = 5
) -> Dict[str, Any]:
    """
    오답 분포 (Fact 기반: 누적 제출 히스토리)

    - is_correct=False 인 오답만 집계
    - 채점/정답비교 없음 (단순 통계)
    """
    qs = ResultFact.objects.filter(
        target_type="exam",
        target_id=exam_id,
        question_id=question_id,
        is_correct=False,
    ).exclude(answer="")

    counter = Counter(qs.values_list("answer", flat=True))
    total = sum(counter.values())

    top = []
    for ans, cnt in counter.most_common(limit):
        top.append(
            {
                "answer": ans,
                "count": int(cnt),
                "rate": round((cnt / total) * 100.0, 2) if total > 0 else 0.0,
            }
        )

    return {
        "question_id": int(question_id),
        "total": int(total),
        "top": top,
    }
