====================================================================================================
# BACKEND APP: domains__ai
# ROOT PATH: C:\academy\apps\domains\ai
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# apps/domains/ai/__init__.py


==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/ai/apps.py
from django.apps import AppConfig

class AIDomainConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.ai"
    label = "ai_domain"


==========================================================================================
# FILE: callbacks.py
==========================================================================================
from apps.shared.contracts.ai_result import AIResult
from apps.domains.ai.models import AIJobModel, AIResultModel
from apps.domains.submissions.services.ai_omr_result_mapper import apply_ai_result
from apps.domains.results.tasks.grading_tasks import grade_submission_task


def handle_ai_result(result: AIResult) -> None:
    """
    Worker â†’ API callback entry
    """
    job = AIJobModel.objects.get(job_id=result.job_id)

    if result.status == "FAILED":
        job.status = "FAILED"
        job.error_message = result.error or ""
        job.save(update_fields=["status", "error_message"])
        return

    # 1ï¸âƒ£ AI ê²°ê³¼ ì €ìž¥ (fact)
    AIResultModel.objects.create(
        job=job,
        payload=result.result,
    )

    # 2ï¸âƒ£ submissions ë¡œ ìœ„ìž„ (ë‹µì•ˆ ì¤‘ê°„ì‚°ë¬¼ ì €ìž¥)
    submission_id = apply_ai_result(result.result)

    # 3ï¸âƒ£ ì±„ì  job enqueue (results ì±…ìž„)
    if submission_id:
        grade_submission_task.delay(int(submission_id))

    job.status = "DONE"
    job.save(update_fields=["status"])


==========================================================================================
# FILE: gateway.py
==========================================================================================
from __future__ import annotations

from typing import Any, Dict, Optional

from apps.shared.contracts.ai_job import AIJob
from apps.domains.ai.types import ensure_payload_dict, AIJobType
from apps.domains.ai.safe import safe_dispatch
from apps.domains.ai.publisher import publish_job
from apps.domains.ai.models import AIJobModel


def dispatch_job(
    *,
    job_type: AIJobType,
    payload: Dict[str, Any],
    tenant_id: Optional[str] = None,
    source_domain: Optional[str] = None,
    source_id: Optional[str] = None,
) -> Dict[str, Any]:
    payload = ensure_payload_dict(payload)

    job = AIJob.new(
        type=job_type,
        payload=payload,
        tenant_id=tenant_id,
        source_domain=source_domain,
        source_id=source_id,
    )

    def _do():
        # âœ… callbacksê°€ AIJobModelì„ ì¡°íšŒí•˜ë¯€ë¡œ, ë°œí–‰ ì‹œì ì— ë°˜ë“œì‹œ ì €ìž¥
        job_model = AIJobModel.objects.create(
            job_id=job.id,
            job_type=job.type,
            payload=job.payload,
            status="PENDING",
        )

        try:
            publish_job(job)
        except Exception as e:
            job_model.status = "FAILED"
            job_model.error_message = str(e)
            job_model.save(update_fields=["status", "error_message", "updated_at"])
            raise

        return {"ok": True, "job_id": job.id, "type": job.type}

    return safe_dispatch(_do, fallback={"ok": False, "job_id": job.id, "type": job.type})


==========================================================================================
# FILE: models.py
==========================================================================================
# apps/domains/ai/models.py
from django.db import models
from apps.api.common.models import BaseModel


class AIJobModel(BaseModel):
    """
    API ì„œë²„ê°€ ê´€ë¦¬í•˜ëŠ” AI Job ë©”íƒ€
    (DB-based Queue + Lock + Retry)
    """
    job_id = models.CharField(max_length=64, unique=True)
    job_type = models.CharField(max_length=50)

    status = models.CharField(
        max_length=20,
        choices=[
            ("PENDING", "PENDING"),
            ("RUNNING", "RUNNING"),
            ("DONE", "DONE"),
            ("FAILED", "FAILED"),
        ],
        default="PENDING",
        db_index=True,
    )

    payload = models.JSONField()
    error_message = models.TextField(blank=True)

    # =========================
    # ðŸ”’ Queue / Retry / Lock
    # =========================
    retry_count = models.IntegerField(default=0)
    max_retries = models.IntegerField(default=5)

    locked_by = models.CharField(max_length=100, null=True, blank=True)
    locked_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "ai_job"
        app_label = "ai_domain"   # âœ… ì´ í•œ ì¤„ì´ í•µì‹¬
        
        indexes = [
            models.Index(fields=["status", "created_at"]),
            models.Index(fields=["locked_at"]),
        ]


class AIResultModel(BaseModel):
    """
    AI ê²°ê³¼ fact (ì €ìž¥ë§Œ, ê³„ì‚° ì—†ìŒ)
    """
    job = models.OneToOneField(
        AIJobModel,
        on_delete=models.CASCADE,
        related_name="result",
    )
    payload = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "ai_result"
        app_label = "ai_domain"   # âœ… ì´ê²ƒë„


==========================================================================================
# FILE: publisher.py
==========================================================================================
# apps/domains/ai/publisher.py
from apps.shared.contracts.ai_job import AIJob

def publish_job(job: AIJob) -> None:
    """
    ì‹¤ì œ ë©”ì‹œì§€ í ì—°ê²° ì§€ì .
    ì§€ê¸ˆì€ infra layer placeholder.
    """
    from worker.queue.producer import publish_ai_job
    publish_ai_job(job)


==========================================================================================
# FILE: queue.py
==========================================================================================
from datetime import timedelta
from django.db import transaction
from django.utils import timezone
from django.db.models import Q

from apps.domains.ai.models import AIJobModel


class DBJobQueue:
    """
    DB-backed Job Queue (SQS-style semantics)
    """

    def __init__(self, *, worker_id: str, visibility_seconds: int = 60):
        self.worker_id = worker_id
        self.visibility_seconds = visibility_seconds

    @transaction.atomic
    def claim_next(self) -> AIJobModel | None:
        now = timezone.now()
        expired = now - timedelta(seconds=self.visibility_seconds)

        job = (
            AIJobModel.objects
            .select_for_update(skip_locked=True)
            .filter(
                Q(status="PENDING") |
                Q(status="RUNNING", locked_at__lt=expired)
            )
            .order_by("created_at")
            .first()
        )

        if not job:
            return None

        if job.retry_count >= job.max_retries:
            job.status = "FAILED"
            job.error_message = "max retries exceeded"
            job.locked_at = None
            job.locked_by = None
            job.save()
            return None

        job.status = "RUNNING"
        job.retry_count += 1
        job.locked_by = self.worker_id
        job.locked_at = now
        job.save()

        return job

    @transaction.atomic
    def mark_done(self, job: AIJobModel):
        job.status = "DONE"
        job.locked_by = None
        job.locked_at = None
        job.save(update_fields=["status", "locked_by", "locked_at", "updated_at"])

    @transaction.atomic
    def mark_failed(self, job: AIJobModel, error: str):
        job.status = "FAILED"
        job.error_message = error[:2000]
        job.locked_by = None
        job.locked_at = None
        job.save(update_fields=["status", "error_message", "locked_by", "locked_at"])


==========================================================================================
# FILE: safe.py
==========================================================================================
# apps/domains/ai/safe.py
from __future__ import annotations

import logging
from typing import Any, Dict, Optional

logger = logging.getLogger(__name__)


def safe_dispatch(fn, *, fallback: Optional[Dict[str, Any]] = None, **kwargs) -> Dict[str, Any]:
    """
    AI Job ë°œí–‰ì„ ì•ˆì „í•˜ê²Œ ê°ì‹¼ë‹¤.
    APIëŠ” ì‹¤íŒ¨í•´ë„ ê¹¨ì§€ë©´ ì•ˆ ëœë‹¤.
    """
    try:
        return fn(**kwargs)
    except Exception as e:
        logger.exception("AI job dispatch failed", exc_info=e)
        return fallback or {"ok": False, "error": str(e)}


==========================================================================================
# FILE: types.py
==========================================================================================
from __future__ import annotations

from typing import Any, Dict, Literal, Optional, TypedDict


AIJobType = Literal[
    "ocr",
    "question_segmentation",
    "handwriting_analysis",
    "embedding",
    "problem_generation",
    "homework_video_analysis",
]


class OCRPayload(TypedDict, total=False):
    image_path: str
    engine: Optional[Literal["google", "tesseract", "auto"]]
    academy_id: Optional[int]


class SegmentationPayload(TypedDict, total=False):
    image_path: str
    engine: Optional[Literal["yolo", "opencv", "template", "auto"]]


class HandwritingPayload(TypedDict, total=False):
    image_path: str


class EmbeddingPayload(TypedDict, total=False):
    texts: list[str]
    backend: Optional[Literal["local", "openai", "auto"]]


class ProblemGenerationPayload(TypedDict, total=False):
    ocr_text: str
    model: Optional[str]


class HomeworkVideoPayload(TypedDict, total=False):
    video_path: str
    frame_stride: Optional[int]
    min_frame_count: Optional[int]


def ensure_payload_dict(payload: Any) -> Dict[str, Any]:
    if payload is None:
        return {}
    if isinstance(payload, dict):
        return payload
    raise TypeError("payload must be a dict")


==========================================================================================
# FILE: views.py
==========================================================================================
from __future__ import annotations

import json
from typing import Optional
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt

from apps.shared.contracts.ai_job import AIJob
from apps.domains.ai.queue import DBJobQueue


def _auth_or_401(request) -> Optional[JsonResponse]:
    token = request.headers.get("X-Worker-Token")
    if not token or token != settings.INTERNAL_WORKER_TOKEN:
        return JsonResponse({"detail": "unauthorized"}, status=401)
    return None


@csrf_exempt
@require_http_methods(["GET"])
def next_ai_job_view(request):
    unauth = _auth_or_401(request)
    if unauth:
        return unauth

    worker_id = request.headers.get("X-Worker-Id", "ai-worker")

    queue = DBJobQueue(
        worker_id=worker_id,
        visibility_seconds=60,
    )

    job = queue.claim_next()
    if not job:
        return JsonResponse({"job": None}, status=200)

    contract = AIJob.new(
        type=job.job_type,
        payload=job.payload,
        source_id=job.job_id,
    )

    return JsonResponse({"job": contract.to_dict()}, status=200)


==========================================================================================
# FILE: views_internal.py
==========================================================================================
# apps/domains/ai/views_internal.py
from django.http import JsonResponse
from django.views.decorators.http import require_GET
from django.db import transaction
from django.conf import settings

from apps.domains.ai.models import AIJobModel
from apps.shared.contracts.ai_job import AIJob


def _auth_worker(request):
    token = request.headers.get("X-Worker-Token")
    return token and token == settings.INTERNAL_WORKER_TOKEN


@require_GET
def next_ai_job(request):
    """
    Worker â†’ API
    GET /api/v1/internal/ai/job/next/
    """
    if not _auth_worker(request):
        return JsonResponse({"detail": "unauthorized"}, status=401)

    with transaction.atomic():
        job = (
            AIJobModel.objects
            .select_for_update(skip_locked=True)
            .filter(status="PENDING")
            .order_by("created_at")
            .first()
        )

        if not job:
            return JsonResponse({"job": None})

        job.status = "RUNNING"
        job.save(update_fields=["status", "updated_at"])

    ai_job = AIJob(
        id=job.job_id,
        type=job.job_type,
        payload=job.payload,
        tenant_id=None,
        source_domain=None,
        source_id=None,
    )

    return JsonResponse({"job": ai_job.to_dict()})


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 02:52

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="AIJobModel",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("job_id", models.CharField(max_length=64, unique=True)),
                ("job_type", models.CharField(max_length=50)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "PENDING"),
                            ("RUNNING", "RUNNING"),
                            ("DONE", "DONE"),
                            ("FAILED", "FAILED"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("payload", models.JSONField()),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "ai_job",
            },
        ),
        migrations.CreateModel(
            name="AIResultModel",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("payload", models.JSONField(blank=True, null=True)),
                (
                    "job",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="result",
                        to="ai_domain.aijobmodel",
                    ),
                ),
            ],
            options={
                "db_table": "ai_result",
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_job_queue_fields.py
==========================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("ai_domain", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="aijobmodel",
            name="retry_count",
            field=models.IntegerField(default=0),
        ),
        migrations.AddField(
            model_name="aijobmodel",
            name="max_retries",
            field=models.IntegerField(default=5),
        ),
        migrations.AddField(
            model_name="aijobmodel",
            name="locked_by",
            field=models.CharField(blank=True, max_length=100, null=True),
        ),
        migrations.AddField(
            model_name="aijobmodel",
            name="locked_at",
            field=models.DateTimeField(blank=True, null=True),
        ),
    ]


==========================================================================================
# FILE: migrations/0003_alter_aijobmodel_status_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-31 02:51

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("ai_domain", "0002_job_queue_fields"),
    ]

    operations = [
        migrations.AlterField(
            model_name="aijobmodel",
            name="status",
            field=models.CharField(
                choices=[
                    ("PENDING", "PENDING"),
                    ("RUNNING", "RUNNING"),
                    ("DONE", "DONE"),
                    ("FAILED", "FAILED"),
                ],
                db_index=True,
                default="PENDING",
                max_length=20,
            ),
        ),
        migrations.AddIndex(
            model_name="aijobmodel",
            index=models.Index(
                fields=["status", "created_at"], name="ai_job_status_ba4967_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="aijobmodel",
            index=models.Index(fields=["locked_at"], name="ai_job_locked__f6f4a2_idx"),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================

