====================================================================================================
# BACKEND APP: domains__submissions
# ROOT PATH: C:\academy\apps\domains\submissions
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: admin.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/submissions/apps.py
from django.apps import AppConfig


class SubmissionsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.submissions"
    label = "submissions"


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/domains/submissions/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter

from .views import SubmissionViewSet
from .views.exam_omr_submit_view import ExamOMRSubmitView

router = DefaultRouter()
router.register("submissions", SubmissionViewSet, basename="submissions")

urlpatterns = [
    # ğŸ”¥ STEP 2: ì‹œí—˜ OMR ì „ìš© ì œì¶œ
    # âš ï¸ TEMPORARY API (STEP 2 ì „ìš©)
    # - REST ì •ê·œ ê²½ë¡œëŠ” ì¶”í›„ /submissions/ í†µí•© ì˜ˆì •
    # - í˜„ì¬ëŠ” OMR ì „ìš© UX íë¦„ ë¶„ë¦¬ë¥¼ ìœ„í•´ ìœ ì§€
    path(
        "submissions/exams/<int:exam_id>/omr/",
        ExamOMRSubmitView.as_view(),
        name="exam-omr-submit",
    ),
]

urlpatterns += router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# apps/domains/submissions/migrations/0001_initial.py
# Generated by Django 5.2.9
#
# âš ï¸ IMPORTANT
# - ì´ 0001ì€ "ìµœì¢… ê³„ì•½" ê¸°ì¤€ìœ¼ë¡œ ìˆ˜ë™ ìˆ˜ì •ë¨
# - question_id / question_number ê°œë… ì—†ìŒ
# - exam_question_idë§Œ ë‹¨ì¼ ì§„ì‹¤
# - ì´í›„ migrationì—ì„œ ì ˆëŒ€ ì¶©ëŒ ë‚˜ì§€ ì•ŠìŒ

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # ======================================================
        # Submission
        # ======================================================
        migrations.CreateModel(
            name="Submission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),

                ("enrollment_id", models.PositiveIntegerField(null=True, blank=True, db_index=True)),

                (
                    "target_type",
                    models.CharField(
                        max_length=20,
                        choices=[("exam", "Exam"), ("homework", "Homework")],
                    ),
                ),
                ("target_id", models.PositiveIntegerField()),

                (
                    "source",
                    models.CharField(
                        max_length=30,
                        choices=[
                            ("omr_scan", "OMR Scan"),
                            ("omr_manual", "OMR Manual Input"),
                            ("online", "Online"),
                            ("homework_image", "Homework Image"),
                            ("homework_video", "Homework Video"),
                            ("ai_match", "AI Image Match"),
                        ],
                    ),
                ),

                # R2 file metadata
                ("file_key", models.CharField(max_length=512, null=True, blank=True)),
                ("file_type", models.CharField(max_length=50, null=True, blank=True)),
                ("file_size", models.PositiveIntegerField(null=True, blank=True)),

                ("payload", models.JSONField(null=True, blank=True)),

                (
                    "status",
                    models.CharField(
                        max_length=20,
                        default="submitted",
                        choices=[
                            ("submitted", "Submitted"),
                            ("dispatched", "Dispatched"),
                            ("extracting", "Extracting"),
                            ("answers_ready", "Answers Ready"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                    ),
                ),

                ("error_message", models.TextField(blank=True)),
                ("meta", models.JSONField(null=True, blank=True)),

                (
                    "user",
                    models.ForeignKey(
                        to=settings.AUTH_USER_MODEL,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="submissions",
                    ),
                ),
            ],
        ),

        # ======================================================
        # SubmissionAnswer (FINAL CONTRACT)
        # ======================================================
        migrations.CreateModel(
            name="SubmissionAnswer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),

                # âœ… ë‹¨ì¼ ì§„ì‹¤
                (
                    "exam_question_id",
                    models.PositiveIntegerField(
                        help_text="Fixed contract: exams.ExamQuestion.id",
                    ),
                ),

                ("answer", models.TextField(blank=True)),
                ("meta", models.JSONField(default=dict, blank=True)),

                (
                    "submission",
                    models.ForeignKey(
                        to="submissions.submission",
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="answers",
                    ),
                ),
            ],
            options={
                "db_table": "submissions_submissionanswer",
                "unique_together": {("submission", "exam_question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
from .submission import Submission
from .submission_answer import SubmissionAnswer

__all__ = [
    "Submission", 
    "SubmissionAnswer"
    ]


==========================================================================================
# FILE: models/submission.py
==========================================================================================
# PATH: apps/domains/submissions/models/submission.py
# ë³€ê²½ ìš”ì•½:
# - FileField ì œê±°
# - R2 ê¸°ë°˜ file_key / file_type í•„ë“œ ì¶”ê°€

from __future__ import annotations

from django.db import models
from django.conf import settings
from apps.api.common.models import TimestampModel


class Submission(TimestampModel):
    """
    submissions = ì œì¶œ í–‰ìœ„ + ì›ë³¸ ë©”íƒ€
    - íŒŒì¼ì€ Object Storage(R2)ì—ë§Œ ì¡´ì¬
    """

    class TargetType(models.TextChoices):
        EXAM = "exam", "Exam"
        HOMEWORK = "homework", "Homework"

    class Source(models.TextChoices):
        OMR_SCAN = "omr_scan", "OMR Scan"
        OMR_MANUAL = "omr_manual", "OMR Manual Input"
        ONLINE = "online", "Online"
        HOMEWORK_IMAGE = "homework_image", "Homework Image"
        HOMEWORK_VIDEO = "homework_video", "Homework Video"
        AI_MATCH = "ai_match", "AI Image Match"

    class Status(models.TextChoices):
        SUBMITTED = "submitted", "Submitted"
        DISPATCHED = "dispatched", "Dispatched"
        EXTRACTING = "extracting", "Extracting"
        ANSWERS_READY = "answers_ready", "Answers Ready"
        GRADING = "grading", "Grading"
        DONE = "done", "Done"
        FAILED = "failed", "Failed"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="submissions",
    )

    enrollment_id = models.PositiveIntegerField(null=True, blank=True, db_index=True)

    target_type = models.CharField(max_length=20, choices=TargetType.choices)
    target_id = models.PositiveIntegerField()

    source = models.CharField(max_length=30, choices=Source.choices)

    # âœ… R2 ê¸°ì¤€ íŒŒì¼ ë©”íƒ€
    file_key = models.CharField(max_length=512, null=True, blank=True)
    file_type = models.CharField(max_length=50, null=True, blank=True)
    file_size = models.PositiveIntegerField(null=True, blank=True)

    payload = models.JSONField(null=True, blank=True)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.SUBMITTED,
    )
    error_message = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["target_type", "target_id"]),
            models.Index(fields=["enrollment_id", "created_at"]),
            models.Index(fields=["user", "created_at"]),
            models.Index(fields=["status"]),
            models.Index(fields=["source"]),
        ]


==========================================================================================
# FILE: models/submission_answer.py
==========================================================================================
# apps/domains/submissions/models/submission_answer.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import BaseModel


class SubmissionAnswer(BaseModel):
    """
    submissions ë„ë©”ì¸ì˜ ë¬¸í•­ ë‹¨ìœ„ raw ë‹µì•ˆ (ì¤‘ê°„ì‚°ë¬¼)

    âœ… FINAL CONTRACT (DO NOT BREAK)
    - exam_question_id = exams.ExamQuestion.id (NOT NULL)
    - number / question_id / legacy ê°œë… ì—†ìŒ
    """

    submission = models.ForeignKey(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="answers",
    )

    # âœ… ë‹¨ì¼ ì§„ì‹¤
    exam_question_id = models.PositiveIntegerField(
        db_index=True,
        help_text="Fixed contract: exams.ExamQuestion.id",
    )

    answer = models.TextField(blank=True)

    # metaëŠ” submissionsê°€ ì†Œìœ  (AI ì›ë³¸/OMR ì •ë³´ ì €ì¥)
    meta = models.JSONField(default=dict, blank=True)

    class Meta:
        db_table = "submissions_submissionanswer"

        indexes = [
            models.Index(fields=["exam_question_id"]),
            models.Index(fields=["submission", "exam_question_id"]),
        ]

        # âœ… ìµœì¢… ê³ ì •
        unique_together = ("submission", "exam_question_id")

    def __str__(self):
        return f"Submission#{self.submission_id} Q={self.exam_question_id}"


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
from .submission import SubmissionSerializer, SubmissionCreateSerializer

__all__ = ["SubmissionSerializer", "SubmissionCreateSerializer"]


==========================================================================================
# FILE: serializers/submission.py
==========================================================================================
# PATH: apps/domains/submissions/serializers/submission.py
# ë³€ê²½ ìš”ì•½:
# - file(FileField) ì œê±°
# - ì—…ë¡œë“œëœ íŒŒì¼ì„ R2ë¡œ ì¦‰ì‹œ ì—…ë¡œë“œ
# - file_key/file_type/file_size ì €ì¥

from __future__ import annotations

import mimetypes
import uuid

from rest_framework import serializers

from apps.domains.submissions.models import Submission

# âœ… API ì„œë²„ ì „ìš© R2 ì—…ë¡œë“œ
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2


class SubmissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Submission
        fields = "__all__"
        read_only_fields = (
            "id",
            "user",
            "status",
            "error_message",
            "meta",
            "created_at",
            "updated_at",
        )


class SubmissionCreateSerializer(serializers.ModelSerializer):
    file = serializers.FileField(required=False)

    class Meta:
        model = Submission
        fields = (
            "enrollment_id",
            "target_type",
            "target_id",
            "source",
            "file",
            "payload",
        )

    def validate(self, attrs):
        source = attrs.get("source")
        target_type = attrs.get("target_type")

        if target_type in (Submission.TargetType.EXAM, Submission.TargetType.HOMEWORK):
            if not attrs.get("enrollment_id"):
                raise serializers.ValidationError({"enrollment_id": "required"})

        if source in (
            Submission.Source.OMR_SCAN,
            Submission.Source.HOMEWORK_IMAGE,
            Submission.Source.HOMEWORK_VIDEO,
        ):
            if not attrs.get("file"):
                raise serializers.ValidationError({"file": "file required"})

        if source == Submission.Source.ONLINE and not attrs.get("payload"):
            raise serializers.ValidationError({"payload": "required"})

        return attrs

    def create(self, validated_data):
        upload_file = validated_data.pop("file", None)

        submission = Submission.objects.create(**validated_data)

        if upload_file:
            ext = upload_file.name.split(".")[-1]
            key = f"submissions/{submission.id}/{uuid.uuid4().hex}.{ext}"

            upload_fileobj_to_r2(
                fileobj=upload_file,
                key=key,
                content_type=upload_file.content_type,
            )

            submission.file_key = key
            submission.file_type = upload_file.content_type or mimetypes.guess_type(upload_file.name)[0]
            submission.file_size = upload_file.size
            submission.save(update_fields=["file_key", "file_type", "file_size"])

        return submission


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/ai_omr_result_mapper.py
==========================================================================================
# apps/domains/submissions/services/ai_omr_result_mapper.py
from __future__ import annotations

from typing import Any, Dict, Optional
import logging

from django.db import transaction   # âœ… ì´ ì¤„ ì¶”ê°€

from apps.domains.submissions.models import Submission, SubmissionAnswer

logger = logging.getLogger(__name__)


@transaction.atomic
def apply_omr_ai_result(payload: Dict[str, Any]) -> Optional[int]:
    """
    FINAL CONTRACT:
    - answers[*].exam_question_id í•„ìˆ˜
    """

    submission_id = payload.get("submission_id")
    if not submission_id:
        return None

    try:
        submission = Submission.objects.select_for_update().get(id=int(submission_id))
    except Submission.DoesNotExist:
        return None

    base_payload = submission.payload or {}
    base_payload["ai_result"] = payload
    submission.payload = base_payload

    status = payload.get("status")
    if status == "FAILED":
        submission.status = Submission.Status.FAILED
        submission.error_message = payload.get("error") or "AI worker failed"
        submission.save(update_fields=["payload", "status", "error_message", "updated_at"])
        return submission.id

    result = payload.get("result") or {}
    answers = result.get("answers") or []

    for a in answers:
        eqid = a.get("exam_question_id")
        if not eqid:
            continue

        SubmissionAnswer.objects.update_or_create(
            submission=submission,
            exam_question_id=int(eqid),
            defaults={
                "answer": "".join([str(x) for x in a.get("detected") or []]),
                "meta": {
                    "omr": {
                        "version": result.get("version"),
                        "detected": a.get("detected"),
                        "marking": a.get("marking"),
                        "confidence": a.get("confidence"),
                        "status": a.get("status"),
                    }
                },
            },
        )

    submission.status = Submission.Status.ANSWERS_READY
    submission.error_message = ""
    submission.save(update_fields=["payload", "status", "error_message", "updated_at"])
    return submission.id


==========================================================================================
# FILE: services/ai_result_router.py
==========================================================================================
# PATH: apps/domains/submissions/services/ai_result_router.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple
import logging

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.ai_omr_result_mapper import apply_omr_ai_result

logger = logging.getLogger(__name__)


# =========================================================
# STEP 1 ì •ì±… ìƒìˆ˜ (ìš´ì˜í•˜ë©´ì„œ ì¡°ì •)
# =========================================================

MIN_HOMEWORK_VIDEO_FILLED_RATIO = 0.10  # ì´ ì´ìƒì´ë©´ "ì‘ì„± ìˆìŒ"ìœ¼ë¡œ íŒì •


@dataclass(frozen=True)
class ApplyAIResultOutcome:
    """
    API ë‚´ë¶€ ì½œë°±ì—ì„œ ì“°ëŠ” ê²°ê³¼
    - should_grade: Trueë©´ results ì±„ì  Celeryë¥¼ enqueue í•´ì•¼ í•¨ (ì‹œí—˜ ì œì¶œ)
    - returned_submission_id: ì²˜ë¦¬ëœ submission id (ì—†ìœ¼ë©´ None)
    """
    returned_submission_id: Optional[int]
    should_grade: bool
    detail: Dict[str, Any]


def _coerce_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return default


def _safe_bool(v: Any, default: bool = False) -> bool:
    if isinstance(v, bool):
        return v
    if isinstance(v, (int, float)):
        return bool(v)
    if isinstance(v, str):
        return v.strip().lower() in ("1", "true", "yes", "y", "on")
    return default


@transaction.atomic
def apply_ai_result_for_submission(
    *,
    submission_id: int,
    status: str,
    result: Optional[Dict[str, Any]],
    error: Optional[str],
) -> ApplyAIResultOutcome:
    """
    STEP 1 ë‹¨ì¼ ì§„ì‹¤:
    - AI result ì½œë°±ì€ submission.source ê¸°ì¤€ìœ¼ë¡œ ë¼ìš°íŒ…í•œë‹¤.
    - workerê°€ job.typeì„ ê°™ì´ ì•ˆ ë³´ë‚´ë„ ë¨.
    """
    try:
        submission = Submission.objects.select_for_update().get(id=int(submission_id))
    except Submission.DoesNotExist:
        return ApplyAIResultOutcome(
            returned_submission_id=None,
            should_grade=False,
            detail={"error": "submission not found"},
        )

    # ---------------------------------------------
    # ê³µí†µ: ai_result ì›ë³¸ì€ submission.metaì— ì €ì¥
    # (payloadëŠ” ìš”ì²­ ì…ë ¥ì´ë¯€ë¡œ ëœ ì˜¤ì—¼ì‹œí‚¤ëŠ” ê²Œ ì¢‹ë‹¤)
    # ---------------------------------------------
    meta = dict(submission.meta or {})
    meta["ai_result"] = {
        "status": status,
        "result": result,
        "error": error,
    }
    submission.meta = meta

    # FAILED ì²˜ë¦¬
    if str(status).upper() == "FAILED":
        submission.status = Submission.Status.FAILED
        submission.error_message = error or "AI worker failed"
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return ApplyAIResultOutcome(
            returned_submission_id=submission.id,
            should_grade=False,
            detail={"status": "FAILED"},
        )

    # ---------------------------------------------
    # ë¼ìš°íŒ…: submission.source ê¸°ì¤€
    # ---------------------------------------------

    # 1) ì‹œí—˜ OMR: answers ì €ì¥ â†’ ANSWERS_READY â†’ ì±„ì  enqueue
    if submission.source == Submission.Source.OMR_SCAN:
        # ê¸°ì¡´ mapperëŠ” payload êµ¬ì¡°ë¥¼ ê¸°ëŒ€í•˜ë¯€ë¡œ ìµœì†Œ í˜•íƒœë¡œ ë§ì¶° ì¤€ë‹¤.
        # (ë„¤ ê¸°ì¡´ submit_ai_result_viewê°€ payloadë¥¼ ì„ëŠ” ë°©ì‹ê³¼ ì¶©ëŒ ë°©ì§€)
        payload_for_mapper = {
            "submission_id": submission.id,
            "status": "DONE",
            "result": result or {},
            "error": None,
        }
        returned_id = apply_omr_ai_result(payload_for_mapper)

        # mapperê°€ statusë¥¼ ANSWERS_READYë¡œ ë§Œë“¤ì–´ì¤Œ
        submission.save(update_fields=["meta", "updated_at"])

        return ApplyAIResultOutcome(
            returned_submission_id=returned_id,
            should_grade=True,  # âœ… ì‹œí—˜ì€ ì±„ì í•´ì•¼ í•¨
            detail={"routed": "omr_scan"},
        )

    # 2) ì˜ìƒ ìˆ™ì œ ë¶„ì„: "ì‘ì„± ìˆìŒ/ì—†ìŒ" íŒë³„ì„ metaì— ê³ ì • í›„ DONE ì²˜ë¦¬
    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        r = result or {}
        filled_ratio = _coerce_float(r.get("filled_ratio"), 0.0)
        too_short = _safe_bool(r.get("too_short"), False)

        # íŒì • ê·œì¹™ (STEP 1 ê³ ì •)
        has_content = (not too_short) and (filled_ratio >= MIN_HOMEWORK_VIDEO_FILLED_RATIO)

        meta = dict(submission.meta or {})
        meta["homework_video_result"] = {
            "has_content": bool(has_content),
            "filled_ratio": float(filled_ratio),
            "too_short": bool(too_short),
            "policy": {
                "min_filled_ratio": MIN_HOMEWORK_VIDEO_FILLED_RATIO,
            },
        }
        submission.meta = meta

        # ì˜ìƒ ìˆ™ì œëŠ” "ì±„ì "ì´ ì•„ë‹ˆë¼ "íŒë³„ ê²°ê³¼ í™•ì •"ì´ë¯€ë¡œ DONE ì²˜ë¦¬
        submission.status = Submission.Status.DONE
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])

        return ApplyAIResultOutcome(
            returned_submission_id=submission.id,
            should_grade=False,
            detail={"routed": "homework_video", "has_content": has_content},
        )

    # 3) ì´ë¯¸ì§€ OCR ìˆ™ì œ(ìˆë‹¤ë©´): ê²°ê³¼ë§Œ ì €ì¥í•˜ê³  DONE ì²˜ë¦¬ (ì±„ì  X)
    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        meta = dict(submission.meta or {})
        meta["homework_image_ocr"] = result or {}
        submission.meta = meta

        submission.status = Submission.Status.DONE
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])

        return ApplyAIResultOutcome(
            returned_submission_id=submission.id,
            should_grade=False,
            detail={"routed": "homework_image"},
        )

    # ê·¸ ì™¸: ì¼ë‹¨ meta ì €ì¥ + DONE (ì•ˆì „)
    submission.status = Submission.Status.DONE
    submission.error_message = ""
    submission.save(update_fields=["meta", "status", "error_message", "updated_at"])

    return ApplyAIResultOutcome(
        returned_submission_id=submission.id,
        should_grade=False,
        detail={"routed": "default_done"},
    )


==========================================================================================
# FILE: services/dispatcher.py
==========================================================================================
# apps/domains/submissions/services/dispatcher.py
from __future__ import annotations

import redis
from django.conf import settings

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.submission_service import SubmissionService
from apps.domains.results.tasks.grading_tasks import grade_submission_task
from apps.shared.contracts.ai_job import AIJob
from apps.infrastructure.storage.r2 import generate_presigned_get_url

# âœ… exams ë„ë©”ì¸ì—ì„œ ë¬¸í•­ ë©”íƒ€ ì œê³µ
from apps.domains.exams.models import ExamQuestion

AI_QUEUE_KEY = "ai:jobs"


def _redis():
    return redis.from_url(settings.REDIS_URL, decode_responses=True)


def dispatch_submission(submission: Submission) -> None:
    """
    Submission ìƒì„± ì§í›„ í˜¸ì¶œë˜ëŠ” ìœ ì¼í•œ ì§„ì…ì 

    ìƒíƒœ ì „ì´ ê·œì¹™ (ê³ ì •):
    - SUBMITTED â†’ DISPATCHED : dispatcher
    - DISPATCHED â†’ ANSWERS_READY / FAILED : ai_result_mapper
    - ANSWERS_READY â†’ GRADING â†’ DONE : results.grader
    """

    # 1) ONLINE ì œì¶œ: ì¦‰ì‹œ ì²˜ë¦¬
    if submission.source == Submission.Source.ONLINE:
        SubmissionService.process(submission)
        grade_submission_task.delay(int(submission.id))
        return

    # 2) FILE ì œì¶œ: presigned URL â†’ AI Worker
    if not submission.file_key:
        submission.status = Submission.Status.FAILED
        submission.error_message = "file_key missing"
        submission.save(update_fields=["status", "error_message"])
        return

    # ìƒíƒœ ì „ì´: SUBMITTED â†’ DISPATCHED
    submission.status = Submission.Status.DISPATCHED
    submission.error_message = ""
    submission.save(update_fields=["status", "error_message"])

    # 3) AI Job ìƒì„±
    job = AIJob.new(
        type=_infer_ai_job_type(submission),
        source_domain="submissions",
        source_id=str(submission.id),
        payload=_build_ai_payload(submission),
    )

    r = _redis()
    r.lpush(AI_QUEUE_KEY, job.to_json())


def _infer_ai_job_type(submission: Submission) -> str:
    if submission.source == Submission.Source.OMR_SCAN:
        return "omr_grading"
    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        return "ocr"
    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        return "homework_video_analysis"
    return "ocr"


def _build_ai_payload(submission: Submission) -> dict:
    """
    âœ… NEXT-2 í™•ì • payload ê·œì¹™
    - file ì ‘ê·¼ì€ presigned GET URLë§Œ
    - OMRì€ "sheet_id" ê¸°ë°˜ìœ¼ë¡œ ë¬¸í•­ ëª©ë¡ì„ í•¨ê»˜ ì œê³µ
    - workerëŠ” answers[*].exam_question_id ë¡œë§Œ ê²°ê³¼ë¥¼ ë¦¬í„´í•´ì•¼ í•¨

    Worker ì…ë ¥(ê¶Œì¥):
    {
      "submission_id": ...,
      "download_url": "...",
      "omr": {"sheet_id": 45},
      "questions": [
        {
          "exam_question_id": 123,
          "number": 1,
          "region_meta": {...}  # bbox ë“±
        },
        ...
      ]
    }
    """
    payload = dict(submission.payload or {})

    sheet_id = None
    if isinstance(payload.get("sheet_id"), int):
        sheet_id = int(payload["sheet_id"])
    elif payload.get("sheet_id") is not None:
        try:
            sheet_id = int(payload.get("sheet_id"))
        except Exception:
            sheet_id = None

    # -------------------------------------------------
    # âœ… ë¬¸í•­ ëª©ë¡ êµ¬ì„± (sheet_id ê¸°ë°˜)
    # -------------------------------------------------
    questions_payload = []
    if sheet_id:
        qs = ExamQuestion.objects.filter(sheet_id=sheet_id).order_by("number")
        for q in qs:
            # region_meta í•„ë“œëª…ì´ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ getattrë¡œ ë°©ì–´
            region_meta = getattr(q, "region_meta", None) or getattr(q, "meta", None) or None

            questions_payload.append(
                {
                    "exam_question_id": int(q.id),
                    "number": int(getattr(q, "number", 0) or 0),
                    "region_meta": region_meta,
                }
            )

    payload.update(
        {
            "submission_id": submission.id,
            "target_type": submission.target_type,
            "target_id": submission.target_id,

            "file_key": submission.file_key,
            "download_url": generate_presigned_get_url(
                key=submission.file_key,
                expires_in=60 * 60,
            ),

            # âœ… OMR ì „ìš©
            "omr": {
                "sheet_id": sheet_id,
            },

            # âœ… NEXT-2 í•µì‹¬: workerê°€ exam_question_idë¥¼ ì•Œë„ë¡ ì œê³µ
            "questions": questions_payload,
        }
    )

    return payload


==========================================================================================
# FILE: services/submission_service.py
==========================================================================================
# apps/domains/submissions/services/submission_service.py
from typing import List, Type

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor
from apps.domains.submissions.services.processor.online import OnlineSubmissionProcessor


PROCESSOR_MAP: dict[str, Type[BaseSubmissionProcessor]] = {
    Submission.Source.ONLINE: OnlineSubmissionProcessor,
}


class SubmissionService:
    """
    submissions ì²˜ë¦¬ì˜ ìœ ì¼í•œ í¼ë¸”ë¦­ ì„œë¹„ìŠ¤
    - ONLINEë§Œ ì¦‰ì‹œ ì²˜ë¦¬ (ì •ê·œí™”ë§Œ ìˆ˜í–‰)
    # OMR / IMAGE / VIDEOëŠ” ë°˜ë“œì‹œ AI Worker ê²½ìœ 
    """

    @staticmethod
    @transaction.atomic
    def process(submission: Submission) -> List[SubmissionAnswer]:
        processor_cls = PROCESSOR_MAP.get(submission.source)
        if not processor_cls:
            return []

        processor = processor_cls(submission)
        answers = processor.process()

        # ONLINEì€ ì¦‰ì‹œ answers_readyë¡œ
        submission.status = Submission.Status.ANSWERS_READY
        submission.save(update_fields=["status", "updated_at"])

        return answers


==========================================================================================
# FILE: services/processor/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/processor/base.py
==========================================================================================
# apps/domains/submissions/services/processor/base.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Dict, Any, List

from django.db import transaction
from apps.domains.submissions.models import Submission, SubmissionAnswer


class BaseSubmissionProcessor(ABC):
    """
    submissions ë‚´ processor = 'ë‹µì•ˆ ì¤‘ê°„ì‚°ë¬¼ ì €ì¥'ê¹Œì§€ë§Œ
    """

    source: str = "base"

    def __init__(self, submission: Submission):
        self.submission = submission

    @transaction.atomic
    def process(self) -> List[SubmissionAnswer]:
        extracted = list(self.extract_answers())
        return self._save_answers(extracted)

    @abstractmethod
    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        """
        ë°˜í™˜ í¬ë§· (FINAL):
            {
              "exam_question_id": int,
              "answer": str,
              "meta": dict|None
            }
        """
        raise NotImplementedError

    def _save_answers(self, extracted: Iterable[Dict[str, Any]]) -> List[SubmissionAnswer]:
        results: List[SubmissionAnswer] = []

        for item in extracted:
            eqid = item.get("exam_question_id")
            if not eqid:
                continue  # âŒ ê³„ì•½ ìœ„ë°˜ ë°ì´í„° ë¬´ì‹œ

            obj, _ = SubmissionAnswer.objects.update_or_create(
                submission=self.submission,
                exam_question_id=int(eqid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or {},
                },
            )
            results.append(obj)

        return results


==========================================================================================
# FILE: services/processor/online.py
==========================================================================================
# apps/domains/submissions/services/processor/online.py
from __future__ import annotations

from typing import Iterable, Dict, Any
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OnlineSubmissionProcessor(BaseSubmissionProcessor):
    source = "online"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        answers = payload.get("answers")

        if not isinstance(answers, (list, dict)):
            return

        rows = answers if isinstance(answers, list) else answers.items()

        for row in rows:
            eqid = (
                row.get("exam_question_id")
                if isinstance(row, dict)
                else None
            )
            if not eqid:
                continue

            yield {
                "exam_question_id": int(eqid),
                "answer": row.get("answer", ""),
                "meta": row.get("meta") or {"via": "online"},
            }


==========================================================================================
# FILE: services/processor/video.py
==========================================================================================
# apps/domains/submissions/services/processor/video.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor

class VideoSubmissionProcessor(BaseSubmissionProcessor):
    source = "homework_video"

    def extract_answers(self):
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        if not isinstance(extracted, (list, dict)):
            return

        rows = extracted if isinstance(extracted, list) else extracted.items()

        for row in rows:
            # workerê°€ v2 ê³„ì•½ì„ ì§€í‚¨ ê²½ìš°ë§Œ ì²˜ë¦¬
            eqid = (
                row.get("exam_question_id")
                if isinstance(row, dict)
                else None
            )

            if not eqid:
                # âŒ legacy video ë‹µì•ˆì€ ì •ê·œ ì €ì¥í•˜ì§€ ì•ŠìŒ
                continue

            yield {
                "exam_question_id": int(eqid),
                "question_number": None,
                "answer": row.get("answer", ""),
                "meta": row.get("meta") or {"via": "video"},
            }


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# domains/submissions/views/__init__.py

from .submission_view import SubmissionViewSet

__all__ = ["SubmissionViewSet"]


==========================================================================================
# FILE: views/exam_omr_submit_view.py
==========================================================================================
# PATH: apps/domains/submissions/views/exam_omr_submit_view.py
"""
ğŸ”¥ STEP 2 (ì •ë¦¬ ì™„ë£ŒíŒ)

ì‹œí—˜ OMR ì „ìš© Submission ì§„ì…ì 

ì„¤ê³„ ì›ì¹™ (ì¤‘ìš”):
- âŒ status ì§ì ‘ ì œì–´ ê¸ˆì§€
- âŒ AIJob ì§ì ‘ ìƒì„± ê¸ˆì§€
- âœ” Submission ìƒì„±ë§Œ ìˆ˜í–‰
- âœ” ì´í›„ íë¦„ì€ dispatcher ë‹¨ì¼ ì§„ì‹¤
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.dispatcher import dispatch_submission


class ExamOMRSubmitView(APIView):
    """
    POST /api/v1/submissions/exams/<exam_id>/omr/

    body:
    {
        "enrollment_id": 123,
        "sheet_id": 45,
        "file_key": "exams/submissions/abc.jpg"
    }
    """

    permission_classes = [IsAuthenticated]

    def post(self, request, exam_id: int):
        enrollment_id = request.data.get("enrollment_id")
        sheet_id = request.data.get("sheet_id")
        file_key = request.data.get("file_key")

        if not all([enrollment_id, sheet_id, file_key]):
            return Response(
                {"detail": "enrollment_id, sheet_id, file_key are required"},
                status=400,
            )

        # -------------------------------------------------
        # 1ï¸âƒ£ Submission ìƒì„±
        # -------------------------------------------------
        # âš ï¸ statusëŠ” SUBMITTED ê³ ì •
        # âš ï¸ ì´í›„ ìƒíƒœ ì „ì´ëŠ” dispatcher / AI / grader ì±…ì„
        submission = Submission.objects.create(
            user=request.user,
            target_type=Submission.TargetType.EXAM,
            target_id=int(exam_id),
            enrollment_id=int(enrollment_id),
            source=Submission.Source.OMR_SCAN,
            file_key=str(file_key),
            payload={
                # OMR ì „ìš© ë©”íƒ€ëŠ” payloadì—ë§Œ ë‘ 
                "sheet_id": int(sheet_id),
            },
        )

        # -------------------------------------------------
        # 2ï¸âƒ£ ë‹¨ì¼ ì§„ì…ì : dispatcher
        # -------------------------------------------------
        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            },
            status=201,
        )


==========================================================================================
# FILE: views/submission_view.py
==========================================================================================
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.serializers.submission import (
    SubmissionSerializer,
    SubmissionCreateSerializer,
)
from apps.domains.submissions.services.dispatcher import dispatch_submission


class SubmissionViewSet(ModelViewSet):
    """
    Submission ë‹¨ì¼ ì§„ì‹¤ ì—”ë“œí¬ì¸íŠ¸

    - ì‹œí—˜ / ê³¼ì œ / ì˜ìƒ ì—…ë¡œë“œ ì „ë¶€ ì—¬ê¸°ì„œ ìƒì„±
    - ì‹¤ì œ ì²˜ë¦¬ ë¡œì§ì€ Celery Workerê°€ ë‹´ë‹¹
    """

    queryset = Submission.objects.all().order_by("-id")
    permission_classes = [IsAuthenticated]

    # --------------------------------------------
    # serializer ë¶„ê¸°
    # --------------------------------------------
    def get_serializer_class(self):
        # ìƒì„± ê³„ì—´ì€ CreateSerializer ì‚¬ìš©
        if self.action in ("create", "admin_omr_upload"):
            return SubmissionCreateSerializer
        return SubmissionSerializer

    # --------------------------------------------
    # ê³µí†µ create (í•™ìƒ/ê´€ë¦¬ì ê³µìš©)
    # POST /api/v1/submissions/
    # --------------------------------------------
    def perform_create(self, serializer):
        """
        Submission ìƒì„± ì§í›„:
        - status = SUBMITTED
        - dispatcherë¥¼ í†µí•´ Workerë¡œ ì „ë‹¬
        """
        submission = serializer.save(user=self.request.user)
        dispatch_submission(submission)

    # ============================================================
    # ğŸ”¥ ê´€ë¦¬ì OMR ì—…ë¡œë“œ ì „ìš© API
    # POST /api/v1/submissions/admin/omr-upload/
    # ============================================================
    @action(
        detail=False,
        methods=["post"],
        url_path="admin/omr-upload",
    )
    def admin_omr_upload(self, request):
        """
        ê´€ë¦¬ì OMR ìŠ¤ìº” ì—…ë¡œë“œ

        form-data:
        - enrollment_id
        - target_id        (exam_id)
        - file             (pdf / image)

        âš ï¸ target_type, sourceëŠ” ì„œë²„ì—ì„œ ê°•ì œ
        """

        serializer = SubmissionCreateSerializer(
            data={
                "enrollment_id": request.data.get("enrollment_id"),
                "target_type": Submission.TargetType.EXAM,
                "target_id": request.data.get("target_id"),
                "source": Submission.Source.OMR_SCAN,
                "file": request.FILES.get("file"),
            }
        )
        serializer.is_valid(raise_exception=True)

        submission = serializer.save(user=request.user)

        # ğŸ”¥ STEP 2: AI / OMR Worker ë””ìŠ¤íŒ¨ì¹˜
        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            },
            status=status.HTTP_201_CREATED,
        )

    # ============================================================
    # ğŸ” Submission ì¬ì²˜ë¦¬
    # POST /api/v1/submissions/{id}/retry/
    # ============================================================
    @action(detail=True, methods=["post"])
    def retry(self, request, pk=None):
        """
        FAILED ìƒíƒœ Submission ì¬ì²˜ë¦¬ ì „ìš©

        - status ë¦¬ì…‹
        - ë‹¤ì‹œ dispatcher í˜¸ì¶œ
        """

        submission = self.get_object()

        # â— ì‹¤íŒ¨í•œ ê²ƒë§Œ ì¬ì²˜ë¦¬ í—ˆìš©
        if submission.status != Submission.Status.FAILED:
            return Response(
                {"detail": "Only FAILED submissions can be retried."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # ìƒíƒœ ë¦¬ì…‹
        submission.status = Submission.Status.SUBMITTED
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])

        # ë‹¤ì‹œ ë””ìŠ¤íŒ¨ì¹˜
        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            }
        )
