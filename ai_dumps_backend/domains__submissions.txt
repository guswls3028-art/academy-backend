====================================================================================================
# BACKEND APP: domains__submissions
# ROOT PATH: C:\academy\apps\domains\submissions
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: admin.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/submissions/apps.py
from django.apps import AppConfig


class SubmissionsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.submissions"
    label = "submissions"


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/submissions/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter

from .views import SubmissionViewSet
from .views.exam_omr_submit_view import ExamOMRSubmitView

# âœ… ì¶”ê°€
from .views.exam_submissions_list_view import ExamSubmissionsListView
from .views.exam_omr_batch_upload_view import ExamOMRBatchUploadView

router = DefaultRouter()
router.register("submissions", SubmissionViewSet, basename="submissions")

urlpatterns = [
    # ğŸ”¥ STEP 2: ì‹œí—˜ OMR ì „ìš© ì œì¶œ (file_key ê¸°ë°˜)
    path(
        "submissions/exams/<int:exam_id>/omr/",
        ExamOMRSubmitView.as_view(),
        name="exam-omr-submit",
    ),

    # âœ… í”„ë¡ íŠ¸ ì œì¶œ ëª©ë¡: GET /submissions/exams/{examId}/
    path(
        "submissions/exams/<int:exam_id>/",
        ExamSubmissionsListView.as_view(),
        name="exam-submissions-list",
    ),

    # âœ… ë‹¤ê±´ ì—…ë¡œë“œ: POST /submissions/exams/{examId}/omr/batch/
    path(
        "submissions/exams/<int:exam_id>/omr/batch/",
        ExamOMRBatchUploadView.as_view(),
        name="exam-omr-batch-upload",
    ),
]

urlpatterns += router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# apps/domains/submissions/migrations/0001_initial.py
# Generated by Django 5.2.9
#
# âš ï¸ IMPORTANT
# - ì´ 0001ì€ "ìµœì¢… ê³„ì•½" ê¸°ì¤€ìœ¼ë¡œ ìˆ˜ë™ ìˆ˜ì •ë¨
# - question_id / question_number ê°œë… ì—†ìŒ
# - exam_question_idë§Œ ë‹¨ì¼ ì§„ì‹¤
# - ì´í›„ migrationì—ì„œ ì ˆëŒ€ ì¶©ëŒ ë‚˜ì§€ ì•ŠìŒ

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # ======================================================
        # Submission
        # ======================================================
        migrations.CreateModel(
            name="Submission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),

                ("enrollment_id", models.PositiveIntegerField(null=True, blank=True, db_index=True)),

                (
                    "target_type",
                    models.CharField(
                        max_length=20,
                        choices=[("exam", "Exam"), ("homework", "Homework")],
                    ),
                ),
                ("target_id", models.PositiveIntegerField()),

                (
                    "source",
                    models.CharField(
                        max_length=30,
                        choices=[
                            ("omr_scan", "OMR Scan"),
                            ("omr_manual", "OMR Manual Input"),
                            ("online", "Online"),
                            ("homework_image", "Homework Image"),
                            ("homework_video", "Homework Video"),
                            ("ai_match", "AI Image Match"),
                        ],
                    ),
                ),

                # R2 file metadata
                ("file_key", models.CharField(max_length=512, null=True, blank=True)),
                ("file_type", models.CharField(max_length=50, null=True, blank=True)),
                ("file_size", models.PositiveIntegerField(null=True, blank=True)),

                ("payload", models.JSONField(null=True, blank=True)),

                (
                    "status",
                    models.CharField(
                        max_length=20,
                        default="submitted",
                        choices=[
                            ("submitted", "Submitted"),
                            ("dispatched", "Dispatched"),
                            ("extracting", "Extracting"),
                            ("answers_ready", "Answers Ready"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                    ),
                ),

                ("error_message", models.TextField(blank=True)),
                ("meta", models.JSONField(null=True, blank=True)),

                (
                    "user",
                    models.ForeignKey(
                        to=settings.AUTH_USER_MODEL,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="submissions",
                    ),
                ),
            ],
        ),

        # ======================================================
        # SubmissionAnswer (FINAL CONTRACT)
        # ======================================================
        migrations.CreateModel(
            name="SubmissionAnswer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),

                # âœ… ë‹¨ì¼ ì§„ì‹¤
                (
                    "exam_question_id",
                    models.PositiveIntegerField(
                        help_text="Fixed contract: exams.ExamQuestion.id",
                    ),
                ),

                ("answer", models.TextField(blank=True)),
                ("meta", models.JSONField(default=dict, blank=True)),

                (
                    "submission",
                    models.ForeignKey(
                        to="submissions.submission",
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="answers",
                    ),
                ),
            ],
            options={
                "db_table": "submissions_submissionanswer",
                "unique_together": {("submission", "exam_question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_alter_submissionanswer_exam_question_id_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-01 15:34

from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("submissions", "0001_initial"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AlterField(
            model_name="submissionanswer",
            name="exam_question_id",
            field=models.PositiveIntegerField(
                db_index=True, help_text="Fixed contract: exams.ExamQuestion.id"
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["target_type", "target_id"],
                name="submissions_target__6e8ca2_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["enrollment_id", "created_at"],
                name="submissions_enrollm_bf0086_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["user", "created_at"], name="submissions_user_id_6a1f53_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["status"], name="submissions_status_c2b4f2_idx"),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["source"], name="submissions_source_234254_idx"),
        ),
        migrations.AddIndex(
            model_name="submissionanswer",
            index=models.Index(
                fields=["exam_question_id"], name="submissions_exam_qu_5bbab0_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="submissionanswer",
            index=models.Index(
                fields=["submission", "exam_question_id"],
                name="submissions_submiss_2a9caf_idx",
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0003_alter_submission_status.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-03 10:42

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("submissions", "0002_alter_submissionanswer_exam_question_id_and_more"),
    ]

    operations = [
        migrations.AlterField(
            model_name="submission",
            name="status",
            field=models.CharField(
                choices=[
                    ("submitted", "Submitted"),
                    ("dispatched", "Dispatched"),
                    ("extracting", "Extracting"),
                    ("answers_ready", "Answers Ready"),
                    ("grading", "Grading"),
                    ("done", "Done"),
                    ("failed", "Failed"),
                    ("needs_identification", "Needs Identification"),
                ],
                default="submitted",
                max_length=30,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0004_add_submissions_tenant.py
==========================================================================================
# PATH: apps/domains/submissions/migrations/0004_add_submissions_tenant.py
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
        ("submissions", "0003_alter_submission_status"),
    ]

    operations = [
        migrations.AddField(
            model_name="submission",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="submissions",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="submissionanswer",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="submission_answers",
                null=True,
                blank=True,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0005_backfill_submissions_tenant.py
==========================================================================================
# PATH: apps/domains/submissions/migrations/0005_backfill_submissions_tenant.py
from django.db import migrations


def backfill_submissions_tenant(apps, schema_editor):
    Tenant = apps.get_model("core", "Tenant")
    Submission = apps.get_model("submissions", "Submission")
    SubmissionAnswer = apps.get_model("submissions", "SubmissionAnswer")

    tenants = Tenant.objects.filter(is_active=True).order_by("id")
    if tenants.count() != 1:
        raise RuntimeError("Cannot auto-backfill tenant for submissions domain")

    tenant = tenants.first()
    Submission.objects.filter(tenant__isnull=True).update(tenant=tenant)
    SubmissionAnswer.objects.filter(tenant__isnull=True).update(tenant=tenant)


class Migration(migrations.Migration):

    dependencies = [
        ("submissions", "0004_add_submissions_tenant"),
    ]

    operations = [
        migrations.RunPython(backfill_submissions_tenant, migrations.RunPython.noop),
    ]


==========================================================================================
# FILE: migrations/0006_make_submissions_tenant_not_null.py
==========================================================================================
# PATH: apps/domains/submissions/migrations/0006_make_submissions_tenant_not_null.py
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ("submissions", "0005_backfill_submissions_tenant"),
    ]

    operations = [
        migrations.AlterField(
            model_name="submission",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="submissions",
                null=False,
                blank=False,
            ),
        ),
        migrations.AlterField(
            model_name="submissionanswer",
            name="tenant",
            field=models.ForeignKey(
                to="core.tenant",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="submission_answers",
                null=False,
                blank=False,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0007_submission_submissions_tenant__da4eb9_idx.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-12 12:00

from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0014_alter_user_phone_and_more"),
        ("submissions", "0006_make_submissions_tenant_not_null"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["tenant", "created_at"], name="submissions_tenant__da4eb9_idx"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
from .submission import Submission
from .submission_answer import SubmissionAnswer

__all__ = [
    "Submission", 
    "SubmissionAnswer"
    ]


==========================================================================================
# FILE: models/submission.py
==========================================================================================
# PATH: apps/domains/submissions/models/submission.py
from __future__ import annotations

from django.db import models
from django.conf import settings
from apps.api.common.models import TimestampModel
from apps.core.models import Tenant


class Submission(TimestampModel):
    class TargetType(models.TextChoices):
        EXAM = "exam", "Exam"
        HOMEWORK = "homework", "Homework"

    class Source(models.TextChoices):
        OMR_SCAN = "omr_scan", "OMR Scan"
        OMR_MANUAL = "omr_manual", "OMR Manual Input"
        ONLINE = "online", "Online"
        HOMEWORK_IMAGE = "homework_image", "Homework Image"
        HOMEWORK_VIDEO = "homework_video", "Homework Video"
        AI_MATCH = "ai_match", "AI Image Match"

    class Status(models.TextChoices):
        SUBMITTED = "submitted", "Submitted"
        DISPATCHED = "dispatched", "Dispatched"
        EXTRACTING = "extracting", "Extracting"
        ANSWERS_READY = "answers_ready", "Answers Ready"
        GRADING = "grading", "Grading"
        DONE = "done", "Done"
        FAILED = "failed", "Failed"
        NEEDS_IDENTIFICATION = "needs_identification", "Needs Identification"

    STATUS_FLOW = {
        Status.SUBMITTED: {Status.DISPATCHED},
        Status.DISPATCHED: {Status.EXTRACTING, Status.ANSWERS_READY},
        Status.ANSWERS_READY: {Status.GRADING},
        Status.GRADING: {Status.DONE, Status.FAILED},
        Status.FAILED: {Status.SUBMITTED},
        Status.NEEDS_IDENTIFICATION: {Status.ANSWERS_READY},
    }

    @classmethod
    def can_transit(cls, from_status: str, to_status: str) -> bool:
        return to_status in cls.STATUS_FLOW.get(from_status, set())

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="submissions",
        db_index=True,  # âœ… tenant_id ì¸ë±ìŠ¤ ì¶”ê°€
    )

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="submissions",
    )

    enrollment_id = models.PositiveIntegerField(null=True, blank=True, db_index=True)

    target_type = models.CharField(max_length=20, choices=TargetType.choices)
    target_id = models.PositiveIntegerField()

    source = models.CharField(max_length=30, choices=Source.choices)

    file_key = models.CharField(max_length=512, null=True, blank=True)
    file_type = models.CharField(max_length=50, null=True, blank=True)
    file_size = models.PositiveIntegerField(null=True, blank=True)

    payload = models.JSONField(null=True, blank=True)

    status = models.CharField(
        max_length=30,
        choices=Status.choices,
        default=Status.SUBMITTED,
    )
    error_message = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["target_type", "target_id"]),
            models.Index(fields=["enrollment_id", "created_at"]),
            models.Index(fields=["user", "created_at"]),
            models.Index(fields=["status"]),
            models.Index(fields=["source"]),
            models.Index(fields=["tenant", "created_at"]),  # âœ… ë³µí•© ì¸ë±ìŠ¤ ì¶”ê°€
        ]


==========================================================================================
# FILE: models/submission_answer.py
==========================================================================================
# PATH: apps/domains/submissions/models/submission_answer.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import BaseModel
from apps.core.models import Tenant


class SubmissionAnswer(BaseModel):
    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="submission_answers",
    )

    submission = models.ForeignKey(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="answers",
    )

    exam_question_id = models.PositiveIntegerField(
        db_index=True,
        help_text="Fixed contract: exams.ExamQuestion.id",
    )

    answer = models.TextField(blank=True)
    meta = models.JSONField(default=dict, blank=True)

    class Meta:
        db_table = "submissions_submissionanswer"
        indexes = [
            models.Index(fields=["exam_question_id"]),
            models.Index(fields=["submission", "exam_question_id"]),
        ]
        unique_together = ("submission", "exam_question_id")

    def __str__(self):
        return f"Submission#{self.submission_id} Q={self.exam_question_id}"


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
from .submission import SubmissionSerializer, SubmissionCreateSerializer

__all__ = ["SubmissionSerializer", "SubmissionCreateSerializer"]


==========================================================================================
# FILE: serializers/submission.py
==========================================================================================
# PATH: apps/domains/submissions/serializers/submission.py
# ë³€ê²½ ìš”ì•½:
# - OMR_SCANì€ enrollment_id ì—†ì´ ì œì¶œ ìƒì„± í—ˆìš© (ì‹ë³„ì€ OMR ë§ˆí‚¹/AIê°€ ì±„ì›€)
# - file(FileField)ë¡œ ì—…ë¡œë“œ ë°›ì€ íŒŒì¼ì„ R2ë¡œ ì—…ë¡œë“œ í›„ file_key ì €ì¥

from __future__ import annotations

import mimetypes
import uuid

from rest_framework import serializers

from apps.domains.submissions.models import Submission

# âœ… API ì„œë²„ ì „ìš© R2 ì—…ë¡œë“œ
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2


class SubmissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Submission
        fields = "__all__"
        read_only_fields = (
            "id",
            "user",
            "status",
            "error_message",
            "meta",
            "created_at",
            "updated_at",
        )


class SubmissionCreateSerializer(serializers.ModelSerializer):
    file = serializers.FileField(required=False)

    class Meta:
        model = Submission
        fields = (
            "enrollment_id",
            "target_type",
            "target_id",
            "source",
            "file",
            "payload",
        )

    def validate(self, attrs):
        source = attrs.get("source")
        target_type = attrs.get("target_type")

        # âœ… í•µì‹¬ ì •ì±…:
        # - exam/homeworkëŠ” ì¼ë°˜ì ìœ¼ë¡œ enrollment_id í•„ìš”
        # - ë‹¨, OMR_SCANì€ "ì‹ë³„ì„ OMR ë§ˆí‚¹ìœ¼ë¡œ ì²˜ë¦¬"í•˜ë¯€ë¡œ enrollment_id ì—†ì´ ìƒì„± í—ˆìš©
        if target_type in (Submission.TargetType.EXAM, Submission.TargetType.HOMEWORK):
            if source != Submission.Source.OMR_SCAN:
                if not attrs.get("enrollment_id"):
                    raise serializers.ValidationError({"enrollment_id": "required"})

        # íŒŒì¼ ê¸°ë°˜ ì†ŒìŠ¤ëŠ” file í•„ìš”
        if source in (
            Submission.Source.OMR_SCAN,
            Submission.Source.HOMEWORK_IMAGE,
            Submission.Source.HOMEWORK_VIDEO,
        ):
            if not attrs.get("file"):
                raise serializers.ValidationError({"file": "file required"})

        # onlineì€ payload í•„ìš”
        if source == Submission.Source.ONLINE and not attrs.get("payload"):
            raise serializers.ValidationError({"payload": "required"})

        return attrs

    def create(self, validated_data):
        upload_file = validated_data.pop("file", None)

        submission = Submission.objects.create(**validated_data)

        if upload_file:
            ext = upload_file.name.split(".")[-1]
            key = f"submissions/{submission.id}/{uuid.uuid4().hex}.{ext}"

            upload_fileobj_to_r2(
                fileobj=upload_file,
                key=key,
                content_type=getattr(upload_file, "content_type", None),
            )

            submission.file_key = key
            submission.file_type = (
                getattr(upload_file, "content_type", None)
                or mimetypes.guess_type(upload_file.name)[0]
            )
            submission.file_size = getattr(upload_file, "size", None)
            submission.save(update_fields=["file_key", "file_type", "file_size"])

        return submission


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/ai_omr_result_mapper.py
==========================================================================================
from __future__ import annotations

from typing import Any, Dict, Optional
import logging
from datetime import datetime, timezone

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer

logger = logging.getLogger(__name__)


@transaction.atomic
def apply_omr_ai_result(payload: Dict[str, Any]) -> Optional[int]:
    submission_id = payload.get("submission_id")
    if not submission_id:
        return None

    try:
        submission = Submission.objects.select_for_update().get(id=int(submission_id))
    except Submission.DoesNotExist:
        return None

    status = payload.get("status")
    result = payload.get("result") or {}
    error = payload.get("error")

    meta = dict(submission.meta or {})
    meta["ai_result"] = {
        "status": status,
        "result": result,
        "error": error,
        "received_at": datetime.now(timezone.utc).isoformat(),
        "kind": "omr_scan",
    }
    submission.meta = meta

    if status == "FAILED":
        submission.status = Submission.Status.FAILED
        submission.error_message = error or "AI worker failed"
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return submission.id

    answers = result.get("answers") or []
    identifier = result.get("identifier")

    manual_required = False
    reasons = []

    for a in answers:
        eqid = a.get("exam_question_id")
        if not eqid:
            continue

        SubmissionAnswer.objects.update_or_create(
            submission=submission,
            exam_question_id=int(eqid),
            defaults={
                "answer": "".join([str(x) for x in a.get("detected") or []]),
                "meta": {
                    "omr": {
                        "version": result.get("version"),
                        "detected": a.get("detected"),
                        "marking": a.get("marking"),
                        "confidence": a.get("confidence"),
                        "status": a.get("status"),
                    }
                },
            },
        )

        st = str(a.get("status") or "").lower()
        mk = str(a.get("marking") or "").lower()
        conf = a.get("confidence")

        try:
            conf_f = float(conf) if conf is not None else None
        except Exception:
            conf_f = None

        if st != "ok":
            manual_required = True
            reasons.append("ANSWER_STATUS_NOT_OK")

        if mk in ("blank", "multi"):
            manual_required = True
            reasons.append("ANSWER_BLANK_OR_MULTI")

        if conf_f is not None and conf_f < 0.70:
            manual_required = True
            reasons.append("ANSWER_LOW_CONFIDENCE")

    # âœ… ì‹ë³„ì ì‹¤íŒ¨ â†’ ëª…ì‹œì  ìƒíƒœ
    identifier_ok = (
        isinstance(identifier, dict)
        and identifier.get("status") == "ok"
        and identifier.get("enrollment_id")
    )

    meta.setdefault("manual_review", {})
    meta["manual_review"]["required"] = bool(manual_required or not identifier_ok)
    meta["manual_review"]["reasons"] = sorted(set(reasons))
    meta["manual_review"]["updated_at"] = datetime.now(timezone.utc).isoformat()

    submission.meta = meta

    if not identifier_ok:
        submission.status = Submission.Status.NEEDS_IDENTIFICATION
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return submission.id

    submission.enrollment_id = int(identifier.get("enrollment_id"))
    submission.status = Submission.Status.ANSWERS_READY
    submission.error_message = ""
    submission.save(update_fields=["meta", "status", "enrollment_id", "error_message", "updated_at"])

    return submission.id


==========================================================================================
# FILE: services/ai_result_router.py
==========================================================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional
import logging

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.ai_omr_result_mapper import apply_omr_ai_result

logger = logging.getLogger(__name__)

MIN_HOMEWORK_VIDEO_FILLED_RATIO = 0.10


@dataclass(frozen=True)
class ApplyAIResultOutcome:
    returned_submission_id: Optional[int]
    should_grade: bool
    detail: Dict[str, Any]


def _coerce_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return default


def _safe_bool(v: Any, default: bool = False) -> bool:
    if isinstance(v, bool):
        return v
    if isinstance(v, (int, float)):
        return bool(v)
    if isinstance(v, str):
        return v.strip().lower() in ("1", "true", "yes", "y", "on")
    return default


@transaction.atomic
def apply_ai_result_for_submission(
    *,
    submission_id: int,
    status: str,
    result: Optional[Dict[str, Any]],
    error: Optional[str],
) -> ApplyAIResultOutcome:
    try:
        submission = Submission.objects.select_for_update().get(id=int(submission_id))
    except Submission.DoesNotExist:
        return ApplyAIResultOutcome(None, False, {"error": "submission not found"})

    meta = dict(submission.meta or {})
    meta["ai_result"] = {"status": status, "result": result, "error": error}
    submission.meta = meta

    if str(status).upper() == "FAILED":
        submission.status = Submission.Status.FAILED
        submission.error_message = error or "AI worker failed"
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return ApplyAIResultOutcome(submission.id, False, {"status": "FAILED"})

    if submission.source == Submission.Source.OMR_SCAN:
        payload = {
            "submission_id": submission.id,
            "status": "DONE",
            "result": result or {},
            "error": None,
        }
        returned_id = apply_omr_ai_result(payload)
        submission.save(update_fields=["meta", "updated_at"])
        return ApplyAIResultOutcome(returned_id, True, {"routed": "omr_scan"})

    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        r = result or {}
        filled_ratio = _coerce_float(r.get("filled_ratio"))
        too_short = _safe_bool(r.get("too_short"))
        has_content = (not too_short) and (filled_ratio >= MIN_HOMEWORK_VIDEO_FILLED_RATIO)

        meta["homework_video_result"] = {
            "has_content": has_content,
            "filled_ratio": filled_ratio,
            "too_short": too_short,
            "policy": {"min_filled_ratio": MIN_HOMEWORK_VIDEO_FILLED_RATIO},
        }
        submission.meta = meta
        submission.status = Submission.Status.DONE
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return ApplyAIResultOutcome(submission.id, False, {"routed": "homework_video"})

    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        meta["homework_image_ocr"] = result or {}
        submission.meta = meta
        submission.status = Submission.Status.DONE
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
        return ApplyAIResultOutcome(submission.id, False, {"routed": "homework_image"})

    submission.status = Submission.Status.DONE
    submission.error_message = ""
    submission.save(update_fields=["meta", "status", "error_message", "updated_at"])
    return ApplyAIResultOutcome(submission.id, False, {"routed": "default"})


==========================================================================================
# FILE: services/dispatcher.py
==========================================================================================
# PATH: apps/domains/submissions/services/dispatcher.py
from __future__ import annotations

import logging
from typing import Any, Dict, Optional

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.submission_service import SubmissionService

from apps.domains.exams.models import ExamQuestion, Sheet
from apps.domains.assets.omr.services.meta_generator import build_objective_template_meta
from apps.infrastructure.storage.r2 import generate_presigned_get_url

from apps.domains.ai.gateway import dispatch_job
from apps.domains.results.services.grading_service import grade_submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline

# âœ… [ì¶”ê°€] AI ì›Œì»¤ EC2 ì œì–´
from apps.domains.ai.services.worker_instance_control import start_ai_worker_instance

logger = logging.getLogger(__name__)


def _infer_ai_job_type(submission: Submission) -> str:
    if submission.source == Submission.Source.OMR_SCAN:
        return "omr_grading"
    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        return "ocr"
    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        return "homework_video_analysis"
    return "ocr"


def _safe_int(v: Any) -> Optional[int]:
    try:
        return int(v) if v is not None else None
    except Exception:
        return None


def _build_ai_payload(submission: Submission) -> Dict[str, Any]:
    payload = dict(submission.payload or {})

    mode = str(payload.get("mode") or "auto").lower()
    if mode not in ("scan", "photo", "auto"):
        mode = "auto"

    sheet_id = _safe_int(payload.get("sheet_id"))

    questions_payload = []
    if sheet_id:
        qs = ExamQuestion.objects.filter(sheet_id=sheet_id).order_by("number")
        for q in qs:
            region_meta = getattr(q, "region_meta", None) or getattr(q, "meta", None)
            questions_payload.append(
                {
                    "exam_question_id": int(q.id),
                    "number": int(getattr(q, "number", 0) or 0),
                    "region_meta": region_meta,
                }
            )

    download_url = None
    if submission.file_key:
        download_url = generate_presigned_get_url(
            key=submission.file_key,
            expires_in=3600,
        )

    payload.update(
        {
            "submission_id": int(submission.id),
            "target_type": submission.target_type,
            "target_id": int(submission.target_id),
            "file_key": submission.file_key,
            "download_url": download_url,
            "omr": {"sheet_id": sheet_id},
            "questions": questions_payload,
            "mode": mode,
        }
    )

    if submission.source == Submission.Source.OMR_SCAN and sheet_id:
        qc = 0
        sh = Sheet.objects.filter(id=sheet_id).first()
        if sh:
            qc = int(getattr(sh, "total_questions", 0) or 0)

        if qc in (10, 20, 30):
            payload["question_count"] = qc
            payload["template_meta"] = build_objective_template_meta(question_count=qc)

    return payload


@transaction.atomic
def dispatch_submission(submission: Submission) -> None:
    """
    Submission ì²˜ë¦¬ SSOT
    """

    if submission.status != Submission.Status.SUBMITTED:
        return

    # ONLINE
    if submission.source == Submission.Source.ONLINE:
        SubmissionService.process(submission)

        submission.status = Submission.Status.GRADING
        submission.save(update_fields=["status", "updated_at"])

        grade_submission(int(submission.id))
        dispatch_progress_pipeline(submission_id=submission.id)

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status", "updated_at"])
        return

    # FILE ê¸°ë°˜
    if not submission.file_key:
        submission.status = Submission.Status.FAILED
        submission.error_message = "file_key missing"
        submission.save(update_fields=["status", "error_message", "updated_at"])
        return

    submission.status = Submission.Status.DISPATCHED
    submission.error_message = ""
    submission.save(update_fields=["status", "error_message", "updated_at"])

    # ==================================================
    # âœ… 1) AI Job ìƒì„± (DB SSOT)
    # ==================================================
    dispatch_job(
        job_type=_infer_ai_job_type(submission),
        payload=_build_ai_payload(submission),
        source_domain="submissions",
        source_id=str(submission.id),
    )

    # ==================================================
    # âœ… 2) ì›Œì»¤ EC2 ê¹¨ìš°ê¸° (API ì„œë²„ ì±…ì„)
    # - jobì´ ì‹¤ì œë¡œ ìƒê¸´ ë’¤ì—ë§Œ í˜¸ì¶œ
    # - ì¤‘ë³µ í˜¸ì¶œë¼ë„ EC2ëŠ” idempotent
    # ==================================================
    start_ai_worker_instance()


==========================================================================================
# FILE: services/submission_service.py
==========================================================================================
from typing import List, Type
from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor
from apps.domains.submissions.services.processor.online import OnlineSubmissionProcessor

PROCESSOR_MAP: dict[str, Type[BaseSubmissionProcessor]] = {
    Submission.Source.ONLINE: OnlineSubmissionProcessor,
}


class SubmissionService:
    @staticmethod
    @transaction.atomic
    def process(submission: Submission) -> List[SubmissionAnswer]:
        processor_cls = PROCESSOR_MAP.get(submission.source)
        if not processor_cls:
            return []

        processor = processor_cls(submission)
        answers = processor.process()

        submission.status = Submission.Status.ANSWERS_READY
        submission.save(update_fields=["status", "updated_at"])
        return answers


==========================================================================================
# FILE: services/processor/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/processor/base.py
==========================================================================================
# apps/domains/submissions/services/processor/base.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Dict, Any, List

from django.db import transaction
from apps.domains.submissions.models import Submission, SubmissionAnswer


class BaseSubmissionProcessor(ABC):
    """
    submissions ë‚´ processor = 'ë‹µì•ˆ ì¤‘ê°„ì‚°ë¬¼ ì €ì¥'ê¹Œì§€ë§Œ
    """

    source: str = "base"

    def __init__(self, submission: Submission):
        self.submission = submission

    @transaction.atomic
    def process(self) -> List[SubmissionAnswer]:
        extracted = list(self.extract_answers())
        return self._save_answers(extracted)

    @abstractmethod
    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        """
        ë°˜í™˜ í¬ë§· (FINAL):
            {
              "exam_question_id": int,
              "answer": str,
              "meta": dict|None
            }
        """
        raise NotImplementedError

    def _save_answers(self, extracted: Iterable[Dict[str, Any]]) -> List[SubmissionAnswer]:
        results: List[SubmissionAnswer] = []

        for item in extracted:
            eqid = item.get("exam_question_id")
            if not eqid:
                continue  # âŒ ê³„ì•½ ìœ„ë°˜ ë°ì´í„° ë¬´ì‹œ

            obj, _ = SubmissionAnswer.objects.update_or_create(
                submission=self.submission,
                exam_question_id=int(eqid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or {},
                },
            )
            results.append(obj)

        return results


==========================================================================================
# FILE: services/processor/online.py
==========================================================================================
# apps/domains/submissions/services/processor/online.py
from __future__ import annotations

from typing import Iterable, Dict, Any
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OnlineSubmissionProcessor(BaseSubmissionProcessor):
    source = "online"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        answers = payload.get("answers")

        if not isinstance(answers, (list, dict)):
            return

        rows = answers if isinstance(answers, list) else answers.items()

        for row in rows:
            eqid = (
                row.get("exam_question_id")
                if isinstance(row, dict)
                else None
            )
            if not eqid:
                continue

            yield {
                "exam_question_id": int(eqid),
                "answer": row.get("answer", ""),
                "meta": row.get("meta") or {"via": "online"},
            }


==========================================================================================
# FILE: services/processor/video.py
==========================================================================================
# apps/domains/submissions/services/processor/video.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor

class VideoSubmissionProcessor(BaseSubmissionProcessor):
    source = "homework_video"

    def extract_answers(self):
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        if not isinstance(extracted, (list, dict)):
            return

        rows = extracted if isinstance(extracted, list) else extracted.items()

        for row in rows:
            # workerê°€ v2 ê³„ì•½ì„ ì§€í‚¨ ê²½ìš°ë§Œ ì²˜ë¦¬
            eqid = (
                row.get("exam_question_id")
                if isinstance(row, dict)
                else None
            )

            if not eqid:
                # âŒ legacy video ë‹µì•ˆì€ ì •ê·œ ì €ì¥í•˜ì§€ ì•ŠìŒ
                continue

            yield {
                "exam_question_id": int(eqid),
                "question_number": None,
                "answer": row.get("answer", ""),
                "meta": row.get("meta") or {"via": "video"},
            }


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# domains/submissions/views/__init__.py

from .submission_view import SubmissionViewSet

__all__ = ["SubmissionViewSet"]


==========================================================================================
# FILE: views/exam_omr_batch_upload_view.py
==========================================================================================
# PATH: apps/domains/submissions/views/exam_omr_batch_upload_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.serializers.submission import SubmissionCreateSerializer
from apps.domains.submissions.services.dispatcher import dispatch_submission


class ExamOMRBatchUploadView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, exam_id: int):
        """
        multipart/form-data:
          - files: File[]  (ë°˜ë³µ)
          - (optional) sheet_id: number  (payloadë¡œ ì „ë‹¬)
        """
        files = request.FILES.getlist("files") or []
        if not files:
            # ì¼ë¶€ í´ë¼ì´ì–¸íŠ¸ëŠ” file ë‹¨ì¼ í‚¤ë¥¼ ì“°ê¸°ë„ í•¨
            f = request.FILES.get("file")
            if f:
                files = [f]

        if not files:
            return Response({"detail": "files required"}, status=400)

        sheet_id = request.data.get("sheet_id")
        payload = {}
        if sheet_id:
            try:
                payload["sheet_id"] = int(sheet_id)
            except Exception:
                payload["sheet_id"] = sheet_id

        created_ids = []

        for f in files:
            # âœ… OMR_SCANì€ enrollment_id ì—†ì´ ìƒì„± ê°€ëŠ¥(Serializer ì •ì±…ê³¼ ì¼ì¹˜)
            ser = SubmissionCreateSerializer(
                data={
                    "enrollment_id": None,
                    "target_type": Submission.TargetType.EXAM,
                    "target_id": int(exam_id),
                    "source": Submission.Source.OMR_SCAN,
                    "payload": payload or None,
                    "file": f,
                }
            )
            ser.is_valid(raise_exception=True)
            sub = ser.save(user=request.user)
            dispatch_submission(sub)
            created_ids.append(int(sub.id))

        return Response(
            {"created_count": len(created_ids), "submission_ids": created_ids},
            status=201,
        )


==========================================================================================
# FILE: views/exam_omr_submit_view.py
==========================================================================================
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.dispatcher import dispatch_submission


class ExamOMRSubmitView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, exam_id: int):
        enrollment_id = request.data.get("enrollment_id")
        sheet_id = request.data.get("sheet_id")
        file_key = request.data.get("file_key")

        if not all([enrollment_id, sheet_id, file_key]):
            return Response(
                {"detail": "enrollment_id, sheet_id, file_key required"}, status=400
            )

        submission = Submission.objects.create(
            user=request.user,
            enrollment_id=int(enrollment_id),
            target_type=Submission.TargetType.EXAM,
            target_id=int(exam_id),
            source=Submission.Source.OMR_SCAN,
            file_key=str(file_key),
            payload={"sheet_id": int(sheet_id)},
        )

        dispatch_submission(submission)

        return Response(
            {"submission_id": submission.id, "status": submission.status}, status=201
        )


==========================================================================================
# FILE: views/exam_submissions_list_view.py
==========================================================================================
# PATH: apps/domains/submissions/views/exam_submissions_list_view.py
from __future__ import annotations

from typing import Any, Dict, Optional

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission


def _map_row_status(s: str) -> str:
    """
    Front SubmissionRow.status contract:
    - pending | processing | done | failed
    """
    s = str(s or "").lower()

    if s in ("failed",):
        return "failed"

    # needs_identificationë„ ìš´ì˜ìƒ "ì²˜ë¦¬ì¤‘(ìˆ˜ë™ê°œì… í•„ìš”)"ë¡œ ë³¸ë‹¤
    if s in ("done",):
        return "done"

    if s in ("submitted", "dispatched"):
        return "pending"

    if s in ("extracting", "answers_ready", "grading", "needs_identification"):
        return "processing"

    return "processing"


def _resolve_student_name(enrollment_id: Optional[int]) -> str:
    """
    í”„ë¡œì íŠ¸ë§ˆë‹¤ Enrollment/Student ëª¨ë¸ ê²½ë¡œê°€ ë‹¤ë¥´ë¯€ë¡œ best-effort.
    ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜(í”„ë¡ íŠ¸ê°€ #idë¡œë„ ì‹ë³„ ê°€ëŠ¥).
    """
    if not enrollment_id:
        return ""

    # 1) ê°€ì¥ í”í•œ ì¼€ì´ìŠ¤: apps.domains.enrollments.models.Enrollment
    try:
        from apps.domains.enrollments.models import Enrollment  # type: ignore

        obj = Enrollment.objects.filter(id=int(enrollment_id)).first()
        if obj:
            for attr in ("student_name", "name", "full_name"):
                v = getattr(obj, attr, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()
    except Exception:
        pass

    # 2) ë‹¤ë¥¸ ì¼€ì´ìŠ¤ë“¤(ìˆìœ¼ë©´ í™•ì¥)
    return ""


def _resolve_score_for_submission(submission_id: int) -> Optional[float]:
    """
    ê²°ê³¼ ë„ë©”ì¸ êµ¬í˜„ì´ ì—¬ëŸ¬ í˜•íƒœì¼ ìˆ˜ ìˆì–´ best-effort.
    ìˆìœ¼ë©´ score ë°˜í™˜, ì—†ìœ¼ë©´ None.
    """
    # í”í•œ ì¼€ì´ìŠ¤: results ëª¨ë¸ì— submission_id ì—°ê²°
    try:
        from apps.domains.results.models import Result  # type: ignore

        r = Result.objects.filter(submission_id=int(submission_id)).order_by("-id").first()
        if r and getattr(r, "score", None) is not None:
            return float(r.score)
    except Exception:
        pass

    # ë‹¤ë¥¸ í…Œì´ë¸” êµ¬ì¡°ë¼ë©´ ì—¬ê¸° ì¶”ê°€
    return None


class ExamSubmissionsListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        qs = (
            Submission.objects
            .filter(target_type=Submission.TargetType.EXAM, target_id=int(exam_id))
            .order_by("-id")[:200]
        )

        items: list[Dict[str, Any]] = []
        for s in qs:
            enrollment_id = getattr(s, "enrollment_id", None)
            items.append(
                {
                    "id": int(s.id),
                    "enrollment_id": int(enrollment_id) if enrollment_id else 0,
                    "student_name": _resolve_student_name(enrollment_id),
                    "status": _map_row_status(getattr(s, "status", "")),
                    "score": _resolve_score_for_submission(int(s.id)),
                    "created_at": s.created_at.isoformat(),
                }
            )

        return Response(items, status=200)


==========================================================================================
# FILE: views/submission_view.py
==========================================================================================
# PATH: apps/domains/submissions/views/submission_view.py
from __future__ import annotations

from django.utils import timezone

from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.submissions.serializers.submission import (
    SubmissionSerializer,
    SubmissionCreateSerializer,
)
from apps.domains.submissions.services.dispatcher import dispatch_submission
from apps.domains.results.services.grading_service import grade_submission


class SubmissionViewSet(ModelViewSet):
    queryset = Submission.objects.all().order_by("-id")
    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action in ("create", "admin_omr_upload"):
            return SubmissionCreateSerializer
        return SubmissionSerializer

    def perform_create(self, serializer):
        submission = serializer.save(user=self.request.user)
        dispatch_submission(submission)

    @action(detail=True, methods=["post"])
    def retry(self, request, pk=None):
        submission: Submission = self.get_object()

        if submission.status != Submission.Status.FAILED:
            return Response(
                {"detail": "Only FAILED submissions can be retried."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        submission.status = Submission.Status.SUBMITTED
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message", "updated_at"])

        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            }
        )

    @action(detail=True, methods=["post"], url_path="manual-edit")
    def manual_edit(self, request, pk=None):
        submission: Submission = self.get_object()

        if submission.status == Submission.Status.GRADING:
            return Response({"detail": "Submission is grading now."}, status=409)

        identifier = request.data.get("identifier")
        answers = request.data.get("answers") or []
        note = str(request.data.get("note") or "manual_edit")

        updated = 0

        for a in answers:
            if not isinstance(a, dict):
                continue

            eqid = a.get("exam_question_id")
            if not eqid:
                continue

            ans = str(a.get("answer") or "")

            SubmissionAnswer.objects.update_or_create(
                submission=submission,
                exam_question_id=int(eqid),
                defaults={"answer": ans},
            )
            updated += 1

        meta = dict(submission.meta or {})
        meta.setdefault("omr", {})
        meta["omr"]["identifier_override"] = identifier

        meta.setdefault("manual_edits", [])
        meta["manual_edits"].append(
            {
                "at": timezone.now().isoformat(),
                "by_user_id": getattr(request.user, "id", None),
                "note": note,
                "updated_answers_count": updated,
                "identifier": identifier,
            }
        )

        meta.setdefault("manual_review", {})
        meta["manual_review"]["required"] = False
        meta["manual_review"]["resolved_at"] = timezone.now().isoformat()

        submission.meta = meta
        submission.status = Submission.Status.ANSWERS_READY
        submission.error_message = ""
        submission.save(update_fields=["meta", "status", "error_message", "updated_at"])

        try:
            result_obj = grade_submission(int(submission.id))
        except Exception:
            return Response(
                {
                    "submission_id": submission.id,
                    "status": submission.status,
                    "updated": updated,
                    "detail": "grading failed",
                },
                status=500,
            )

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
                "updated": updated,
                "graded": True,
                "result_id": getattr(result_obj, "id", None),
            }
        )
