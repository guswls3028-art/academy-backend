====================================================================================================
# BACKEND APP: domains__submissions
# ROOT PATH: C:\academy\apps\domains\submissions
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: admin.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/submissions/apps.py
from django.apps import AppConfig


class SubmissionsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.submissions"
    label = "submissions"


==========================================================================================
# FILE: urls.py
==========================================================================================
from rest_framework.routers import DefaultRouter
from .views import SubmissionViewSet

router = DefaultRouter()
router.register("submissions", SubmissionViewSet, basename="submissions")

urlpatterns = router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2025-12-19 00:33

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="Submission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment_id",
                    models.PositiveIntegerField(blank=True, db_index=True, null=True),
                ),
                (
                    "target_type",
                    models.CharField(
                        choices=[("exam", "Exam"), ("homework", "Homework")],
                        max_length=20,
                    ),
                ),
                ("target_id", models.PositiveIntegerField()),
                (
                    "source",
                    models.CharField(
                        choices=[
                            ("omr_scan", "OMR Scan"),
                            ("omr_manual", "OMR Manual Input"),
                            ("online", "Online"),
                            ("homework_image", "Homework Image"),
                            ("homework_video", "Homework Video"),
                            ("ai_match", "AI Image Match"),
                        ],
                        max_length=30,
                    ),
                ),
                (
                    "file",
                    models.FileField(
                        blank=True, null=True, upload_to="submissions/%Y/%m/%d/"
                    ),
                ),
                ("payload", models.JSONField(blank=True, null=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("submitted", "Submitted"),
                            ("dispatched", "Dispatched"),
                            ("extracting", "Extracting"),
                            ("answers_ready", "Answers Ready"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="submitted",
                        max_length=20,
                    ),
                ),
                ("error_message", models.TextField(blank=True)),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="submissions",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="SubmissionAnswer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "submission",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="answers",
                        to="submissions.submission",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["target_type", "target_id"],
                name="submissions_target__6e8ca2_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["enrollment_id", "created_at"],
                name="submissions_enrollm_bf0086_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["user", "created_at"], name="submissions_user_id_6a1f53_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["status"], name="submissions_status_c2b4f2_idx"),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["source"], name="submissions_source_234254_idx"),
        ),
        migrations.AddIndex(
            model_name="submissionanswer",
            index=models.Index(
                fields=["submission", "question_id"],
                name="submissions_submiss_102ae9_idx",
            ),
        ),
        migrations.AlterUniqueTogether(
            name="submissionanswer",
            unique_together={("submission", "question_id")},
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
from .submission import Submission
from .submission_answer import SubmissionAnswer

__all__ = [
    "Submission", 
    "SubmissionAnswer"
    ]


==========================================================================================
# FILE: models/submission.py
==========================================================================================
# apps/domains/submissions/models/submission.py
from __future__ import annotations

from django.db import models
from django.conf import settings

from apps.api.common.models import TimestampModel


class Submission(TimestampModel):
    """
    submissions = "제출 행위 + 원본 보관"
    - 계산/채점/정답비교 금지
    """

    class TargetType(models.TextChoices):
        EXAM = "exam", "Exam"
        HOMEWORK = "homework", "Homework"

    class Source(models.TextChoices):
        # 시험
        OMR_SCAN = "omr_scan", "OMR Scan"
        OMR_MANUAL = "omr_manual", "OMR Manual Input"
        ONLINE = "online", "Online"
        # 숙제
        HOMEWORK_IMAGE = "homework_image", "Homework Image"
        HOMEWORK_VIDEO = "homework_video", "Homework Video"
        # 기타
        AI_MATCH = "ai_match", "AI Image Match"

    class Status(models.TextChoices):
        SUBMITTED = "submitted", "Submitted"
        DISPATCHED = "dispatched", "Dispatched"            # AI job publish 완료
        EXTRACTING = "extracting", "Extracting"            # (선택) worker 처리중 표현
        ANSWERS_READY = "answers_ready", "Answers Ready"   # SubmissionAnswer 저장 완료
        GRADING = "grading", "Grading"                     # results 채점 job 처리 중
        DONE = "done", "Done"
        FAILED = "failed", "Failed"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="submissions",
    )

    # ✅ A안: enrollment_id 추가 (FK 강제 X)
    enrollment_id = models.PositiveIntegerField(null=True, blank=True, db_index=True)

    target_type = models.CharField(max_length=20, choices=TargetType.choices)
    target_id = models.PositiveIntegerField()

    source = models.CharField(max_length=30, choices=Source.choices)

    file = models.FileField(
        upload_to="submissions/%Y/%m/%d/",
        null=True,
        blank=True,
    )

    payload = models.JSONField(null=True, blank=True)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.SUBMITTED,
    )
    error_message = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["target_type", "target_id"]),
            models.Index(fields=["enrollment_id", "created_at"]),
            models.Index(fields=["user", "created_at"]),
            models.Index(fields=["status"]),
            models.Index(fields=["source"]),
        ]

    def __str__(self) -> str:
        return (
            f"Submission({self.id}) {self.target_type}:{self.target_id} "
            f"source={self.source} by user={self.user_id}"
        )


==========================================================================================
# FILE: models/submission_answer.py
==========================================================================================
# apps/domains/submissions/models/submission_answer.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import TimestampModel


class SubmissionAnswer(TimestampModel):
    """
    SubmissionAnswer = "답안 추출 중간산물"
    - 정답/점수/정오판정 금지 (results 도메인 책임)
    """
    submission = models.ForeignKey(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="answers",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["submission", "question_id"]),
        ]
        unique_together = ("submission", "question_id")

    def __str__(self) -> str:
        return f"SubmissionAnswer(submission={self.submission_id}, q={self.question_id})"


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
from .submission import SubmissionSerializer, SubmissionCreateSerializer

__all__ = ["SubmissionSerializer", "SubmissionCreateSerializer"]


==========================================================================================
# FILE: serializers/submission.py
==========================================================================================
# apps/domains/submissions/serializers/submission.py
from rest_framework import serializers
from apps.domains.submissions.models import Submission


class SubmissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Submission
        fields = "__all__"
        read_only_fields = (
            "id",
            "user",
            "status",
            "error_message",
            "meta",
            "created_at",
            "updated_at",
        )


class SubmissionCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Submission
        fields = (
            "enrollment_id",
            "target_type",
            "target_id",
            "source",
            "file",
            "payload",
        )

    def validate(self, attrs):
        source = attrs.get("source")
        target_type = attrs.get("target_type")

        # enrollment_id는 grading에 필요하므로 강제(시험/숙제 공통)
        if target_type in (Submission.TargetType.EXAM, Submission.TargetType.HOMEWORK):
            if not attrs.get("enrollment_id"):
                raise serializers.ValidationError({"enrollment_id": "enrollment_id is required"})

        if source in (
            Submission.Source.OMR_SCAN,
            Submission.Source.HOMEWORK_IMAGE,
            Submission.Source.HOMEWORK_VIDEO,
        ):
            if not attrs.get("file"):
                raise serializers.ValidationError({"file": "해당 source는 file 업로드가 필요합니다."})

        if source == Submission.Source.ONLINE:
            if not attrs.get("payload"):
                raise serializers.ValidationError({"payload": "온라인 제출은 payload가 필요합니다."})

        return attrs


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/ai_result_mapper.py
==========================================================================================
# apps/domains/submissions/services/ai_result_mapper.py
from __future__ import annotations

from typing import Any, Dict, Optional

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer


@transaction.atomic
def apply_ai_result(payload: Dict[str, Any]) -> Optional[int]:
    """
    Worker AI 결과를 submissions에 반영.

    지원 스키마:
    1) 답안형(items):
      {
        "submission_id": int,
        "items": [{"question_id":int,"answer":str,"meta":dict?}, ...]
      }
      -> SubmissionAnswer upsert + status=ANSWERS_READY + submission.id 반환

    2) OMR형(v1):
      {
        "submission_id": int,
        "version": "v1",
        "answers": [ {version, question_id, detected, marking, confidence, status, raw?}, ... ]
      }
      -> SubmissionAnswer upsert(meta["omr"]=answer_payload) + status=ANSWERS_READY + submission.id 반환

    3) 분석형(채점 없음):
      {"submission_id": int, "analysis": {...}}
      -> meta["analysis"] 저장 + (HOMEWORK이면) status=DONE + None 반환
    """
    submission_id = payload.get("submission_id")
    if not submission_id:
        return None

    submission = Submission.objects.select_for_update().get(id=int(submission_id))

    # 결과 원본 저장(디버그/추적용)
    base_payload = submission.payload or {}
    base_payload["ai_result"] = payload
    submission.payload = base_payload

    # 1) items 답안형
    items = payload.get("items")
    if isinstance(items, list) and items:
        for item in items:
            qid = item.get("question_id")
            if not qid:
                continue

            SubmissionAnswer.objects.update_or_create(
                submission=submission,
                question_id=int(qid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or None,
                },
            )

        submission.status = Submission.Status.ANSWERS_READY
        submission.error_message = ""
        meta = submission.meta or {}
        meta["answers_ready"] = True
        meta["answer_count"] = SubmissionAnswer.objects.filter(submission=submission).count()
        submission.meta = meta
        submission.save(update_fields=["payload", "status", "error_message", "meta", "updated_at"])
        return submission.id

    # 2) OMR v1 형식
    answers = payload.get("answers")
    version = payload.get("version")
    if version and isinstance(answers, list) and answers:
        for a in answers:
            qid = (a or {}).get("question_id")
            if not qid:
                continue

            detected = (a or {}).get("detected") or []
            # 사람이 읽기 쉬운 answer 문자열(예: "B" / "BD")
            ans_text = "".join([str(x).strip().upper() for x in detected]) if isinstance(detected, list) else ""

            SubmissionAnswer.objects.update_or_create(
                submission=submission,
                question_id=int(qid),
                defaults={
                    "answer": ans_text,
                    "meta": {"omr": a},  # ✅ results.grader가 meta["omr"]를 읽는다
                },
            )

        submission.status = Submission.Status.ANSWERS_READY
        submission.error_message = ""
        meta = submission.meta or {}
        meta["answers_ready"] = True
        meta["answer_count"] = SubmissionAnswer.objects.filter(submission=submission).count()
        meta["omr_version"] = str(version)
        submission.meta = meta
        submission.save(update_fields=["payload", "status", "error_message", "meta", "updated_at"])
        return submission.id

    # 3) 분석형
    analysis = payload.get("analysis")
    if analysis is not None:
        meta = submission.meta or {}
        meta["analysis"] = analysis
        submission.meta = meta

        if submission.target_type == Submission.TargetType.HOMEWORK:
            submission.status = Submission.Status.DONE

        submission.save(update_fields=["payload", "meta", "status", "updated_at"])
        return None

    submission.save(update_fields=["payload", "updated_at"])
    return None


==========================================================================================
# FILE: services/dispatcher.py
==========================================================================================
# apps/domains/submissions/services/dispatcher.py
from __future__ import annotations

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.submission_service import SubmissionService
from apps.domains.results.tasks.grading_tasks import grade_submission_task

from apps.shared.contracts.ai_job import AIJob
from apps.shared.contracts.ai_result import AIResult
from apps.shared.tasks.ai_worker import run_ai_job_task
from apps.domains.submissions.services.ai_result_mapper import apply_ai_result


def dispatch_submission(submission: Submission) -> None:
    """
    Submission 생성 직후 호출되는 단일 진입점.

    - ONLINE:
        - submissions 내부 처리
        - grading 바로 enqueue
    - FILE 기반:
        - AI Job 생성 → ai worker celery
        - (MVP) 동기 결과 수신
        - 결과 반영 → grading enqueue
    """

    # 1️⃣ ONLINE 제출
    if submission.source == Submission.Source.ONLINE:
        SubmissionService.process(submission)
        grade_submission_task.delay(int(submission.id))
        return

    # 2️⃣ FILE 기반 제출 (OMR / IMAGE / VIDEO)
    if not submission.file:
        submission.status = Submission.Status.FAILED
        submission.error_message = "file is required"
        submission.save(update_fields=["status", "error_message"])
        return

    submission.status = Submission.Status.DISPATCHED
    submission.error_message = ""
    submission.save(update_fields=["status", "error_message"])

    # 3️⃣ AI Job 생성
    job = AIJob.new(
        type=_infer_ai_job_type(submission),
        payload=_build_ai_payload(submission),
        source_domain="submissions",
        source_id=str(submission.id),
    )

    # 4️⃣ AI Worker 실행
    # ⚠️ MVP ONLY: 동기 대기 (운영 환경에서는 async callback 구조로 교체 필요)
    async_result = run_ai_job_task.delay(job.to_dict())

    try:
        result_dict = async_result.get(timeout=120)
    except Exception as e:
        submission.status = Submission.Status.FAILED
        submission.error_message = f"AI timeout or error: {e}"
        submission.save(update_fields=["status", "error_message"])
        return

    ai_result = AIResult.from_dict(result_dict)

    if ai_result.status != "DONE":
        submission.status = Submission.Status.FAILED
        submission.error_message = ai_result.error or "AI failed"
        submission.save(update_fields=["status", "error_message"])
        return

    # 5️⃣ AI 결과 반영
    returned_submission_id = apply_ai_result(
        {
            **ai_result.result,
            "submission_id": submission.id,
        }
    )

    # 6️⃣ 채점 enqueue
    if returned_submission_id:
        grade_submission_task.delay(returned_submission_id)


# ---------------------------------------------------------------------
# AI Job 타입 / payload 빌더
# ---------------------------------------------------------------------

def _infer_ai_job_type(submission: Submission) -> str:
    if submission.source == Submission.Source.OMR_SCAN:
        return "omr_grading"
    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        return "ocr"
    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        return "homework_video_analysis"
    return "ocr"


def _build_ai_payload(submission: Submission) -> dict:
    """
    Worker는 DB를 모르므로 path / 최소 정보만 전달
    """
    payload = submission.payload or {}

    if not submission.file:
        return payload

    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        payload["video_path"] = submission.file.path
    else:
        payload["image_path"] = submission.file.path

    return payload


==========================================================================================
# FILE: services/submission_service.py
==========================================================================================
# apps/domains/submissions/services/submission_service.py
from typing import List, Type

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor
from apps.domains.submissions.services.processor.online import OnlineSubmissionProcessor


PROCESSOR_MAP: dict[str, Type[BaseSubmissionProcessor]] = {
    Submission.Source.ONLINE: OnlineSubmissionProcessor,
}


class SubmissionService:
    """
    submissions 처리의 유일한 퍼블릭 서비스
    - ONLINE만 즉시 처리 (정규화만 수행)
    """

    @staticmethod
    @transaction.atomic
    def process(submission: Submission) -> List[SubmissionAnswer]:
        processor_cls = PROCESSOR_MAP.get(submission.source)
        if not processor_cls:
            return []

        processor = processor_cls(submission)
        answers = processor.process()

        # ONLINE은 즉시 answers_ready로
        submission.status = Submission.Status.ANSWERS_READY
        submission.save(update_fields=["status", "updated_at"])

        return answers


==========================================================================================
# FILE: services/processor/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/processor/base.py
==========================================================================================
# apps/domains/submissions/services/processor/base.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Dict, Any, List

from django.db import transaction
from apps.domains.submissions.models import Submission, SubmissionAnswer


class BaseSubmissionProcessor(ABC):
    """
    submissions 내 processor = '답안 중간산물 저장'까지만
    - 채점/정답비교/점수계산 절대 금지
    """
    source: str = "base"

    def __init__(self, submission: Submission):
        self.submission = submission

    @transaction.atomic
    def process(self) -> List[SubmissionAnswer]:
        extracted = list(self.extract_answers())
        return self._save_answers(extracted)

    @abstractmethod
    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        """
        반환 포맷(고정):
            {"question_id": int, "answer": str, "meta": dict|None}
        """
        raise NotImplementedError

    def _save_answers(self, extracted: Iterable[Dict[str, Any]]) -> List[SubmissionAnswer]:
        results: List[SubmissionAnswer] = []

        for item in extracted:
            qid = item.get("question_id")
            if not qid:
                continue

            obj, _ = SubmissionAnswer.objects.update_or_create(
                submission=self.submission,
                question_id=int(qid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or None,
                },
            )
            results.append(obj)

        return results


==========================================================================================
# FILE: services/processor/omr.py
==========================================================================================
# apps/domains/submissions/services/processor/omr.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OMRSubmissionProcessor(BaseSubmissionProcessor):
    """
    원칙상 OMR '추출'은 worker 책임.
    API(submissions)에서는 아래 중 하나만 수행:
      - (권장) dispatcher가 AI job 발행, 결과는 ai callbacks에서 SubmissionAnswer로 저장
      - (보조) 이미 meta/payload에 추출 결과가 들어온 경우 정규화 저장만
    """

    source = "omr_scan"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        # 1) worker가 돌려준 결과가 payload/meta에 들어온 케이스만 처리
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        # extracted가 online과 같은 스키마면 그대로 처리 가능
        if isinstance(extracted, list):
            for row in extracted:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta") or {"via": "omr"},
                }
            return

        if isinstance(extracted, dict):
            for k, v in extracted.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "omr"},
                }
            return

        return


==========================================================================================
# FILE: services/processor/online.py
==========================================================================================
# apps/domains/submissions/services/processor/online.py
from __future__ import annotations

from typing import Iterable, Dict, Any
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OnlineSubmissionProcessor(BaseSubmissionProcessor):
    source = "online"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        answers = payload.get("answers")

        # A) list
        if isinstance(answers, list):
            for row in answers:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta"),
                }
            return

        # B) dict (key=question_id)
        if isinstance(answers, dict):
            for k, v in answers.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "online"},
                }
            return

        return


==========================================================================================
# FILE: services/processor/video.py
==========================================================================================
# apps/domains/submissions/services/processor/video.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class VideoSubmissionProcessor(BaseSubmissionProcessor):
    """
    원칙상 영상 분석은 worker 책임.
    API(submissions)에서는:
      - (권장) dispatcher가 AI job 발행
      - (보조) payload/meta에 분석결과가 이미 들어온 경우만 SubmissionAnswer로 정규화 저장
    """

    source = "homework_video"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        if isinstance(extracted, list):
            for row in extracted:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta") or {"via": "video"},
                }
            return

        if isinstance(extracted, dict):
            for k, v in extracted.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "video"},
                }
            return

        return


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# domains/submissions/views/__init__.py

from .submission_view import SubmissionViewSet

__all__ = ["SubmissionViewSet"]


==========================================================================================
# FILE: views/submission_view.py
==========================================================================================
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.serializers.submission import (
    SubmissionSerializer,
    SubmissionCreateSerializer,
)
from apps.domains.submissions.services.dispatcher import dispatch_submission


class SubmissionViewSet(ModelViewSet):
    queryset = Submission.objects.all().order_by("-id")
    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == "create":
            return SubmissionCreateSerializer
        return SubmissionSerializer

    def perform_create(self, serializer):
        submission = serializer.save(user=self.request.user)
        dispatch_submission(submission)
