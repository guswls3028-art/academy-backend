====================================================================================================
# BACKEND APP: domains__submissions
# ROOT PATH: C:\academy\apps\domains\submissions
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: admin.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/submissions/apps.py
from django.apps import AppConfig


class SubmissionsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.submissions"
    label = "submissions"


==========================================================================================
# FILE: urls.py
==========================================================================================
from rest_framework.routers import DefaultRouter
from .views import SubmissionViewSet

router = DefaultRouter()
router.register("submissions", SubmissionViewSet, basename="submissions")

urlpatterns = router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 02:52

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="Submission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment_id",
                    models.PositiveIntegerField(blank=True, db_index=True, null=True),
                ),
                (
                    "target_type",
                    models.CharField(
                        choices=[("exam", "Exam"), ("homework", "Homework")],
                        max_length=20,
                    ),
                ),
                ("target_id", models.PositiveIntegerField()),
                (
                    "source",
                    models.CharField(
                        choices=[
                            ("omr_scan", "OMR Scan"),
                            ("omr_manual", "OMR Manual Input"),
                            ("online", "Online"),
                            ("homework_image", "Homework Image"),
                            ("homework_video", "Homework Video"),
                            ("ai_match", "AI Image Match"),
                        ],
                        max_length=30,
                    ),
                ),
                ("file_key", models.CharField(blank=True, max_length=512, null=True)),
                ("file_type", models.CharField(blank=True, max_length=50, null=True)),
                ("file_size", models.PositiveIntegerField(blank=True, null=True)),
                ("payload", models.JSONField(blank=True, null=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("submitted", "Submitted"),
                            ("dispatched", "Dispatched"),
                            ("extracting", "Extracting"),
                            ("answers_ready", "Answers Ready"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="submitted",
                        max_length=20,
                    ),
                ),
                ("error_message", models.TextField(blank=True)),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="submissions",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="SubmissionAnswer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "submission",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="answers",
                        to="submissions.submission",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["target_type", "target_id"],
                name="submissions_target__6e8ca2_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["enrollment_id", "created_at"],
                name="submissions_enrollm_bf0086_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(
                fields=["user", "created_at"], name="submissions_user_id_6a1f53_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["status"], name="submissions_status_c2b4f2_idx"),
        ),
        migrations.AddIndex(
            model_name="submission",
            index=models.Index(fields=["source"], name="submissions_source_234254_idx"),
        ),
        migrations.AddIndex(
            model_name="submissionanswer",
            index=models.Index(
                fields=["submission", "question_id"],
                name="submissions_submiss_102ae9_idx",
            ),
        ),
        migrations.AlterUniqueTogether(
            name="submissionanswer",
            unique_together={("submission", "question_id")},
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
from .submission import Submission
from .submission_answer import SubmissionAnswer

__all__ = [
    "Submission", 
    "SubmissionAnswer"
    ]


==========================================================================================
# FILE: models/submission.py
==========================================================================================
# PATH: apps/domains/submissions/models/submission.py
# ë³€ê²½ ìš”ì•½:
# - FileField ì œê±°
# - R2 ê¸°ë°˜ file_key / file_type í•„ë“œ ì¶”ê°€

from __future__ import annotations

from django.db import models
from django.conf import settings
from apps.api.common.models import TimestampModel


class Submission(TimestampModel):
    """
    submissions = ì œì¶œ í–‰ìœ„ + ì›ë³¸ ë©”íƒ€
    - íŒŒì¼ì€ Object Storage(R2)ì—ë§Œ ì¡´ì¬
    """

    class TargetType(models.TextChoices):
        EXAM = "exam", "Exam"
        HOMEWORK = "homework", "Homework"

    class Source(models.TextChoices):
        OMR_SCAN = "omr_scan", "OMR Scan"
        OMR_MANUAL = "omr_manual", "OMR Manual Input"
        ONLINE = "online", "Online"
        HOMEWORK_IMAGE = "homework_image", "Homework Image"
        HOMEWORK_VIDEO = "homework_video", "Homework Video"
        AI_MATCH = "ai_match", "AI Image Match"

    class Status(models.TextChoices):
        SUBMITTED = "submitted", "Submitted"
        DISPATCHED = "dispatched", "Dispatched"
        EXTRACTING = "extracting", "Extracting"
        ANSWERS_READY = "answers_ready", "Answers Ready"
        GRADING = "grading", "Grading"
        DONE = "done", "Done"
        FAILED = "failed", "Failed"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="submissions",
    )

    enrollment_id = models.PositiveIntegerField(null=True, blank=True, db_index=True)

    target_type = models.CharField(max_length=20, choices=TargetType.choices)
    target_id = models.PositiveIntegerField()

    source = models.CharField(max_length=30, choices=Source.choices)

    # âœ… R2 ê¸°ì¤€ íŒŒì¼ ë©”íƒ€
    file_key = models.CharField(max_length=512, null=True, blank=True)
    file_type = models.CharField(max_length=50, null=True, blank=True)
    file_size = models.PositiveIntegerField(null=True, blank=True)

    payload = models.JSONField(null=True, blank=True)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.SUBMITTED,
    )
    error_message = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["target_type", "target_id"]),
            models.Index(fields=["enrollment_id", "created_at"]),
            models.Index(fields=["user", "created_at"]),
            models.Index(fields=["status"]),
            models.Index(fields=["source"]),
        ]


==========================================================================================
# FILE: models/submission_answer.py
==========================================================================================
# apps/domains/submissions/models/submission_answer.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import TimestampModel


class SubmissionAnswer(TimestampModel):
    """
    SubmissionAnswer = "ë‹µì•ˆ ì¶”ì¶œ ì¤‘ê°„ì‚°ë¬¼"
    - ì •ë‹µ/ì ìˆ˜/ì •ì˜¤íŒì • ê¸ˆì§€ (results ë„ë©”ì¸ ì±…ì„)
    """
    submission = models.ForeignKey(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="answers",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["submission", "question_id"]),
        ]
        unique_together = ("submission", "question_id")

    def __str__(self) -> str:
        return f"SubmissionAnswer(submission={self.submission_id}, q={self.question_id})"


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
from .submission import SubmissionSerializer, SubmissionCreateSerializer

__all__ = ["SubmissionSerializer", "SubmissionCreateSerializer"]


==========================================================================================
# FILE: serializers/submission.py
==========================================================================================
# PATH: apps/domains/submissions/serializers/submission.py
# ë³€ê²½ ìš”ì•½:
# - file(FileField) ì œê±°
# - ì—…ë¡œë“œëœ íŒŒì¼ì„ R2ë¡œ ì¦‰ì‹œ ì—…ë¡œë“œ
# - file_key/file_type/file_size ì €ì¥

from __future__ import annotations

import mimetypes
import uuid

from rest_framework import serializers

from apps.domains.submissions.models import Submission

# âœ… API ì„œë²„ ì „ìš© R2 ì—…ë¡œë“œ
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2


class SubmissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Submission
        fields = "__all__"
        read_only_fields = (
            "id",
            "user",
            "status",
            "error_message",
            "meta",
            "created_at",
            "updated_at",
        )


class SubmissionCreateSerializer(serializers.ModelSerializer):
    file = serializers.FileField(required=False)

    class Meta:
        model = Submission
        fields = (
            "enrollment_id",
            "target_type",
            "target_id",
            "source",
            "file",
            "payload",
        )

    def validate(self, attrs):
        source = attrs.get("source")
        target_type = attrs.get("target_type")

        if target_type in (Submission.TargetType.EXAM, Submission.TargetType.HOMEWORK):
            if not attrs.get("enrollment_id"):
                raise serializers.ValidationError({"enrollment_id": "required"})

        if source in (
            Submission.Source.OMR_SCAN,
            Submission.Source.HOMEWORK_IMAGE,
            Submission.Source.HOMEWORK_VIDEO,
        ):
            if not attrs.get("file"):
                raise serializers.ValidationError({"file": "file required"})

        if source == Submission.Source.ONLINE and not attrs.get("payload"):
            raise serializers.ValidationError({"payload": "required"})

        return attrs

    def create(self, validated_data):
        upload_file = validated_data.pop("file", None)

        submission = Submission.objects.create(**validated_data)

        if upload_file:
            ext = upload_file.name.split(".")[-1]
            key = f"submissions/{submission.id}/{uuid.uuid4().hex}.{ext}"

            upload_fileobj_to_r2(
                fileobj=upload_file,
                key=key,
                content_type=upload_file.content_type,
            )

            submission.file_key = key
            submission.file_type = upload_file.content_type or mimetypes.guess_type(upload_file.name)[0]
            submission.file_size = upload_file.size
            submission.save(update_fields=["file_key", "file_type", "file_size"])

        return submission


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/ai_result_mapper.py
==========================================================================================
# apps/domains/submissions/services/ai_result_mapper.py
from __future__ import annotations

from typing import Any, Dict, Optional
import logging

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer

logger = logging.getLogger(__name__)


@transaction.atomic
def apply_ai_result(payload: Dict[str, Any]) -> Optional[int]:
    """
    Worker AI ê²°ê³¼ë¥¼ submissionsì— ë°˜ì˜.
    """
    submission_id = payload.get("submission_id")
    if not submission_id:
        return None

    # âœ… ë³´í˜¸íŒ¨ì¹˜: submission ì—†ìœ¼ë©´ DROP
    try:
        submission = Submission.objects.select_for_update().get(
            id=int(submission_id)
        )
    except Submission.DoesNotExist:
        logger.warning(
            "[AI_RESULT] submission %s not found. result dropped.",
            submission_id,
        )
        return None

    # âœ… ê²°ê³¼ ì›ë³¸ ì €ì¥ (í•­ìƒ)
    base_payload = submission.payload or {}
    base_payload["ai_result"] = payload
    submission.payload = base_payload

    status = payload.get("status")
    error = payload.get("error")

    # âœ… FAILED ê²°ê³¼ ì¦‰ì‹œ ì²˜ë¦¬
    if status == "FAILED":
        submission.status = Submission.Status.FAILED
        submission.error_message = error or "AI worker failed"
        submission.save(
            update_fields=[
                "payload",
                "status",
                "error_message",
                "updated_at",
            ]
        )
        return submission.id

    # =========================
    # 1) items ë‹µì•ˆí˜•
    # =========================
    items = payload.get("result", {}).get("items")
    if isinstance(items, list) and items:
        for item in items:
            qid = item.get("question_id")
            if not qid:
                continue

            SubmissionAnswer.objects.update_or_create(
                submission=submission,
                question_id=int(qid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or None,
                },
            )

        submission.status = Submission.Status.ANSWERS_READY
        submission.error_message = ""
        meta = submission.meta or {}
        meta["answers_ready"] = True
        meta["answer_count"] = SubmissionAnswer.objects.filter(
            submission=submission
        ).count()
        submission.meta = meta
        submission.save(
            update_fields=[
                "payload",
                "status",
                "error_message",
                "meta",
                "updated_at",
            ]
        )
        return submission.id

    # =========================
    # 2) OMR v1 í˜•ì‹
    # =========================
    result = payload.get("result") or {}
    answers = result.get("answers")
    version = result.get("version")

    if version and isinstance(answers, list) and answers:
        for a in answers:
            qid = (a or {}).get("question_id")
            if not qid:
                continue

            detected = (a or {}).get("detected") or []
            ans_text = (
                "".join([str(x).strip().upper() for x in detected])
                if isinstance(detected, list)
                else ""
            )

            SubmissionAnswer.objects.update_or_create(
                submission=submission,
                question_id=int(qid),
                defaults={
                    "answer": ans_text,
                    "meta": {"omr": a},
                },
            )

        submission.status = Submission.Status.ANSWERS_READY
        submission.error_message = ""
        meta = submission.meta or {}
        meta["answers_ready"] = True
        meta["answer_count"] = SubmissionAnswer.objects.filter(
            submission=submission
        ).count()
        meta["omr_version"] = str(version)
        submission.meta = meta
        submission.save(
            update_fields=[
                "payload",
                "status",
                "error_message",
                "meta",
                "updated_at",
            ]
        )
        return submission.id

    # =========================
    # 3) ë¶„ì„í˜•
    # =========================
    analysis = result.get("analysis")
    if analysis is not None:
        meta = submission.meta or {}
        meta["analysis"] = analysis
        submission.meta = meta

        if submission.target_type == Submission.TargetType.HOMEWORK:
            submission.status = Submission.Status.DONE

        submission.save(
            update_fields=[
                "payload",
                "meta",
                "status",
                "updated_at",
            ]
        )
        return None

    submission.save(update_fields=["payload", "updated_at"])
    return None


==========================================================================================
# FILE: services/dispatcher.py
==========================================================================================
# apps/domains/submissions/services/dispatcher.py
from __future__ import annotations

import redis
from django.conf import settings

from apps.domains.submissions.models import Submission
from apps.domains.submissions.services.submission_service import SubmissionService
from apps.domains.results.tasks.grading_tasks import grade_submission_task
from apps.shared.contracts.ai_job import AIJob

# â­ STEP 2: presigned URL ìƒì„± ìœ í‹¸
from apps.infrastructure.storage.r2 import generate_presigned_get_url

# ---------------------------------------------------------------------
# Redis AI Queue
# ---------------------------------------------------------------------

AI_QUEUE_KEY = "ai:jobs"


def _redis():
    return redis.from_url(settings.REDIS_URL, decode_responses=True)


# ---------------------------------------------------------------------
# Public Entry
# ---------------------------------------------------------------------

def dispatch_submission(submission: Submission) -> None:
    """
    Submission ìƒì„± ì§í›„ í˜¸ì¶œë˜ëŠ” ë‹¨ì¼ ì§„ì…ì  (STEP 2 í™•ì •íŒ)

    ì—­í• :
    - ONLINE ì œì¶œ:
        - ì¦‰ì‹œ ì²˜ë¦¬ (ì •ê·œí™”)
        - ì±„ì  task enqueue
    - FILE ì œì¶œ:
        - R2ì— ì €ì¥ëœ file_key ì¡´ì¬ ì—¬ë¶€ë§Œ ê²€ì¦
        - presigned GET URL ìƒì„±
        - AIJob enqueue
        - íŒŒì¼ ì ‘ê·¼/ë‹¤ìš´ë¡œë“œëŠ” worker ì±…ì„
    """

    # 1ï¸âƒ£ ONLINE ì œì¶œ
    if submission.source == Submission.Source.ONLINE:
        SubmissionService.process(submission)
        grade_submission_task.delay(int(submission.id))
        return

    # 2ï¸âƒ£ FILE ì œì¶œ (R2 ê¸°ì¤€)
    if not submission.file_key:
        submission.status = Submission.Status.FAILED
        submission.error_message = "file_key missing"
        submission.save(update_fields=["status", "error_message"])
        return

    # ìƒíƒœ ì „ì´: DISPATCHED
    submission.status = Submission.Status.DISPATCHED
    submission.error_message = ""
    submission.save(update_fields=["status", "error_message"])

    # 3ï¸âƒ£ AI Job ìƒì„± (STEP 2: presigned URL í¬í•¨)
    job = AIJob.new(
        type=_infer_ai_job_type(submission),
        payload=_build_ai_payload(submission),
        source_domain="submissions",
        source_id=str(submission.id),
    )

    # 4ï¸âƒ£ Redis enqueue
    r = _redis()
    r.lpush(AI_QUEUE_KEY, job.to_json())


# ---------------------------------------------------------------------
# AI Job íƒ€ì… / payload ë¹Œë”
# ---------------------------------------------------------------------

def _infer_ai_job_type(submission: Submission) -> str:
    if submission.source == Submission.Source.OMR_SCAN:
        return "omr_grading"
    if submission.source == Submission.Source.HOMEWORK_IMAGE:
        return "ocr"
    if submission.source == Submission.Source.HOMEWORK_VIDEO:
        return "homework_video_analysis"
    return "ocr"


def _build_ai_payload(submission: Submission) -> dict:
    """
    STEP 2 payload ê·œì¹™ (ğŸ”¥ ì¤‘ìš”)

    - ë¡œì»¬ íŒŒì¼ ê²½ë¡œ(.path) âŒ ì ˆëŒ€ ì‚¬ìš© ê¸ˆì§€
    - R2 presigned GET URLë§Œ ì „ë‹¬
    - workerëŠ” download_url â†’ /tmp ì €ì¥ í›„ ì²˜ë¦¬
    """
    payload = dict(submission.payload or {})

    # â­ presigned GET URL ìƒì„±
    download_url = generate_presigned_get_url(
        key=submission.file_key,
        expires_in=60 * 60,  # 1ì‹œê°„
    )

    payload.update(
        {
            # ë©”íƒ€ ì •ë³´
            "file_key": submission.file_key,
            "file_type": submission.file_type,

            # â­ worker ì „ìš© íŒŒì¼ ì ‘ê·¼ ìˆ˜ë‹¨
            "download_url": download_url,
        }
    )

    return payload


==========================================================================================
# FILE: services/submission_service.py
==========================================================================================
# apps/domains/submissions/services/submission_service.py
from typing import List, Type

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor
from apps.domains.submissions.services.processor.online import OnlineSubmissionProcessor


PROCESSOR_MAP: dict[str, Type[BaseSubmissionProcessor]] = {
    Submission.Source.ONLINE: OnlineSubmissionProcessor,
}


class SubmissionService:
    """
    submissions ì²˜ë¦¬ì˜ ìœ ì¼í•œ í¼ë¸”ë¦­ ì„œë¹„ìŠ¤
    - ONLINEë§Œ ì¦‰ì‹œ ì²˜ë¦¬ (ì •ê·œí™”ë§Œ ìˆ˜í–‰)
    """

    @staticmethod
    @transaction.atomic
    def process(submission: Submission) -> List[SubmissionAnswer]:
        processor_cls = PROCESSOR_MAP.get(submission.source)
        if not processor_cls:
            return []

        processor = processor_cls(submission)
        answers = processor.process()

        # ONLINEì€ ì¦‰ì‹œ answers_readyë¡œ
        submission.status = Submission.Status.ANSWERS_READY
        submission.save(update_fields=["status", "updated_at"])

        return answers


==========================================================================================
# FILE: services/processor/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/processor/base.py
==========================================================================================
# apps/domains/submissions/services/processor/base.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Dict, Any, List

from django.db import transaction
from apps.domains.submissions.models import Submission, SubmissionAnswer


class BaseSubmissionProcessor(ABC):
    """
    submissions ë‚´ processor = 'ë‹µì•ˆ ì¤‘ê°„ì‚°ë¬¼ ì €ì¥'ê¹Œì§€ë§Œ
    - ì±„ì /ì •ë‹µë¹„êµ/ì ìˆ˜ê³„ì‚° ì ˆëŒ€ ê¸ˆì§€
    """
    source: str = "base"

    def __init__(self, submission: Submission):
        self.submission = submission

    @transaction.atomic
    def process(self) -> List[SubmissionAnswer]:
        extracted = list(self.extract_answers())
        return self._save_answers(extracted)

    @abstractmethod
    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        """
        ë°˜í™˜ í¬ë§·(ê³ ì •):
            {"question_id": int, "answer": str, "meta": dict|None}
        """
        raise NotImplementedError

    def _save_answers(self, extracted: Iterable[Dict[str, Any]]) -> List[SubmissionAnswer]:
        results: List[SubmissionAnswer] = []

        for item in extracted:
            qid = item.get("question_id")
            if not qid:
                continue

            obj, _ = SubmissionAnswer.objects.update_or_create(
                submission=self.submission,
                question_id=int(qid),
                defaults={
                    "answer": str(item.get("answer") or ""),
                    "meta": item.get("meta") or None,
                },
            )
            results.append(obj)

        return results


==========================================================================================
# FILE: services/processor/omr.py
==========================================================================================
# apps/domains/submissions/services/processor/omr.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OMRSubmissionProcessor(BaseSubmissionProcessor):
    """
    ì›ì¹™ìƒ OMR 'ì¶”ì¶œ'ì€ worker ì±…ì„.
    API(submissions)ì—ì„œëŠ” ì•„ë˜ ì¤‘ í•˜ë‚˜ë§Œ ìˆ˜í–‰:
      - (ê¶Œì¥) dispatcherê°€ AI job ë°œí–‰, ê²°ê³¼ëŠ” ai callbacksì—ì„œ SubmissionAnswerë¡œ ì €ì¥
      - (ë³´ì¡°) ì´ë¯¸ meta/payloadì— ì¶”ì¶œ ê²°ê³¼ê°€ ë“¤ì–´ì˜¨ ê²½ìš° ì •ê·œí™” ì €ì¥ë§Œ
    """

    source = "omr_scan"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        # 1) workerê°€ ëŒë ¤ì¤€ ê²°ê³¼ê°€ payload/metaì— ë“¤ì–´ì˜¨ ì¼€ì´ìŠ¤ë§Œ ì²˜ë¦¬
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        # extractedê°€ onlineê³¼ ê°™ì€ ìŠ¤í‚¤ë§ˆë©´ ê·¸ëŒ€ë¡œ ì²˜ë¦¬ ê°€ëŠ¥
        if isinstance(extracted, list):
            for row in extracted:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta") or {"via": "omr"},
                }
            return

        if isinstance(extracted, dict):
            for k, v in extracted.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "omr"},
                }
            return

        return


==========================================================================================
# FILE: services/processor/online.py
==========================================================================================
# apps/domains/submissions/services/processor/online.py
from __future__ import annotations

from typing import Iterable, Dict, Any
from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class OnlineSubmissionProcessor(BaseSubmissionProcessor):
    source = "online"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        answers = payload.get("answers")

        # A) list
        if isinstance(answers, list):
            for row in answers:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta"),
                }
            return

        # B) dict (key=question_id)
        if isinstance(answers, dict):
            for k, v in answers.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "online"},
                }
            return

        return


==========================================================================================
# FILE: services/processor/video.py
==========================================================================================
# apps/domains/submissions/services/processor/video.py
from __future__ import annotations

from typing import Iterable, Dict, Any

from apps.domains.submissions.services.processor.base import BaseSubmissionProcessor


class VideoSubmissionProcessor(BaseSubmissionProcessor):
    """
    ì›ì¹™ìƒ ì˜ìƒ ë¶„ì„ì€ worker ì±…ì„.
    API(submissions)ì—ì„œëŠ”:
      - (ê¶Œì¥) dispatcherê°€ AI job ë°œí–‰
      - (ë³´ì¡°) payload/metaì— ë¶„ì„ê²°ê³¼ê°€ ì´ë¯¸ ë“¤ì–´ì˜¨ ê²½ìš°ë§Œ SubmissionAnswerë¡œ ì •ê·œí™” ì €ì¥
    """

    source = "homework_video"

    def extract_answers(self) -> Iterable[Dict[str, Any]]:
        payload = self.submission.payload or {}
        extracted = payload.get("extracted_answers") or payload.get("answers")

        if isinstance(extracted, list):
            for row in extracted:
                qid = row.get("question_id")
                if not qid:
                    continue
                yield {
                    "question_id": int(qid),
                    "answer": row.get("answer", ""),
                    "meta": row.get("meta") or {"via": "video"},
                }
            return

        if isinstance(extracted, dict):
            for k, v in extracted.items():
                try:
                    qid = int(k)
                except Exception:
                    continue
                yield {
                    "question_id": qid,
                    "answer": v if v is not None else "",
                    "meta": {"via": "video"},
                }
            return

        return


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# domains/submissions/views/__init__.py

from .submission_view import SubmissionViewSet

__all__ = ["SubmissionViewSet"]


==========================================================================================
# FILE: views/submission_view.py
==========================================================================================
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated

from apps.domains.submissions.models import Submission
from apps.domains.submissions.serializers.submission import (
    SubmissionSerializer,
    SubmissionCreateSerializer,
)
from apps.domains.submissions.services.dispatcher import dispatch_submission


class SubmissionViewSet(ModelViewSet):
    """
    Submission ë‹¨ì¼ ì§„ì‹¤ ì—”ë“œí¬ì¸íŠ¸

    - ì‹œí—˜ / ê³¼ì œ / ì˜ìƒ ì—…ë¡œë“œ ì „ë¶€ ì—¬ê¸°ì„œ ìƒì„±
    - ì‹¤ì œ ì²˜ë¦¬ ë¡œì§ì€ Celery Workerê°€ ë‹´ë‹¹
    """

    queryset = Submission.objects.all().order_by("-id")
    permission_classes = [IsAuthenticated]

    # --------------------------------------------
    # serializer ë¶„ê¸°
    # --------------------------------------------
    def get_serializer_class(self):
        # ìƒì„± ê³„ì—´ì€ CreateSerializer ì‚¬ìš©
        if self.action in ("create", "admin_omr_upload"):
            return SubmissionCreateSerializer
        return SubmissionSerializer

    # --------------------------------------------
    # ê³µí†µ create (í•™ìƒ/ê´€ë¦¬ì ê³µìš©)
    # POST /api/v1/submissions/
    # --------------------------------------------
    def perform_create(self, serializer):
        """
        Submission ìƒì„± ì§í›„:
        - status = SUBMITTED
        - dispatcherë¥¼ í†µí•´ Workerë¡œ ì „ë‹¬
        """
        submission = serializer.save(user=self.request.user)
        dispatch_submission(submission)

    # ============================================================
    # ğŸ”¥ ê´€ë¦¬ì OMR ì—…ë¡œë“œ ì „ìš© API
    # POST /api/v1/submissions/admin/omr-upload/
    # ============================================================
    @action(
        detail=False,
        methods=["post"],
        url_path="admin/omr-upload",
    )
    def admin_omr_upload(self, request):
        """
        ê´€ë¦¬ì OMR ìŠ¤ìº” ì—…ë¡œë“œ

        form-data:
        - enrollment_id
        - target_id        (exam_id)
        - file             (pdf / image)

        âš ï¸ target_type, sourceëŠ” ì„œë²„ì—ì„œ ê°•ì œ
        """

        serializer = SubmissionCreateSerializer(
            data={
                "enrollment_id": request.data.get("enrollment_id"),
                "target_type": Submission.TargetType.EXAM,
                "target_id": request.data.get("target_id"),
                "source": Submission.Source.OMR_SCAN,
                "file": request.FILES.get("file"),
            }
        )
        serializer.is_valid(raise_exception=True)

        submission = serializer.save(user=request.user)

        # ğŸ”¥ STEP 2: AI / OMR Worker ë””ìŠ¤íŒ¨ì¹˜
        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            },
            status=status.HTTP_201_CREATED,
        )

    # ============================================================
    # ğŸ” Submission ì¬ì²˜ë¦¬
    # POST /api/v1/submissions/{id}/retry/
    # ============================================================
    @action(detail=True, methods=["post"])
    def retry(self, request, pk=None):
        """
        FAILED ìƒíƒœ Submission ì¬ì²˜ë¦¬ ì „ìš©

        - status ë¦¬ì…‹
        - ë‹¤ì‹œ dispatcher í˜¸ì¶œ
        """

        submission = self.get_object()

        # â— ì‹¤íŒ¨í•œ ê²ƒë§Œ ì¬ì²˜ë¦¬ í—ˆìš©
        if submission.status != Submission.Status.FAILED:
            return Response(
                {"detail": "Only FAILED submissions can be retried."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # ìƒíƒœ ë¦¬ì…‹
        submission.status = Submission.Status.SUBMITTED
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])

        # ë‹¤ì‹œ ë””ìŠ¤íŒ¨ì¹˜
        dispatch_submission(submission)

        return Response(
            {
                "submission_id": submission.id,
                "status": submission.status,
            }
        )
