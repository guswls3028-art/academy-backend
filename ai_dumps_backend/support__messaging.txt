====================================================================================================
# BACKEND APP: support__messaging
# ROOT PATH: C:\academy\apps\support\messaging
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: alimtalk_templates.py
==========================================================================================
"""
알림톡 템플릿 변수 — 비즈니스 채널 승인 전에도 미리 확정·등록용.

솔라피/카카오 콘솔에 등록할 템플릿 문구의 변수명을 코드에 고정해 두고,
DB 필드와 매칭해 치환 데이터를 만듭니다.
"""

from __future__ import annotations

from typing import Any, Dict

# -----------------------------------------------------------------------------
# 템플릿 변수명 (카카오 #{변수명} 형식, 솔라피 콘솔에 등록 시 동일하게)
# -----------------------------------------------------------------------------

# 클리닉/예약 관련 (예: 예약 안내, 리마인더)
ALIMTALK_VAR_NAME = "name"           # 수신자 이름 (학생/학부모)
ALIMTALK_VAR_DATE = "date"           # 예약일 또는 안내 날짜 (예: 2025-02-15)
ALIMTALK_VAR_TIME = "time"           # 시간 (예: 14:00)
ALIMTALK_VAR_CLINIC_NAME = "clinic_name"  # 클리닉/상담명
ALIMTALK_VAR_PLACE = "place"         # 장소
ALIMTALK_VAR_LINK = "link"           # 상세 링크 (선택)

# 공통
ALIMTALK_VAR_TITLE = "title"         # 제목/안내 제목

# 템플릿 문구 예시 (승인 받을 때 사용할 문구에 들어갈 변수)
# 예: "#{name}님, #{date} #{time} #{clinic_name} 예약이 완료되었습니다."
ALIMTALK_TEMPLATE_VARIABLES = [
    ALIMTALK_VAR_NAME,
    ALIMTALK_VAR_DATE,
    ALIMTALK_VAR_TIME,
    ALIMTALK_VAR_CLINIC_NAME,
    ALIMTALK_VAR_PLACE,
    ALIMTALK_VAR_LINK,
    ALIMTALK_VAR_TITLE,
]


def build_replacements(context: Dict[str, Any]) -> list[dict]:
    """
    DB/컨텍스트 dict를 Solapi 알림톡 replacements 형식으로 변환.

    Solapi RequestMessage.replacements 형식:
    [ {"key": "name", "value": "홍길동"}, ... ]

    context 예시 (클리닉 예약 리마인더):
        {"name": "홍길동", "date": "2025-02-15", "time": "14:00", "clinic_name": "수학 클리닉", "place": "A관 301"}
    """
    key_to_var = {
        "name": ALIMTALK_VAR_NAME,
        "date": ALIMTALK_VAR_DATE,
        "time": ALIMTALK_VAR_TIME,
        "clinic_name": ALIMTALK_VAR_CLINIC_NAME,
        "place": ALIMTALK_VAR_PLACE,
        "link": ALIMTALK_VAR_LINK,
        "title": ALIMTALK_VAR_TITLE,
    }
    out = []
    for ctx_key, var_name in key_to_var.items():
        if ctx_key in context and context[ctx_key] is not None:
            out.append({"key": var_name, "value": str(context[ctx_key])})
    return out


def template_context_from_reservation(reservation: Any) -> Dict[str, Any]:
    """
    예약 모델(또는 dict)에서 알림톡 context 추출.
    프로젝트에 Reservation 모델이 생기면 여기서 필드 매핑.

    예시 (추후 구현):
        return {
            "name": reservation.student.name if hasattr(reservation, "student") else "",
            "date": reservation.date.strftime("%Y-%m-%d") if getattr(reservation, "date", None) else "",
            "time": getattr(reservation, "time", "") or "",
            "clinic_name": getattr(reservation, "clinic_name", "") or getattr(reservation, "title", ""),
            "place": getattr(reservation, "place", "") or "",
        }
    """
    if hasattr(reservation, "__dict__"):
        d = reservation.__dict__ if not hasattr(reservation, "pk") else {}
        return {
            "name": d.get("student_name") or getattr(reservation, "student_name", "") or "",
            "date": d.get("date") or getattr(reservation, "date", ""),
            "time": d.get("time") or getattr(reservation, "time", "") or "",
            "clinic_name": d.get("clinic_name") or getattr(reservation, "clinic_name", "") or getattr(reservation, "title", "") or "",
            "place": d.get("place") or getattr(reservation, "place", "") or "",
        }
    if isinstance(reservation, dict):
        return {
            "name": reservation.get("name", ""),
            "date": reservation.get("date", ""),
            "time": reservation.get("time", ""),
            "clinic_name": reservation.get("clinic_name", "") or reservation.get("title", ""),
            "place": reservation.get("place", ""),
            "link": reservation.get("link", ""),
            "title": reservation.get("title", ""),
        }
    return {}


==========================================================================================
# FILE: credit_services.py
==========================================================================================
# apps/support/messaging/credit_services.py
"""
크레딧 충전·차감·롤백 (발송 실패 시 복구)
- 충전: 선생님이 결제 완료 후 credit_balance 증가
- 차감: 발송 전 잔액 체크 후 차감 (워커에서 호출)
- 롤백: 발송 실패 시 차감된 금액 복구
"""

from decimal import Decimal
from typing import Optional

from django.db import transaction

from apps.core.models import Tenant


def charge_credits(tenant_id: int, amount: str | Decimal) -> Decimal:
    """
    선불 충전. 결제 완료 후 호출.
    Returns: 새 잔액
    """
    amt = Decimal(str(amount))
    if amt <= 0:
        raise ValueError("amount must be positive")
    with transaction.atomic():
        tenant = Tenant.objects.select_for_update().get(pk=tenant_id)
        tenant.credit_balance += amt
        tenant.save(update_fields=["credit_balance"])
        return tenant.credit_balance


def deduct_credits(tenant_id: int, amount: str | Decimal) -> Decimal:
    """
    발송 전 차감. 잔액 부족 시 ValueError.
    Returns: 차감 후 잔액
    """
    amt = Decimal(str(amount))
    if amt <= 0:
        raise ValueError("amount must be positive")
    with transaction.atomic():
        tenant = Tenant.objects.select_for_update().get(pk=tenant_id)
        if tenant.credit_balance < amt:
            raise ValueError("insufficient_balance")
        tenant.credit_balance -= amt
        tenant.save(update_fields=["credit_balance"])
        return tenant.credit_balance


def rollback_credits(tenant_id: int, amount: str | Decimal) -> Decimal:
    """
    발송 실패 시 차감 롤백. 복구 후 잔액 반환.
    """
    amt = Decimal(str(amount))
    if amt <= 0:
        return Tenant.objects.get(pk=tenant_id).credit_balance
    with transaction.atomic():
        tenant = Tenant.objects.select_for_update().get(pk=tenant_id)
        tenant.credit_balance += amt
        tenant.save(update_fields=["credit_balance"])
        return tenant.credit_balance


def get_tenant_messaging_info(tenant_id: int) -> Optional[dict]:
    """워커/API용: 테넌트 메시징 정보 (잔액, PFID, 활성화, 단가)"""
    t = Tenant.objects.filter(pk=tenant_id).values(
        "kakao_pfid", "credit_balance", "messaging_is_active", "messaging_base_price"
    ).first()
    if not t:
        return None
    return {
        "kakao_pfid": t["kakao_pfid"] or None,
        "credit_balance": str(t["credit_balance"]),
        "is_active": t["messaging_is_active"],
        "base_price": str(t["messaging_base_price"]),
    }


==========================================================================================
# FILE: models.py
==========================================================================================
# apps/support/messaging/models.py
"""
알림톡 발송 로그 — 성공/실패, 차감 금액 기록
"""

from decimal import Decimal

from django.db import models


class NotificationLog(models.Model):
    """
    발송 1건당 1행. 워커가 Solapi 호출 후 성공 시 차감·기록, 실패 시 롤백 후 기록(선택).
    """

    tenant = models.ForeignKey(
        "core.Tenant",
        on_delete=models.CASCADE,
        related_name="notification_logs",
        db_index=True,
    )
    sent_at = models.DateTimeField(auto_now_add=True, db_index=True)
    success = models.BooleanField(default=False)
    amount_deducted = models.DecimalField(
        max_digits=10, decimal_places=2, default=Decimal("0")
    )
    recipient_summary = models.CharField(max_length=500, blank=True, default="")
    template_summary = models.CharField(max_length=255, blank=True, default="")
    failure_reason = models.CharField(max_length=500, blank=True, default="")

    class Meta:
        app_label = "messaging"
        ordering = ["-sent_at"]
        verbose_name = "Notification log"
        verbose_name_plural = "Notification logs"


class MessageTemplate(models.Model):
    """
    메시지 양식 템플릿 — 테넌트별 저장, 카테고리별 사용처 구분
    - default: 기본(어디서나), 기본 블록만
    - lecture: 강의·차시(세션) 내 학생 선택 발송용
    - clinic: 클리닉 내 학생 선택 발송용
    """
    class Category(models.TextChoices):
        DEFAULT = "default", "기본"
        LECTURE = "lecture", "강의"
        CLINIC = "clinic", "클리닉"

    tenant = models.ForeignKey(
        "core.Tenant",
        on_delete=models.CASCADE,
        related_name="message_templates",
        db_index=True,
    )
    category = models.CharField(
        max_length=20,
        choices=Category.choices,
        default=Category.DEFAULT,
        db_index=True,
    )
    name = models.CharField(max_length=120, help_text="템플릿 이름")
    subject = models.CharField(max_length=200, blank=True, default="", help_text="제목(선택)")
    body = models.TextField(help_text="본문")

    # 솔라피 알림톡 검수 신청 연동
    solapi_template_id = models.CharField(max_length=100, blank=True, default="")
    solapi_status = models.CharField(
        max_length=20,
        blank=True,
        default="",
        choices=[
            ("", "미신청"),
            ("PENDING", "검수 대기"),
            ("APPROVED", "승인"),
            ("REJECTED", "반려"),
        ],
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        app_label = "messaging"
        ordering = ["-updated_at"]
        verbose_name = "Message template"
        verbose_name_plural = "Message templates"


==========================================================================================
# FILE: selectors.py
==========================================================================================
# apps/support/messaging/selectors.py

def get_active_provider():
    return None


==========================================================================================
# FILE: serializers.py
==========================================================================================
# apps/support/messaging/serializers.py
from rest_framework import serializers

from apps.core.models import Tenant
from apps.support.messaging.models import MessageTemplate


class MessagingInfoSerializer(serializers.ModelSerializer):
    """GET/PATCH 응답: 테넌트 메시징 정보"""
    credit_balance = serializers.DecimalField(
        max_digits=12, decimal_places=0, read_only=True
    )
    is_active = serializers.BooleanField(source="messaging_is_active", read_only=True)
    base_price = serializers.DecimalField(
        source="messaging_base_price", max_digits=10, decimal_places=2, read_only=True
    )

    class Meta:
        model = Tenant
        fields = ["kakao_pfid", "credit_balance", "is_active", "base_price"]
        read_only_fields = ["credit_balance", "is_active", "base_price"]


class MessagingInfoUpdateSerializer(serializers.Serializer):
    """PATCH 요청: PFID만 수정 가능"""
    kakao_pfid = serializers.CharField(max_length=100, required=False, allow_blank=True)


class ChargeRequestSerializer(serializers.Serializer):
    amount = serializers.DecimalField(max_digits=12, decimal_places=0, min_value=1)


class ChargeResponseSerializer(serializers.Serializer):
    credit_balance = serializers.DecimalField(max_digits=12, decimal_places=0)


class NotificationLogSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    sent_at = serializers.DateTimeField()
    success = serializers.BooleanField()
    amount_deducted = serializers.DecimalField(max_digits=10, decimal_places=2)
    recipient_summary = serializers.CharField()
    template_summary = serializers.CharField()
    failure_reason = serializers.CharField()


class MessageTemplateSerializer(serializers.ModelSerializer):
    class Meta:
        model = MessageTemplate
        fields = [
            "id",
            "category",
            "name",
            "subject",
            "body",
            "solapi_template_id",
            "solapi_status",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "id",
            "solapi_template_id",
            "solapi_status",
            "created_at",
            "updated_at",
        ]


==========================================================================================
# FILE: services.py
==========================================================================================
# apps/support/messaging/services.py
"""
메시지 발송 서비스 — Solapi(SMS/LMS) 연동

- API 키/시크릿: 환경변수 SOLAPI_API_KEY, SOLAPI_API_SECRET (또는 Django 설정)
- 발신번호: SOLAPI_SENDER 또는 settings.SOLAPI_SENDER
"""

import logging
import os
from typing import Optional

from django.conf import settings

logger = logging.getLogger(__name__)


def _get_solapi_credentials() -> tuple[Optional[str], Optional[str]]:
    """Solapi API Key/Secret (환경변수 우선, 설정 fallback). 코드에 키 노출 금지."""
    key = os.environ.get("SOLAPI_API_KEY") or getattr(settings, "SOLAPI_API_KEY", None)
    secret = os.environ.get("SOLAPI_API_SECRET") or getattr(settings, "SOLAPI_API_SECRET", None)
    return (key or None, secret or None)


def _is_mock_mode() -> bool:
    """DEBUG=True 또는 SOLAPI_MOCK=true 이면 실제 API 호출 없이 Mock 사용."""
    if os.environ.get("SOLAPI_MOCK", "").lower() in ("true", "1", "yes"):
        return True
    if getattr(settings, "DEBUG", False):
        return True
    return os.environ.get("DEBUG", "").lower() in ("true", "1", "yes")


def get_solapi_client():
    """
    SolapiMessageService 인스턴스 반환.
    DEBUG=True 또는 SOLAPI_MOCK=true 이면 MockSolapiMessageService (로그만).
    키/시크릿이 없으면 None (스텁 모드).
    """
    if _is_mock_mode():
        from apps.support.messaging.solapi_mock import MockSolapiMessageService
        key, secret = _get_solapi_credentials()
        return MockSolapiMessageService(api_key=key or "", api_secret=secret or "")
    key, secret = _get_solapi_credentials()
    if not key or not secret:
        return None
    try:
        from solapi import SolapiMessageService
        return SolapiMessageService(api_key=key, api_secret=secret)
    except ImportError as e:
        logger.warning("solapi SDK not installed: %s", e)
        return None


def send_sms(
    to: str,
    text: str,
    sender: Optional[str] = None,
) -> dict:
    """
    SMS/LMS 즉시 발송 (Solapi).

    Args:
        to: 수신 번호 (01012345678)
        text: 본문
        sender: 발신 번호 (미지정 시 SOLAPI_SENDER 사용)

    Returns:
        dict: {"status": "ok"|"error"|"skipped", "group_id"?, "reason"?}
    """
    client = get_solapi_client()
    if not client:
        logger.info("send_sms skipped: Solapi not configured")
        return {"status": "skipped", "reason": "solapi_not_configured"}

    sender = (sender or "").strip() or os.environ.get("SOLAPI_SENDER") or getattr(settings, "SOLAPI_SENDER", "")
    if not sender:
        return {"status": "error", "reason": "sender_required"}

    to = (to or "").replace("-", "").strip()
    if not to or not (text or "").strip():
        return {"status": "error", "reason": "to_and_text_required"}

    try:
        from solapi.model import RequestMessage
        message = RequestMessage(from_=sender, to=to, text=text.strip())
        response = client.send(message)
        group_id = getattr(getattr(response, "group_info", None), "group_id", None)
        logger.info("send_sms ok to=%s group_id=%s", to[:4] + "****", group_id)
        return {"status": "ok", "group_id": group_id}
    except Exception as e:
        logger.exception("send_sms failed to=%s", to[:4] + "****")
        return {"status": "error", "reason": str(e)[:500]}


def enqueue_sms(
    tenant_id: int,
    to: str,
    text: str,
    sender: Optional[str] = None,
    *,
    reservation_id: Optional[int] = None,
    use_alimtalk_first: bool = False,
    alimtalk_replacements: Optional[list[dict]] = None,
    template_id: Optional[str] = None,
) -> bool:
    """
    SMS(또는 알림톡→SMS 폴백) 발송을 SQS에 넣어 워커가 비동기로 발송하도록 함.

    Args:
        tenant_id: 테넌트 ID (워커에서 잔액/PFID 조회)
        to: 수신 번호
        text: 본문 (SMS fallback용)
        sender: 발신 번호
        reservation_id: 예약 ID 있으면 워커에서 취소 여부 Double Check 후 발송/스킵
        use_alimtalk_first: True면 워커가 알림톡 우선 시도, 실패 시 SMS
        alimtalk_replacements: 알림톡 템플릿 치환 [{"key": "name", "value": "홍길동"}, ...]
        template_id: 알림톡 템플릿 ID (선택)

    Returns:
        bool: enqueue 성공 여부
    """
    from apps.support.messaging.sqs_queue import MessagingSQSQueue
    queue = MessagingSQSQueue()
    return queue.enqueue(
        tenant_id=tenant_id,
        to=to,
        text=text,
        sender=sender,
        reservation_id=reservation_id,
        use_alimtalk_first=use_alimtalk_first,
        alimtalk_replacements=alimtalk_replacements,
        template_id=template_id,
    )


def is_reservation_cancelled(reservation_id: int) -> bool:
    """
    예약 취소 여부 (Double Check용).
    Django ORM이 로드된 상태에서, 프로젝트 내 Reservation 비슷한 모델의 status가 CANCELLED면 True.
    해당 모델이 없거나 status가 다르면 False.
    """
    try:
        from django.apps import apps
        for model in apps.get_models():
            if model.__name__ == "Reservation" and hasattr(model, "status"):
                r = model.objects.filter(pk=reservation_id).first()
                if r and getattr(r, "status", None) == "CANCELLED":
                    return True
        return False
    except Exception:
        return False


def send_clinic_reminder_for_students(*args, **kwargs):
    """
    서버 부팅용 더미 함수
    - 실제 문자 발송 없음
    - ImportError 방지용
    """
    return {
        "status": "noop",
        "message": "clinic reminder skipped (stub)",
    }


def get_site_url(request=None):
    """홈페이지 링크 (메시지용)"""
    from django.conf import settings
    url = getattr(settings, "SITE_URL", None)
    if url:
        return url.rstrip("/")
    if request:
        scheme = "https" if request.is_secure() else "http"
        return f"{scheme}://{request.get_host()}"
    return ""


def send_welcome_messages(
    *,
    created_students: list,
    student_password: str,
    parent_password_by_phone: dict = None,
    site_url: str = "",
):
    """
    가입 성공 메시지 일괄 발송 (학생 + 학부모)

    - 학생용: 홈페이지 링크 + 학생이름, 학생ID, 학생비번
    - 학부모용: 홈페이지 링크 + 학부모ID(학부모폰번호), 학부모비번, 학생이름, 아이디, 비번

    현재는 스텁: 로깅만. 실제 SMS 연동 시 여기서 구현.
    """
    parent_password_by_phone = parent_password_by_phone or {}
    sent = 0

    for student in created_students:
        name = getattr(student, "name", "")
        ps_number = getattr(student, "ps_number", "")
        parent_phone = getattr(student, "parent_phone", "")

        # 학생용 메시지
        student_msg = (
            f"[가입 완료]\n{site_url}\n"
            f"학생이름: {name}\n학생 ID: {ps_number}\n학생 비번: {student_password}"
        )
        logger.info("send_welcome (student) %s: %s", parent_phone or "no-phone", student_msg[:80])
        sent += 1

        # 학부모용 메시지 (학부모 전화번호가 있으면)
        if parent_phone:
            pwd = parent_password_by_phone.get(parent_phone, student_password)
            parent_msg = (
                f"[가입 완료]\n{site_url}\n"
                f"학부모 ID: {parent_phone}\n학부모 비번: {pwd}\n"
                f"학생이름: {name}\n아이디: {ps_number}\n비번: {student_password}"
            )
            logger.info("send_welcome (parent) %s: %s", parent_phone, parent_msg[:80])
            sent += 1

    return {"status": "stub", "logged": sent}


==========================================================================================
# FILE: solapi_mock.py
==========================================================================================
"""
Mock Solapi — DEBUG=True 일 때 실제 API 호출 없이 콘솔에 발송될 JSON만 로깅.

실제 API를 쓰면 잔액이 차감되고, 템플릿 미승인 시 에러가 나므로
개발/테스트 시에는 이 Mock을 사용.
"""

from __future__ import annotations

import json
import logging
import uuid
from typing import Any, Optional, Union

logger = logging.getLogger(__name__)


def _message_to_log_payload(message: Any) -> dict:
    """RequestMessage(또는 리스트)를 로그용 dict로 변환."""
    if hasattr(message, "model_dump"):
        return message.model_dump(exclude_none=True)
    if hasattr(message, "dict"):
        return message.dict(exclude_none=True)
    if isinstance(message, list):
        return [_message_to_log_payload(m) for m in message]
    if isinstance(message, dict):
        return message
    return {"raw": str(message)}


class MockSolapiMessageService:
    """
    Solapi 실제 호출 대신 로그만 출력하는 Mock.
    DEBUG=True(또는 SOLAPI_MOCK=true) 일 때 사용.
    """

    def __init__(self, api_key: str = "", api_secret: str = ""):
        self.api_key = api_key
        self.api_secret = api_secret

    def send(
        self,
        messages: Union[list, Any],
        request_config: Optional[Any] = None,
    ) -> Any:
        """
        실제 발송 대신 JSON을 예쁘게 로그하고, 성공 응답 형태의 Mock 객체 반환.
        """
        if not isinstance(messages, list):
            messages = [messages]
        request_config_payload = None
        if request_config:
            if hasattr(request_config, "model_dump"):
                request_config_payload = request_config.model_dump(exclude_none=True)
            elif hasattr(request_config, "dict"):
                request_config_payload = request_config.dict(exclude_none=True)
            else:
                request_config_payload = str(request_config)
        payload = {
            "messages": _message_to_log_payload(messages),
            "request_config": request_config_payload,
        }
        logger.info(
            "[MockSolapi] 발송 스킵 (실제 API 미호출)\n%s",
            json.dumps(payload, indent=2, ensure_ascii=False),
        )
        group_id = f"mock-{uuid.uuid4().hex[:12]}"
        return _MockSendResponse(group_id=group_id, count=len(messages))


class _MockSendResponse:
    """send() 반환값 호환용 Mock 객체."""

    def __init__(self, group_id: str, count: int = 1):
        self.group_info = _MockGroupInfo(group_id=group_id, count=count)


class _MockGroupInfo:
    def __init__(self, group_id: str, count: int = 1):
        self.group_id = group_id
        self.count = _MockCount(registered_success=count, registered_failed=0, total=count)


class _MockCount:
    def __init__(self, registered_success: int = 1, registered_failed: int = 0, total: int = 1):
        self.registered_success = registered_success
        self.registered_failed = registered_failed
        self.total = total


==========================================================================================
# FILE: solapi_template_client.py
==========================================================================================
# apps/support/messaging/solapi_template_client.py
"""
솔라피 알림톡 템플릿 등록(검수 신청) — REST API 연동

- POST /kakao/v2/templates (channelId=PFID, name, content, categoryCode)
- #{변수명} 형식 검증
- API Key 인증: HMAC-SHA256 (date + salt → signature)
"""

import hmac
import hashlib
import logging
import re
import secrets
from datetime import datetime, timezone
from typing import Optional

import requests

logger = logging.getLogger(__name__)

SOLAPI_BASE = "https://api.solapi.com"
TEMPLATE_CREATE_PATH = "/kakao/v2/templates"

# #{변수명} 형식 검증 시 참고 (필요 시 확장)
VARIABLE_PATTERN = re.compile(r"#\{[^}]+\}")


def validate_template_variables(*texts: str) -> tuple[bool, list[str]]:
    """
    템플릿 본문/제목에 #{변수명} 형식이 유지되는지 검증.
    - #{변수명} 형태가 올바르게 닫혀 있는지 확인 ( #{ ... } )
    - 닫히지 않은 #{ 가 있으면 에러
    반환: (성공 여부, 에러 메시지 리스트)
    """
    errors = []
    for raw in texts:
        if not raw or not raw.strip():
            continue
        idx = 0
        while True:
            open_brace = raw.find("#{", idx)
            if open_brace == -1:
                break
            close_brace = raw.find("}", open_brace)
            if close_brace == -1:
                errors.append("'#{'에 대응하는 '}'가 없습니다.")
                break
            idx = close_brace + 1
    return (len(errors) == 0, errors)


def _create_auth_header(api_key: str, api_secret: str) -> str:
    """HMAC-SHA256 Authorization 헤더 생성 (Solapi 규격)."""
    date_time = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
    salt = secrets.token_hex(16)
    data = date_time + salt
    signature = hmac.new(
        api_secret.encode(),
        data.encode(),
        hashlib.sha256,
    ).hexdigest()
    return f"HMAC-SHA256 apiKey={api_key}, date={date_time}, salt={salt}, signature={signature}"


def create_kakao_template(
    api_key: str,
    api_secret: str,
    channel_id: str,
    name: str,
    content: str,
    category_code: str = "TE",
    message_type: str = "BA",
    emphasize_type: str = "NONE",
) -> dict:
    """
    솔라피 알림톡 템플릿 등록(검수 신청).

    Args:
        api_key: SOLAPI API Key
        api_secret: SOLAPI API Secret
        channel_id: 카카오 채널 ID (테넌트 kakao_pfid)
        name: 템플릿 이름
        content: 본문 (변수 #{변수명} 포함 가능)
        category_code: 카테고리 코드 (기본 TE)
        message_type: BA(기본형) 등
        emphasize_type: NONE 등

    Returns:
        {"templateId": "KA01TP..."} 또는 예외

    Raises:
        ValueError: 검증 실패 또는 API 에러
    """
    channel_id = (channel_id or "").strip()
    if not channel_id:
        raise ValueError("channelId(PFID)가 필요합니다.")
    if not (name or "").strip():
        raise ValueError("템플릿 이름이 필요합니다.")
    if not (content or "").strip():
        raise ValueError("템플릿 본문이 필요합니다.")

    ok, errs = validate_template_variables(content)
    if not ok:
        raise ValueError("변수 검증 실패: " + "; ".join(errs))

    url = SOLAPI_BASE + TEMPLATE_CREATE_PATH
    headers = {
        "Authorization": _create_auth_header(api_key, api_secret),
        "Content-Type": "application/json",
    }
    body = {
        "channelId": channel_id,
        "name": name.strip(),
        "content": content.strip(),
        "categoryCode": (category_code or "TE").strip(),
        "messageType": message_type,
        "emphasizeType": emphasize_type,
    }

    logger.info("Solapi template create request channelId=%s name=%s", channel_id, name[:30])
    resp = requests.post(url, json=body, headers=headers, timeout=30)

    if resp.status_code != 200:
        try:
            err_body = resp.json()
            msg = err_body.get("errorMessage") or err_body.get("message") or resp.text
        except Exception:
            msg = resp.text
        logger.warning("Solapi template create failed status=%s body=%s", resp.status_code, msg)
        raise ValueError(f"솔라피 템플릿 등록 실패: {msg}")

    data = resp.json()
    template_id = (data.get("templateId") or data.get("id") or "").strip()
    if not template_id:
        raise ValueError("솔라피 응답에 templateId가 없습니다.")
    return {"templateId": template_id, "raw": data}


==========================================================================================
# FILE: sqs_queue.py
==========================================================================================
"""
SQS 기반 메시지 발송 큐

API/서비스에서 enqueue → messaging_worker가 소비하여 Solapi로 발송
"""

from __future__ import annotations

import json
import logging
from typing import Optional

from django.conf import settings
from django.utils import timezone

from libs.queue import get_queue_client

logger = logging.getLogger(__name__)


class MessagingSQSQueue:
    """
    메시지 발송 작업 SQS 큐

    메시지 형식:
    {
        "to": str,
        "text": str,
        "sender": str | None,
        "reservation_id": int | None,
        "use_alimtalk_first": bool,
        "alimtalk_replacements": list[{"key": str, "value": str}] | None,  # #{name}, #{date}, #{clinic_name} 등
    }
    """

    QUEUE_NAME = "academy-messaging-jobs"
    DLQ_NAME = "academy-messaging-jobs-dlq"

    def __init__(self):
        self.queue_client = get_queue_client()

    def _get_queue_name(self) -> str:
        return getattr(settings, "MESSAGING_SQS_QUEUE_NAME", self.QUEUE_NAME)

    def enqueue(
        self,
        *,
        tenant_id: int,
        to: str,
        text: str,
        sender: Optional[str] = None,
        reservation_id: Optional[int] = None,
        use_alimtalk_first: bool = False,
        alimtalk_replacements: Optional[list[dict]] = None,
        template_id: Optional[str] = None,
    ) -> bool:
        """
        발송 작업을 SQS에 추가

        Args:
            tenant_id: 테넌트 ID (워커에서 잔액/PFID 조회용)
            to: 수신 번호
            text: 본문 (SMS fallback용)
            sender: 발신 번호
            reservation_id: 예약 ID (워커에서 취소 시 스킵)
            use_alimtalk_first: 알림톡 우선 시도, 실패 시 SMS
            alimtalk_replacements: 알림톡 치환 [{"key": "name", "value": "홍길동"}, ...]
            template_id: 알림톡 템플릿 ID (미지정 시 워커 기본값 사용)
        """
        message = {
            "tenant_id": int(tenant_id),
            "to": str(to).replace("-", "").strip(),
            "text": (text or "").strip(),
            "sender": (sender or "").strip() or None,
            "created_at": timezone.now().isoformat(),
        }
        if reservation_id is not None:
            message["reservation_id"] = int(reservation_id)
        if use_alimtalk_first:
            message["use_alimtalk_first"] = True
        if alimtalk_replacements:
            message["alimtalk_replacements"] = alimtalk_replacements
        if template_id:
            message["template_id"] = str(template_id)
        if not message["to"] or not message["text"]:
            logger.warning("enqueue skipped: to or text empty")
            return False
        try:
            ok = self.queue_client.send_message(
                queue_name=self._get_queue_name(),
                message=message,
            )
            if ok:
                logger.info("Messaging job enqueued: to=%s", message["to"][:4] + "****")
            return bool(ok)
        except Exception as e:
            logger.exception("Error enqueuing messaging job: %s", e)
            return False

    def receive_message(self, wait_time_seconds: int = 20) -> Optional[dict]:
        """
        SQS에서 메시지 수신 (Long Polling)

        Returns:
            dict: { to, text, sender, receipt_handle, message_id, created_at } 또는 None
        """
        try:
            raw = self.queue_client.receive_message(
                queue_name=self._get_queue_name(),
                wait_time_seconds=wait_time_seconds,
            )
            if not raw:
                return None
            body = raw.get("Body", "")
            receipt_handle = raw.get("ReceiptHandle")
            if not receipt_handle:
                return None
            if isinstance(body, str):
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    logger.error("Invalid JSON in message body")
                    return None
            else:
                data = body
            if not isinstance(data, dict) or "to" not in data or "text" not in data:
                logger.error("Invalid message format: %s", data)
                return None
            return {
                "to": str(data.get("to", "")),
                "text": str(data.get("text", "")),
                "sender": (data.get("sender") or "").strip() or None,
                "receipt_handle": receipt_handle,
                "message_id": raw.get("MessageId"),
                "created_at": data.get("created_at"),
                "reservation_id": data.get("reservation_id"),
                "use_alimtalk_first": bool(data.get("use_alimtalk_first")),
                "alimtalk_replacements": data.get("alimtalk_replacements") or [],
            }
        except Exception as e:
            logger.exception("Error receiving messaging message: %s", e)
            return None

    def delete_message(self, receipt_handle: str) -> bool:
        """처리 완료된 메시지 삭제"""
        try:
            return self.queue_client.delete_message(
                queue_name=self._get_queue_name(),
                receipt_handle=receipt_handle,
            )
        except Exception as e:
            logger.exception("Error deleting message: %s", e)
            return False


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/support/messaging/urls.py
from django.urls import path
from apps.support.messaging import views

urlpatterns = [
    path("info/", views.MessagingInfoView.as_view(), name="messaging-info"),
    path("charge/", views.ChargeView.as_view(), name="messaging-charge"),
    path("log/", views.NotificationLogListView.as_view(), name="messaging-log"),
    path("channel-check/", views.ChannelCheckView.as_view(), name="messaging-channel-check"),
    path("templates/", views.MessageTemplateListCreateView.as_view(), name="messaging-templates"),
    path("templates/<int:pk>/", views.MessageTemplateDetailView.as_view(), name="messaging-template-detail"),
    path(
        "templates/<int:pk>/submit-review/",
        views.MessageTemplateSubmitReviewView.as_view(),
        name="messaging-template-submit-review",
    ),
]


==========================================================================================
# FILE: views.py
==========================================================================================
# apps/support/messaging/views.py
"""
메시징 API — 잔액/충전/PFID/발송 로그 (테넌트 기준)
"""

from rest_framework import status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.core.permissions import TenantResolvedAndStaff
from apps.core.models import Tenant
from apps.support.messaging.models import NotificationLog, MessageTemplate
from apps.support.messaging.solapi_template_client import (
    create_kakao_template,
    validate_template_variables,
)
from apps.support.messaging.credit_services import (
    charge_credits as do_charge,
    get_tenant_messaging_info,
)
from apps.support.messaging.serializers import (
    MessagingInfoSerializer,
    MessagingInfoUpdateSerializer,
    ChargeRequestSerializer,
    NotificationLogSerializer,
    MessageTemplateSerializer,
)


class MessagingInfoView(APIView):
    """GET: 현재 테넌트 메시징 정보. PATCH: PFID 저장"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def get(self, request):
        tenant = request.tenant
        serializer = MessagingInfoSerializer(tenant)
        data = serializer.data
        data["credit_balance"] = str(data["credit_balance"])
        data["base_price"] = str(data["base_price"])
        return Response(data)

    def patch(self, request):
        tenant = request.tenant
        ser = MessagingInfoUpdateSerializer(data=request.data, partial=True)
        ser.is_valid(raise_exception=True)
        pfid = ser.validated_data.get("kakao_pfid")
        if pfid is not None:
            tenant.kakao_pfid = (pfid or "").strip()
            tenant.save(update_fields=["kakao_pfid"])
        serializer = MessagingInfoSerializer(tenant)
        data = serializer.data
        data["credit_balance"] = str(data["credit_balance"])
        data["base_price"] = str(data["base_price"])
        return Response(data)


class ChargeView(APIView):
    """POST: 크레딧 충전 (결제 완료 후)"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def post(self, request):
        ser = ChargeRequestSerializer(data=request.data)
        ser.is_valid(raise_exception=True)
        amount = ser.validated_data["amount"]
        try:
            new_balance = do_charge(request.tenant.id, amount)
            return Response({"credit_balance": str(new_balance)})
        except ValueError as e:
            return Response(
                {"detail": str(e)},
                status=status.HTTP_400_BAD_REQUEST,
            )


class NotificationLogListView(APIView):
    """GET: 발송 로그 목록 (페이지네이션)"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def get(self, request):
        page = max(1, int(request.query_params.get("page", 1)))
        page_size = min(50, max(1, int(request.query_params.get("page_size", 20))))
        offset = (page - 1) * page_size
        qs = (
            NotificationLog.objects.filter(tenant=request.tenant)
            .order_by("-sent_at")[offset : offset + page_size]
        )
        count = NotificationLog.objects.filter(tenant=request.tenant).count()
        items = [
            {
                "id": r.id,
                "sent_at": r.sent_at,
                "success": r.success,
                "amount_deducted": r.amount_deducted,
                "recipient_summary": r.recipient_summary or "",
                "template_summary": r.template_summary or "",
                "failure_reason": r.failure_reason or "",
            }
            for r in qs
        ]
        return Response({"results": items, "count": count})


class ChannelCheckView(APIView):
    """GET: 채널 공유 확인 (파트너 등록 여부) — 4단계, 스텁 가능"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def get(self, request):
        # TODO: Solapi/카카오 API로 실제 채널 공유 여부 조회
        pfid = (request.tenant.kakao_pfid or "").strip()
        if not pfid:
            return Response({"shared": False, "message": "PFID 미연동"})
        return Response({"shared": True, "message": "연동됨 (실제 검증은 API 연동 후)"})


class MessageTemplateListCreateView(APIView):
    """GET: 템플릿 목록 (category 쿼리로 필터). POST: 템플릿 생성"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def get(self, request):
        qs = MessageTemplate.objects.filter(tenant=request.tenant).order_by("-updated_at")
        category = (request.query_params.get("category") or "").strip().lower()
        if category in ("default", "lecture", "clinic"):
            qs = qs.filter(category=category)
        serializer = MessageTemplateSerializer(qs, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = MessageTemplateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save(tenant=request.tenant)
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class MessageTemplateDetailView(APIView):
    """GET/PATCH/DELETE: 단일 템플릿"""
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def _get_template(self, request, pk):
        return MessageTemplate.objects.filter(tenant=request.tenant, pk=pk).first()

    def get(self, request, pk):
        t = self._get_template(request, pk)
        if not t:
            return Response({"detail": "Not found."}, status=status.HTTP_404_NOT_FOUND)
        return Response(MessageTemplateSerializer(t).data)

    def patch(self, request, pk):
        t = self._get_template(request, pk)
        if not t:
            return Response({"detail": "Not found."}, status=status.HTTP_404_NOT_FOUND)
        serializer = MessageTemplateSerializer(t, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, pk):
        t = self._get_template(request, pk)
        if not t:
            return Response({"detail": "Not found."}, status=status.HTTP_404_NOT_FOUND)
        t.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class MessageTemplateSubmitReviewView(APIView):
    """
    POST: 해당 템플릿을 솔라피에 알림톡 템플릿으로 등록(검수 신청).
    - 테넌트 PFID 사용
    - #{변수명} 검증 후 솔라피 API 호출
    - 응답 templateId 및 PENDING 상태 DB 저장
    """
    permission_classes = [IsAuthenticated, TenantResolvedAndStaff]

    def post(self, request, pk):
        from django.conf import settings

        t = MessageTemplate.objects.filter(tenant=request.tenant, pk=pk).first()
        if not t:
            return Response({"detail": "Not found."}, status=status.HTTP_404_NOT_FOUND)

        pfid = (request.tenant.kakao_pfid or "").strip()
        if not pfid:
            return Response(
                {"detail": "카카오 채널(PFID)이 연동되지 않았습니다. 메시징 설정에서 PFID를 등록해 주세요."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        api_key = getattr(settings, "SOLAPI_API_KEY", None) or ""
        api_secret = getattr(settings, "SOLAPI_API_SECRET", None) or ""
        if not api_key or not api_secret:
            return Response(
                {"detail": "솔라피 API 키가 설정되지 않았습니다. (SOLAPI_API_KEY, SOLAPI_API_SECRET)"},
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
            )

        # 변수 형식 검증 (본문 + 제목)
        ok, errs = validate_template_variables(t.body, t.subject or "")
        if not ok:
            return Response(
                {"detail": "변수 검증 실패: " + "; ".join(errs)},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # 알림톡 content: 제목 + 본문 (제목이 있으면 첫 줄로)
        content = (t.subject.strip() + "\n" + t.body).strip() if t.subject else t.body

        try:
            result = create_kakao_template(
                api_key=api_key,
                api_secret=api_secret,
                channel_id=pfid,
                name=t.name,
                content=content,
                category_code="TE",
            )
            template_id = result.get("templateId", "")
        except ValueError as e:
            return Response(
                {"detail": str(e)},
                status=status.HTTP_400_BAD_REQUEST,
            )

        t.solapi_template_id = template_id
        t.solapi_status = "PENDING"
        t.save(update_fields=["solapi_template_id", "solapi_status", "updated_at"])

        serializer = MessageTemplateSerializer(t)
        return Response(
            {"detail": "검수 신청이 완료되었습니다. 카카오 검수는 영업일 기준 1~3일 소요됩니다.", "template": serializer.data},
            status=status.HTTP_200_OK,
        )


==========================================================================================
# FILE: management/__init__.py
==========================================================================================
# apps/support/messaging/management


==========================================================================================
# FILE: management/commands/__init__.py
==========================================================================================
# apps/support/messaging/management/commands


==========================================================================================
# FILE: management/commands/copy_master_template.py
==========================================================================================
# apps/support/messaging/management/commands/copy_master_template.py
"""
4단계: 마스터 템플릿을 학원 PFID로 복사하여 검수 신청

선생님이 PFID 연동 후, 현진님 계정의 마스터 템플릿을 해당 학원 PFID로 복사하고
카카오 검수 신청을 넣는 자동화.

사용:
  python manage.py copy_master_template --tenant=academy-code
  python manage.py copy_master_template --tenant=1  # tenant id

환경변수:
  SOLAPI_MASTER_TEMPLATE_ID: 마스터 템플릿 ID (현진님 승인 템플릿)
  SOLAPI_API_KEY, SOLAPI_API_SECRET: Solapi 인증

실제 연동 시 Solapi/Kakao 비즈니스 API에서
- 채널 공유(파트너) 여부 조회
- 템플릿 복사 및 검수 신청
호출을 추가하면 됨. 현재는 스켈레톤 + 로그.
"""
from django.core.management.base import BaseCommand
from django.conf import settings

from apps.core.models import Tenant


class Command(BaseCommand):
    help = "Copy master alimtalk template to tenant PFID and submit for review (skeleton)"

    def add_arguments(self, parser):
        parser.add_argument(
            "--tenant",
            type=str,
            required=True,
            help="Tenant code or id",
        )
        parser.add_argument(
            "--master-template",
            type=str,
            default=None,
            help="Master template ID (default: SOLAPI_MASTER_TEMPLATE_ID env)",
        )

    def handle(self, *args, **options):
        tenant_arg = options["tenant"].strip()
        master_id = options["master_template"] or getattr(
            settings, "SOLAPI_MASTER_TEMPLATE_ID", None
        ) or __import__("os").environ.get("SOLAPI_MASTER_TEMPLATE_ID", "")

        if not master_id:
            self.stdout.write(
                self.style.WARNING("SOLAPI_MASTER_TEMPLATE_ID not set, using placeholder")
            )
            master_id = "MASTER_TEMPLATE_ID"

        # Resolve tenant
        tenant = None
        if tenant_arg.isdigit():
            tenant = Tenant.objects.filter(pk=int(tenant_arg)).first()
        if not tenant:
            tenant = Tenant.objects.filter(code=tenant_arg).first()
        if not tenant:
            self.stderr.write(self.style.ERROR(f"Tenant not found: {tenant_arg}"))
            return 1

        pfid = (tenant.kakao_pfid or "").strip()
        if not pfid:
            self.stderr.write(
                self.style.ERROR(f"Tenant {tenant.code} has no kakao_pfid. Link first.")
            )
            return 1

        self.stdout.write(
            f"Would copy master_template_id={master_id} to tenant={tenant.code} pfid={pfid}"
        )
        self.stdout.write(
            "Implement: 1) Check channel shared (partner). 2) Copy template to PFID. 3) Submit review."
        )
        # TODO: Solapi/Kakao API 호출
        # - 채널 공유 확인
        # - 템플릿 복사 (마스터 → 학원 PFID)
        # - 검수 신청
        self.stdout.write(self.style.SUCCESS("Done (no-op until API wired)"))
        return 0


==========================================================================================
# FILE: migrations/0001_notification_log.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-13 02:02

import django.db.models.deletion
from decimal import Decimal
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("core", "0015_add_tenant_messaging_fields"),
    ]

    operations = [
        migrations.CreateModel(
            name="NotificationLog",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("sent_at", models.DateTimeField(auto_now_add=True, db_index=True)),
                ("success", models.BooleanField(default=False)),
                (
                    "amount_deducted",
                    models.DecimalField(
                        decimal_places=2, default=Decimal("0"), max_digits=10
                    ),
                ),
                (
                    "recipient_summary",
                    models.CharField(blank=True, default="", max_length=500),
                ),
                (
                    "template_summary",
                    models.CharField(blank=True, default="", max_length=255),
                ),
                (
                    "failure_reason",
                    models.CharField(blank=True, default="", max_length=500),
                ),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="notification_logs",
                        to="core.tenant",
                    ),
                ),
            ],
            options={
                "verbose_name": "Notification log",
                "verbose_name_plural": "Notification logs",
                "ordering": ["-sent_at"],
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_message_template.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-13 03:27

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0015_add_tenant_messaging_fields"),
        ("messaging", "0001_notification_log"),
    ]

    operations = [
        migrations.CreateModel(
            name="MessageTemplate",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(help_text="템플릿 이름", max_length=120)),
                (
                    "subject",
                    models.CharField(
                        blank=True, default="", help_text="제목(선택)", max_length=200
                    ),
                ),
                ("body", models.TextField(help_text="본문")),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="message_templates",
                        to="core.tenant",
                    ),
                ),
            ],
            options={
                "verbose_name": "Message template",
                "verbose_name_plural": "Message templates",
                "ordering": ["-updated_at"],
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0003_add_template_category.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-13 04:04

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("messaging", "0002_message_template"),
    ]

    operations = [
        migrations.AddField(
            model_name="messagetemplate",
            name="category",
            field=models.CharField(
                choices=[
                    ("default", "기본"),
                    ("lecture", "강의"),
                    ("clinic", "클리닉"),
                ],
                db_index=True,
                default="default",
                max_length=20,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0004_message_template_solapi_fields.py
==========================================================================================
# Generated migration: MessageTemplate solapi_template_id, solapi_status

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("messaging", "0003_add_template_category"),
    ]

    operations = [
        migrations.AddField(
            model_name="messagetemplate",
            name="solapi_template_id",
            field=models.CharField(blank=True, default="", max_length=100),
        ),
        migrations.AddField(
            model_name="messagetemplate",
            name="solapi_status",
            field=models.CharField(
                blank=True,
                default="",
                max_length=20,
                choices=[
                    ("", "미신청"),
                    ("PENDING", "검수 대기"),
                    ("APPROVED", "승인"),
                    ("REJECTED", "반려"),
                ],
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================

