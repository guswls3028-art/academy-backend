====================================================================================================
# BACKEND APP: domains__exams
# ROOT PATH: C:\academy\apps\domains\exams
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ExamsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.exams"
    label = "exams"


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/exams/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views.exam_view import ExamViewSet
from .views.sheet_view import SheetViewSet
from .views.question_view import QuestionViewSet
from .views.answer_key_view import AnswerKeyViewSet

from .views.exam_asset_view import ExamAssetView
from .views.exam_questions_by_exam_view import ExamQuestionsByExamView
from .views.template_builder_view import TemplateBuilderView
from .views.template_editor_view import TemplateEditorView
from .views.template_status_view import TemplateStatusView
from .views.template_validation_view import TemplateValidationView
from .views.regular_from_template_view import RegularExamFromTemplateView
from .views.omr_generate_view import GenerateOMRSheetAssetView
from .views.exam_enrollment_view import ExamEnrollmentManageView
from .views.student_exam_view import StudentAvailableExamListView
from .views.question_auto_view import SheetAutoQuestionsView

router = DefaultRouter()
router.register(r"", ExamViewSet, basename="exams")
router.register(r"sheets", SheetViewSet, basename="sheets")
router.register(r"questions", QuestionViewSet, basename="questions")
router.register(r"answer-keys", AnswerKeyViewSet, basename="answer-keys")

urlpatterns = [
    # =========================
    # Student
    # =========================
    path("me/available/", StudentAvailableExamListView.as_view(), name="student-available-exams"),

    # =========================
    # Exam Assets / Questions (resolve template)
    # =========================
    path("<int:exam_id>/assets/", ExamAssetView.as_view(), name="exam-assets"),
    path("<int:exam_id>/questions/", ExamQuestionsByExamView.as_view(), name="exam-questions-by-exam"),

    # =========================
    # Template utilities
    # =========================
    path("<int:exam_id>/builder/", TemplateBuilderView.as_view(), name="template-builder"),
    path("<int:exam_id>/template-editor/", TemplateEditorView.as_view(), name="template-editor"),
    path("<int:exam_id>/template-status/", TemplateStatusView.as_view(), name="template-status"),
    path("<int:exam_id>/template-validation/", TemplateValidationView.as_view(), name="template-validation"),

    # =========================
    # Template -> Regular spawn
    # =========================
    path("<int:exam_id>/spawn-regular/", RegularExamFromTemplateView.as_view(), name="spawn-regular-from-template"),

    # =========================
    # OMR sheet generate (template only)
    # =========================
    path("<int:exam_id>/generate-omr/", GenerateOMRSheetAssetView.as_view(), name="generate-omr-sheet"),

    # =========================
    # Exam Enrollment manage
    # =========================
    path("<int:exam_id>/enrollments/", ExamEnrollmentManageView.as_view(), name="exam-enrollments"),

    # =========================
    # Sheet auto questions (segmentation result)
    # =========================
    path("sheets/<int:sheet_id>/auto-questions/", SheetAutoQuestionsView.as_view(), name="sheet-auto-questions"),

    # Router
    path("", include(router.urls)),
]


==========================================================================================
# FILE: dto/omr_blueprint.py
==========================================================================================
# apps/domains/exams/dto/omr_blueprint.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Literal, List, Dict, Any, Optional


Axis = Literal["x", "y"]
Choice = Literal["A", "B", "C", "D", "E"]


@dataclass(frozen=True)
class Point:
    x: float
    y: float


@dataclass(frozen=True)
class ROI:
    x: float
    y: float
    w: float
    h: float


@dataclass(frozen=True)
class Bubble:
    choice: Choice
    center: Point
    radius: float


@dataclass(frozen=True)
class QuestionBlueprint:
    question_number: int
    axis: Axis
    roi: ROI
    choices: List[Bubble]


@dataclass(frozen=True)
class IdentifierDigitBlueprint:
    digit: int
    bubbles: List[Dict[str, Any]]  # ê³„ì•½ì€ assets/meta ìª½ì´ ì´ë¯¸ ìˆìœ¼ë‹ˆ ëŠìŠ¨í•˜ê²Œ


@dataclass(frozen=True)
class OMRBlueprint:
    version: Literal["objective_v1"]
    units: Literal["mm"]
    question_count: int
    page: Dict[str, Any]
    identifier: Optional[Dict[str, Any]]
    questions: List[QuestionBlueprint]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "version": self.version,
            "units": self.units,
            "question_count": self.question_count,
            "page": self.page,
            "identifier": self.identifier,
            "questions": [
                {
                    "question_number": q.question_number,
                    "axis": q.axis,
                    "roi": {"x": q.roi.x, "y": q.roi.y, "w": q.roi.w, "h": q.roi.h},
                    "choices": [
                        {
                            "choice": b.choice,
                            "center": {"x": b.center.x, "y": b.center.y},
                            "radius": b.radius,
                        }
                        for b in q.choices
                    ],
                }
                for q in self.questions
            ],
        }


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 02:52

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Exam",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                ("description", models.TextField(blank=True)),
                ("subject", models.CharField(max_length=100)),
                ("exam_type", models.CharField(default="regular", max_length=50)),
                ("is_active", models.BooleanField(default=True)),
            ],
            options={
                "db_table": "exams_exam",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="AnswerKey",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("answers", models.JSONField()),
                (
                    "exam",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="answer_key",
                        to="exams.exam",
                    ),
                ),
            ],
            options={
                "db_table": "exams_answer_key",
            },
        ),
        migrations.CreateModel(
            name="Sheet",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("name", models.CharField(max_length=50)),
                ("total_questions", models.PositiveIntegerField(default=0)),
                (
                    "file",
                    models.FileField(blank=True, null=True, upload_to="exams/sheets/"),
                ),
                (
                    "exam",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="sheets",
                        to="exams.exam",
                    ),
                ),
            ],
            options={
                "db_table": "exams_sheet",
                "unique_together": {("exam", "name")},
            },
        ),
        migrations.CreateModel(
            name="ExamQuestion",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("number", models.PositiveIntegerField()),
                ("score", models.FloatField(default=1.0)),
                (
                    "image",
                    models.ImageField(
                        blank=True, null=True, upload_to="exams/questions/"
                    ),
                ),
                (
                    "sheet",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="questions",
                        to="exams.sheet",
                    ),
                ),
            ],
            options={
                "db_table": "exams_question",
                "ordering": ["number"],
                "unique_together": {("sheet", "number")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_exam_policy_and_assets.py
==========================================================================================
# apps/domains/exams/migrations/0002_exam_policy_and_assets.py
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ("exams", "0001_initial"),
    ]

    operations = [
        # ==============================
        # âœ… Exam ì •ì±… í•„ë“œ ì¶”ê°€
        # ==============================
        migrations.AddField(
            model_name="exam",
            name="allow_retake",
            field=models.BooleanField(default=False),
        ),
        migrations.AddField(
            model_name="exam",
            name="max_attempts",
            field=models.PositiveIntegerField(default=1),
        ),
        migrations.AddField(
            model_name="exam",
            name="pass_score",
            field=models.FloatField(default=0.0),
        ),
        migrations.AddField(
            model_name="exam",
            name="open_at",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name="exam",
            name="close_at",
            field=models.DateTimeField(blank=True, null=True),
        ),

        # ==============================
        # âœ… ExamAsset ì‹ ê·œ í…Œì´ë¸”
        # ==============================
        migrations.CreateModel(
            name="ExamAsset",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),

                ("asset_type", models.CharField(max_length=30)),
                ("file_key", models.CharField(max_length=512)),
                ("file_type", models.CharField(blank=True, max_length=50, null=True)),
                ("file_size", models.PositiveIntegerField(blank=True, null=True)),
                (
                    "exam",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="assets",
                        to="exams.exam",
                    ),
                ),
            ],
            options={
                "db_table": "exams_exam_asset",
            },
        ),
        migrations.AddIndex(
            model_name="examasset",
            index=models.Index(fields=["exam", "asset_type"], name="exams_examasset_exam_asset_type_idx"),
        ),
        migrations.AlterUniqueTogether(
            name="examasset",
            unique_together={("exam", "asset_type")},
        ),
    ]


==========================================================================================
# FILE: migrations/0003_rename_exams_examasset_exam_asset_type_idx_exams_exam__exam_id_1b856d_idx_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 11:53

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("exams", "0002_exam_policy_and_assets"),
    ]

    operations = [
        migrations.RenameIndex(
            model_name="examasset",
            new_name="exams_exam__exam_id_1b856d_idx",
            old_name="exams_examasset_exam_asset_type_idx",
        ),
        migrations.AddField(
            model_name="examquestion",
            name="region_meta",
            field=models.JSONField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name="examasset",
            name="asset_type",
            field=models.CharField(
                choices=[("problem_pdf", "Problem PDF"), ("omr_sheet", "OMR Sheet")],
                max_length=30,
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0004_exam_sessions_alter_answerkey_answers.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-13 03:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        (
            "exams",
            "0003_rename_exams_examasset_exam_asset_type_idx_exams_exam__exam_id_1b856d_idx_and_more",
        ),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.AddField(
            model_name="exam",
            name="sessions",
            field=models.ManyToManyField(
                blank=True,
                help_text="ì´ ì‹œí—˜ì´ ì†í•œ ì°¨ì‹œë“¤",
                related_name="exams",
                to="lectures.session",
            ),
        ),
        migrations.AlterField(
            model_name="answerkey",
            name="answers",
            field=models.JSONField(
                help_text="key=ExamQuestion.id (string), value=correct answer"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0005_examenrollment.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-23 08:42

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("enrollment", "0001_initial"),
        ("exams", "0004_exam_sessions_alter_answerkey_answers"),
    ]

    operations = [
        migrations.CreateModel(
            name="ExamEnrollment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="exam_enrollments",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "exam",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="exam_enrollments",
                        to="exams.exam",
                    ),
                ),
            ],
            options={
                "db_table": "exams_exam_enrollment",
                "unique_together": {("exam", "enrollment")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0006_alter_sheet_unique_together_exam_template_exam_and_more.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-29 17:06

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("exams", "0005_examenrollment"),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.AlterUniqueTogether(
            name="sheet",
            unique_together=set(),
        ),
        migrations.AddField(
            model_name="exam",
            name="template_exam",
            field=models.ForeignKey(
                blank=True,
                help_text="regular ì‹œí—˜ì´ ì°¸ì¡°í•˜ëŠ” template ì‹œí—˜",
                null=True,
                on_delete=django.db.models.deletion.PROTECT,
                related_name="derived_exams",
                to="exams.exam",
            ),
        ),
        migrations.AlterField(
            model_name="exam",
            name="exam_type",
            field=models.CharField(
                choices=[("template", "Template"), ("regular", "Regular")],
                default="regular",
                max_length=50,
            ),
        ),
        migrations.AlterField(
            model_name="sheet",
            name="exam",
            field=models.OneToOneField(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="sheet",
                to="exams.exam",
            ),
        ),
        migrations.AlterField(
            model_name="sheet",
            name="name",
            field=models.CharField(default="MAIN", max_length=50),
        ),
        migrations.AddConstraint(
            model_name="exam",
            constraint=models.CheckConstraint(
                condition=models.Q(
                    models.Q(("exam_type", "template"), _negated=True),
                    ("template_exam__isnull", True),
                    _connector="OR",
                ),
                name="exams_exam_template_has_no_template_exam",
            ),
        ),
        migrations.AddConstraint(
            model_name="exam",
            constraint=models.CheckConstraint(
                condition=models.Q(
                    models.Q(("exam_type", "regular"), _negated=True),
                    ("template_exam__isnull", False),
                    _connector="OR",
                ),
                name="exams_exam_regular_requires_template_exam",
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/exams/models/__init__.py
from .exam import Exam
from .sheet import Sheet
from .question import ExamQuestion
from .answer_key import AnswerKey
from .exam_asset import ExamAsset
from .exam_enrollment import ExamEnrollment

__all__ = [
    "Exam",
    "Sheet",
    "ExamQuestion",
    "AnswerKey",
    "ExamAsset",
    "ExamEnrollment",
]


==========================================================================================
# FILE: models/answer_key.py
==========================================================================================
# PATH: apps/domains/exams/models/answer_key.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import BaseModel
from .exam import Exam


class AnswerKey(BaseModel):
    """
    AnswerKey

    âœ… ë‹¨ì¼ ì§„ì‹¤:
    - template examì—ë§Œ ì¡´ì¬
    - regular examì—ì„œëŠ” template_examì„ í†µí•´ resolve
    """

    exam = models.OneToOneField(
        Exam,
        on_delete=models.CASCADE,
        related_name="answer_key",
    )

    answers = models.JSONField(
        help_text="key=ExamQuestion.id (string), value=correct answer"
    )

    class Meta:
        db_table = "exams_answer_key"

    def __str__(self) -> str:
        return f"AnswerKey for template exam {self.exam_id}"


==========================================================================================
# FILE: models/exam.py
==========================================================================================
# PATH: apps/domains/exams/models/exam.py
from __future__ import annotations

from django.db import models
from django.db.models import Q
from apps.api.common.models import BaseModel
from apps.domains.lectures.models import Session


class Exam(BaseModel):
    """
    Exam

    âœ… í™•ì • ì •ì±…
    - exam_type="template": ì–‘ì‹ ì „ìš© (ì‘ì‹œ/ì œì¶œ/ê²°ê³¼/ëŒ€ìƒì âŒ)
    - exam_type="regular" : ìš´ì˜ ì‹œí—˜ (ë°˜ë“œì‹œ template_exam ê¸°ë°˜)

    âœ… í•µì‹¬
    - ì‹œí—˜ì˜ ì •ì²´ì„±ì€ exam.id
    - ê°™ì€ ì‹œí—˜(regular)ì„ ì—¬ëŸ¬ ì„¸ì…˜ì— ë¶™ì—¬ ì¬ì‚¬ìš© ê°€ëŠ¥ (N:M)
    - Sheet/Question/AnswerKey/AssetëŠ” template_examì´ ë‹¨ì¼ ì§„ì‹¤
    """

    class ExamType(models.TextChoices):
        TEMPLATE = "template", "Template"
        REGULAR = "regular", "Regular"

    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    subject = models.CharField(max_length=100)

    exam_type = models.CharField(
        max_length=50,
        choices=ExamType.choices,
        default=ExamType.REGULAR,
    )
    is_active = models.BooleanField(default=True)

    # ===============================
    # ğŸ”¥ Session : Exam = N:M
    # ===============================
    sessions = models.ManyToManyField(
        Session,
        related_name="exams",
        blank=True,
        help_text="ì´ ì‹œí—˜ì´ ì†í•œ ì°¨ì‹œë“¤",
    )

    # ===============================
    # ğŸ”¥ Template binding (ë‹¨ì¼ ì§„ì‹¤)
    # ===============================
    template_exam = models.ForeignKey(
        "self",
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="derived_exams",
        help_text="regular ì‹œí—˜ì´ ì°¸ì¡°í•˜ëŠ” template ì‹œí—˜",
    )

    allow_retake = models.BooleanField(default=False)
    max_attempts = models.PositiveIntegerField(default=1)
    pass_score = models.FloatField(default=0.0)

    open_at = models.DateTimeField(null=True, blank=True)
    close_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "exams_exam"
        ordering = ["-created_at"]
        constraints = [
            # templateëŠ” template_examì„ ê°€ì§ˆ ìˆ˜ ì—†ìŒ
            models.CheckConstraint(
                name="exams_exam_template_has_no_template_exam",
                check=~Q(exam_type="template") | Q(template_exam__isnull=True),
            ),
            # regularì€ template_examì´ ë°˜ë“œì‹œ í•„ìš”
            models.CheckConstraint(
                name="exams_exam_regular_requires_template_exam",
                check=~Q(exam_type="regular") | Q(template_exam__isnull=False),
            ),
        ]

    def __str__(self) -> str:
        return self.title

    @property
    def effective_template_exam_id(self) -> int:
        """
        âœ… ë‹¨ì¼ ì§„ì‹¤ resolver
        - templateì´ë©´ ìê¸° ìì‹ 
        - regularì´ë©´ template_exam
        """
        if self.exam_type == self.ExamType.TEMPLATE:
            return int(self.id)
        return int(self.template_exam_id)

    def assert_template(self):
        if self.exam_type != self.ExamType.TEMPLATE:
            raise ValueError("This operation is allowed only for template exams.")

    def assert_regular(self):
        if self.exam_type != self.ExamType.REGULAR:
            raise ValueError("This operation is allowed only for regular exams.")


==========================================================================================
# FILE: models/exam_asset.py
==========================================================================================
# apps/domains/exams/models/exam_asset.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import BaseModel


class ExamAsset(BaseModel):
    """
    ì‹œí—˜ ë°°í¬ìš© íŒŒì¼ ìì‚° (R2 ê¸°ë°˜)

    âœ… ì±…ì„:
    - ë¬¸ì œ PDF / OMR ë‹µì•ˆì§€ ë“± "ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥í•œ íŒŒì¼"ë§Œ ê´€ë¦¬
    - ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ URLì€ serializerì—ì„œ presigned GETìœ¼ë¡œ ì œê³µ

    âš ï¸ ìš´ì˜ ê·œì¹™:
    - exam + asset_typeëŠ” 1ê°œë§Œ ìœ ì§€(update_or_create)
      â†’ teacherê°€ ìµœì‹  íŒŒì¼ë¡œ êµì²´í•´ë„ ì‹ë³„ì€ ë™ì¼
    """

    class AssetType(models.TextChoices):
        PROBLEM_PDF = "problem_pdf", "Problem PDF"
        OMR_SHEET = "omr_sheet", "OMR Sheet"

    exam = models.ForeignKey(
        "exams.Exam",
        on_delete=models.CASCADE,
        related_name="assets",
    )

    asset_type = models.CharField(
        max_length=30,
        choices=AssetType.choices,
    )

    # âœ… R2
    file_key = models.CharField(max_length=512)
    file_type = models.CharField(max_length=50, null=True, blank=True)
    file_size = models.PositiveIntegerField(null=True, blank=True)

    class Meta:
        db_table = "exams_exam_asset"
        unique_together = ("exam", "asset_type")
        indexes = [
            models.Index(fields=["exam", "asset_type"]),
        ]

    def __str__(self):
        return f"{self.exam_id}:{self.asset_type}"


==========================================================================================
# FILE: models/exam_enrollment.py
==========================================================================================
# PATH: apps/domains/exams/models/exam_enrollment.py

from __future__ import annotations

from django.db import models


class ExamEnrollment(models.Model):
    """
    ExamEnrollment
    - ì‹œí—˜(Exam) ì‘ì‹œ ëŒ€ìƒì ì—”í‹°í‹°
    - ì„¸ì…˜ ë“±ë¡(SessionEnrollment)ì˜ ë¶€ë¶„ì§‘í•©ë§Œ ê°€ëŠ¥
    - "ì‹œí—˜ë§ˆë‹¤ ì‘ì‹œìƒì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ"ì„ ì§€ì›í•˜ê¸° ìœ„í•œ êµ¬ì¡°

    âœ… ë‹¨ì¼ ì§„ì‹¤:
    - ìˆ˜ê°•ìƒ/ì„¸ì…˜ ë“±ë¡: SessionEnrollment
    - ì‹œí—˜ ì‘ì‹œ ëŒ€ìƒì: ExamEnrollment
    """

    exam = models.ForeignKey(
        "exams.Exam",
        on_delete=models.CASCADE,
        related_name="exam_enrollments",
    )

    enrollment = models.ForeignKey(
        "enrollment.Enrollment",
        on_delete=models.CASCADE,
        related_name="exam_enrollments",
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "exams_exam_enrollment"
        unique_together = [("exam", "enrollment")]

    def __str__(self) -> str:
        return f"ExamEnrollment(exam={self.exam_id}, enrollment={self.enrollment_id})"


==========================================================================================
# FILE: models/question.py
==========================================================================================
# apps/domains/exams/models/question.py
from django.db import models
from apps.api.common.models import BaseModel
from .sheet import Sheet


class ExamQuestion(BaseModel):
    """
    ì‹œí—˜ ë¬¸í•­ ì •ì˜

    ì„¤ê³„ ì›ì¹™:
    - ë¬¸í•­ì˜ 'ì˜ë¯¸'ëŠ” numberë¡œë§Œ ì‹ë³„
    - ì±„ì /ì •ë‹µ ì—¬ë¶€/ì ìˆ˜ ê³„ì‚° âŒ (results ë„ë©”ì¸ ì±…ì„)
    - ì´ ëª¨ë¸ì€ "ì‹œí—˜ì§€ ìœ„ì˜ ë¬¸í•­ ìœ„ì¹˜ + ì ìˆ˜ ë‹¨ìœ„"ë§Œ ê´€ë¦¬

    region_meta:
    - OMR / Vision Workerê°€ ì œê³µí•œ ë¬¸í•­ ì˜ì—­ ì •ë³´
    - ì˜ˆ: {"x": 12, "y": 34, "w": 120, "h": 45}
    - ì¬ì±„ì  / ì˜¤ë‹µë…¸íŠ¸ / ë¬¸í•­ í•˜ì´ë¼ì´íŠ¸ì— í•„ìˆ˜
    """

    sheet = models.ForeignKey(
        Sheet,
        on_delete=models.CASCADE,
        related_name="questions",
    )

    number = models.PositiveIntegerField()  # 1ë²ˆ, 2ë²ˆ ...
    score = models.FloatField(default=1.0)

    # ë¬¸í•­ ì´ë¯¸ì§€ (AIë¡œ ì˜ë¼ë‚¸ ê²°ê³¼ í¬í•¨ ê°€ëŠ¥)
    image = models.ImageField(
        upload_to="exams/questions/",
        null=True,
        blank=True,
    )

    # ğŸ”¥ STEP 2 í•„ìˆ˜: ë¬¸í•­ ì˜ì—­ ë©”íƒ€ (bbox)
    # worker segmentation ê²°ê³¼ë¥¼ ê·¸ëŒ€ë¡œ ì €ì¥
    # í˜•ì‹ ì˜ˆ: {"x": 10, "y": 20, "w": 100, "h": 40}
    region_meta = models.JSONField(
        null=True,
        blank=True,
    )

    class Meta:
        db_table = "exams_question"
        unique_together = ("sheet", "number")
        ordering = ["number"]

    def __str__(self):
        return f"{self.sheet} Q{self.number}"


==========================================================================================
# FILE: models/sheet.py
==========================================================================================
# PATH: apps/domains/exams/models/sheet.py
from __future__ import annotations

from django.db import models
from apps.api.common.models import BaseModel
from .exam import Exam


class Sheet(BaseModel):
    """
    Sheet

    âœ… í™•ì • ì •ì±…
    - SheetëŠ” template examì—ë§Œ ê·€ì†ëœë‹¤ (ë‹¨ì¼ ì§„ì‹¤)
    - 1 Exam : 1 Sheet (OneToOne)
    - regular examì€ sheetë¥¼ ì§ì ‘ ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤ (templateì„ í†µí•´ resolve)
    """

    exam = models.OneToOneField(
        Exam,
        on_delete=models.CASCADE,
        related_name="sheet",
    )

    name = models.CharField(max_length=50, default="MAIN")

    total_questions = models.PositiveIntegerField(default=0)

    file = models.FileField(
        upload_to="exams/sheets/",
        null=True,
        blank=True,
    )

    class Meta:
        db_table = "exams_sheet"

    def __str__(self) -> str:
        return f"{self.exam.title} - {self.name}"


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
# apps/domains/exams/serializers/__init__.py
# intentionally empty (avoid side-effect imports)


==========================================================================================
# FILE: serializers/answer_key.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import AnswerKey

class AnswerKeySerializer(serializers.ModelSerializer):
    def validate_answers(self, value):
        if not isinstance(value, dict):
            raise serializers.ValidationError("answers must be an object")

        normalized = {}
        for k, v in value.items():
            normalized[str(k)] = str(v).strip()

        return normalized

    class Meta:
        model = AnswerKey
        fields = [
            "id",
            "exam",
            "answers",
            "created_at",
            "updated_at",
        ]


==========================================================================================
# FILE: serializers/exam.py
==========================================================================================
# apps/domains/exams/serializers/exam.py
from rest_framework import serializers
from apps.domains.exams.models import Exam


class ExamSerializer(serializers.ModelSerializer):
    
    # ê³¼ëª© ìë™ìœ¼ë¡œ ì…ë ¥ë˜ê²Œ.
    subject = serializers.CharField(read_only=True)

    """
    âœ… Exam ì¡°íšŒ/ìˆ˜ì • serializer

    í”„ë¡ íŠ¸ì—ì„œ:
    - allow_retake / max_attempts / pass_scoreë¡œ ì¬ì‹œí—˜ ì •ì±… í‘œì‹œ/í† ê¸€
    - open_at / close_atë¡œ ì‹œí—˜ ê³µê°œ/ë§ˆê° UX êµ¬í˜„
    """

    class Meta:
        model = Exam
        fields = [
            "id",
            "title",
            "description",
            "subject",
            "exam_type",
            "is_active",
            # âœ… STEP 1/3
            "allow_retake",
            "max_attempts",
            "pass_score",
            "open_at",
            "close_at",
            
            "created_at",
            "updated_at",
        ]


==========================================================================================
# FILE: serializers/exam_asset.py
==========================================================================================
# apps/domains/exams/serializers/exam_asset.py
from __future__ import annotations

from rest_framework import serializers

from apps.domains.exams.models import ExamAsset
from apps.infrastructure.storage.r2 import generate_presigned_get_url


class ExamAssetSerializer(serializers.ModelSerializer):
    """
    âœ… ExamAsset ì‘ë‹µ serializer

    download_url:
    - R2 presigned GET URL
    - expires_inì€ ì§§ê²Œ (ë³´í†µ 1ì‹œê°„) ê¶Œì¥
    """

    download_url = serializers.SerializerMethodField()

    class Meta:
        model = ExamAsset
        fields = [
            "id",
            "exam",
            "asset_type",
            "file_key",
            "file_type",
            "file_size",
            "download_url",
            "created_at",
            "updated_at",
        ]
        # ì—…ë¡œë“œëŠ” Viewì—ì„œ ì²˜ë¦¬í•˜ê³  DB í•„ë“œëŠ” ì„œë²„ê°€ í™•ì •í•˜ëŠ” ë°©ì‹(ì •ì„)
        read_only_fields = ["file_key", "file_type", "file_size", "download_url"]

    def get_download_url(self, obj: ExamAsset) -> str:
        return generate_presigned_get_url(key=obj.file_key, expires_in=60 * 60)


==========================================================================================
# FILE: serializers/exam_create.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import Exam


class ExamCreateSerializer(serializers.ModelSerializer):
    """
    ìƒì„± ì „ìš© serializer (Production Grade)

    ì •ì±…:
    - template:
        - subject í•„ìˆ˜
    - regular:
        - subject ì…ë ¥ ê¸ˆì§€ (templateì—ì„œ ìë™ ë³µì‚¬)
    """

    # ğŸ”¥ í•µì‹¬ ìˆ˜ì •
    subject = serializers.CharField(
        required=False,
        allow_blank=True,
    )

    class Meta:
        model = Exam
        fields = [
            "title",
            "description",
            "subject",
            "exam_type",
        ]

    def validate_exam_type(self, value):
        if value not in {Exam.ExamType.TEMPLATE, Exam.ExamType.REGULAR}:
            raise serializers.ValidationError("invalid exam_type")
        return value

    def validate(self, attrs):
        exam_type = attrs.get("exam_type")
        subject = attrs.get("subject")

        # âœ… TEMPLATE
        if exam_type == Exam.ExamType.TEMPLATE:
            if not subject:
                raise serializers.ValidationError(
                    {"subject": "subject is required for template exam"}
                )

        # âœ… REGULAR
        if exam_type == Exam.ExamType.REGULAR:
            if subject:
                raise serializers.ValidationError(
                    {"subject": "regular exam must not set subject"}
                )

        return attrs


==========================================================================================
# FILE: serializers/exam_enrollment_serializer.py
==========================================================================================
# PATH: apps/domains/exams/serializers/exam_enrollment_serializer.py

from __future__ import annotations

from rest_framework import serializers


class ExamEnrollmentRowSerializer(serializers.Serializer):
    """
    GET ì‘ë‹µ row (UI í¸ì˜ë¥¼ ìœ„í•´ is_selected í¬í•¨)
    """
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField(allow_blank=True)
    is_selected = serializers.BooleanField()


class ExamEnrollmentUpdateSerializer(serializers.Serializer):
    """
    PUT ìš”ì²­ payload
    """
    enrollment_ids = serializers.ListField(
        child=serializers.IntegerField(),
        allow_empty=True,
        required=True,
    )


==========================================================================================
# FILE: serializers/exam_list_student.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import Exam


class StudentExamListSerializer(serializers.ModelSerializer):
    """
    í•™ìƒ ë…¸ì¶œìš© ì‹œí—˜ serializer
    """

    class Meta:
        model = Exam
        fields = [
            "id",
            "title",
            "description",
            "open_at",
            "close_at",
        ]


==========================================================================================
# FILE: serializers/exam_update.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import Exam


class ExamUpdateSerializer(serializers.ModelSerializer):
    """
    ìˆ˜ì • ì „ìš© serializer

    í•µì‹¬ ë´‰ì¸:
    - exam_type ë³€ê²½ âŒ
    - template_exam ë³€ê²½ âŒ
    - subject ë³€ê²½ âŒ
    """

    class Meta:
        model = Exam
        fields = [
            "title",
            "description",
            "is_active",
            "allow_retake",
            "max_attempts",
            "pass_score",
            "open_at",
            "close_at",
        ]

    def validate(self, attrs):
        exam: Exam = self.instance

        if exam.exam_type == Exam.ExamType.TEMPLATE:
            # í…œí”Œë¦¿ì€ êµ¬ì¡°/ì •ì±… ì •ì˜ê¹Œì§€ë§Œ í—ˆìš©
            # (ì˜ë¯¸ìƒ open/closeê°€ ìˆì–´ë„, ì‹¤ì œ ë™ì‘ì€ regularì—ì„œë§Œ)
            return attrs

        return attrs


==========================================================================================
# FILE: serializers/question.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import ExamQuestion


class QuestionSerializer(serializers.ModelSerializer):
    """
    ğŸ”§ PATCH:
    - ExamQuestion.region_meta(bbox)ê°€ ì´ë¯¸ ëª¨ë¸/ì„œë¹„ìŠ¤ì—ì„œ ì €ì¥ë˜ëŠ”ë°
      serializerì—ì„œ ëˆ„ë½ë˜ë©´ í”„ë¡ íŠ¸ì—ì„œ í•˜ì´ë¼ì´íŠ¸/ì˜¤ë‹µë…¸íŠ¸ ì˜ì—­í‘œì‹œ ë¶ˆê°€.
    """

    class Meta:
        model = ExamQuestion
        fields = [
            "id",
            "sheet",
            "number",
            "score",
            "image",
            "region_meta",  # âœ… ì¶”ê°€
            "created_at",
            "updated_at",
        ]


==========================================================================================
# FILE: serializers/question_auto.py
==========================================================================================
# apps/domains/exams/serializers/question_auto.py
from __future__ import annotations

from rest_framework import serializers


class QuestionAutoCreateSerializer(serializers.Serializer):
    """
    worker segmentation ê²°ê³¼ boxesë¥¼ ê·¸ëŒ€ë¡œ ë°›ëŠ”ë‹¤.
    boxes: [[x,y,w,h], ...]
    """
    boxes = serializers.ListField(
        child=serializers.ListField(
            child=serializers.IntegerField(),
            min_length=4,
            max_length=4,
        ),
        allow_empty=False,
    )

    def validate_boxes(self, v):
        # x,y,w,h ëª¨ë‘ 0 ì´ìƒ, w/hëŠ” 1 ì´ìƒ
        out = []
        for row in v:
            x, y, w, h = row
            if x < 0 or y < 0 or w <= 0 or h <= 0:
                raise serializers.ValidationError("Each box must be [x>=0, y>=0, w>0, h>0].")
            out.append([int(x), int(y), int(w), int(h)])
        return out


==========================================================================================
# FILE: serializers/sheet.py
==========================================================================================
from rest_framework import serializers
from apps.domains.exams.models import Sheet

class SheetSerializer(serializers.ModelSerializer):
    class Meta:
        model = Sheet
        fields = [
            "id",
            "exam",
            "name",
            "total_questions",
            "file",
            "created_at",
            "updated_at",
        ]


==========================================================================================
# FILE: serializers/template_builder.py
==========================================================================================
# PATH: apps/domains/exams/serializers/template_builder.py
from rest_framework import serializers


class TemplateBuilderResultSerializer(serializers.Serializer):
    """
    Template Builder ê²°ê³¼ ê³„ì•½

    í”„ë¡ íŠ¸ ë³´ì¥:
    - sheet_id / answer_key_idëŠ” í•­ìƒ ì¡´ì¬
    """
    exam_id = serializers.IntegerField()
    sheet_id = serializers.IntegerField()
    answer_key_id = serializers.IntegerField()
    total_questions = serializers.IntegerField()


==========================================================================================
# FILE: serializers/template_editor.py
==========================================================================================
# PATH: apps/domains/exams/serializers/template_editor.py
from __future__ import annotations

from rest_framework import serializers


class TemplateEditorSummarySerializer(serializers.Serializer):
    """
    í…œí”Œë¦¿ í¸ì§‘ í™”ë©´ ì´ˆê¸° ë¡œë”©ìš© ìš”ì•½ ì •ë³´

    í”„ë¡ íŠ¸ ë³´ì¥:
    - ì´ ì‘ë‹µë§Œìœ¼ë¡œ í…œí”Œë¦¿ í¸ì§‘ í™”ë©´ êµ¬ì„± ê°€ëŠ¥
    """
    exam_id = serializers.IntegerField()
    title = serializers.CharField()
    subject = serializers.CharField()

    sheet_id = serializers.IntegerField()
    total_questions = serializers.IntegerField()

    has_answer_key = serializers.BooleanField()
    is_locked = serializers.BooleanField()  # derived regular ì¡´ì¬ ì—¬ë¶€


==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/omr_blueprint_builder.py
==========================================================================================
# apps/domains/exams/services/omr_blueprint_builder.py
from __future__ import annotations

from typing import Any, Dict, Optional

from apps.domains.exams.dto.omr_blueprint import OMRBlueprint, QuestionBlueprint, ROI, Bubble, Point

# âœ… IMPORTANT
# OMR Objective v1ì˜ "ë ˆì´ì•„ì›ƒ/ì¢Œí‘œ"ëŠ” assets ë„ë©”ì¸ì´ SSOT.
# examsëŠ” "í…œí”Œë¦¿ì´ ì–´ë–¤ ê·œê²©ì„ ì“°ëŠ”ì§€"ë§Œ ê²°ì •í•˜ê³ ,
# ì‹¤ì œ metaëŠ” assetsì˜ /api/v1/assets/omr/objective/meta/ ì—ì„œ ê°€ì ¸ì˜¨ë‹¤.
#
# ë”°ë¼ì„œ exams ìª½ BlueprintëŠ” "assets metaë¥¼ proxy/ìºì‹±í•´ì„œ ì œê³µ"í•˜ê±°ë‚˜,
# ì‹œí—˜ í…œí”Œë¦¿ì—ì„œ "question_countë¥¼ í™•ì •"í•˜ì—¬ í”„ë¡ íŠ¸/ì„œë¸Œë¯¸ì…˜ì—ì„œ ì°¸ì¡°í•˜ë„ë¡ í•œë‹¤.


class OMRBlueprintBuilder:
    """
    - exams í…œí”Œë¦¿ì˜ question_count ê¸°ì¤€ìœ¼ë¡œ
      assets meta(JSON)ë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•˜ê±°ë‚˜, í•„ìš”í•œ ìµœì†Œ í•„ë“œë§Œ normalize.
    """

    def __init__(self, fetch_assets_meta_fn):
        """
        fetch_assets_meta_fn(question_count:int) -> dict
        - ì™¸ë¶€ ì˜ì¡´ì„ ì£¼ì…í•´ì„œ í…ŒìŠ¤íŠ¸/ë„ë©”ì¸ ë¶„ë¦¬ë¥¼ ìœ ì§€
        """
        self._fetch = fetch_assets_meta_fn

    def build_from_assets_meta(self, *, question_count: int) -> Dict[str, Any]:
        meta = self._fetch(int(question_count))
        if not isinstance(meta, dict) or meta.get("version") != "objective_v1":
            raise ValueError("Invalid OMR meta from assets")
        return meta

    def build_strict(self, *, question_count: int) -> OMRBlueprint:
        """
        (ì„ íƒ) metaë¥¼ DTOë¡œ ì—„ê²© ë³€í™˜.
        ì§€ê¸ˆì€ assets meta ê³„ì•½ì„ ì‹ ë¢°í•˜ëŠ” êµ¬ì¡°ë¼ strictëŠ” ë³´ì¡°ìš©.
        """
        meta = self.build_from_assets_meta(question_count=question_count)
        qs = []
        for q in meta.get("questions", []) or []:
            choices = []
            for c in q.get("choices", []) or []:
                choices.append(
                    Bubble(
                        choice=c["choice"],
                        center=Point(x=float(c["center"]["x"]), y=float(c["center"]["y"])),
                        radius=float(c["radius"]),
                    )
                )
            qs.append(
                QuestionBlueprint(
                    question_number=int(q["question_number"]),
                    axis=q["axis"],
                    roi=ROI(
                        x=float(q["roi"]["x"]),
                        y=float(q["roi"]["y"]),
                        w=float(q["roi"]["w"]),
                        h=float(q["roi"]["h"]),
                    ),
                    choices=choices,
                )
            )

        return OMRBlueprint(
            version="objective_v1",
            units="mm",
            question_count=int(meta["question_count"]),
            page=meta.get("page") or {},
            identifier=meta.get("identifier"),
            questions=qs,
        )


==========================================================================================
# FILE: services/omr_pdf_generator.py
==========================================================================================
# PATH: apps/domains/exams/services/omr_pdf_generator.py
from __future__ import annotations

import io
from typing import Optional

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm


def generate_simple_objective_omr_pdf(*, title: str, question_count: int) -> bytes:
    """
    Objective OMR PDF (ê°„ë‹¨ ìƒì„± ë²„ì „)

    âš ï¸ ì£¼ì˜:
    - ì´ ë²„ì „ì€ "ì¸ì‡„ ê°€ëŠ¥í•œ OMR"ì„ ìµœì†Œ ê¸°ëŠ¥ìœ¼ë¡œ ìƒì„±í•œë‹¤.
    - ë„¤ í”„ë¡œì íŠ¸ì˜ ì¢Œí‘œ SSOTë¥¼ assets/metaë¡œ ì™„ì „íˆ ë§ì¶”ë ¤ë©´,
      ë‹¤ìŒ ë‹¨ê³„ì—ì„œ assets meta ê¸°ë°˜ ë Œë”ë§ìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œí•˜ë©´ ëœë‹¤.
    """
    buf = io.BytesIO()
    c = canvas.Canvas(buf, pagesize=A4)
    w, h = A4

    # header
    c.setFont("Helvetica-Bold", 14)
    c.drawString(20 * mm, h - 20 * mm, f"OMR Answer Sheet")
    c.setFont("Helvetica", 11)
    c.drawString(20 * mm, h - 28 * mm, f"Title: {title}")
    c.drawString(20 * mm, h - 35 * mm, f"Questions: {question_count}")

    # layout
    # 10/20/30ì„ 2~3ì—´ë¡œ ë¶„ì‚°
    cols = 2 if question_count <= 20 else 3
    per_col = (question_count + cols - 1) // cols

    start_x = 20 * mm
    start_y = h - 50 * mm
    col_w = 60 * mm
    row_h = 7 * mm

    bubble_r = 2.2 * mm
    choices = ["A", "B", "C", "D", "E"]
    choice_gap = 8 * mm

    c.setFont("Helvetica", 9)

    qn = 1
    for col in range(cols):
        x0 = start_x + col * col_w
        y = start_y
        for _ in range(per_col):
            if qn > question_count:
                break

            # number
            c.drawString(x0, y, f"{qn:02d}")

            # bubbles
            bx = x0 + 12 * mm
            for ch in choices:
                c.circle(bx, y + 2.2 * mm, bubble_r, stroke=1, fill=0)
                c.drawString(bx - 1.5 * mm, y - 2.2 * mm, ch)
                bx += choice_gap

            y -= row_h
            qn += 1

    c.showPage()
    c.save()
    return buf.getvalue()


==========================================================================================
# FILE: services/question_factory.py
==========================================================================================
# apps/domains/exams/services/question_factory.py
from __future__ import annotations

from typing import List, Tuple

from django.db import transaction
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Sheet, ExamQuestion, Exam
from apps.domains.exams.services.template_resolver import assert_template_editable

BBox = Tuple[int, int, int, int]  # (x, y, w, h)


@transaction.atomic
def create_questions_from_boxes(*, sheet_id: int, boxes: List[BBox]) -> List[ExamQuestion]:
    """
    Segmentation ê²°ê³¼(boxes)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ExamQuestion ìë™ ìƒì„±.

    ë´‰ì¸ ê·œì¹™:
    - template examì˜ sheetì—ì„œë§Œ ìˆ˜í–‰ ê°€ëŠ¥
    - templateì´ ì´ë¯¸ regularì— ì˜í•´ ì°¸ì¡° ì¤‘ì´ë©´ êµ¬ì¡° ë³€ê²½ ê¸ˆì§€
    - idempotent: (sheet, number) update_or_create
    - boxes ê°œìˆ˜ ë³€í™” ì‹œ ê¸°ì¡´ ë¬¸ì œ ì‚­ì œ/ì¶”ê°€ ë™ê¸°í™”
    - scoreëŠ” ì ˆëŒ€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
    - bbox(region_meta) ì €ì¥ í•„ìˆ˜
    """

    sheet = (
        Sheet.objects
        .select_for_update()
        .select_related("exam")
        .get(id=int(sheet_id))
    )

    exam: Exam = sheet.exam
    if exam.exam_type != Exam.ExamType.TEMPLATE:
        raise ValidationError({"detail": "Questions can be auto-generated only for template exams."})

    # templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡° ë´‰ì¸
    assert_template_editable(exam)

    total = int(len(boxes or []))

    # 1) total_questions ë™ê¸°í™”
    if sheet.total_questions != total:
        sheet.total_questions = total
        sheet.save(update_fields=["total_questions", "updated_at"])

    # 2) ê¸°ì¡´ ë¬¸í•­ ì •ë¦¬
    existing_numbers = set(
        ExamQuestion.objects.filter(sheet=sheet).values_list("number", flat=True)
    )
    new_numbers = set(range(1, total + 1))

    to_delete = existing_numbers - new_numbers
    if to_delete:
        ExamQuestion.objects.filter(sheet=sheet, number__in=to_delete).delete()

    # 3) ìƒì„±/ê°±ì‹ 
    created: List[ExamQuestion] = []
    for idx in range(1, total + 1):
        x, y, w, h = boxes[idx - 1]

        obj, _ = ExamQuestion.objects.update_or_create(
            sheet=sheet,
            number=idx,
            defaults={
                "region_meta": {"x": int(x), "y": int(y), "w": int(w), "h": int(h)},
            },
        )
        created.append(obj)

    return created


==========================================================================================
# FILE: services/regular_exam_factory.py
==========================================================================================
# PATH: apps/domains/exams/services/regular_exam_factory.py
from __future__ import annotations

from typing import Optional

from django.db import transaction
from django.shortcuts import get_object_or_404
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Exam
from apps.domains.exams.services.template_builder_service import TemplateBuilderService
from apps.domains.exams.services.template_validation_service import TemplateValidationService
from apps.domains.lectures.models import Session


class RegularExamFactory:
    """
    âœ… PHASE 2-A
    í…œí”Œë¦¿(ExamType.TEMPLATE) ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ ì‹œí—˜(regular)ì„ ìƒì„±í•œë‹¤.

    ì›ì¹™:
    - templateì€ SSOT, regularì€ template_examë§Œ ì°¸ì¡°
    - templateì´ "regular ìƒì„± ê°€ëŠ¥í•œ ìƒíƒœ"ì¸ì§€ ì„œë²„ì—ì„œ ê²€ì¦
    """

    @transaction.atomic
    def create_regular_from_template(
        self,
        *,
        template_exam: Exam,
        session_id: int,
        title: Optional[str] = None,
        description: Optional[str] = None,
    ) -> Exam:
        if template_exam.exam_type != Exam.ExamType.TEMPLATE:
            raise ValidationError({"detail": "template exam required"})

        # 1) ìµœì†Œ êµ¬ì¡° ë³´ì¥(ì‹œíŠ¸/ì •ë‹µí‚¤ ë“±)
        TemplateBuilderService.ensure_initialized(template_exam)

        # 2) regular ìƒì„± ê°€ëŠ¥ ê²€ì¦(questions/answerkey ë“±)
        valid = TemplateValidationService.validate_for_regular(template_exam)
        if not valid.get("ok"):
            raise ValidationError({"detail": f"template not ready: {valid.get('reason')}"})

        session = get_object_or_404(Session, id=int(session_id))

        # 3) regular ìƒì„±
        regular = Exam.objects.create(
            title=(title or template_exam.title).strip(),
            description=(description if description is not None else template_exam.description) or "",
            subject=template_exam.subject,
            exam_type=Exam.ExamType.REGULAR,
            template_exam=template_exam,
            is_active=True,
        )
        regular.sessions.add(session)

        return regular


==========================================================================================
# FILE: services/template_builder_service.py
==========================================================================================
# PATH: apps/domains/exams/services/template_builder_service.py
from __future__ import annotations

from typing import Dict, Any

from django.db import transaction
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Exam, Sheet, AnswerKey
from apps.domains.exams.services.template_resolver import assert_template_editable


class TemplateBuilderService:
    """
    Template Builder Service (SSOT)

    ì±…ì„:
    - í…œí”Œë¦¿ ì‹œí—˜ì˜ 'ìƒì„± ì§í›„ í•„ìˆ˜ êµ¬ì¡°'ë¥¼ ë³´ì¥
    - í”„ë¡ íŠ¸/ìš´ì˜ì´ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ìµœì†Œ ìƒíƒœë¥¼ ê°•ì œ

    ë³´ì¥ ì‚¬í•­:
    - template examì€ ë°˜ë“œì‹œ Sheet(1:1)ë¥¼ ê°€ì§„ë‹¤
    - AnswerKeyëŠ” ë°˜ë“œì‹œ ì¡´ì¬í•œë‹¤ (ë¹ˆ answersë¼ë„)
    - total_questionsëŠ” í•­ìƒ Sheet ê¸°ì¤€ìœ¼ë¡œ ì‹ ë¢° ê°€ëŠ¥
    """

    @staticmethod
    @transaction.atomic
    def ensure_initialized(template_exam: Exam) -> Dict[str, Any]:
        if template_exam.exam_type != Exam.ExamType.TEMPLATE:
            raise ValidationError({"detail": "template exam required"})

        # ì´ë¯¸ ìš´ì˜ ì‹œí—˜ì—ì„œ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡° ë³€ê²½ ë¶ˆê°€
        assert_template_editable(template_exam)

        # 1ï¸âƒ£ Sheet ë³´ì¥ (1:1)
        sheet, _ = Sheet.objects.get_or_create(
            exam=template_exam,
            defaults={
                "name": "MAIN",
                "total_questions": 0,
            },
        )

        # 2ï¸âƒ£ AnswerKey ë³´ì¥ (ë¹ˆ answers í—ˆìš©)
        answer_key, _ = AnswerKey.objects.get_or_create(
            exam=template_exam,
            defaults={
                "answers": {},
            },
        )

        return {
            "exam_id": template_exam.id,
            "sheet_id": sheet.id,
            "answer_key_id": answer_key.id,
            "total_questions": sheet.total_questions,
        }


==========================================================================================
# FILE: services/template_resolver.py
==========================================================================================
# apps/domains/exams/services/template_resolver.py
from __future__ import annotations

from django.shortcuts import get_object_or_404
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Exam


def resolve_template_exam(exam: Exam) -> Exam:
    """
    ì‹œí—˜ ë‹¨ì¼ì§„ì‹¤ resolver

    - template â†’ ìê¸° ìì‹ 
    - regular â†’ template_exam (ë°˜ë“œì‹œ ì¡´ì¬í•´ì•¼ í•¨)
    """
    if exam.exam_type == Exam.ExamType.TEMPLATE:
        return exam

    # regularì€ template_examì´ í•„ìˆ˜ (DB constraint + ì—¬ê¸°ì„œë„ ë°©ì–´)
    if not getattr(exam, "template_exam_id", None):
        raise ValidationError({"detail": "regular exam must have template_exam"})

    # select_relatedê°€ ì•„ë‹ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ fetch
    return get_object_or_404(Exam, id=int(exam.template_exam_id), exam_type=Exam.ExamType.TEMPLATE)


def assert_template_editable(template_exam: Exam) -> None:
    """
    template examì˜ êµ¬ì¡°(Sheet/Question/AnswerKey/Asset)ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸.

    ë´‰ì¸ ê·œì¹™:
    - templateì´ ì´ë¯¸ regularì— ì˜í•´ ì°¸ì¡°(derived_exams ì¡´ì¬)ë˜ë©´
      êµ¬ì¡° ë³€ê²½ì€ ê¸ˆì§€í•œë‹¤. (ìš´ì˜ ì‚¬ê³  ì°¨ë‹¨)
    """
    if template_exam.exam_type != Exam.ExamType.TEMPLATE:
        raise ValidationError({"detail": "template exam required"})

    if template_exam.derived_exams.exists():
        raise ValidationError(
            {"detail": "This template is already used by regular exams; structural edits are locked."}
        )


==========================================================================================
# FILE: services/template_validation_service.py
==========================================================================================
# PATH: apps/domains/exams/services/template_validation_service.py
from __future__ import annotations

from typing import Dict, Any

from apps.domains.exams.models import Exam, ExamQuestion, AnswerKey


class TemplateValidationService:
    """
    Template Validation Service

    ì±…ì„:
    - í…œí”Œë¦¿ì´ ì‹¤ì œ ì‹œí—˜(regular)ë¡œ ìƒì„± ê°€ëŠ¥í•œì§€ íŒë‹¨
    - í”„ë¡ íŠ¸ ì¶”ì¸¡ ê¸ˆì§€, ì„œë²„ ë‹¨ íŒë‹¨ë§Œ ì‹ ë¢°
    """

    @staticmethod
    def validate_for_regular(template_exam: Exam) -> Dict[str, Any]:
        sheet = getattr(template_exam, "sheet", None)
        if not sheet:
            return {"ok": False, "reason": "SHEET_MISSING"}

        q_count = (
            ExamQuestion.objects
            .filter(sheet=sheet)
            .count()
        )
        if q_count <= 0:
            return {"ok": False, "reason": "NO_QUESTIONS"}

        if not AnswerKey.objects.filter(exam=template_exam).exists():
            return {"ok": False, "reason": "ANSWER_KEY_MISSING"}

        return {"ok": True}


==========================================================================================
# FILE: views/__init__.py
==========================================================================================



==========================================================================================
# FILE: views/answer_key_view.py
==========================================================================================
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, ValidationError

from apps.domains.exams.models import AnswerKey, Exam
from apps.domains.exams.serializers.answer_key import AnswerKeySerializer
from apps.domains.exams.services.template_resolver import resolve_template_exam, assert_template_editable

from apps.domains.results.permissions import IsTeacherOrAdmin


class AnswerKeyViewSet(ModelViewSet):
    """
    AnswerKey API (ë´‰ì¸)

    - list/retrieve: ë¡œê·¸ì¸ë§Œ
      - ?exam=<id> ë¡œ regular ì ‘ê·¼ ì‹œ templateë¡œ resolveí•´ì„œ ë‹¨ì¼ì§„ì‹¤ ì¡°íšŒ
    - create/update/destroy: Teacher/Admin + template only
    - templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ ì •ë‹µ ë³€ê²½ ê¸ˆì§€(ìš´ì˜ ì‚¬ê³  ì°¨ë‹¨)
    """

    queryset = AnswerKey.objects.select_related("exam")
    serializer_class = AnswerKeySerializer

    def get_permissions(self):
        if self.action in {"list", "retrieve"}:
            return [IsAuthenticated()]
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    def get_queryset(self):
        qs = super().get_queryset()
        exam_id = self.request.query_params.get("exam")
        if not exam_id:
            return qs

        try:
            eid = int(exam_id)
        except (TypeError, ValueError):
            raise ValidationError({"exam": "must be integer"})

        exam = get_object_or_404(Exam, id=eid)
        template = resolve_template_exam(exam)
        return qs.filter(exam=template)

    def perform_create(self, serializer):
        exam: Exam = serializer.validated_data["exam"]
        if exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("AnswerKey can be created only for template exams.")
        assert_template_editable(exam)
        serializer.save()

    def perform_update(self, serializer):
        obj: AnswerKey = self.get_object()
        if obj.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("AnswerKey can be updated only for template exams.")
        assert_template_editable(obj.exam)
        serializer.save()

    def perform_destroy(self, instance):
        if instance.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("AnswerKey can be deleted only for template exams.")
        assert_template_editable(instance.exam)
        return super().perform_destroy(instance)


==========================================================================================
# FILE: views/exam_asset_view.py
==========================================================================================
from __future__ import annotations

import mimetypes
import uuid

from django.shortcuts import get_object_or_404
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Exam, ExamAsset
from apps.domains.exams.serializers.exam_asset import ExamAssetSerializer
from apps.domains.exams.services.template_resolver import resolve_template_exam, assert_template_editable
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAssetView(APIView):
    """
    ExamAsset API (ë´‰ì¸)

    - GET: ë¡œê·¸ì¸ë§Œ, regular â†’ template resolve
    - POST: Teacher/Admin + template only
    - templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ ìì‚° êµì²´ ê¸ˆì§€(ìš´ì˜ ì‚¬ê³  ì°¨ë‹¨)
    """

    def get_permissions(self):
        if self.request.method == "GET":
            return [IsAuthenticated()]
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    def get(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))
        template = resolve_template_exam(exam)

        qs = ExamAsset.objects.filter(exam=template).order_by("asset_type")
        return Response(ExamAssetSerializer(qs, many=True).data)

    def post(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))
        if exam.exam_type != Exam.ExamType.TEMPLATE:
            return Response({"detail": "Assets can be uploaded only to template exams."}, status=403)

        # templateì´ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡° ë´‰ì¸ (asset í¬í•¨)
        assert_template_editable(exam)

        asset_type = request.data.get("asset_type")
        upload_file = request.FILES.get("file")
        if not asset_type or not upload_file:
            return Response({"detail": "asset_type and file are required"}, status=400)

        valid = {t for t, _ in ExamAsset.AssetType.choices}
        if asset_type not in valid:
            raise ValidationError({"asset_type": f"must be one of {sorted(valid)}"})

        name = upload_file.name or ""
        ext = name.split(".")[-1] if "." in name else "bin"
        key = f"exams/{exam.id}/assets/{asset_type}/{uuid.uuid4().hex}.{ext}"

        upload_fileobj_to_r2(
            fileobj=upload_file,
            key=key,
            content_type=upload_file.content_type,
        )

        obj, _ = ExamAsset.objects.update_or_create(
            exam=exam,
            asset_type=asset_type,
            defaults={
                "file_key": key,
                "file_type": upload_file.content_type or mimetypes.guess_type(upload_file.name)[0],
                "file_size": upload_file.size,
            },
        )

        return Response(ExamAssetSerializer(obj).data, status=status.HTTP_201_CREATED)


==========================================================================================
# FILE: views/exam_enrollment_view.py
==========================================================================================
# PATH: apps/domains/exams/views/exam_enrollment_view.py

from __future__ import annotations

from typing import List, Set

from django.db import transaction
from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status

from apps.domains.exams.models import ExamEnrollment
from apps.domains.exams.models.exam import Exam

from apps.domains.enrollment.models import SessionEnrollment

from apps.domains.exams.serializers.exam_enrollment_serializer import (
    ExamEnrollmentRowSerializer,
    ExamEnrollmentUpdateSerializer,
)


class ExamEnrollmentManageView(APIView):
    """
    Exam Enrollment Manage API

    âœ… ìš”êµ¬ì‚¬í•­:
    - ì„¸ì…˜(SessionEnrollment) í•™ìƒ ì¤‘ì—ì„œ ì„ íƒí•˜ì—¬
      ì‹œí—˜(Exam)ì— ì‘ì‹œ ëŒ€ìƒìë¡œ ë“±ë¡/ì œê±° ê°€ëŠ¥

    Endpoint:
    - GET /api/v1/exams/{exam_id}/enrollments/?session_id=123
    - PUT /api/v1/exams/{exam_id}/enrollments/?session_id=123

    ê·œì¹™:
    - session_idëŠ” ë°˜ë“œì‹œ í•„ìš” (M:N êµ¬ì¡°ì´ë¯€ë¡œ)
    - í•´ë‹¹ session_idëŠ” exam.sessionsì— í¬í•¨ëœ sessionë§Œ í—ˆìš©
    - enrollment_idsëŠ” ë°˜ë“œì‹œ "í•´ë‹¹ ì„¸ì…˜ ë“±ë¡ í•™ìƒ"ì˜ enrollment_idë§Œ í—ˆìš©
    """

    permission_classes = [IsAuthenticated]

    def _get_session_id_or_400(self, request, exam: Exam) -> int:
        """
        âœ… M:N êµ¬ì¡° ëŒ€ì‘:
        - session_idëŠ” query paramìœ¼ë¡œ ë°›ëŠ”ë‹¤.
        - í•´ë‹¹ sessionì´ exam.sessionsì— í¬í•¨ë˜ì§€ ì•Šìœ¼ë©´ 400.
        """
        raw = request.query_params.get("session_id") or request.data.get("session_id")
        if not raw:
            raise ValueError("session_id is required")

        try:
            session_id = int(raw)
        except (TypeError, ValueError):
            raise ValueError("session_id must be integer")

        # âœ… exam.sessionsì— í¬í•¨ëœ ì„¸ì…˜ì¸ì§€ ê²€ì¦
        if hasattr(exam, "sessions"):
            ok = exam.sessions.filter(id=session_id).exists()
            if not ok:
                raise ValueError("This exam is not linked to the given session_id")
        # (legacy) ë‹¨ì¼ session í•„ë“œê°€ ìˆëŠ” ê²½ìš°ë§Œ fallback
        elif hasattr(exam, "session_id"):
            if int(getattr(exam, "session_id", 0) or 0) != session_id:
                raise ValueError("This exam is not linked to the given session_id")

        return session_id

    def get(self, request, exam_id: int):
        exam = get_object_or_404(Exam, pk=exam_id)

        try:
            session_id = self._get_session_id_or_400(request, exam)
        except ValueError as e:
            return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        # 1) ì„¸ì…˜ ë“±ë¡ í•™ìƒ ëª©ë¡
        session_enrollments = (
            SessionEnrollment.objects
            .filter(session_id=session_id)
            .select_related("enrollment")
            .order_by("id")
        )

        # 2) í˜„ì¬ ì‹œí—˜ì— ì„ íƒëœ enrollment_id set
        selected_ids: Set[int] = set(
            ExamEnrollment.objects
            .filter(exam_id=exam_id)
            .values_list("enrollment_id", flat=True)
        )

        # 3) UI row êµ¬ì„±
        items: List[dict] = []
        for se in session_enrollments:
            enrollment = getattr(se, "enrollment", None)
            student_name = ""

            if enrollment is not None:
                student = getattr(enrollment, "student", None)
                if student is not None:
                    student_name = str(getattr(student, "name", "") or "")
                else:
                    student_name = str(getattr(enrollment, "student_name", "") or "")

            items.append(
                {
                    "enrollment_id": int(se.enrollment_id),
                    "student_name": student_name,
                    "is_selected": int(se.enrollment_id) in selected_ids,
                }
            )

        return Response(
            {
                "exam_id": exam_id,
                "session_id": int(session_id),
                "items": ExamEnrollmentRowSerializer(items, many=True).data,
            }
        )

    @transaction.atomic
    def put(self, request, exam_id: int):
        exam = get_object_or_404(Exam, pk=exam_id)

        try:
            session_id = self._get_session_id_or_400(request, exam)
        except ValueError as e:
            return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        ser = ExamEnrollmentUpdateSerializer(data=request.data)
        ser.is_valid(raise_exception=True)

        incoming_ids = set(map(int, ser.validated_data["enrollment_ids"]))

        # âœ… ì„¸ì…˜ ë“±ë¡ í•™ìƒì— í¬í•¨ë˜ëŠ” enrollment_idë§Œ í—ˆìš©
        valid_ids = set(
            SessionEnrollment.objects
            .filter(session_id=session_id)
            .values_list("enrollment_id", flat=True)
        )

        invalid = list(incoming_ids - valid_ids)
        if invalid:
            return Response(
                {
                    "detail": "ì„¸ì…˜ ë“±ë¡ í•™ìƒì´ ì•„ë‹Œ enrollment_idê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.",
                    "invalid_enrollment_ids": invalid,
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        # âœ… ì™„ì „ ì¹˜í™˜ ë°©ì‹
        ExamEnrollment.objects.filter(exam_id=exam_id).delete()

        bulk = [
            ExamEnrollment(exam_id=exam_id, enrollment_id=eid)
            for eid in sorted(incoming_ids)
        ]
        if bulk:
            ExamEnrollment.objects.bulk_create(bulk, ignore_conflicts=True)

        return Response(
            {
                "exam_id": exam_id,
                "session_id": int(session_id),
                "selected_count": len(incoming_ids),
            },
            status=status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/exam_questions_by_exam_view.py
==========================================================================================
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import ExamQuestion, Exam
from apps.domains.exams.serializers.question import QuestionSerializer
from apps.domains.exams.services.template_resolver import resolve_template_exam


class ExamQuestionsByExamView(APIView):
    """
    ì‹œí—˜ ê¸°ì¤€ ë¬¸í•­ ì¡°íšŒ
    - template â†’ self
    - regular â†’ template_exam
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        exam = Exam.objects.get(id=exam_id)
        template = resolve_template_exam(exam)

        qs = (
            ExamQuestion.objects
            .filter(sheet__exam=template)
            .select_related("sheet")
            .order_by("number")
        )

        return Response(QuestionSerializer(qs, many=True).data)


==========================================================================================
# FILE: views/exam_view.py
==========================================================================================
from __future__ import annotations

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError, PermissionDenied
from rest_framework.response import Response

from apps.domains.exams.models import Exam
from apps.domains.exams.serializers.exam import ExamSerializer
from apps.domains.exams.serializers.exam_create import ExamCreateSerializer
from apps.domains.exams.serializers.exam_update import ExamUpdateSerializer
from apps.domains.lectures.models import Session

from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamViewSet(ModelViewSet):
    """
    Exam ìƒì„±/ì¡°íšŒ/ìˆ˜ì •/ì‚­ì œ API (ë´‰ì¸)

    ë´‰ì¸ ê·œì¹™:
    - create/update/deleteëŠ” Teacher/Adminë§Œ
    - template: subject í•„ìˆ˜, session_id/template_exam_id ì…ë ¥ ê¸ˆì§€
    - regular: template_exam_id + session_id í•„ìˆ˜, subjectëŠ” template ê¸°ë°˜ìœ¼ë¡œ ë´‰ì¸
    - update/patchì—ì„œ exam_type/subject/template_exam ë³€ê²½ ì‹œë„ëŠ” ì¦‰ì‹œ 400
    - template ì‚­ì œ: derived regular ì¡´ì¬ ì‹œ ê¸ˆì§€
    """

    queryset = Exam.objects.all()
    permission_classes = [IsAuthenticated]

    # ================================
    # Serializer ì„ íƒ
    # ================================
    def get_serializer_class(self):
        if self.action == "create":
            return ExamCreateSerializer
        if self.action in {"update", "partial_update"}:
            return ExamUpdateSerializer
        return ExamSerializer

    # ================================
    # Permissions
    # ================================
    def get_permissions(self):
        if self.action in {"list", "retrieve"}:
            return [IsAuthenticated()]
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    # ================================
    # ğŸ”¥ í•µì‹¬ FIX: create ì‘ë‹µì„ read serializerë¡œ
    # ================================
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        self.perform_create(serializer)
        instance = serializer.instance

        # âœ… ì‘ë‹µì€ ë°˜ë“œì‹œ read serializer
        read_serializer = ExamSerializer(instance)
        headers = self.get_success_headers(read_serializer.data)

        return Response(
            read_serializer.data,
            status=201,
            headers=headers,
        )

    # ================================
    # Immutable í•„ë“œ ë°©ì–´
    # ================================
    def _reject_immutable_fields_on_update(self, request):
        forbidden = {"exam_type", "subject", "template_exam", "template_exam_id"}
        incoming = set(request.data.keys())
        bad = sorted(list(incoming & forbidden))
        if bad:
            raise ValidationError(
                {"detail": f"Immutable fields in update are forbidden: {bad}"}
            )

    # ================================
    # CREATE ë¡œì§
    # ================================
    def perform_create(self, serializer):
        exam_type = serializer.validated_data.get("exam_type")

        # =========================
        # TEMPLATE CREATE
        # =========================
        if exam_type == Exam.ExamType.TEMPLATE:
            if self.request.data.get("session_id"):
                raise ValidationError(
                    {"session_id": "template exam must not receive session_id"}
                )
            if self.request.data.get("template_exam_id"):
                raise ValidationError(
                    {"template_exam_id": "template exam must not receive template_exam_id"}
                )

            serializer.save(
                exam_type=Exam.ExamType.TEMPLATE,
                template_exam=None,
            )
            return

        # =========================
        # REGULAR CREATE
        # =========================
        template_exam_id = self.request.data.get("template_exam_id")
        if not template_exam_id:
            raise ValidationError({"template_exam_id": "required"})

        try:
            template_exam_id = int(template_exam_id)
        except (TypeError, ValueError):
            raise ValidationError({"template_exam_id": "must be integer"})

        try:
            template_exam = Exam.objects.get(id=template_exam_id)
        except Exam.DoesNotExist:
            raise ValidationError({"template_exam_id": "invalid"})

        if template_exam.exam_type != Exam.ExamType.TEMPLATE:
            raise ValidationError({"template_exam_id": "must be template exam"})

        session_id = self.request.data.get("session_id")
        if not session_id:
            raise ValidationError({"session_id": "required"})

        try:
            session_id = int(session_id)
        except (TypeError, ValueError):
            raise ValidationError({"session_id": "must be integer"})

        try:
            session = Session.objects.get(id=session_id)
        except Session.DoesNotExist:
            raise ValidationError({"session_id": "invalid"})

        exam = serializer.save(
            exam_type=Exam.ExamType.REGULAR,
            subject=template_exam.subject,
            template_exam=template_exam,
        )

        exam.sessions.add(session)

    # ================================
    # UPDATE ë°©ì–´
    # ================================
    def update(self, request, *args, **kwargs):
        self._reject_immutable_fields_on_update(request)
        return super().update(request, *args, **kwargs)

    def partial_update(self, request, *args, **kwargs):
        self._reject_immutable_fields_on_update(request)
        return super().partial_update(request, *args, **kwargs)

    # ================================
    # DELETE ë´‰ì¸
    # ================================
    def destroy(self, request, *args, **kwargs):
        obj: Exam = self.get_object()

        if obj.exam_type == Exam.ExamType.TEMPLATE and obj.derived_exams.exists():
            raise PermissionDenied(
                "This template is used by regular exams and cannot be deleted."
            )

        return super().destroy(request, *args, **kwargs)

    # ================================
    # Query Filters
    # ================================
    def get_queryset(self):
        qs = super().get_queryset()

        exam_type = self.request.query_params.get("exam_type")
        if exam_type:
            qs = qs.filter(exam_type=exam_type)

        session_id = self.request.query_params.get("session_id")
        if session_id:
            try:
                sid = int(session_id)
            except (TypeError, ValueError):
                raise ValidationError({"session_id": "must be integer"})
            qs = qs.filter(sessions__id=sid)

        lecture_id = self.request.query_params.get("lecture_id")
        if lecture_id:
            try:
                lid = int(lecture_id)
            except (TypeError, ValueError):
                raise ValidationError({"lecture_id": "must be integer"})
            qs = qs.filter(sessions__lecture_id=lid)

        return qs.distinct().order_by("-created_at")


==========================================================================================
# FILE: views/omr_generate_view.py
==========================================================================================
# PATH: apps/domains/exams/views/omr_generate_view.py
from __future__ import annotations

import io
import uuid

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.domains.exams.models import Exam, ExamAsset
from apps.domains.exams.serializers.exam_asset import ExamAssetSerializer
from apps.domains.exams.services.template_builder_service import TemplateBuilderService
from apps.domains.exams.services.omr_pdf_generator import generate_simple_objective_omr_pdf
from apps.domains.exams.services.template_resolver import assert_template_editable
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2
from apps.domains.results.permissions import IsTeacherOrAdmin


class GenerateOMRSheetAssetView(APIView):
    """
    âœ… PHASE 2-B
    POST /api/v1/exams/<template_exam_id>/generate-omr/

    - template examì— ëŒ€í•´ì„œë§Œ ìƒì„±
    - derived regular ì¡´ì¬ ì‹œ(ë´‰ì¸) ìƒì„± ê¸ˆì§€(ìš´ì˜ ì‚¬ê³  ë°©ì§€)
    - ìƒì„± ê²°ê³¼ë¥¼ ExamAsset(omr_sheet)ë¡œ ì €ì¥
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def post(self, request, exam_id: int):
        template_exam = get_object_or_404(Exam, id=int(exam_id), exam_type=Exam.ExamType.TEMPLATE)

        # ë´‰ì¸: ì´ë¯¸ regularë¡œ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡°/ìì‚° ë³€ê²½ ê¸ˆì§€
        assert_template_editable(template_exam)

        init = TemplateBuilderService.ensure_initialized(template_exam)
        sheet = getattr(template_exam, "sheet", None)
        question_count = int(getattr(sheet, "total_questions", 0) or 0)

        # question_countê°€ 0ì´ë©´ ìµœì†Œí•œ template_examì˜ OMR presetìœ¼ë¡œ ìƒì„±í•˜ë„ë¡ fallback
        # (ì›í•˜ë©´ í”„ë¡ íŠ¸ì—ì„œ total_questions ë¨¼ì € í™•ì •ì‹œí‚¤ëŠ” íë¦„ì´ ì •ì„)
        if question_count <= 0:
            question_count = int(request.data.get("question_count") or 20)

        if question_count not in (10, 20, 30):
            return Response({"detail": "question_count must be 10|20|30"}, status=status.HTTP_400_BAD_REQUEST)

        # 1) PDF ìƒì„± (in-memory)
        pdf_bytes = generate_simple_objective_omr_pdf(
            title=template_exam.title,
            question_count=question_count,
        )
        bio = io.BytesIO(pdf_bytes)

        # 2) ì—…ë¡œë“œ
        key = f"exams/{template_exam.id}/assets/omr_sheet/{uuid.uuid4().hex}.pdf"
        upload_fileobj_to_r2(
            fileobj=bio,
            key=key,
            content_type="application/pdf",
        )

        # 3) ExamAsset ì €ì¥/ê°±ì‹ (ìµœì‹  êµì²´)
        obj, _ = ExamAsset.objects.update_or_create(
            exam=template_exam,
            asset_type=ExamAsset.AssetType.OMR_SHEET,
            defaults={
                "file_key": key,
                "file_type": "application/pdf",
                "file_size": len(pdf_bytes),
            },
        )

        return Response(ExamAssetSerializer(obj).data, status=status.HTTP_201_CREATED)


==========================================================================================
# FILE: views/question_auto_view.py
==========================================================================================
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.exams.models import Sheet, Exam
from apps.domains.exams.serializers.question import QuestionSerializer
from apps.domains.exams.serializers.question_auto import QuestionAutoCreateSerializer
from apps.domains.exams.services.question_factory import create_questions_from_boxes

from apps.domains.results.permissions import IsTeacherOrAdmin


class SheetAutoQuestionsView(APIView):
    """
    POST /exams/sheets/<sheet_id>/auto-questions/

    ë´‰ì¸:
    - Teacher/Adminë§Œ ê°€ëŠ¥
    - template examì—ì„œë§Œ ê°€ëŠ¥
    - templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ ë¶ˆê°€(ì„œë¹„ìŠ¤ì—ì„œ ë°©ì–´)
    """

    def get_permissions(self):
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    def post(self, request, sheet_id: int):
        sheet = get_object_or_404(Sheet.objects.select_related("exam"), id=int(sheet_id))
        if sheet.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("Auto-question is allowed only for template exams.")

        s = QuestionAutoCreateSerializer(data=request.data)
        s.is_valid(raise_exception=True)

        boxes = [tuple(b) for b in s.validated_data["boxes"]]
        questions = create_questions_from_boxes(sheet_id=int(sheet_id), boxes=boxes)

        return Response(QuestionSerializer(questions, many=True).data)


==========================================================================================
# FILE: views/question_view.py
==========================================================================================
from __future__ import annotations

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.exams.models import ExamQuestion, Exam
from apps.domains.exams.serializers.question import QuestionSerializer
from apps.domains.exams.services.template_resolver import assert_template_editable

from apps.domains.results.permissions import IsTeacherOrAdmin


class QuestionViewSet(ModelViewSet):
    """
    ExamQuestion API (ë´‰ì¸)

    - list/retrieve: ë¡œê·¸ì¸ë§Œ
    - update/partial_update/destroy: Teacher/Admin + template examë§Œ
    - templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡° ë³€ê²½ ê¸ˆì§€
    """

    queryset = ExamQuestion.objects.select_related("sheet", "sheet__exam")
    serializer_class = QuestionSerializer

    def get_permissions(self):
        if self.action in {"list", "retrieve"}:
            return [IsAuthenticated()]
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    def _assert_template_editable(self, obj: ExamQuestion):
        if obj.sheet.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("Questions can be modified only in template exams.")
        assert_template_editable(obj.sheet.exam)

    def perform_update(self, serializer):
        obj = self.get_object()
        self._assert_template_editable(obj)
        serializer.save()

    def perform_destroy(self, instance):
        self._assert_template_editable(instance)
        return super().perform_destroy(instance)


==========================================================================================
# FILE: views/regular_from_template_view.py
==========================================================================================
# PATH: apps/domains/exams/views/regular_from_template_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.domains.exams.models import Exam
from apps.domains.exams.serializers.exam import ExamSerializer
from apps.domains.exams.services.regular_exam_factory import RegularExamFactory
from apps.domains.results.permissions import IsTeacherOrAdmin


class RegularExamFromTemplateView(APIView):
    """
    âœ… PHASE 2-A
    POST /api/v1/exams/<template_exam_id>/spawn-regular/

    ëª©ì :
    - ê¸°ì¡´ ExamViewSet.create(regular)ë„ ê·¸ëŒ€ë¡œ ìœ ì§€
    - í…œí”Œë¦¿ í™”ë©´ì—ì„œ "ì´ í…œí”Œë¦¿ìœ¼ë¡œ ì‹¤ì œ ì‹œí—˜ ë§Œë“¤ê¸°"ë¥¼ ë” ë‹¨ìˆœí•˜ê²Œ ì œê³µ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def post(self, request, exam_id: int):
        template_exam = get_object_or_404(Exam, id=int(exam_id), exam_type=Exam.ExamType.TEMPLATE)

        session_id = request.data.get("session_id")
        title = request.data.get("title")  # optional
        description = request.data.get("description")  # optional

        if not session_id:
            return Response({"detail": "session_id required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            session_id = int(session_id)
        except (TypeError, ValueError):
            return Response({"detail": "session_id must be integer"}, status=status.HTTP_400_BAD_REQUEST)

        factory = RegularExamFactory()
        regular = factory.create_regular_from_template(
            template_exam=template_exam,
            session_id=session_id,
            title=str(title).strip() if title else None,
            description=str(description).strip() if description else None,
        )

        return Response(ExamSerializer(regular).data, status=status.HTTP_201_CREATED)


==========================================================================================
# FILE: views/sheet_view.py
==========================================================================================
from __future__ import annotations

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, ValidationError

from apps.domains.exams.models import Sheet, Exam
from apps.domains.exams.serializers.sheet import SheetSerializer
from apps.domains.exams.services.template_resolver import assert_template_editable

from apps.domains.results.permissions import IsTeacherOrAdmin


class SheetViewSet(ModelViewSet):
    queryset = Sheet.objects.select_related("exam")
    serializer_class = SheetSerializer

    def get_permissions(self):
        # ì¡°íšŒëŠ” ë¡œê·¸ì¸ë§Œ
        if self.action in {"list", "retrieve"}:
            return [IsAuthenticated()]
        # ìƒì„±/ìˆ˜ì •/ì‚­ì œëŠ” Teacher/Admin
        return [IsAuthenticated(), IsTeacherOrAdmin()]

    def _assert_exam_is_template(self, exam_id: int) -> Exam:
        try:
            exam = Exam.objects.get(id=int(exam_id))
        except Exam.DoesNotExist:
            raise ValidationError({"exam": "invalid exam id"})

        if exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("Sheet can be created/updated only for template exams.")

        # templateì´ regularì— ì˜í•´ ì‚¬ìš© ì¤‘ì´ë©´ êµ¬ì¡° ë´‰ì¸
        assert_template_editable(exam)
        return exam

    def perform_create(self, serializer):
        exam_id = self.request.data.get("exam")
        if not exam_id:
            raise ValidationError({"exam": "exam is required"})
        exam = self._assert_exam_is_template(int(exam_id))

        # 1:1 ê°•ì œ
        if hasattr(exam, "sheet") and getattr(exam, "sheet", None) is not None:
            raise ValidationError({"exam": "This template exam already has a sheet (1:1)."})

        serializer.save(exam=exam)

    def perform_update(self, serializer):
        obj: Sheet = self.get_object()
        if obj.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("Sheet can be updated only for template exams.")
        assert_template_editable(obj.exam)
        serializer.save()

    def perform_destroy(self, instance):
        if instance.exam.exam_type != Exam.ExamType.TEMPLATE:
            raise PermissionDenied("Sheet can be deleted only for template exams.")
        assert_template_editable(instance.exam)
        return super().perform_destroy(instance)


==========================================================================================
# FILE: views/student_exam_view.py
==========================================================================================
from __future__ import annotations

from django.utils import timezone
from django.db.models import Q
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import Exam
from apps.domains.exams.serializers.exam_list_student import StudentExamListSerializer


class StudentAvailableExamListView(APIView):
    """
    í•™ìƒ ê¸°ì¤€ ì ‘ê·¼ ê°€ëŠ¥í•œ ì‹œí—˜ ëª©ë¡

    ë´‰ì¸ ê·œì¹™:
    - regular examë§Œ ë…¸ì¶œ
    - ExamEnrollmentì— í¬í•¨ëœ ì‹œí—˜ë§Œ ë…¸ì¶œ
    - is_active/open_at/close_at ê¸°ê°„ í•„í„° ì ìš©
    """

    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        now = timezone.now()

        qs = (
            Exam.objects.filter(
                exam_type=Exam.ExamType.REGULAR,
                exam_enrollments__enrollment__user=user,
                is_active=True,
            )
            .filter(
                Q(open_at__isnull=True) | Q(open_at__lte=now),
                Q(close_at__isnull=True) | Q(close_at__gte=now),
            )
            .distinct()
            .order_by("open_at", "id")
        )

        return Response(StudentExamListSerializer(qs, many=True).data)


==========================================================================================
# FILE: views/template_builder_view.py
==========================================================================================
# PATH: apps/domains/exams/views/template_builder_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import Exam
from apps.domains.exams.services.template_builder_service import TemplateBuilderService
from apps.domains.results.permissions import IsTeacherOrAdmin


class TemplateBuilderView(APIView):
    """
    Template Builder API

    POST /api/v1/exams/<exam_id>/builder/

    ì—­í• :
    - í…œí”Œë¦¿ ì‹œí—˜ì„ 'í¸ì§‘ ê°€ëŠ¥í•œ ìµœì†Œ ì™„ì„± ìƒíƒœ'ë¡œ ë³´ê°•
    - í”„ë¡ íŠ¸ì—ì„œ í…œí”Œë¦¿ í¸ì§‘ í™”ë©´ ì§„ì… ì‹œ ë‹¨ì¼ í˜¸ì¶œ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def post(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))

        result = TemplateBuilderService.ensure_initialized(exam)

        return Response(result, status=200)


==========================================================================================
# FILE: views/template_editor_view.py
==========================================================================================
# PATH: apps/domains/exams/views/template_editor_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import Exam
from apps.domains.exams.services.template_builder_service import TemplateBuilderService
from apps.domains.exams.serializers.template_editor import TemplateEditorSummarySerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class TemplateEditorView(APIView):
    """
    Template Editor ì´ˆê¸° ì§„ì… API

    GET /api/v1/exams/<exam_id>/template-editor/

    ì—­í• :
    - í…œí”Œë¦¿ ì‹œí—˜ì„ í¸ì§‘ í™”ë©´ì— ë¡œë”©í•˜ê¸° ìœ„í•œ ë‹¨ì¼ ì—”ë“œí¬ì¸íŠ¸
    - builder ë³´ì¥ + ìƒíƒœ ìš”ì•½ ë°˜í™˜
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))

        # ğŸ”¥ í¸ì§‘ ì§„ì… ì‹œ í•­ìƒ ìµœì†Œ êµ¬ì¡° ë³´ì¥
        init = TemplateBuilderService.ensure_initialized(exam)

        is_locked = exam.derived_exams.exists()

        payload = {
            "exam_id": exam.id,
            "title": exam.title,
            "subject": exam.subject,
            "sheet_id": init["sheet_id"],
            "total_questions": init["total_questions"],
            "has_answer_key": True,
            "is_locked": bool(is_locked),
        }

        return Response(TemplateEditorSummarySerializer(payload).data)


==========================================================================================
# FILE: views/template_status_view.py
==========================================================================================
# PATH: apps/domains/exams/views/template_status_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import Exam, ExamQuestion
from apps.domains.exams.services.template_resolver import resolve_template_exam


class TemplateStatusView(APIView):
    """
    Template ìƒíƒœ ì ê²€ API

    GET /api/v1/exams/<exam_id>/template-status/

    ëª©ì :
    - ì´ í…œí”Œë¦¿ìœ¼ë¡œ 'ì‹¤ì œ ì‹œí—˜ ìƒì„± ê°€ëŠ¥ ì—¬ë¶€' íŒë‹¨
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))
        template = resolve_template_exam(exam)

        has_sheet = hasattr(template, "sheet")
        question_count = (
            ExamQuestion.objects
            .filter(sheet__exam=template)
            .count()
        )

        ready = bool(has_sheet and question_count > 0)

        return Response(
            {
                "template_exam_id": template.id,
                "has_sheet": has_sheet,
                "question_count": question_count,
                "is_ready_for_regular_exam": ready,
            }
        )


==========================================================================================
# FILE: views/template_validation_view.py
==========================================================================================
# PATH: apps/domains/exams/views/template_validation_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.exams.models import Exam
from apps.domains.exams.services.template_resolver import resolve_template_exam
from apps.domains.exams.services.template_validation_service import TemplateValidationService


class TemplateValidationView(APIView):
    """
    Template Validation API

    GET /api/v1/exams/<exam_id>/template-validation/
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, exam_id: int):
        exam = get_object_or_404(Exam, id=int(exam_id))
        template = resolve_template_exam(exam)

        result = TemplateValidationService.validate_for_regular(template)

        return Response(
            {
                "template_exam_id": template.id,
                **result,
            }
        )
