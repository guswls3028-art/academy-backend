====================================================================================================
# BACKEND APP: video_worker
# ROOT PATH: C:\academy\apps\worker\video_worker
====================================================================================================


==========================================================================================
# FILE: config.py
==========================================================================================
from __future__ import annotations

import os
import sys
from dataclasses import dataclass


def _require(name: str) -> str:
    v = os.environ.get(name)
    if not v:
        raise RuntimeError(f"Missing required env: {name}")
    return v


def _require_any(*names: str) -> str:
    """
    여러 env 중 하나라도 있으면 사용.
    (SSOT 유지 + 운영 환경 차이 흡수용)
    """
    for name in names:
        v = os.environ.get(name)
        if v:
            return v
    raise RuntimeError(f"Missing required env (any of): {', '.join(names)}")


def _float(name: str, default: str) -> float:
    try:
        return float(os.environ.get(name, default))
    except Exception:
        return float(default)


def _int(name: str, default: str) -> int:
    try:
        return int(os.environ.get(name, default))
    except Exception:
        return int(default)


@dataclass(frozen=True)
class Config:
    # API
    API_BASE_URL: str
    WORKER_TOKEN: str
    WORKER_ID: str

    # Polling / retry
    POLL_INTERVAL_SECONDS: float
    HTTP_TIMEOUT_SECONDS: float
    RETRY_MAX_ATTEMPTS: int
    BACKOFF_BASE_SECONDS: float
    BACKOFF_CAP_SECONDS: float

    # Temp
    TEMP_DIR: str

    # Locking (Idempotency)
    LOCK_DIR: str
    LOCK_STALE_SECONDS: int

    # Heartbeat
    HEARTBEAT_INTERVAL_SECONDS: int

    # ffmpeg / ffprobe
    FFMPEG_BIN: str
    FFPROBE_BIN: str
    FFPROBE_TIMEOUT_SECONDS: int
    FFMPEG_TIMEOUT_SECONDS: int

    # HLS / thumb
    HLS_TIME_SECONDS: int
    THUMBNAIL_AT_SECONDS: float

    # Validation
    MIN_SEGMENTS_PER_VARIANT: int

    # R2 (S3 compatible)
    R2_BUCKET: str
    R2_PREFIX: str
    R2_ENDPOINT: str
    R2_ACCESS_KEY: str
    R2_SECRET_KEY: str
    R2_REGION: str
    UPLOAD_MAX_CONCURRENCY: int

    # download tuning
    DOWNLOAD_TIMEOUT_SECONDS: float
    DOWNLOAD_CHUNK_BYTES: int


def load_config() -> Config:
    try:
        return Config(
            API_BASE_URL=_require("API_BASE_URL").rstrip("/"),
            WORKER_TOKEN=_require("INTERNAL_WORKER_TOKEN"),
            WORKER_ID=os.environ.get("WORKER_ID", "video-worker-1"),

            POLL_INTERVAL_SECONDS=_float("VIDEO_WORKER_POLL_INTERVAL", "1.0"),
            HTTP_TIMEOUT_SECONDS=_float("VIDEO_WORKER_HTTP_TIMEOUT", "10.0"),
            RETRY_MAX_ATTEMPTS=_int("VIDEO_WORKER_RETRY_MAX", "6"),
            BACKOFF_BASE_SECONDS=_float("VIDEO_WORKER_BACKOFF_BASE", "0.5"),
            BACKOFF_CAP_SECONDS=_float("VIDEO_WORKER_BACKOFF_CAP", "10.0"),

            TEMP_DIR=os.environ.get("VIDEO_WORKER_TEMP_DIR", "/tmp/video-worker"),

            # Idempotency lock
            LOCK_DIR=os.environ.get("VIDEO_WORKER_LOCK_DIR", "/tmp/video-worker-locks"),
            LOCK_STALE_SECONDS=_int("VIDEO_WORKER_LOCK_STALE_SECONDS", "3600"),

            # Heartbeat
            HEARTBEAT_INTERVAL_SECONDS=_int("VIDEO_WORKER_HEARTBEAT_INTERVAL", "20"),

            FFMPEG_BIN=os.environ.get("FFMPEG_BIN", "ffmpeg"),
            FFPROBE_BIN=os.environ.get("FFPROBE_BIN", "ffprobe"),
            FFPROBE_TIMEOUT_SECONDS=_int("FFPROBE_TIMEOUT_SECONDS", "60"),
            FFMPEG_TIMEOUT_SECONDS=_int("FFMPEG_TIMEOUT_SECONDS", "3600"),

            HLS_TIME_SECONDS=_int("HLS_TIME_SECONDS", "4"),
            THUMBNAIL_AT_SECONDS=_float("THUMBNAIL_AT_SECONDS", "1.0"),

            MIN_SEGMENTS_PER_VARIANT=_int("MIN_SEGMENTS_PER_VARIANT", "3"),

            # ✅ 핵심 수정 포인트 (원본 로직 유지 + env 불일치 흡수)
            R2_BUCKET=_require_any("R2_BUCKET", "R2_VIDEO_BUCKET"),
            R2_PREFIX=os.environ.get("R2_PREFIX", "media/hls/videos"),
            R2_ENDPOINT=_require("R2_ENDPOINT"),
            R2_ACCESS_KEY=_require("R2_ACCESS_KEY"),
            R2_SECRET_KEY=_require("R2_SECRET_KEY"),
            R2_REGION=os.environ.get("R2_REGION", "auto"),
            UPLOAD_MAX_CONCURRENCY=_int("UPLOAD_MAX_CONCURRENCY", "8"),

            DOWNLOAD_TIMEOUT_SECONDS=_float("DOWNLOAD_TIMEOUT_SECONDS", "30.0"),
            DOWNLOAD_CHUNK_BYTES=_int("DOWNLOAD_CHUNK_BYTES", str(1024 * 1024)),
        )
    except Exception as e:
        print(f"[fatal] config error: {e}", file=sys.stderr)
        sys.exit(1)


==========================================================================================
# FILE: download.py
==========================================================================================
from __future__ import annotations

import logging
from pathlib import Path

import requests

from apps.worker.video_worker.config import Config
from apps.worker.video_worker.utils import backoff_sleep, ensure_dir, trim_tail

logger = logging.getLogger("video_worker")


class DownloadError(RuntimeError):
    pass


def download_to_file(*, url: str, dst: Path, cfg: Config) -> None:
    """
    안정적 다운로드:
    - stream chunk
    - retry with backoff
    - tmp(.part) -> atomic rename
    """
    ensure_dir(dst.parent)

    attempt = 0
    while True:
        try:
            with requests.get(url, stream=True, timeout=cfg.DOWNLOAD_TIMEOUT_SECONDS) as r:
                r.raise_for_status()

                tmp = dst.with_suffix(dst.suffix + ".part")
                bytes_written = 0

                with open(tmp, "wb") as f:
                    for chunk in r.iter_content(chunk_size=cfg.DOWNLOAD_CHUNK_BYTES):
                        if chunk:
                            f.write(chunk)
                            bytes_written += len(chunk)

                if bytes_written <= 0:
                    raise DownloadError("downloaded file is empty")

                tmp.replace(dst)
                return

        except Exception as e:
            attempt += 1
            if attempt >= cfg.RETRY_MAX_ATTEMPTS:
                raise DownloadError(f"download failed: {trim_tail(str(e))}") from e
            logger.warning("download retry attempt=%s err=%s", attempt, e)
            backoff_sleep(attempt, cfg.BACKOFF_BASE_SECONDS, cfg.BACKOFF_CAP_SECONDS)


==========================================================================================
# FILE: heartbeat.py
==========================================================================================
# PATH: apps/worker/video_worker/heartbeat.py
#
# PURPOSE:
# - long-running 작업 동안 backend에 주기적으로 heartbeat 전송
# - backend의 reclaim 오판 방지
#
# CONTRACT:
# - POST /api/v1/internal/video-worker/{video_id}/heartbeat/
# - 실패해도 worker 메인 작업은 중단하지 않음
#
# DESIGN:
# - exponential backoff
# - stop() 호출 시 즉시 종료
# - thread-safe

from __future__ import annotations

import logging
import threading
import time
from typing import Optional

from apps.worker.video_worker.http_client import VideoAPIClient

logger = logging.getLogger("video_worker.heartbeat")


class HeartbeatThread:
    def __init__(
        self,
        *,
        client: VideoAPIClient,
        video_id: int,
        interval: int,
        backoff_base: int,
        backoff_cap: int,
    ):
        self._client = client
        self._video_id = video_id
        self._interval = max(1, int(interval))
        self._backoff_base = max(1, int(backoff_base))
        self._backoff_cap = max(self._backoff_base, int(backoff_cap))

        self._stop_event = threading.Event()
        self._thread: Optional[threading.Thread] = None

    def start(self) -> None:
        if self._thread is not None:
            return

        self._thread = threading.Thread(
            target=self._run,
            name=f"heartbeat-video-{self._video_id}",
            daemon=True,
        )
        self._thread.start()

    def stop(self) -> None:
        self._stop_event.set()
        if self._thread is not None:
            self._thread.join(timeout=5)

    def _run(self) -> None:
        backoff = self._backoff_base

        # 최초 1회는 바로 보내지 않고 interval 이후 전송
        next_sleep = self._interval

        while not self._stop_event.wait(next_sleep):
            try:
                self._client.send_heartbeat(self._video_id)
                # 성공 시 backoff 리셋
                backoff = self._backoff_base
                next_sleep = self._interval
            except Exception as e:
                # heartbeat 실패는 치명적이지 않다
                logger.warning(
                    "heartbeat failed video_id=%s err=%s",
                    self._video_id,
                    e,
                )
                # backoff 증가
                next_sleep = min(backoff, self._backoff_cap)
                backoff = min(backoff * 2, self._backoff_cap)


==========================================================================================
# FILE: http_client.py
==========================================================================================
from __future__ import annotations

import logging
from typing import Any, Dict, Optional

import requests

logger = logging.getLogger("video_worker.http")


class VideoAPIClient:
    def __init__(
        self,
        *,
        base_url: str,
        worker_token: str,
        worker_id: str,
        timeout_seconds: int,
    ):
        self._base_url = base_url.rstrip("/")
        self._timeout = timeout_seconds
        self._headers = {
            "X-Worker-Token": worker_token,
            "X-Worker-Id": worker_id,
            "Content-Type": "application/json",
        }

    # --------------------------------------------------
    # Job control
    # --------------------------------------------------

    def fetch_next_job(self) -> Optional[Dict[str, Any]]:
        url = f"{self._base_url}/internal/video-worker/next/"
        resp = requests.get(
            url,
            headers=self._headers,
            timeout=self._timeout,
        )
        if resp.status_code == 204:
            return None
        resp.raise_for_status()
        return resp.json()

    def notify_complete(self, video_id: int, payload: Dict[str, Any]) -> None:
        url = f"{self._base_url}/internal/video-worker/{video_id}/complete/"
        resp = requests.post(
            url,
            json=payload,
            headers=self._headers,
            timeout=self._timeout,
        )
        resp.raise_for_status()

    def notify_fail(self, video_id: int, reason: str) -> None:
        url = f"{self._base_url}/internal/video-worker/{video_id}/fail/"
        resp = requests.post(
            url,
            json={"reason": reason},
            headers=self._headers,
            timeout=self._timeout,
        )
        resp.raise_for_status()

    # --------------------------------------------------
    # Heartbeat
    # --------------------------------------------------

    def send_heartbeat(self, video_id: int) -> None:
        url = f"{self._base_url}/internal/video-worker/{video_id}/heartbeat/"
        resp = requests.post(
            url,
            headers=self._headers,
            timeout=self._timeout,
        )
        resp.raise_for_status()

    # --------------------------------------------------
    # Lifecycle
    # --------------------------------------------------

    def close(self) -> None:
        """
        requests.Session을 쓰지 않으므로 noop.
        main.py의 client.close() 계약을 맞추기 위한 메서드.
        """
        return


==========================================================================================
# FILE: locking.py
==========================================================================================
from __future__ import annotations

import os
import time
from pathlib import Path
from dataclasses import dataclass


@dataclass(frozen=True)
class LockHandle:
    path: Path
    fd: int


class LockBusyError(RuntimeError):
    pass


def acquire_video_lock(lock_dir: str, video_id: int, stale_seconds: int) -> LockHandle:
    """
    로컬 idempotency lock:
    - single host에서 중복처리 방지
    - stale lock은 mtime 기반으로 회수

    NOTE:
    - multi-host는 backend lease까지 있어야 완벽 (요구사항상 최소 하나 구현이면 OK)
    """
    Path(lock_dir).mkdir(parents=True, exist_ok=True)
    path = Path(lock_dir) / f"video_{video_id}.lock"

    now = int(time.time())
    pid = os.getpid()
    payload = f"pid={pid}\ncreated_at={now}\n"

    try:
        fd = os.open(str(path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
        os.write(fd, payload.encode())
        os.fsync(fd)
        return LockHandle(path=path, fd=fd)

    except FileExistsError:
        try:
            stat = path.stat()
            age = now - int(stat.st_mtime)
            if age > int(stale_seconds):
                try:
                    path.unlink()
                except Exception:
                    pass
                return acquire_video_lock(lock_dir, video_id, stale_seconds)
        except Exception:
            # stat 실패 시에도 lock은 존중
            pass

        raise LockBusyError(f"video {video_id} already processing")


def release_video_lock(handle: LockHandle) -> None:
    try:
        os.close(handle.fd)
    except Exception:
        pass
    try:
        handle.path.unlink()
    except Exception:
        pass


==========================================================================================
# FILE: main.py
==========================================================================================
# PATH: apps/worker/video_worker/main.py
from __future__ import annotations

import logging
import signal
import time
import os
import subprocess

from apps.worker.video_worker.config import load_config
from apps.worker.video_worker.http_client import VideoAPIClient
from apps.worker.video_worker.video.processor import process_video_job
from apps.worker.video_worker.utils import backoff_sleep

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] [VIDEO-WORKER] %(message)s",
)
logger = logging.getLogger("video_worker")

_shutdown = False


def _handle_signal(sig, frame):
    global _shutdown
    logger.warning("shutdown signal received sig=%s", sig)
    _shutdown = True


def _shutdown_self():
    """
    ✅ 단일 진실:
    - worker는 '자기 자신'만 종료 가능
    - region은 EC2 metadata 기준으로 계산
    - INSTANCE_ID는 systemd Environment로 주입됨
    """
    instance_id = os.environ.get("INSTANCE_ID")
    if not instance_id:
        logger.warning("INSTANCE_ID not set; skip self shutdown")
        return

    try:
        az = subprocess.check_output(
            ["curl", "-s", "http://169.254.169.254/latest/meta-data/placement/availability-zone"],
            text=True,
        ).strip()
        region = az[:-1]  # ap-northeast-2a → ap-northeast-2
    except Exception as e:
        logger.error("failed to resolve region from metadata: %s", e)
        return

    logger.warning("idle limit reached; stopping instance %s", instance_id)

    subprocess.run(
        [
            "aws",
            "ec2",
            "stop-instances",
            "--instance-ids",
            instance_id,
            "--region",
            region,
        ],
        check=False,
    )


def main() -> None:
    signal.signal(signal.SIGINT, _handle_signal)
    signal.signal(signal.SIGTERM, _handle_signal)

    cfg = load_config()

    client = VideoAPIClient(
        base_url=cfg.API_BASE_URL,
        worker_token=cfg.WORKER_TOKEN,
        worker_id=cfg.WORKER_ID,
        timeout_seconds=int(cfg.HTTP_TIMEOUT_SECONDS),
    )

    logger.info(
        "Video Worker started worker_id=%s api=%s poll=%ss",
        cfg.WORKER_ID,
        cfg.API_BASE_URL,
        cfg.POLL_INTERVAL_SECONDS,
    )

    error_attempt = 0
    idle_count = 0
    IDLE_LIMIT = int(os.environ.get("VIDEO_WORKER_IDLE_LIMIT", "5"))

    try:
        while not _shutdown:
            try:
                job = client.fetch_next_job()

                if not job:
                    idle_count += 1
                    if idle_count >= IDLE_LIMIT:
                        _shutdown_self()
                        break

                    time.sleep(cfg.POLL_INTERVAL_SECONDS)
                    continue

                idle_count = 0

                if isinstance(job, dict) and "job" in job:
                    job = job.get("job")

                if not job or not isinstance(job, dict):
                    time.sleep(cfg.POLL_INTERVAL_SECONDS)
                    continue

                if job.get("video_id") is None:
                    logger.info("idle job payload=%s", job)
                    time.sleep(cfg.POLL_INTERVAL_SECONDS)
                    continue

                error_attempt = 0

                logger.info("job received video_id=%s", job.get("video_id"))

                process_video_job(job=job, cfg=cfg, client=client)

            except Exception:
                logger.exception("worker loop error")
                error_attempt = min(error_attempt + 1, 10)
                backoff_sleep(
                    error_attempt,
                    cfg.BACKOFF_BASE_SECONDS,
                    cfg.BACKOFF_CAP_SECONDS,
                )

    finally:
        try:
            client.close()
        except Exception:
            pass
        logger.info("Video Worker shutdown complete")


if __name__ == "__main__":
    main()


==========================================================================================
# FILE: utils.py
==========================================================================================
from __future__ import annotations

import logging
import random
import shutil
import tempfile
import time
from contextlib import contextmanager
from pathlib import Path

logger = logging.getLogger("video_worker")


@contextmanager
def temp_workdir(base_dir: str, prefix: str):
    Path(base_dir).mkdir(parents=True, exist_ok=True)
    path = Path(tempfile.mkdtemp(prefix=prefix, dir=base_dir))
    try:
        yield path
    finally:
        try:
            shutil.rmtree(path, ignore_errors=True)
        except Exception:
            logger.warning("Failed to cleanup temp dir: %s", path)


def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def backoff_sleep(attempt: int, base: float, cap: float) -> None:
    raw = min(cap, base * (2 ** attempt))
    jitter = random.uniform(0.5, 1.5)
    time.sleep(raw * jitter)


def trim_tail(s: str, limit: int = 2000) -> str:
    if not s:
        return ""
    return s[-limit:] if len(s) > limit else s


def guess_content_type(name: str) -> str:
    n = name.lower()
    if n.endswith(".m3u8"):
        return "application/vnd.apple.mpegurl"
    if n.endswith(".ts"):
        return "video/MP2T"
    if n.endswith(".mp4"):
        return "video/mp4"
    if n.endswith(".jpg") or n.endswith(".jpeg"):
        return "image/jpeg"
    if n.endswith(".png"):
        return "image/png"
    if n.endswith(".json"):
        return "application/json"
    return "application/octet-stream"


def cache_control_for_object(name: str) -> str:
    """
    R2 Cache-Control 전략 (요구사항 반영)

    - HLS playlist (.m3u8): 서명 정책/쿠키 기반 접근을 전제로 "no-cache"
      (플레이리스트는 재생 정책/토큰 갱신 영향 받음)
    - Segment (.ts): immutable (콘텐츠 주소가 prefix/video_id 고정이라도,
      세그먼트는 VOD 생성 후 변경되지 않는 것이 정상)
    - Thumbnail: 7d 캐시
    """
    n = name.lower()
    if n.endswith(".m3u8"):
        return "no-cache"
    if n.endswith(".ts"):
        return "public, max-age=31536000, immutable"
    if n.endswith(".jpg") or n.endswith(".jpeg") or n.endswith(".png"):
        return "public, max-age=604800"
    return "public, max-age=3600"


==========================================================================================
# FILE: video/duration.py
==========================================================================================
# PATH: apps/worker/video_worker/video/duration.py
#
# PURPOSE:
# - 로컬 영상 파일에서 ffprobe로 duration(초) 추출
# - 실패해도 worker 전체 작업을 fail 시키지 않음 (best-effort)

from __future__ import annotations

import subprocess
from typing import Optional


class DurationProbeError(RuntimeError):
    pass


def probe_duration_seconds(
    *,
    input_path: str,
    ffprobe_bin: str,
    timeout: int,
) -> Optional[int]:
    if not input_path:
        return None

    cmd = [
        ffprobe_bin,
        "-v", "error",
        "-show_entries", "format=duration",
        "-of", "default=noprint_wrappers=1:nokey=1",
        input_path,
    ]

    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout,
            check=False,
        )
    except Exception:
        return None

    if p.returncode != 0:
        return None

    raw = (p.stdout or "").strip()
    if not raw:
        return None

    try:
        sec = float(raw)
        if sec < 0:
            return None
        return int(sec)
    except Exception:
        return None


==========================================================================================
# FILE: video/processor.py
==========================================================================================
# PATH: apps/worker/video_worker/video/processor.py

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, Dict, Optional

from apps.worker.video_worker.config import Config
from apps.worker.video_worker.download import download_to_file
from apps.worker.video_worker.heartbeat import HeartbeatThread
from apps.worker.video_worker.http_client import VideoAPIClient
from apps.worker.video_worker.locking import (
    LockBusyError,
    acquire_video_lock,
    release_video_lock,
)
from apps.worker.video_worker.utils import temp_workdir, trim_tail

from apps.worker.video_worker.video.duration import probe_duration_seconds
from apps.worker.video_worker.video.thumbnail import generate_thumbnail
from apps.worker.video_worker.video.transcoder import transcode_to_hls
from apps.worker.video_worker.video.validate import validate_hls_output
from apps.worker.video_worker.video.r2_uploader import upload_directory

logger = logging.getLogger("video_worker.processor")


def _safe_int(v: Any) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return None


def _build_source_url_from_file_key(*, file_key: str) -> str:
    """
    SSOT:
    - job payload에는 file_key만 온다. (backend /internal/video-worker/next/)
    - worker는 source 다운로드용 URL을 만든다.
    - libs.s3_client.presign이 있으면 presigned GET 생성 (원본 구조 존중)
    """
    if not file_key:
        raise RuntimeError("file_key_missing")

    try:
        from libs.s3_client.presign import create_presigned_get_url  # lazy import
    except Exception as e:
        raise RuntimeError(f"presign_module_missing:{trim_tail(str(e))}") from e

    try:
        return create_presigned_get_url(key=str(file_key), expires_in=600)
    except Exception as e:
        raise RuntimeError(f"presigned_get_failed:{trim_tail(str(e))}") from e


def _hls_r2_prefix(cfg: Config, video_id: int) -> str:
    base = (cfg.R2_PREFIX or "media/hls/videos").strip("/")
    return f"{base}/{int(video_id)}"


def _hls_master_relpath(cfg: Config, video_id: int) -> str:
    return f"{_hls_r2_prefix(cfg, video_id)}/master.m3u8"


def process_video_job(*, job: Dict[str, Any], cfg: Config, client: VideoAPIClient) -> None:
    """
    main.py 계약:
    - process_video_job(job=job, cfg=cfg, client=client)
    - job은 dict이며, 최소 {"video_id": int, "file_key": str} 기대
    """
    video_id = _safe_int(job.get("video_id"))
    file_key = (job.get("file_key") or "").strip()

    if not video_id:
        raise KeyError("video_id")

    # single-host idempotency lock
    lock = None
    try:
        lock = acquire_video_lock(cfg.LOCK_DIR, int(video_id), int(cfg.LOCK_STALE_SECONDS))
    except LockBusyError:
        logger.info("lock busy video_id=%s", video_id)
        return

    hb: Optional[HeartbeatThread] = None
    try:
        # heartbeat (best-effort)
        hb = HeartbeatThread(
            client=client,
            video_id=int(video_id),
            interval=int(cfg.HEARTBEAT_INTERVAL_SECONDS),
            backoff_base=int(cfg.BACKOFF_BASE_SECONDS) if int(cfg.BACKOFF_BASE_SECONDS) > 0 else 1,
            backoff_cap=int(cfg.BACKOFF_CAP_SECONDS) if int(cfg.BACKOFF_CAP_SECONDS) > 0 else 10,
        )
        hb.start()

        # source url
        source_url = _build_source_url_from_file_key(file_key=file_key)

        with temp_workdir(cfg.TEMP_DIR, prefix=f"video-{video_id}-") as wd:
            wd = Path(wd)

            src_path = wd / "source.mp4"
            out_dir = wd / "hls"

            # 1) download source
            download_to_file(url=source_url, dst=src_path, cfg=cfg)

            # 2) duration (local ffprobe)
            duration = probe_duration_seconds(
                input_path=str(src_path),
                ffprobe_bin=cfg.FFPROBE_BIN,
                timeout=int(cfg.FFPROBE_TIMEOUT_SECONDS),
            )
            if not duration or duration <= 0:
                raise RuntimeError("duration_probe_failed")

            # 3) transcode -> hls
            transcode_to_hls(
                video_id=int(video_id),
                input_path=str(src_path),
                output_root=out_dir,
                ffmpeg_bin=cfg.FFMPEG_BIN,
                ffprobe_bin=cfg.FFPROBE_BIN,
                hls_time=int(cfg.HLS_TIME_SECONDS),
                timeout=int(cfg.FFMPEG_TIMEOUT_SECONDS),
            )

            # 4) validate
            validate_hls_output(out_dir, int(cfg.MIN_SEGMENTS_PER_VARIANT))

            # 5) thumbnail (midpoint)
            try:
                at = float(cfg.THUMBNAIL_AT_SECONDS)
                if duration >= 10:
                    at = float(int(duration * 0.5))
                elif duration >= 3:
                    at = float(max(1, duration // 2))
                else:
                    at = 0.0

                thumb_path = out_dir / "thumbnail.jpg"
                generate_thumbnail(
                    input_path=str(src_path),
                    output_path=thumb_path,
                    ffmpeg_bin=cfg.FFMPEG_BIN,
                    at_seconds=float(at),
                    timeout=min(int(cfg.FFMPEG_TIMEOUT_SECONDS), 120),
                )
            except Exception as e:
                logger.warning("thumbnail failed video_id=%s err=%s", video_id, e)

            # 6) upload directory to R2
            upload_directory(
                local_dir=out_dir,
                bucket=cfg.R2_BUCKET,
                prefix=_hls_r2_prefix(cfg, int(video_id)),
                endpoint_url=cfg.R2_ENDPOINT,
                access_key=cfg.R2_ACCESS_KEY,
                secret_key=cfg.R2_SECRET_KEY,
                region=cfg.R2_REGION,
                max_concurrency=int(cfg.UPLOAD_MAX_CONCURRENCY),
                retry_max=int(cfg.RETRY_MAX_ATTEMPTS),
                backoff_base=float(cfg.BACKOFF_BASE_SECONDS),
                backoff_cap=float(cfg.BACKOFF_CAP_SECONDS),
            )

        # 7) notify backend complete
        client.notify_complete(
            int(video_id),
            {
                "hls_path": _hls_master_relpath(cfg, int(video_id)),
                "duration": int(duration),
            },
        )

        logger.info("job completed video_id=%s duration=%s", video_id, duration)

    except Exception as e:
        logger.exception("job failed video_id=%s err=%s", video_id, e)
        try:
            client.notify_fail(int(video_id), str(e))
        except Exception:
            logger.exception("notify_fail failed video_id=%s", video_id)
        raise

    finally:
        try:
            if hb is not None:
                hb.stop()
        except Exception:
            pass
        try:
            if lock is not None:
                release_video_lock(lock)
        except Exception:
            pass


==========================================================================================
# FILE: video/r2_uploader.py
==========================================================================================
from __future__ import annotations

import os
from pathlib import Path

import boto3
from boto3.s3.transfer import TransferConfig

from apps.worker.video_worker.utils import guess_content_type, cache_control_for_object, trim_tail, backoff_sleep


class UploadError(RuntimeError):
    pass


def upload_directory(
    *,
    local_dir: Path,
    bucket: str,
    prefix: str,
    endpoint_url: str,
    access_key: str,
    secret_key: str,
    region: str,
    max_concurrency: int,
    retry_max: int = 5,
    backoff_base: float = 0.5,
    backoff_cap: float = 10.0,
) -> None:
    """
    업로드 정책 (요구사항 반영):
    - Content-Type 정확히
    - Cache-Control 전략 포함
      - .m3u8 : no-cache
      - .ts   : public, max-age=31536000, immutable
      - thumb : 7d
    - 부분 업로드 방지:
      - boto3 multipart 실패 시 예외 / retry
      - 동일 Key에 overwrite는 허용 (idempotent)
    """
    s3 = boto3.client(
        "s3",
        endpoint_url=endpoint_url,
        aws_access_key_id=access_key,
        aws_secret_access_key=secret_key,
        region_name=region,
    )

    transfer_cfg = TransferConfig(
        max_concurrency=max_concurrency,
        multipart_threshold=8 * 1024 * 1024,
        multipart_chunksize=8 * 1024 * 1024,
        use_threads=True,
    )

    local_dir = local_dir.resolve()

    for root, _, files in os.walk(local_dir):
        for name in files:
            full_path = Path(root) / name
            rel = full_path.relative_to(local_dir)
            key = f"{prefix.rstrip('/')}/{rel.as_posix()}"

            extra = {
                "ContentType": guess_content_type(name),
                "CacheControl": cache_control_for_object(name),
            }

            attempt = 0
            while True:
                try:
                    s3.upload_file(
                        Filename=str(full_path),
                        Bucket=bucket,
                        Key=key,
                        ExtraArgs=extra,
                        Config=transfer_cfg,
                    )
                    break
                except Exception as e:
                    attempt += 1
                    if attempt >= retry_max:
                        raise UploadError(f"upload failed key={key} err={trim_tail(str(e))}") from e
                    backoff_sleep(attempt, backoff_base, backoff_cap)


==========================================================================================
# FILE: video/thumbnail.py
==========================================================================================
from __future__ import annotations

import subprocess
from pathlib import Path

from apps.worker.video_worker.utils import ensure_dir, trim_tail


class ThumbnailError(RuntimeError):
    pass


def generate_thumbnail(
    *,
    input_path: str,
    output_path: Path,
    ffmpeg_bin: str,
    at_seconds: float,
    timeout: int,
) -> None:
    ensure_dir(output_path.parent)

    cmd = [
        ffmpeg_bin,
        "-y",
        "-ss", f"{at_seconds:.3f}",
        "-i", input_path,
        "-frames:v", "1",
        "-q:v", "2",
        str(output_path),
    ]

    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout,
            check=False,
        )
    except subprocess.TimeoutExpired as e:
        raise ThumbnailError(f"thumbnail timeout ({timeout}s)") from e

    if p.returncode != 0:
        raise ThumbnailError(f"thumbnail ffmpeg failed: {trim_tail(p.stderr)}")


==========================================================================================
# FILE: video/transcoder.py
==========================================================================================
# PATH: apps/worker/video_worker/video/transcoder.py

from __future__ import annotations

import json
import subprocess
from pathlib import Path
from typing import List, Optional

from apps.worker.video_worker.utils import ensure_dir, trim_tail

# preset 유지 (순서 중요)
HLS_VARIANTS = [
    {"name": "1", "width": 426, "height": 240, "video_bitrate": "400k", "audio_bitrate": "64k"},
    {"name": "2", "width": 640, "height": 360, "video_bitrate": "800k", "audio_bitrate": "96k"},
    {"name": "3", "width": 1280, "height": 720, "video_bitrate": "2500k", "audio_bitrate": "128k"},
]


class TranscodeError(RuntimeError):
    pass


def _probe_resolution(input_path: str, ffprobe_bin: str, timeout: int) -> tuple[int, int]:
    cmd = [
        ffprobe_bin,
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=width,height",
        "-of", "json",
        input_path,
    ]
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout,
            check=False,
        )
    except subprocess.TimeoutExpired:
        return 0, 0

    if p.returncode != 0:
        return 0, 0

    try:
        data = json.loads(p.stdout)
        s = (data.get("streams") or [{}])[0]
        return int(s.get("width") or 0), int(s.get("height") or 0)
    except Exception:
        return 0, 0


def _select_variants(input_w: int, input_h: int) -> List[dict]:
    """
    입력 해상도 상한 반영:
    - 원본보다 큰 variant는 제외
    """
    selected = []
    for v in HLS_VARIANTS:
        if v["width"] <= input_w and v["height"] <= input_h:
            selected.append(v)
    # 안전장치: 최소 1개
    if not selected:
        selected.append(HLS_VARIANTS[0])
    return selected


def prepare_output_dirs(output_root: Path, variants: List[dict]) -> None:
    ensure_dir(output_root)
    for v in variants:
        ensure_dir(output_root / f"v{v['name']}")


def has_audio_stream(*, input_path: str, ffprobe_bin: str, timeout: int) -> bool:
    cmd = [
        ffprobe_bin,
        "-v", "error",
        "-print_format", "json",
        "-show_streams",
        input_path,
    ]
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout,
            check=False,
        )
    except subprocess.TimeoutExpired:
        return False

    if p.returncode != 0:
        return False

    try:
        data = json.loads(p.stdout)
        streams = data.get("streams") or []
        return any(s.get("codec_type") == "audio" for s in streams)
    except Exception:
        return False


def build_filter_complex(variants: List[dict]) -> str:
    parts: List[str] = []
    split_count = len(variants)
    parts.append("[0:v]split={}".format(split_count) + "".join(f"[v{i}]" for i in range(split_count)))
    for i, v in enumerate(variants):
        parts.append(f"[v{i}]scale={v['width']}:{v['height']}[v{i}out]")
    return ";".join(parts)


def build_ffmpeg_command(
    *,
    input_path: str,
    variants: List[dict],
    with_audio: bool,
    ffmpeg_bin: str,
    hls_time: int,
) -> List[str]:
    cmd: List[str] = [
        ffmpeg_bin,
        "-y",
        "-i", input_path,
        "-filter_complex", build_filter_complex(variants),
    ]

    for i, v in enumerate(variants):
        cmd += ["-map", f"[v{i}out]"]
        if with_audio:
            cmd += ["-map", "0:a?"]

        cmd += [
            f"-c:v:{i}", "libx264",
            "-profile:v", "main",
            "-pix_fmt", "yuv420p",
            f"-b:v:{i}", v["video_bitrate"],
            "-g", "48",
            "-keyint_min", "48",
            "-sc_threshold", "0",
        ]

        if with_audio:
            cmd += [
                f"-c:a:{i}", "aac",
                "-ac", "2",
                f"-b:a:{i}", v["audio_bitrate"],
            ]

    if with_audio:
        var_map = " ".join(f"v:{i},a:{i},name:{v['name']}" for i, v in enumerate(variants))
    else:
        var_map = " ".join(f"v:{i},name:{v['name']}" for i, v in enumerate(variants))

    cmd += [
        "-f", "hls",
        "-hls_time", str(hls_time),
        "-hls_playlist_type", "vod",
        "-hls_flags", "independent_segments",
        "-hls_segment_filename", "v%v/index%d.ts",
        "-master_pl_name", "master.m3u8",
        "-var_stream_map", var_map,
        "v%v/index.m3u8",
    ]
    return cmd


def transcode_to_hls(
    *,
    video_id: int,
    input_path: str,
    output_root: Path,
    ffmpeg_bin: str,
    ffprobe_bin: str,
    hls_time: int,
    timeout: Optional[int],
) -> Path:
    # 입력 해상도 기반 variant 선택
    w, h = _probe_resolution(input_path, ffprobe_bin, min(60, int(timeout or 60)))
    variants = _select_variants(w, h)

    prepare_output_dirs(output_root, variants)

    with_audio = has_audio_stream(
        input_path=input_path,
        ffprobe_bin=ffprobe_bin,
        timeout=min(60, int(timeout or 60)),
    )

    cmd = build_ffmpeg_command(
        input_path=input_path,
        variants=variants,
        with_audio=with_audio,
        ffmpeg_bin=ffmpeg_bin,
        hls_time=hls_time,
    )

    try:
        p = subprocess.run(
            cmd,
            cwd=str(output_root.resolve()),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout,
            check=False,
        )
    except subprocess.TimeoutExpired as e:
        raise TranscodeError(f"ffmpeg timeout video_id={video_id} seconds={timeout}") from e

    if p.returncode != 0:
        raise TranscodeError(
            f"ffmpeg failed video_id={video_id} with_audio={with_audio} stderr={trim_tail(p.stderr)}"
        )

    master = output_root / "master.m3u8"
    if not master.exists():
        raise TranscodeError("master.m3u8 not created")

    return master


==========================================================================================
# FILE: video/validate.py
==========================================================================================
# PATH: apps/worker/video_worker/video/validate.py

from __future__ import annotations

from pathlib import Path


def validate_hls_output(root: Path, min_segments: int) -> None:
    """
    인코딩 결과 깨짐 자동 fail 처리용 검증:
    - master.m3u8 존재
    - 각 variant playlist 존재
    - 각 variant에 최소 세그먼트 수 확보

    상품 레벨 보정:
    - 짧은 영상(총 길이 < min_segments * HLS_TIME)의 경우
      ffmpeg 정상 동작에서도 세그먼트 수가 min보다 작을 수 있음
    - 따라서 "0개"만 실패로 간주하고, 1개 이상이면 정상 처리
    """
    master = root / "master.m3u8"
    if not master.exists():
        raise RuntimeError("master.m3u8 missing")

    variants = list(root.glob("v*/index.m3u8"))
    if not variants:
        raise RuntimeError("no variant playlists (v*/index.m3u8)")

    for v in variants:
        segs = list(v.parent.glob("*.ts"))

        # 기존: 고정 min_segments 강제
        # if len(segs) < int(min_segments):
        #     raise RuntimeError(f"HLS validation failed: {v} segments={len(segs)} min={min_segments}")

        # MODIFIED: 짧은 영상 허용 (세그먼트 1개 이상이면 정상)
        if len(segs) <= 0:  # MODIFIED
            raise RuntimeError(  # MODIFIED
                f"HLS validation failed: {v} segments={len(segs)} min=1"  # MODIFIED
            )
