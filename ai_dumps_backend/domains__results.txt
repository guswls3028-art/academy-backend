====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: README.md
==========================================================================================
RESULTS ë„ë©”ì¸ ë‹¨ì¼ì§„ì‹¤(SSOT) ë´‰ì¸ ë¬¸ì„œ
ğŸ“Œ ë¬¸ì„œ ëª©ì  (READ FIRST)

ì´ ë¬¸ì„œëŠ” results ë„ë©”ì¸ì˜ ì„¤ê³„Â·ì±…ì„Â·ê²½ê³„ë¥¼ ì˜êµ¬ì ìœ¼ë¡œ ê³ ì •í•˜ê¸° ìœ„í•œ ë´‰ì¸ ë¬¸ì„œë‹¤.

ì´ ë¬¸ì„œê°€ ì¡´ì¬í•˜ëŠ” í•œ:

âŒ êµ¬ì¡° ì¬ì„¤ê³„ ê¸ˆì§€

âŒ ì±…ì„ ì´ë™ ê¸ˆì§€

âŒ â€œí¸ì˜ìƒâ€ ë¡œì§ ì¶”ê°€ ê¸ˆì§€

ëª¨ë“  ë³€ê²½ì€ ì´ ë¬¸ì„œì™€ ì¶©ëŒí•˜ì§€ ì•Šì•„ì•¼ í•˜ë©°,
ì¶©ëŒ ì‹œ ì½”ë“œê°€ ì•„ë‹ˆë¼ ë¬¸ì„œê°€ ì •ë‹µì´ë‹¤.

ğŸ¯ ìµœì¢… ê²°ë¡  (í•œ ì¤„ ìš”ì•½)

ì´ í”„ë¡œì íŠ¸ì˜ results ë„ë©”ì¸ì€ ì´ë¯¸ â€œëŒ€ê¸°ì—… ìš´ì˜ ë ˆë²¨â€ë¡œ ì™„ì„±ë˜ì—ˆìœ¼ë©°,
ë¬¸ì œëŠ” ì„¤ê³„ê°€ ì•„ë‹ˆë¼ ê³¼ê±° ì”ì¡´ ì½”ë“œì™€ ì§‘ê³„ ì±…ì„ í˜¼ì¬ì˜€ë‹¤.
ë³¸ ë¬¸ì„œëŠ” ê·¸ í˜¼ì¬ë¥¼ ì˜êµ¬ì ìœ¼ë¡œ ì°¨ë‹¨í•œë‹¤.

ğŸ§­ ì „ì²´ ë„ë©”ì¸ ë‹¨ì¼ì§„ì‹¤ ì§€ë„ (SSOT MAP)
1ï¸âƒ£ Identity & Ownership (ì ˆëŒ€ ê³ ì •)
Student

ì‹¤ì¡´ ì¸ë¬¼

ë¡œê·¸ì¸(User)ê³¼ ì„ íƒì ìœ¼ë¡œ ì—°ê²°

âŒ ê²°ê³¼ì˜ ì§ì ‘ ì£¼ì²´ ì•„ë‹˜

âŒ ì‹œí—˜/í†µê³„ FK ê¸ˆì§€

Enrollment â­â­â­ (í•µì‹¬)

ëª¨ë“  í•™ìŠµ/ì‹œí—˜/ê²°ê³¼/í†µê³„ì˜ ìœ ì¼í•œ ì£¼ì²´

(student, lecture) ë‹¨ì¼

Results FKëŠ” ë¬´ì¡°ê±´ enrollment_id

StudentëŠ” ì–¸ì œë‚˜ ê°„ì ‘ ì°¸ì¡°ë§Œ í—ˆìš©

ğŸ‘‰ ResultsëŠ” Studentë¥¼ ì ˆëŒ€ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ë‹¤.

2ï¸âƒ£ Lecture / Session ë„ë©”ì¸ (ìš´ì˜ ë‹¨ìœ„)
Lecture

êµìœ¡ ìƒí’ˆ

ì—¬ëŸ¬ Session ë³´ìœ 

âŒ ì‹œí—˜/ê²°ê³¼ ê³„ì‚° ì±…ì„ ì—†ìŒ

Session

ìš´ì˜ ë‹¨ìœ„ (ì°¨ì‹œ)

Lecture FK

Examê³¼ N:M

â€œì´ ì°¨ì‹œì— ì‹œí—˜ì´ ìˆì—ˆëŠ”ê°€?â€
â†’ Result / Progressë¡œ íŒë‹¨

ğŸ‘‰ lectures ë„ë©”ì¸ì€ ê²°ê³¼ë¥¼ ê³„ì‚°í•˜ì§€ ì•ŠëŠ”ë‹¤.

3ï¸âƒ£ Exam ë„ë©”ì¸ (ì¶œì œ ë‹¨ìœ„)

Examì€ template / regular

ì‹œí—˜ ì •ì˜ / ìì‚° / ì •ë‹µì˜ SSOT

Session â†” Exam = N:M

âŒ ê²°ê³¼/í†µê³„ ì±…ì„ ì—†ìŒ

4ï¸âƒ£ Submission â†’ Results (ê°€ì¥ ì¤‘ìš”í•œ ì¶•)
Submission

ë‹µì•ˆì˜ SSOT

ìƒíƒœ ë¨¸ì‹ :

CREATED
  â†’ ANSWERS_READY
    â†’ GRADING
      â†’ DONE

Results â­â­â­

ë‹¨ í•˜ë‚˜ì˜ ê²°ê³¼ ì§„ì‹¤

êµ¬ì„± ìš”ì†Œ:

ExamAttempt (ì‹œë„)

ResultFact (append-only, ì›ì‹œ ë¡œê·¸)

ResultItem (ë¬¸í•­ ìŠ¤ëƒ…ìƒ·)

Result (ëŒ€í‘œ ê²°ê³¼)

ì¬ì‹œí—˜ / ì¬ì±„ì  / ëŒ€í‘œ attempt êµì²´ / í†µê³„
â†’ ì „ë¶€ ì´ êµ¬ì¡°ë¡œ ì»¤ë²„

ğŸ‘‰ ResultsëŠ” ì‚¬ì‹¤ë§Œ ê¸°ë¡í•œë‹¤.
ê³„ì‚°Â·í•´ì„Â·íŒë‹¨ì€ í•˜ì§€ ì•ŠëŠ”ë‹¤.

ğŸ§± Aggregation Layer (í•´ì„ì˜ ìœ ì¼í•œ ì¥ì†Œ)
apps/domains/results/aggregations/
â”œâ”€ session_results.py
â”œâ”€ lecture_results.py
â””â”€ global_results.py

ì—­í• 

ì§‘ê³„ / í†µê³„ / íŒë‹¨ì˜ ìœ ì¼í•œ ì±…ì„

SQL, aggregation, business rule í—ˆìš©

View / Model / SerializerëŠ” ì ˆëŒ€ ê³„ì‚° ê¸ˆì§€

ì›ì¹™

Results = write-only facts

Aggregations = read-only interpretation

ğŸš« ê¸ˆì§€ ì‚¬í•­ (ì˜êµ¬ ë´‰ì¸)

ì•„ë˜ëŠ” ì–´ë–¤ ì´ìœ ë¡œë„ ê¸ˆì§€ëœë‹¤:

âŒ Resultì— session_id FK ì¶”ê°€

âŒ Session.exam FK ë¶€í™œ

âŒ Resultsì—ì„œ Student ì§ì ‘ ì°¸ì¡°

âŒ View / Serializer / Modelì— ì§‘ê³„ ë¡œì§ ì‘ì„±

âŒ â€œí¸ì˜ìƒâ€ ê³„ì‚° ë¡œì§ ì¶”ê°€

âŒ Aggregation ë¡œì§ì„ ë‹¤ë¥¸ ë„ë©”ì¸ìœ¼ë¡œ ì´ë™

âš ï¸ ê³¼ê±° ë¬¸ì œì˜ ì •ì²´ (ì¬ë°œ ë°©ì§€ìš© ê¸°ë¡)
ë¬¸ì œëŠ” ì´ê²ƒë¿ì´ì—ˆë‹¤

lectures ë„ë©”ì¸ì— ë‚¨ì•„ ìˆë˜ êµ¬ë²„ì „ ì‹œí—˜ FK ì‚¬ê³ 

Resultsì— ì§‘ê³„ ì±…ì„ì´ ì„ì—¬ ìˆë˜ ìƒíƒœ

Aggregation Layer ë¶€ì¬

ğŸ‘‰ ì„¤ê³„ ìì²´ëŠ” ì²˜ìŒë¶€í„° ì •ë‹µì´ì—ˆë‹¤.

âœ… í˜„ì¬ ìƒíƒœ ì„ ì–¸ (FINAL)

âœ… Results ë„ë©”ì¸: ì™„ì „ ê³ ì •

âœ… Aggregation Layer: ë‹¨ì¼ì§„ì‹¤

âœ… ìš´ì˜ ì‚¬ê³  ê°€ëŠ¥ì„±: êµ¬ì¡°ì ìœ¼ë¡œ 0

âœ… ë°±ì—”ë“œ ì¬ë°©ë¬¸ í•„ìš”ì„±: ì—†ìŒ

ì´í›„ ê°œë°œì€ í”„ë¡ íŠ¸ì—”ë“œ ì‘ì—…ë§Œ ì§„í–‰í•œë‹¤.
ë°±ì—”ë“œ ë³€ê²½ì´ í•„ìš”í•˜ë‹¤ë©´, ì´ ë¬¸ì„œë¥¼ ë¨¼ì € ìˆ˜ì •í•˜ê³ 
ê·¸ ë‹¤ìŒì— ì½”ë“œë¥¼ ìˆ˜ì •í•œë‹¤.

ğŸ”’ ë´‰ì¸ ì„ ì–¸

ì´ ë¬¸ì„œ ì´í›„ë¡œ:

â€œresults ë„ë©”ì¸ì€ ë” ì´ìƒ ì‹¤í—˜ ëŒ€ìƒì´ ì•„ë‹ˆë‹¤.
ì´ë¯¸ ìš´ì˜ ê¸°ì¤€ì„ í†µê³¼í•œ â€˜ì™„ì„±í’ˆâ€™ì´ë‹¤.â€

â€” END â€”


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    í”„ë¡œì íŠ¸ë§ˆë‹¤ user.role / user.user_type / groups ë“± ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ ë°©ì–´ì ìœ¼ë¡œ.
    - ìˆìœ¼ë©´ ì“°ê³ 
    - ì—†ìœ¼ë©´ is_staff/is_superuserë¡œ íŒë‹¨
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # í”„ë¡œì íŠ¸ì— ë”°ë¼ "TEACHER" ë¬¸ìì—´ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ â†’ í•„ìš”ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # ëª…ì‹œì ìœ¼ë¡œ teacher/admin ì•„ë‹ˆë©´ studentë¡œ ì·¨ê¸‰(ì¼ë°˜ì ì¸ ì •ì±…)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/results/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter

from apps.domains.results.views.student_exam_result_view import MyExamResultView
from apps.domains.results.views.student_exam_attempts_view import MyExamAttemptsView

from apps.domains.results.views.admin_exam_results_view import AdminExamResultsView
from apps.domains.results.views.admin_exam_summary_view import AdminExamSummaryView
from apps.domains.results.views.admin_exam_result_detail_view import AdminExamResultDetailView
from apps.domains.results.views.admin_exam_item_score_view import AdminExamItemScoreView
from apps.domains.results.views.admin_representative_attempt_view import AdminRepresentativeAttemptView
from apps.domains.results.views.admin_exam_attempts_view import AdminExamAttemptsView

from apps.domains.results.views.admin_session_exams_view import AdminSessionExamsView
from apps.domains.results.views.admin_session_exams_summary_view import AdminSessionExamsSummaryView
from apps.domains.results.views.session_score_summary_view import SessionScoreSummaryView
from apps.domains.results.views.session_scores_view import SessionScoresView

from apps.domains.results.views.admin_result_fact_view import AdminResultFactView

from apps.domains.results.views.question_stats_views import (
    AdminExamQuestionStatsView,
    ExamQuestionWrongDistributionView,
    ExamTopWrongQuestionsView,
)

from apps.domains.results.views.wrong_note_view import WrongNoteView
from apps.domains.results.views.wrong_note_pdf_view import WrongNotePDFCreateView
from apps.domains.results.views.wrong_note_pdf_status_view import WrongNotePDFStatusView

from apps.domains.results.views.exam_attempt_view import ExamAttemptViewSet
from apps.domains.results.views.admin_clinic_targets_view import AdminClinicTargetsView

from apps.domains.clinic.views import ParticipantViewSet as AdminClinicBookingViewSet

urlpatterns = [
    path("me/exams/<int:exam_id>/", MyExamResultView.as_view(), name="my-exam-result"),
    path("me/exams/<int:exam_id>/attempts/", MyExamAttemptsView.as_view(), name="my-exam-attempts"),
    path("admin/exams/<int:exam_id>/summary/", AdminExamSummaryView.as_view(), name="admin-exam-summary"),
    path("admin/exams/<int:exam_id>/results/", AdminExamResultsView.as_view(), name="admin-exam-results"),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/",
        AdminExamResultDetailView.as_view(),
        name="admin-exam-result-detail",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/items/<int:question_id>/",
        AdminExamItemScoreView.as_view(),
        name="admin-exam-item-score",
    ),
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/attempts/",
        AdminExamAttemptsView.as_view(),
        name="admin-exam-attempts",
    ),
    path("admin/exams/<int:exam_id>/questions/", AdminExamQuestionStatsView.as_view(), name="admin-exam-question-stats"),
    path(
        "admin/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamQuestionWrongDistributionView.as_view(),
        name="admin-exam-question-wrong-distribution",
    ),
    path(
        "admin/exams/<int:exam_id>/questions/top-wrong/",
        ExamTopWrongQuestionsView.as_view(),
        name="admin-exam-top-wrong-questions",
    ),
    path(
        "admin/sessions/<int:session_id>/score-summary/",
        SessionScoreSummaryView.as_view(),
        name="session-score-summary",
    ),
    path("admin/sessions/<int:session_id>/scores/", SessionScoresView.as_view(), name="admin-session-scores"),
    path("admin/sessions/<int:session_id>/exams/", AdminSessionExamsView.as_view(), name="admin-session-exams"),
    path(
        "admin/sessions/<int:session_id>/exams/summary/",
        AdminSessionExamsSummaryView.as_view(),
        name="admin-session-exams-summary",
    ),
    path("admin/facts/", AdminResultFactView.as_view(), name="admin-result-facts"),
    path("admin/clinic-targets/", AdminClinicTargetsView.as_view(), name="admin-clinic-targets"),
    path("wrong-notes", WrongNoteView.as_view(), name="wrong-note"),
    path("wrong-notes/pdf/", WrongNotePDFCreateView.as_view(), name="wrong-note-pdf-create"),
    path("wrong-notes/pdf/<int:job_id>/", WrongNotePDFStatusView.as_view(), name="wrong-note-pdf-status"),
]

router = DefaultRouter()
router.register("exam-attempts", ExamAttemptViewSet)
router.register("admin/clinic-bookings", AdminClinicBookingViewSet, basename="admin-clinic-bookings")
urlpatterns += router.urls


==========================================================================================
# FILE: z_backend_api_final.md
==========================================================================================
# PATH: docs/contracts/backend_api_final.md
# ğŸ“˜ BACKEND API FINAL (EXAMS Â· SUBMISSIONS Â· RESULTS) â€” ë´‰ì¸ë³¸

ê¸°ì¤€
- Django REST Framework
- ìƒíƒœ ë¨¸ì‹ : Submission.Status
- ì±„ì  ë‹¨ì¼ ì§„ì‹¤: grade_submission()
- ê²°ê³¼ ë‹¨ì¼ ì§„ì‹¤: results ë„ë©”ì¸
- Worker: HTTP polling + callback

---

## 0ï¸âƒ£ ê³µí†µ ê·œì¹™ (ì¤‘ìš”)

### Submission ìƒíƒœ íë¦„ (ê³ ì •)
SUBMITTED
 â†’ DISPATCHED
 â†’ EXTRACTING
 â†’ ANSWERS_READY
 â†’ GRADING
 â†’ DONE
 â†’ FAILED (retry ê°€ëŠ¥)

### ì ˆëŒ€ ê·œì¹™
- âŒ í”„ë¡ íŠ¸ëŠ” submissions.answers ì§ì ‘ í•´ì„ ê¸ˆì§€
- âœ… ê²°ê³¼ëŠ” results APIë§Œ ì¡°íšŒ
- âœ… ì±„ì ì€ grade_submission() ë‹¨ì¼ ì§„ì…ì 
- âœ… workerëŠ” backendì˜ internal endpoint ê³„ì•½ë§Œ ì‚¬ìš©

---

## 1ï¸âƒ£ ì‹œí—˜ (Exams)

### 1-1. ì‹œí—˜ ëª©ë¡ (í•™ìƒ)
GET /student/exams/

### 1-2. ì‹œí—˜ ìƒì„¸
GET /student/exams/{exam_id}/

### 1-3. ì‹œí—˜ì§€(OMR PDF) ìƒì„±
POST /exams/{exam_id}/omr/generate/

ê²°ê³¼:
- PDF URL
- sheet_id í¬í•¨

---

## 2ï¸âƒ£ ì œì¶œ (Submissions)

### 2-1. OMR ì‹œí—˜ ì œì¶œ (í•µì‹¬ ì‹œì‘ì )
POST /submissions/exams/{exam_id}/omr/

Body
{
  "enrollment_id": 123,
  "sheet_id": 45,
  "file_key": "uploads/omr/scan1.jpg"
}

Backend
- Submission ìƒì„±
- status = SUBMITTED â†’ DISPATCHED
- AI job dispatch

Response
{
  "submission_id": 1001,
  "status": "dispatched"
}

### 2-2. ì¼ë°˜ ì œì¶œ ìƒì„± (ë²”ìš©)
POST /submissions/
(source = online / homework ë“±)

### 2-3. ì œì¶œ ëª©ë¡ ì¡°íšŒ
GET /submissions/

### 2-4. ì œì¶œ ìƒì„¸ ì¡°íšŒ (polling ìš©)
GET /submissions/{submission_id}/

ì¤‘ìš” í•„ë“œ
- status
- meta.ai_result
- meta.omr / homework ê²°ê³¼

### 2-5. ì‹¤íŒ¨ ì œì¶œ ì¬ì‹œë„
POST /submissions/{submission_id}/retry/

ì¡°ê±´
- status == FAILED

### 2-6. OMR ìˆ˜ë™ ìˆ˜ì • (êµì‚¬ìš©)
POST /submissions/{submission_id}/manual-edit/

Body
{
  "identifier": "manual",
  "answers": [
    { "exam_question_id": 10, "answer": "B" },
    { "exam_question_id": 11, "answer": "D" }
  ],
  "note": "teacher fix"
}

íš¨ê³¼
- SubmissionAnswer overwrite
- status â†’ ANSWERS_READY
- ì¦‰ì‹œ ì¬ì±„ì 

---

## 3ï¸âƒ£ AI ê²°ê³¼ ì½œë°± (Worker â†’ Backend)

### 3-1. AI ê²°ê³¼ ìˆ˜ì‹  (ë‚´ë¶€)
POST /internal/ai/result/

Body (ì˜ˆì‹œ)
{
  "submission_id": 1001,
  "status": "DONE",
  "result": { ... },
  "error": null
}

Router
- apply_ai_result_for_submission()

ë¶„ê¸°
- OMR â†’ answers ì €ì¥ â†’ ANSWERS_READY â†’ ì±„ì  ëŒ€ìƒ
- Homework video/image â†’ meta ì €ì¥ â†’ DONE

---

## 4ï¸âƒ£ ì±„ì  (Results â€“ ë‚´ë¶€ SSOT)

### 4-1. ì±„ì  ì§„ì…ì  (ì§ì ‘ í˜¸ì¶œ âŒ / ë‚´ë¶€ ì‚¬ìš©)
grade_submission(submission_id)

ë³´ì¥
- Idempotent
- Attempt / Result 1ê°œë¡œ ìˆ˜ë ´

### 4-2. ìë™ enqueue (Celery)
enqueue_grading_if_ready(submission)

ì¡°ê±´
- status == ANSWERS_READY

---

## 5ï¸âƒ£ ê²°ê³¼ ì¡°íšŒ (Results)

### 5-1. í•™ìƒ ì‹œí—˜ ê²°ê³¼ ëª©ë¡
GET /student/results/exams/

### 5-2. í•™ìƒ ì‹œí—˜ ê²°ê³¼ ìƒì„¸
GET /student/results/exams/{exam_id}/

í¬í•¨
- total_score
- objective / subjective
- breakdown
- pass/fail

### 5-3. ì‹œí—˜ ì‹œë„(Attempt) ì¡°íšŒ
GET /results/exam-attempts/

### 5-4. ì‹œí—˜ ê²°ê³¼ ìš”ì•½ (ê´€ë¦¬ì)
GET /results/admin/exam-summary/

### 5-5. ë¬¸í•­ í†µê³„
GET /results/question-stats/

---

## 6ï¸âƒ£ ì˜¤ë‹µë…¸íŠ¸ PDF

### 6-1. ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± (ë¹„ë™ê¸°)
POST /results/wrong-notes/pdf/

### 6-2. ì˜¤ë‹µë…¸íŠ¸ PDF ìƒíƒœ ì¡°íšŒ (polling)
GET /results/wrong-notes/pdf/{job_id}/

Response
{
  "job_id": 12,
  "status": "DONE",
  "file_url": "https://..."
}

---

## 7ï¸âƒ£ ìˆ™ì œ (Homework â€“ AI íŒë³„)

### 7-1. ì˜ìƒ ìˆ™ì œ ì œì¶œ
POST /submissions/
source: HOMEWORK_VIDEO

### 7-2. ì˜ìƒ ìˆ™ì œ AI ê²°ê³¼
meta:
{
  "homework_video_result": {
    "has_content": true,
    "filled_ratio": 0.42,
    "too_short": false
  }
}

â€» ì±„ì  âŒ, DONE ì²˜ë¦¬

---

## 8ï¸âƒ£ ìƒíƒœ ì¡°íšŒ ìš”ì•½ (í”„ë¡ íŠ¸ Polling)

í”„ë¡ íŠ¸ëŠ” ì´ 3ê°€ì§€ë§Œ ë³´ë©´ ë¨
- GET /submissions/{id}/  â†’ status í™•ì¸
- status == DONE
- GET /student/results/exams/{exam_id}/

---

## ğŸ”’ ìµœì¢… ë´‰ì¸ ì„ ì–¸
- ì´ ë¬¸ì„œëŠ” í˜„ì¬ ì½”ë“œ ê¸°ì¤€ ìµœì¢… API ê³„ì•½(ìš”ì•½ë³¸)
- Submission / Results / Grading ë‹¨ì¼ ì§„ì‹¤ ì¼ì¹˜
- í”„ë¡ íŠ¸Â·ì›Œì»¤Â·ë°±ì—”ë“œ ë¶„ë¦¬ ì™„ì„±


==========================================================================================
# FILE: z_results_domain_spec_list.md
==========================================================================================
# PATH: docs/contracts/results_domain_spec_list.md
# ğŸ§¾ RESULTS ë„ë©”ì¸ ìŠ¤í™ ë‚˜ì—´ (ìµœì†Œ ì„¤ëª…)

ì•„ë˜ëŠ” â€œresults ë„ë©”ì¸â€ì´ ì œê³µí•˜ëŠ” ìŠ¤í™(ê·œì¹™/endpoint/SSOT)ì„ ìµœì†Œ ì„¤ëª…ìœ¼ë¡œ ë‚˜ì—´í•œë‹¤.

---

## 1) ë‹¨ì¼ ì§„ì‹¤(SSOT)

- ê²°ê³¼ ìŠ¤ëƒ…ìƒ·: Result (+ ResultItem)
- ë³€ê²½ ë¡œê·¸: ResultFact (append-only)
- ì¬ì‹œí—˜/ëŒ€í‘œ: ExamAttempt (ëŒ€í‘œ attempt 1ê°œ invariant)
- clinic_required: progress.ClinicLink(is_auto=True) + resolved_at is null
- ì‹œí—˜-ì„¸ì…˜ ë§¤í•‘ SSOT:
  - get_exams_for_session(session)
  - get_sessions_for_exam(exam_id)
  - get_primary_session_for_exam(exam_id)
  - get_session_ids_for_exam(exam_id)

- í†µê³„/ì§‘ê³„ ì¤‘ë³µ ë°©ì–´ SSOT:
  - latest_results_per_enrollment(target_type, target_id)

---

## 2) Admin/Teacher API

- ì‹œí—˜ ê²°ê³¼ í…Œì´ë¸”:
  - GET /api/v1/results/admin/exams/{exam_id}/results/

- ì‹œí—˜ ìš”ì•½:
  - GET /api/v1/results/admin/exams/{exam_id}/summary/

- ì‹œí—˜ ê²°ê³¼ ìƒì„¸(ë‹¨ì¼ í•™ìƒ):
  - GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/

- Attempt ëª©ë¡(ë‹¨ì¼ í•™ìƒ):
  - GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

- ëŒ€í‘œ attempt êµì²´:
  - POST /api/v1/results/admin/exams/{exam_id}/representative-attempt/

- ë¬¸í•­ ìˆ˜ë™ ì±„ì (ì ìˆ˜ ìˆ˜ì •):
  - PATCH /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

- Fact ë””ë²„ê·¸:
  - GET /api/v1/results/admin/facts/?exam_id=&enrollment_id=&limit=

- ì„¸ì…˜â†’ì‹œí—˜ ëª©ë¡:
  - GET /api/v1/results/admin/sessions/{session_id}/exams/

- ì„¸ì…˜ ê¸°ì¤€ ì‹œí—˜ ìš”ì•½:
  - GET /api/v1/results/admin/sessions/{session_id}/exams/summary/

- ì„¸ì…˜ ì ìˆ˜ íƒ­(ì‹œí—˜+ê³¼ì œ):
  - GET /api/v1/results/admin/sessions/{session_id}/scores/

- ì„¸ì…˜ ì„±ì  ìš”ì•½:
  - GET /api/v1/results/admin/sessions/{session_id}/score-summary/

- í´ë¦¬ë‹‰ ëŒ€ìƒì:
  - GET /api/v1/results/admin/clinic-targets/

- ë¬¸í•­ í†µê³„:
  - GET /api/v1/results/admin/exams/{exam_id}/questions/
  - GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=
  - GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/

---

## 3) Student API

- ëŒ€í‘œ ê²°ê³¼:
  - GET /api/v1/results/me/exams/{exam_id}/

- attempt íˆìŠ¤í† ë¦¬:
  - GET /api/v1/results/me/exams/{exam_id}/attempts/

- ì˜¤ë‹µë…¸íŠ¸:
  - GET /api/v1/results/wrong-notes/?enrollment_id=...

- ì˜¤ë‹µë…¸íŠ¸ PDF job ìƒì„±/ìƒíƒœ:
  - POST /api/v1/results/wrong-notes/pdf/
  - GET  /api/v1/results/wrong-notes/pdf/{job_id}/

---

## 4) Worker API (WrongNote PDF)

- GET  /api/v1/internal/wrong-note-worker/next/
- GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
- POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
- POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
- POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


==========================================================================================
# FILE: z_zfrontend_api_spec_results.md
==========================================================================================
# PATH: docs/contracts/frontend_api_spec_results.md
# ğŸ“— FRONTEND API SPEC (RESULTS ì¤‘ì‹¬) â€” ê³ ì • ê³„ì•½

ì´ ë¬¸ì„œëŠ” í”„ë¡ íŠ¸ê°€ â€œê³„ì•½ë§Œ ë³´ê³ â€ ê°œë°œí•  ìˆ˜ ìˆë„ë¡,
results ë„ë©”ì¸ ê¸°ì¤€ endpoint/ì˜ë¯¸ë§Œ ê°„ë‹¨íˆ ê³ ì •í•œë‹¤.

ì›ì¹™
- í”„ë¡ íŠ¸ëŠ” ìƒíƒœ + ëŒ€í‘œ ê²°ê³¼ë§Œ ì‹ ë¢°
- ì¡°íšŒ APIëŠ” ë¶€ìˆ˜íš¨ê³¼ ì—†ìŒ
- ê²°ê³¼/í†µê³„ëŠ” results SSOTë§Œ ì‚¬ìš©
- Clinic ëŒ€ìƒì/í†µê³¼ìœ¨ì€ progress ë‹¨ì¼ì§„ì‹¤(ClinicLink/SessionProgress)ë¡œ ê³„ì‚°ëœ ê²°ê³¼ë§Œ ì¡°íšŒ

---

## A) í•™ìƒ(Student)

### A-1) ëŒ€í‘œ ê²°ê³¼(ì‹œí—˜)
GET /api/v1/results/me/exams/{exam_id}/
- ë°˜í™˜: Result ìŠ¤ëƒ…ìƒ· + items
- í¬í•¨: allow_retake, max_attempts, can_retake
- í¬í•¨: clinic_required (ClinicLink(is_auto=True) ê¸°ì¤€)

### A-2) ì¬ì‹œí—˜ íˆìŠ¤í† ë¦¬(ì„ íƒ)
GET /api/v1/results/me/exams/{exam_id}/attempts/
- ë°˜í™˜: attempt_id, attempt_index, is_retake, is_representative, status, created_at

### A-3) ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ
GET /api/v1/results/wrong-notes/?enrollment_id=&exam_id=&lecture_id=&from_session_order=&offset=&limit=
- ë°˜í™˜: count, next, prev, results[]

### A-4) ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Job
POST /api/v1/results/wrong-notes/pdf/
Body: { enrollment_id, lecture_id?, exam_id?, from_session_order? }

### A-5) ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ
GET /api/v1/results/wrong-notes/pdf/{job_id}/
- ë°˜í™˜: status + file_url(DONE ì‹œ)

---

## B) ê´€ë¦¬ì/êµì‚¬(Admin/Teacher)

### B-1) ì‹œí—˜ ê²°ê³¼ í…Œì´ë¸”
GET /api/v1/results/admin/exams/{exam_id}/results/

### B-2) ì‹œí—˜ ìš”ì•½(í‰ê· /ìµœì†Œ/ìµœëŒ€/í•©ë¶ˆ/í´ë¦¬ë‹‰)
GET /api/v1/results/admin/exams/{exam_id}/summary/

### B-3) ì‹œí—˜ ë¬¸í•­ í†µê³„
GET /api/v1/results/admin/exams/{exam_id}/questions/
GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=
GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/

### B-4) Attempt ëª©ë¡(íŠ¹ì • ì‹œí—˜+íŠ¹ì • enrollment)
GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

### B-5) ëŒ€í‘œ Attempt êµì²´(ìŠ¤ëƒ…ìƒ· ì¬ë¹Œë“œ + progress íŠ¸ë¦¬ê±°)
POST /api/v1/results/admin/exams/{exam_id}/representative-attempt/
Body: { enrollment_id, attempt_id }

### B-6) ë¬¸í•­ ì ìˆ˜ ìˆ˜ë™ ìˆ˜ì •(append-only Fact + progress íŠ¸ë¦¬ê±°)
PATCH /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/
Body: { score }

### B-7) ì„¸ì…˜ ê¸°ì¤€ ì‹œí—˜ ìš”ì•½(1 Session : N Exams)
GET /api/v1/results/admin/sessions/{session_id}/exams/summary/

### B-8) ì„¸ì…˜ â†’ Exams ëª©ë¡
GET /api/v1/results/admin/sessions/{session_id}/exams/

### B-9) ì„¸ì…˜ ì ìˆ˜ íƒ­(ì‹œí—˜+ê³¼ì œ ì¡°í•©)
GET /api/v1/results/admin/sessions/{session_id}/scores/

### B-10) ì„¸ì…˜ ì„±ì  ìš”ì•½(ëŒ€ì‹œë³´ë“œ ì…ë ¥ìš©)
GET /api/v1/results/admin/sessions/{session_id}/score-summary/

### B-11) í´ë¦¬ë‹‰ ëŒ€ìƒì(ê´€ë¦¬ì íŒ¨ë„)
GET /api/v1/results/admin/clinic-targets/

---

## C) ë‚´ë¶€ Worker (WrongNote PDF)

Bearer token ì¸ì¦ í•„ìš”

- GET  /api/v1/internal/wrong-note-worker/next/
- GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
- POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
- POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
- POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


==========================================================================================
# FILE: aggregations/__init__.py
==========================================================================================
# PATH: apps/domains/results/aggregations/__init__.py
from .session_results import (
    build_session_results_snapshot,
    build_session_scores_matrix_snapshot,
)
from .lecture_results import (
    build_lecture_results_snapshot,
)
from .global_results import (
    build_global_results_snapshot,
)

__all__ = [
    "build_session_results_snapshot",
    "build_session_scores_matrix_snapshot",
    "build_lecture_results_snapshot",
    "build_global_results_snapshot",
]


==========================================================================================
# FILE: aggregations/global_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/global_results.py
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, Optional

from django.db.models import Count
from django.utils import timezone

from apps.domains.lectures.models import Lecture, Session
from apps.domains.progress.models import SessionProgress, ClinicLink

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_dt(v: Any) -> Optional[datetime]:
    if v is None:
        return None
    if isinstance(v, datetime):
        return v
    try:
        # "2026-02-02T00:00:00Z" ë“± ISO ì…ë ¥ ë°©ì–´
        return datetime.fromisoformat(str(v).replace("Z", "+00:00"))
    except Exception:
        return None


def build_global_results_snapshot(
    *,
    lecture_id: Optional[int] = None,
    from_dt: Optional[Any] = None,
    to_dt: Optional[Any] = None,
) -> Dict[str, Any]:
    """
    âœ… ìš´ì˜ìš© ê¸€ë¡œë²Œ ìš”ì•½ (ëŒ€ì‹œë³´ë“œ/ê´€ë¦¬ì í™ˆ ì…ë ¥)

    ë‹¨ì¼ ì§„ì‹¤:
    - participant_count: SessionProgress row count
    - clinic_count: ClinicLink(is_auto=True) enrollment distinct (ì„¸ì…˜ í•©ê³„)
    - exam_result_count: Result (enrollment ì¤‘ë³µ ë°©ì–´ latest_results_per_enrollment) í•©ê³„
      (ì—¬ê¸°ì„œëŠ” "ì‹œí—˜ ìˆ˜ * ì°¸ê°€ì ìˆ˜" ì„±ê²©ì´ë¯€ë¡œ ë‹¨ìˆœí•œ 'ê±´ìˆ˜'ë¡œë§Œ ì œê³µ)

    ë°˜í™˜(ê³ ì •):
    {
      "scope": {"lecture_id": int|null, "from": iso|null, "to": iso|null},
      "session_count": int,
      "participant_count": int,
      "clinic_enrollment_distinct_count": int,
      "exam_latest_result_count": int,
      "generated_at": "iso"
    }
    """
    l_id = _safe_int(lecture_id) if lecture_id is not None else None
    fdt = _safe_dt(from_dt)
    tdt = _safe_dt(to_dt)

    sessions = Session.objects.all()

    if l_id:
        sessions = sessions.filter(lecture_id=int(l_id))

    # ì‹œê°„ ë²”ìœ„ëŠ” session.open_at/close_at ê°™ì€ í•„ë“œê°€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆì–´
    # ì—¬ê¸°ì„œëŠ” "id ê¸°ë°˜ ì „ì²´"ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•˜ë˜, created_at/updated_atì´ ìˆìœ¼ë©´ ì œí•œí•œë‹¤.
    if fdt or tdt:
        # best-effort: updated_at â†’ created_at ìˆœìœ¼ë¡œ ì‹œë„
        if hasattr(Session, "updated_at"):
            if fdt:
                sessions = sessions.filter(updated_at__gte=fdt)
            if tdt:
                sessions = sessions.filter(updated_at__lt=tdt)
        elif hasattr(Session, "created_at"):
            if fdt:
                sessions = sessions.filter(created_at__gte=fdt)
            if tdt:
                sessions = sessions.filter(created_at__lt=tdt)

    session_ids = list(sessions.values_list("id", flat=True))
    session_count = len(session_ids)

    if not session_ids:
        return {
            "scope": {
                "lecture_id": l_id,
                "from": fdt.isoformat() if fdt else None,
                "to": tdt.isoformat() if tdt else None,
            },
            "session_count": 0,
            "participant_count": 0,
            "clinic_enrollment_distinct_count": 0,
            "exam_latest_result_count": 0,
            "generated_at": timezone.now().isoformat(),
        }

    participant_count = SessionProgress.objects.filter(session_id__in=session_ids).count()

    # clinic enrollment distinct (ì„¸ì…˜ í•©ê³„ ê¸°ì¤€)
    clinic_enrollment_distinct_count = (
        ClinicLink.objects.filter(session_id__in=session_ids, is_auto=True)
        .values("enrollment_id")
        .distinct()
        .count()
    )

    # exam ìµœì‹  Result count (ì‹œí—˜ ê±´ìˆ˜ ì„±ê²©)
    exam_latest_result_count = 0
    try:
        # Session -> Exams ìŠ¤ìº”
        # (ë§ì€ ì„¸ì…˜ì—ì„œ N+1ì´ ë  ìˆ˜ ìˆìœ¼ë‚˜ ê¸€ë¡œë²Œ ìš”ì•½ì€ ìš´ì˜ì—ì„œ í˜¸ì¶œ ë¹ˆë„ ë‚®ë‹¤ê³  ê°€ì •)
        exam_ids = set()
        for sid in session_ids:
            s = Session.objects.filter(id=int(sid)).first()
            if not s:
                continue
            for ex in get_exams_for_session(s):
                exid = getattr(ex, "id", None)
                if exid:
                    exam_ids.add(int(exid))

        for exid in exam_ids:
            rs = latest_results_per_enrollment(target_type="exam", target_id=int(exid))
            exam_latest_result_count += rs.count()
    except Exception:
        exam_latest_result_count = 0

    return {
        "scope": {
            "lecture_id": l_id,
            "from": fdt.isoformat() if fdt else None,
            "to": tdt.isoformat() if tdt else None,
        },
        "session_count": int(session_count),
        "participant_count": int(participant_count),
        "clinic_enrollment_distinct_count": int(clinic_enrollment_distinct_count),
        "exam_latest_result_count": int(exam_latest_result_count),
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: aggregations/lecture_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/lecture_results.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

from django.db.models import Avg, Min, Max, Count
from django.utils import timezone

from apps.domains.lectures.models import Lecture, Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _safe_str(v: Any) -> str:
    try:
        return str(v or "")
    except Exception:
        return ""


def _policy_meta_for_lecture(lecture: Lecture) -> Dict[str, str]:
    try:
        policy = ProgressPolicy.objects.filter(lecture=lecture).first()
        strategy = _safe_str(getattr(policy, "exam_aggregate_strategy", "MAX") or "MAX")
        pass_source = _safe_str(getattr(policy, "exam_pass_source", "EXAM") or "EXAM")
        return {
            "strategy": strategy,
            "pass_source": pass_source,
        }
    except Exception:
        return {
            "strategy": "MAX",
            "pass_source": "EXAM",
        }


def build_lecture_results_snapshot(
    *,
    lecture_id: int,
    include_exam_level_stats: bool = False,
) -> Dict[str, Any]:
    """
    âœ… Lecture ë‹¨ìœ„ ìŠ¤ëƒ…ìƒ· (ì„¸ì…˜ ì§‘ê³„ ê¸°ë°˜)

    ë‹¨ì¼ ì§„ì‹¤:
    - ì„¸ì…˜ë³„ pass_rate: SessionProgress.exam_passed ê¸°ì¤€
    - ì„¸ì…˜ë³„ clinic_rate: ClinicLink(is_auto=True) ê¸°ì¤€
    - (ì˜µì…˜) ì‹œí—˜ ë‹¨ìœ„ í†µê³„ëŠ” Result ê¸°ë°˜ + latest_results_per_enrollment

    ë°˜í™˜ ìŠ¤í‚¤ë§ˆ(ê³ ì •):
    {
      "lecture_id": int,
      "strategy": str,
      "pass_source": str,
      "session_count": int,
      "sessions": [
        {
          "session_id": int,
          "order": int|None,
          "participant_count": int,
          "pass_rate": float,
          "clinic_rate": float,
          "exams": [ ... ] | []
        }
      ],
      "generated_at": "iso"
    }
    """
    lecture = Lecture.objects.filter(id=_safe_int(lecture_id)).first()
    if not lecture:
        return {
            "lecture_id": _safe_int(lecture_id),
            "strategy": "MAX",
            "pass_source": "EXAM",
            "session_count": 0,
            "sessions": [],
            "generated_at": timezone.now().isoformat(),
        }

    meta = _policy_meta_for_lecture(lecture)

    sessions_qs = Session.objects.filter(lecture=lecture).order_by("id")
    if hasattr(Session, "order"):
        try:
            sessions_qs = sessions_qs.order_by("order", "id")
        except Exception:
            sessions_qs = sessions_qs.order_by("id")

    rows: List[Dict[str, Any]] = []
    for s in sessions_qs:
        sp_qs = SessionProgress.objects.filter(session=s)
        participant_count = sp_qs.count()

        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        clinic_count = (
            ClinicLink.objects.filter(session=s, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        ex_rows: List[Dict[str, Any]] = []
        if include_exam_level_stats:
            exams = list(get_exams_for_session(s))
            for ex in exams:
                exid = _safe_int(getattr(ex, "id", 0))
                if not exid:
                    continue

                rs = latest_results_per_enrollment(target_type="exam", target_id=exid)

                agg = rs.aggregate(
                    participant_count=Count("id"),
                    avg_score=Avg("total_score"),
                    min_score=Min("total_score"),
                    max_score=Max("total_score"),
                )

                pass_score = _safe_float(getattr(ex, "pass_score", 0.0) or 0.0)
                pcount = rs.filter(total_score__gte=pass_score).count()
                fcount = rs.filter(total_score__lt=pass_score).count()

                p_total = _safe_int(agg["participant_count"] or 0)
                p_rate = (pcount / p_total) if p_total else 0.0

                ex_rows.append(
                    {
                        "exam_id": exid,
                        "title": _safe_str(getattr(ex, "title", "")),
                        "pass_score": float(pass_score),
                        "participant_count": int(p_total),
                        "avg_score": float(agg["avg_score"] or 0.0),
                        "min_score": float(agg["min_score"] or 0.0),
                        "max_score": float(agg["max_score"] or 0.0),
                        "pass_count": int(pcount),
                        "fail_count": int(fcount),
                        "pass_rate": round(float(p_rate), 4),
                    }
                )

        rows.append(
            {
                "session_id": int(s.id),
                "order": _safe_int(getattr(s, "order", None), 0) if getattr(s, "order", None) is not None else None,
                "participant_count": int(participant_count),
                "pass_rate": round(float(pass_rate), 4),
                "clinic_rate": round(float(clinic_rate), 4),
                "exams": ex_rows,
            }
        )

    return {
        "lecture_id": int(lecture.id),
        "strategy": str(meta["strategy"]),
        "pass_source": str(meta["pass_source"]),
        "session_count": int(sessions_qs.count()),
        "sessions": rows,
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: aggregations/session_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/session_results.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Avg, Min, Max, Count
from django.utils import timezone

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


@dataclass(frozen=True)
class SessionExamStatRow:
    exam_id: int
    title: str
    pass_score: float

    participant_count: int
    avg_score: float
    min_score: float
    max_score: float

    pass_count: int
    fail_count: int
    pass_rate: float


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_str(v: Any) -> str:
    try:
        return str(v or "")
    except Exception:
        return ""


def _policy_meta_for_session(session: Session) -> Dict[str, str]:
    """
    ProgressPolicyëŠ” progress ë„ë©”ì¸ì˜ ë‹¨ì¼ ì§„ì‹¤.
    ë‹¨, results ì§‘ê³„ëŠ” "í‘œì‹œìš© ë©”íƒ€"ë§Œ ê°€ì ¸ì˜¨ë‹¤.
    """
    try:
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = _safe_str(getattr(policy, "exam_aggregate_strategy", "MAX") or "MAX")
        pass_source = _safe_str(getattr(policy, "exam_pass_source", "EXAM") or "EXAM")
        return {
            "strategy": strategy,
            "pass_source": pass_source,
        }
    except Exception:
        return {
            "strategy": "MAX",
            "pass_source": "EXAM",
        }


def build_session_results_snapshot(*, session_id: int) -> Dict[str, Any]:
    """
    âœ… Session ë‹¨ìœ„ ì‹œí—˜ ìš”ì•½ ìŠ¤ëƒ…ìƒ· (ì§‘ê³„)

    - participant_count: SessionProgress ê¸°ì¤€
    - pass_rate: SessionProgress.exam_passed ê¸°ì¤€ (ì„¸ì…˜ ì§‘ê³„ ë‹¨ì¼ ì§„ì‹¤)
    - clinic_rate: ClinicLink(is_auto=True) enrollment distinct ê¸°ì¤€ (ë‹¨ì¼ ì§„ì‹¤)
    - exams[]: ì‹œí—˜ ë‹¨ìœ„ í†µê³„ëŠ” Result ê¸°ë°˜ (ë‹¨, enrollment ì¤‘ë³µ ë°©ì–´ latest_results_per_enrollment)

    ë°˜í™˜ ìŠ¤í‚¤ë§ˆ(ê³ ì •):
    {
      "session_id": int,
      "participant_count": int,
      "pass_rate": float,
      "clinic_rate": float,
      "strategy": str,
      "pass_source": str,
      "exams": [ ... ],
      "generated_at": "iso"
    }
    """
    session = Session.objects.filter(id=_safe_int(session_id)).select_related("lecture").first()
    if not session:
        return {
            "session_id": _safe_int(session_id),
            "participant_count": 0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "strategy": "MAX",
            "pass_source": "EXAM",
            "exams": [],
            "generated_at": timezone.now().isoformat(),
        }

    # ì •ì±… ë©”íƒ€ (í‘œì‹œìš©)
    meta = _policy_meta_for_session(session)
    strategy = meta["strategy"]
    pass_source = meta["pass_source"]

    # ì„¸ì…˜ ëª¨ìˆ˜/í†µê³¼ìœ¨(ì§‘ê³„ ë‹¨ì¼ ì§„ì‹¤)
    sp_qs = SessionProgress.objects.filter(session=session)
    participant_count = sp_qs.count()

    pass_count = sp_qs.filter(exam_passed=True).count()
    pass_rate = (pass_count / participant_count) if participant_count else 0.0

    # clinic_rate(ë‹¨ì¼ ì§„ì‹¤)
    clinic_count = (
        ClinicLink.objects.filter(session=session, is_auto=True)
        .values("enrollment_id")
        .distinct()
        .count()
    )
    clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

    # ì‹œí—˜ ë‹¨ìœ„ í†µê³„ (Result ê¸°ë°˜, enrollment ì¤‘ë³µ ë°©ì–´)
    exams = list(get_exams_for_session(session))
    exam_rows: List[Dict[str, Any]] = []

    for ex in exams:
        exid = _safe_int(getattr(ex, "id", 0))
        if not exid:
            continue

        rs = latest_results_per_enrollment(
            target_type="exam",
            target_id=exid,
        )

        agg = rs.aggregate(
            participant_count=Count("id"),  # enrollment 1ê°œì”©ìœ¼ë¡œ ì¤„ì˜€ìœ¼ë‹ˆ count(id)=participant
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_score = _safe_float(getattr(ex, "pass_score", 0.0) or 0.0)
        pcount = rs.filter(total_score__gte=pass_score).count()
        fcount = rs.filter(total_score__lt=pass_score).count()

        p_total = _safe_int(agg["participant_count"] or 0)
        p_rate = (pcount / p_total) if p_total else 0.0

        exam_rows.append(
            {
                "exam_id": exid,
                "title": _safe_str(getattr(ex, "title", "")),
                "pass_score": float(pass_score),
                "participant_count": int(p_total),
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),
                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            }
        )

    return {
        "session_id": int(session.id),
        "participant_count": int(participant_count),
        "pass_rate": round(float(pass_rate), 4),
        "clinic_rate": round(float(clinic_rate), 4),
        "strategy": str(strategy),
        "pass_source": str(pass_source),
        "exams": exam_rows,
        "generated_at": timezone.now().isoformat(),
    }


def build_session_scores_matrix_snapshot(*, session_id: int) -> Dict[str, Any]:
    """
    âœ… Session ì„±ì  íƒ­ìš© "í–‰ë ¬ ìŠ¤ëƒ…ìƒ·"

    ì£¼ì˜:
    - ì´ í•¨ìˆ˜ëŠ” SessionScoresViewì˜ 'ì§‘ê³„ ë¡œì§'ì„ ì¬ì‚¬ìš©í•˜ê³  ì‹¶ì„ ë•Œ ì“°ëŠ” ëª©ì .
    - results ë„ë©”ì¸ì—ì„œ "ì›ë³¸ ë°ì´í„°/ì •ì±…"ì„ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤.
    - ì—¬ê¸°ì„œëŠ” Viewë¥¼ importí•´ì„œ í˜¸ì¶œí•˜ì§€ ì•Šê³ , í•„ìš”í•œ ìµœì†Œ ì¡°í•©ë§Œ ì œê³µí•œë‹¤.

    ë°˜í™˜(ê³ ì •):
    {
      "session_id": int,
      "exam_ids": [...],
      "participant_count": int,
      "generated_at": "iso"
    }

    (ì‹¤ì œ í…Œì´ë¸” rowsëŠ” SessionScoresViewê°€ ì´ë¯¸ ì œê³µí•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë©”íƒ€ë§Œ ì œê³µ)
    """
    session = Session.objects.filter(id=_safe_int(session_id)).select_related("lecture").first()
    if not session:
        return {
            "session_id": _safe_int(session_id),
            "exam_ids": [],
            "participant_count": 0,
            "generated_at": timezone.now().isoformat(),
        }

    exams = list(get_exams_for_session(session))
    exam_ids = [int(getattr(e, "id", 0) or 0) for e in exams if int(getattr(e, "id", 0) or 0)]

    participant_count = SessionProgress.objects.filter(session=session).count()

    return {
        "session_id": int(session.id),
        "exam_ids": exam_ids,
        "participant_count": int(participant_count),
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_add_exam_attempt_meta.py
==========================================================================================
# apps/domains/results/migrations/0002_add_exam_attempt_meta.py
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("results", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="examattempt",
            name="meta",
            field=models.JSONField(
                null=True,
                blank=True,
                help_text=(
                    "Attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„°. "
                    "OMR/AI íŒë… ì •ë³´, total_score, pass_score, "
                    "ì¬ì±„ì  ê·¼ê±° ë“± ìš´ì˜/ë¶„ì„ìš© ì •ë³´ ì €ì¥."
                ),
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0003_examresult.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-01 15:34

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("exams", "0006_alter_sheet_unique_together_exam_template_exam_and_more"),
        ("results", "0002_add_exam_attempt_meta"),
        ("submissions", "0002_alter_submissionanswer_exam_question_id_and_more"),
    ]

    operations = [
        migrations.CreateModel(
            name="ExamResult",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("max_score", models.FloatField(default=0.0)),
                ("total_score", models.FloatField(default=0.0)),
                ("objective_score", models.FloatField(default=0.0)),
                ("subjective_score", models.FloatField(default=0.0)),
                (
                    "status",
                    models.CharField(
                        choices=[("DRAFT", "Draft"), ("FINAL", "Final")],
                        default="DRAFT",
                        max_length=10,
                    ),
                ),
                ("finalized_at", models.DateTimeField(blank=True, null=True)),
                ("breakdown", models.JSONField(blank=True, default=dict)),
                ("manual_overrides", models.JSONField(blank=True, default=dict)),
                ("is_passed", models.BooleanField(default=False)),
                (
                    "exam",
                    models.ForeignKey(
                        help_text="regular exam",
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="results",
                        to="exams.exam",
                    ),
                ),
                (
                    "submission",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="exam_result",
                        to="submissions.submission",
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_result",
                "indexes": [
                    models.Index(
                        fields=["exam", "total_score"], name="results_exam_score_idx"
                    ),
                    models.Index(
                        fields=["exam", "status", "created_at"],
                        name="results_exam_status_crted_idx",
                    ),
                ],
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF
from .exam_result import ExamResult

# âŒ SubmissionAnswer ì œê±°ë¨ (raw inputì€ submissions ë„ë©”ì¸ ì±…ì„)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
    "ExamResult",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
# apps/domains/results/models/exam_attempt.py
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    í•™ìƒì˜ 'ì‹œí—˜ 1íšŒ ì‘ì‹œ'ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—”í‹°í‹° (append-only)

    ğŸ”¥ í•µì‹¬ ì±…ì„
    - Submission ë‹¨ìœ„ê°€ ì•„ë‹Œ 'ì‹œí—˜ ì‘ì‹œ ì‚¬ì‹¤'ì˜ ê³ ì •
    - Result / ResultFact / Progress ì§‘ê³„ì˜ ê¸°ì¤€ì 
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ì˜ ë‹¨ìœ„

    âœ… ì„¤ê³„ ê³ ì • ì‚¬í•­
    --------------------------------------------------
    1) ExamAttemptëŠ” append-only ê°œë…ì´ë‹¤.
       - ê¸°ì¡´ attemptë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ë‹¤.
       - ëŒ€í‘œ attempt ë³€ê²½ì€ is_representative í”Œë˜ê·¸ë¡œë§Œ ì²˜ë¦¬í•œë‹¤.

    2) Result / ResultItemì€ í•­ìƒ
       "ëŒ€í‘œ attempt(is_representative=True)"ë¥¼ ê°€ë¦¬í‚¤ëŠ” snapshotì´ë‹¤.

    3) meta í•„ë“œëŠ” attempt ë‹¨ìœ„ì˜ 'ìš´ì˜/ë¶„ì„/ì¬ì±„ì  ê·¼ê±°'ë¥¼ ì €ì¥í•œë‹¤.
       - OMR ì‹ ë¢°ë„
       - AI íŒë… ê²°ê³¼
       - total_score / pass_score ìŠ¤ëƒ…ìƒ·
       - ì¬ì±„ì  ì‚¬ìœ  ë“±
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # Submissionì€ ì‹œë„ì˜ ì›ì¸(event)
    submission_id = models.PositiveIntegerField(
        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
    )

    # 1ë¶€í„° ì‹œì‘ (ì‹œí—˜ në²ˆì§¸ ì‘ì‹œ)
    attempt_index = models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")

    # ì¬ì‹œí—˜ ì—¬ë¶€ (attempt_index > 1 ê³¼ ì˜ë¯¸ì ìœ¼ë¡œ ë™ì¼í•˜ì§€ë§Œ, ì¡°íšŒ ìµœì í™”ìš©)
    is_retake = models.BooleanField(default=False)

    # ì„œë²„ê°€ íŒë‹¨í•˜ëŠ” ëŒ€í‘œ attempt
    # ResultëŠ” í•­ìƒ ì´ attemptë¥¼ ê¸°ì¤€ìœ¼ë¡œ snapshotì„ ë§Œë“ ë‹¤.
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ìƒì„±ë¨
            ("grading", "Grading"),     # ì±„ì  ì¤‘
            ("done", "Done"),           # ì±„ì  ì™„ë£Œ
            ("failed", "Failed"),       # ì±„ì  ì‹¤íŒ¨
        ],
        default="pending",
    )

    # ==================================================
    # âœ… NEW: attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„° (ì„¤ê³„ í•„ìˆ˜)
    # ==================================================
    meta = models.JSONField(
        null=True,
        blank=True,
        help_text=(
            "Attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„°. "
            "OMR/AI íŒë… ì •ë³´, total_score, pass_score, "
            "ì¬ì±„ì  ê·¼ê±° ë“± ìš´ì˜/ë¶„ì„ìš© ì •ë³´ ì €ì¥."
        ),
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/exam_result.py
==========================================================================================
from __future__ import annotations

from django.db import models
from django.utils import timezone

from apps.api.common.models import BaseModel


class ExamResult(BaseModel):
    """
    results SSOT

    - submission ë‹¨ìœ„ ê²°ê³¼ 1ê°œ (unique)
    - objectiveëŠ” ìë™ì±„ì 
    - subjective/descriptiveëŠ” ìˆ˜ë™ì±„ì (override)
    - finalized ë˜ë©´ ë¶ˆë³€(ìš´ì˜ ì‚¬ê³  ì°¨ë‹¨)
    """

    class Status(models.TextChoices):
        DRAFT = "DRAFT", "Draft"
        FINAL = "FINAL", "Final"

    submission = models.OneToOneField(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="exam_result",
    )

    exam = models.ForeignKey(
        "exams.Exam",
        on_delete=models.CASCADE,
        related_name="results",
        help_text="regular exam",
    )

    # ì ìˆ˜
    max_score = models.FloatField(default=0.0)
    total_score = models.FloatField(default=0.0)
    objective_score = models.FloatField(default=0.0)
    subjective_score = models.FloatField(default=0.0)

    # ìƒíƒœ/í™•ì •
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.DRAFT)
    finalized_at = models.DateTimeField(null=True, blank=True)

    # ìƒì„¸ ë‚´ì—­ (í”„ë¡ íŠ¸/ë””ë²„ê¹…/ì˜¤ë‹µë…¸íŠ¸ìš©)
    # ì˜ˆ: {"1": {"correct": true, "earned": 1, "answer": "A", "correct_answer": "A", "question_id": 123}, ...}
    breakdown = models.JSONField(default=dict, blank=True)

    # ìˆ˜ë™ ì±„ì  override (ë²ˆí˜¸ ê¸°ì¤€)
    # ì˜ˆ: {"6": {"earned": 2, "comment": "ê³„ì‚° ì‹¤ìˆ˜"}, "10": {"earned": 0, "comment": "ë¯¸ì œì¶œ"}}
    manual_overrides = models.JSONField(default=dict, blank=True)

    # pass/fail (ê³„ì‚° ê²°ê³¼ ì €ì¥í•´ë‘ë©´ UXê°€ ì‰¬ì›€)
    is_passed = models.BooleanField(default=False)

    class Meta:
        db_table = "results_exam_result"
        indexes = [
            models.Index(fields=["exam", "total_score"], name="results_exam_score_idx"),
            models.Index(
                fields=["exam", "status", "created_at"],
                name="results_exam_status_crted_idx",
            ),

        ]

    def finalize(self):
        self.status = self.Status.FINAL
        self.finalized_at = timezone.now()
        self.save(update_fields=["status", "finalized_at", "updated_at"])


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ì‹œí—˜/ìˆ™ì œ ê²°ê³¼ ìµœì‹  ìŠ¤ëƒ…ìƒ· (ì¡°íšŒìš©)
    ê³„ì‚° ì—†ìŒ

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Resultê°€ ì–´ë–¤ ExamAttempt(ì‹œë„)ë¥¼ ëŒ€í‘œí•˜ëŠ”ì§€ ì¶”ì  ê°€ëŠ¥
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ ì‹œì—ë„ "ì–´ë–¤ attempt ê²°ê³¼ì¸ì§€" ëª…í™•í•´ì§

    âš ï¸ ì£¼ì˜:
    - ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ attempt_idëŠ” ì¼ë‹¨ NULL í—ˆìš©ìœ¼ë¡œ ë“¤ì–´ê° (ë§ˆì´ê·¸ë ˆì´ì…˜ì—ì„œ null=True)
    - ìš´ì˜ì—ì„œ ë°±í•„ í›„ null=Falseë¡œ tighten í•˜ëŠ” 2ë‹¨ê³„ê°€ ì •ì„
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì˜ ê²°ê³¼ì¸ì§€ ì¶”ì  (ëŒ€í‘œ attempt ê¸°ì¤€)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    ê²°ê³¼ Fact (append-only, ë¶ˆë³€)
    - ì§‘ê³„/í†µê³„/ì´ë²¤íŠ¸ ë¡œê·¸ì— ê°€ê¹Œì›€

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Factê°€ ì–´ëŠ attemptì—ì„œ ë‚˜ì˜¨ ì´ë²¤íŠ¸ì¸ì§€ ì¶”ì  ê°€ëŠ¥

    âš ï¸ ë¦¬íŒ©í† ë§ ë©”ëª¨ (ì¤‘ìš”)
    ì§€ê¸ˆì€ ResultFactê°€ answer/score/meta/sourceê¹Œì§€ ë“¤ê³  ìˆìŒ.
    ì¥ê¸°ì ìœ¼ë¡œëŠ”:
      - ResultFact = "ì§‘ê³„ìš© ì´ë²¤íŠ¸"
      - ìƒì„¸/ì±„ì ê²°ê³¼ = results.SubmissionAnswer ê°€ ë“¤ê³  ê°€ëŠ” ê²Œ ì •ì„
    ë‹¤ë§Œ ì§€ê¸ˆ ë‹¨ê³„ì—ì„œëŠ” analytics ì œê±° + ë‹¨ìˆœ ìš´ì˜ì„ ìœ„í•´ ìœ ì§€.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì—ì„œ ìƒì„±ëœ Factì¸ì§€
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    ë¬¸í•­ë³„ ìµœì‹  ê²°ê³¼ ìƒíƒœ (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
# PATH: apps/domains/results/serializers/__init__.py
from .exam_result import ManualGradeSerializer, ExamResultSerializer

__all__ = [
    "ManualGradeSerializer",
    "ExamResultSerializer",
]


==========================================================================================
# FILE: serializers/admin_clinic_target.py
==========================================================================================
# PATH: apps/domains/results/serializers/admin_clinic_target.py
"""
ì—­í• 
- Admin/Teacherìš© "í´ë¦¬ë‹‰ ëŒ€ìƒì" ë¦¬ìŠ¤íŠ¸ ì‘ë‹µ ê³„ì•½ì„ ê³ ì •í•œë‹¤.

ì„¤ê³„ ê³„ì•½ (ì¤‘ìš”)
- Clinic ëŒ€ìƒì ì„ ì •/íŒë‹¨ì€ results ë„ë©”ì¸ì˜ ë‹¨ì¼ ì§„ì‹¤ì´ë‹¤.
- enrollment_id ê¸°ì¤€(ë‹¨ì¼ ì§„ì‹¤)ìœ¼ë¡œ ë‚´ë ¤ì¤€ë‹¤.
- í”„ë¡ íŠ¸ì˜ ClinicTarget íƒ€ì…ê³¼ 1:1ë¡œ ë§ì¶˜ë‹¤.

ë³´ë¥˜ëœ ê¸°ëŠ¥ (ëª…ì‹œ)
- reasonì˜ ì„¸ë¶€ íŒì •(ì ìˆ˜/ì‹ ë¢°ë„)ì€ ì„œë¹„ìŠ¤ì—ì„œ ë³´ìˆ˜ì ìœ¼ë¡œ íŒì •í•œë‹¤.
  (í”„ë¡œì íŠ¸ë§ˆë‹¤ LOW_CONFIDENCE ì‹ í˜¸ê°€ Attempt.metaì— ìˆì„ ìˆ˜ë„, ResultFact.metaì— ìˆì„ ìˆ˜ë„ ìˆì–´ ë°©ì–´ êµ¬í˜„)
"""

from rest_framework import serializers


class AdminClinicTargetSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    session_title = serializers.CharField()

    reason = serializers.ChoiceField(choices=["score", "confidence"])

    exam_score = serializers.FloatField()
    cutline_score = serializers.FloatField()

    created_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    # =====================================
    # ğŸ”§ PATCH: ì ìˆ˜ í•„ë“œ ëª…ì‹œì  ë¶„ë¦¬
    # - SessionScores / AdminExamResults ê³µìš© ê³„ì•½
    # - í”„ë¡ íŠ¸ ìˆ˜ì • ì—†ì´ í™•ì¥ ê°€ëŠ¥
    # =====================================
    exam_score = serializers.FloatField()
    exam_max_score = serializers.FloatField()

    final_score = serializers.FloatField()
    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # ğŸ”¥ Submission ì—°ë™ í•„ë“œ (ê¸°ì¡´ ìœ ì§€)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (ì‹ ê·œ)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/exam_result.py
from __future__ import annotations

from rest_framework import serializers

from apps.domains.results.models.exam_result import ExamResult


class ManualGradeItemSerializer(serializers.Serializer):
    exam_question_id = serializers.IntegerField()
    score = serializers.FloatField(required=False)
    is_correct = serializers.BooleanField(required=False)
    note = serializers.CharField(required=False, allow_blank=True)


class ManualGradeSerializer(serializers.Serializer):
    """
    Keep stable import name for views.
    Payload shape can evolve without breaking callers.
    """
    identifier = serializers.CharField(required=False, allow_blank=True)
    answers = serializers.ListField(child=serializers.DictField(), required=False)
    grades = serializers.ListField(child=ManualGradeItemSerializer(), required=False)
    note = serializers.CharField(required=False, allow_blank=True)
    overrides = serializers.ListField(child=ManualGradeItemSerializer(), required=False)


class ExamResultSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamResult
        fields = "__all__"


==========================================================================================
# FILE: serializers/question_stats.py
==========================================================================================
# apps/domains/results/serializers/question_stats.py

from rest_framework import serializers


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct = serializers.IntegerField()
    accuracy = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    distribution = serializers.DictField(
        child=serializers.IntegerField()
    )


class TopWrongQuestionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    wrong_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/session_exams_summary.py
==========================================================================================
# apps/domains/results/serializers/session_exams_summary.py
from rest_framework import serializers


class SessionExamRowSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    participant_count = serializers.IntegerField()
    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()


class SessionExamsSummarySerializer(serializers.Serializer):
    session_id = serializers.IntegerField()

    participant_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    strategy = serializers.CharField()
    pass_source = serializers.CharField()

    exams = SessionExamRowSerializer(many=True)


==========================================================================================
# FILE: serializers/session_score_summary.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_score_summary.py

from rest_framework import serializers


class SessionScoreSummarySerializer(serializers.Serializer):
    """
    ì„¸ì…˜ ë‹¨ìœ„ ì„±ì  ìš”ì•½ (ìš´ì˜/í†µê³„ìš©)

    âš ï¸ ì£¼ì˜
    - Result / ResultFact / Progress ê²°ê³¼ë§Œ ì‚¬ìš©
    - attempt êµì²´ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ ê°’
    """

    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    attempt_stats = serializers.DictField()


==========================================================================================
# FILE: serializers/session_scores.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_scores.py
"""
SessionScores Serializer (Score Tab)

âœ… ì„¤ê³„ ê³ ì •(ì¤‘ìš”)
- ì´ SerializerëŠ” "í‘œì‹œìš© DTO" ì´ë‹¤.
- ë„ë©”ì¸ ë¡œì§/íŒì •/ì •ì±… ê³„ì‚°ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤.
- Viewì—ì„œ ë§Œë“¤ì–´ì¤€ dictë¥¼ ê·¸ëŒ€ë¡œ validate/serializeë§Œ ìˆ˜í–‰í•œë‹¤.

âœ… í”„ë¡ íŠ¸ ê³„ì•½
- score === null ì€ "ë¯¸ì‚°ì¶œ/ë¯¸ì‘ì‹œ/ì²˜ë¦¬ì¤‘" ì˜ë¯¸
- is_locked / lock_reason ì€ ì…ë ¥ ë¹„í™œì„±í™” + tooltip ìš©ë„
"""

from __future__ import annotations

from rest_framework import serializers


class ScoreBlockSerializer(serializers.Serializer):
    score = serializers.FloatField(allow_null=True)
    max_score = serializers.FloatField(allow_null=True)

    passed = serializers.BooleanField(allow_null=True)
    clinic_required = serializers.BooleanField()

    is_locked = serializers.BooleanField()
    lock_reason = serializers.CharField(allow_null=True, allow_blank=True)


class ExamScoreBlockSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    block = ScoreBlockSerializer()


class HomeworkScoreBlockSerializer(serializers.Serializer):
    homework_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)

    block = ScoreBlockSerializer()


class SessionScoreRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField(allow_blank=True)

    exams = ExamScoreBlockSerializer(many=True)
    homeworks = HomeworkScoreBlockSerializer(many=True)

    updated_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ë¬¸í•­ë³„ ê²°ê³¼
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ì‹œí—˜ ê²°ê³¼(ì´ì  + ë¬¸í•­ë³„) + ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ê°’

    ì„¤ê³„:
    - Result ëª¨ë¸ ìì²´ëŠ” 'ìŠ¤ëƒ…ìƒ·'ì´ë¯€ë¡œ
      allow_retake/max_attempts/can_retakeëŠ” Exam ì •ì±… + Attempt ìƒíƒœë¡œ ê³„ì‚°í•´ì„œ ë‚´ë ¤ì¤€ë‹¤.
    - ì´ ê°’ë“¤ì€ "ì‘ë‹µ í•„ë“œ"ì´ì§€ Result DB í•„ë“œê°€ ì•„ë‹ˆë‹¤.
      â†’ Viewì—ì„œ ê³„ì‚° í›„ dataì— ì£¼ì…í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ë‹¨ìˆœ/ëª…í™•.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # âœ… STEP 2: í”„ë¡ íŠ¸ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ìš© (ì‘ë‹µ ì „ìš© í•„ë“œ)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # âœ… STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: serializers/wrong_note_pdf_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_pdf_serializers.py
from __future__ import annotations

from rest_framework import serializers


class WrongNotePDFStatusSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ ì‘ë‹µ

    âœ… í”„ë¡ íŠ¸ í´ë§ìš© ìµœì†Œ í•„ë“œ
    - status: PENDING/RUNNING/DONE/FAILED
    - file_url: DONEì¼ ë•Œ ë‹¤ìš´ë¡œë“œ URL
    - error_message: FAILEDì¼ ë•Œ í‘œì‹œ
    """
    job_id = serializers.IntegerField()
    status = serializers.CharField()
    file_path = serializers.CharField(allow_blank=True)
    file_url = serializers.CharField(allow_blank=True, allow_null=True)
    error_message = serializers.CharField(allow_blank=True)
    created_at = serializers.DateTimeField()
    updated_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/wrong_note_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_serializers.py
from __future__ import annotations

from typing import Any, Dict, Optional
from rest_framework import serializers


class WrongNoteItemSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ ë‹¨ì¼ ë¬¸í•­ ì•„ì´í…œ

    âœ… ì˜ë„:
    - ResultFact/ResultItem êµ¬ì¡°ê°€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ì¡°ê¸ˆ ë‹¬ë¼ë„
      Viewì—ì„œ dictë¡œ ë§Œë“¤ì–´ serialize ê°€ëŠ¥í•˜ê²Œ "ë‹¨ìˆœ Serializer"ë¡œ ê³ ì •
    """

    exam_id = serializers.IntegerField()
    attempt_id = serializers.IntegerField()
    attempt_created_at = serializers.DateTimeField(allow_null=True)

    question_id = serializers.IntegerField()
    question_number = serializers.IntegerField(required=False, allow_null=True)
    answer_type = serializers.CharField(required=False, allow_blank=True)

    # í•™ìƒ ë‹µ / ì •ë‹µ / ì ìˆ˜
    student_answer = serializers.CharField(required=False, allow_blank=True)
    correct_answer = serializers.CharField(required=False, allow_blank=True)

    is_correct = serializers.BooleanField()
    score = serializers.FloatField()
    max_score = serializers.FloatField()

    # ì›ë³¸ ë©”íƒ€ (OMR/AI í¬í•¨)
    meta = serializers.JSONField(required=False)

    # ì˜µì…˜: í”„ë¡ íŠ¸ UXìš© (ë¬¸ì œ ì§€ë¬¸/ì„ ì§€/í•´ì„¤ ë“±ì€ í™•ì¥ í¬ì¸íŠ¸)
    extra = serializers.JSONField(required=False)


class WrongNoteListResponseSerializer(serializers.Serializer):
    """
    í˜ì´ì§€ë„¤ì´ì…˜ í¬í•¨ ì‘ë‹µ
    """
    count = serializers.IntegerField()
    next = serializers.IntegerField(allow_null=True)   # ë‹¤ìŒ offset
    prev = serializers.IntegerField(allow_null=True)   # ì´ì „ offset
    results = WrongNoteItemSerializer(many=True)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    ê³„ì‚°ëœ ê²°ê³¼ë¥¼ ë°›ì•„ resultsì— ë°˜ì˜
    âŒ ê³„ì‚° ì—†ìŒ (ê³„ì‚°ì€ graderê°€ í•¨)

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜:
    - apply()ê°€ attempt_idë¥¼ ë°›ì•„ì„œ Result / ResultFactì— ì €ì¥

    âœ… ìš´ì˜ ì•ˆì „ì„± íŒ¨ì¹˜ (Critical #4)
    - ResultFact / ResultItemì— ë“¤ì–´ê°€ëŠ” ê°’ì€ "í•­ìƒ íƒ€ì…ì´ ë³´ì¥ëœë‹¤"ëŠ” ì „ì œê°€ ìš´ì˜ì—ì„œ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
      (blank, meta-only, None, ìˆ«ì/ë¦¬ìŠ¤íŠ¸ ë“±)
    - ë”°ë¼ì„œ ì—¬ê¸°ì„œ ìµœì†Œ ìºìŠ¤íŒ…/ë””í´íŠ¸ë¥¼ ê°•ì œí•´ DB insert ì•ˆì •ì„±ì„ ì˜¬ë¦°ë‹¤.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # âœ… ì¶”ê°€
        items: list[dict],
    ) -> Result:
        """
        items format (ê¶Œì¥):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # âœ… ëŒ€í‘œ attempt ì¶”ì  (ë®ì–´ì“°ëŠ”ê²Œ ì •ìƒ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # âœ… Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1ï¸âƒ£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2ï¸âƒ£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ìƒì„±/ê´€ë¦¬ ì „ë‹´

    ğŸ”¥ Critical íŒ¨ì¹˜:
    - ê°™ì€ submission_idë¡œ Attemptê°€ ì¤‘ë³µ ìƒì„±ë˜ëŠ” ê²ƒì„ ì°¨ë‹¨
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # ğŸ”´ CRITICAL #2
        # -------------------------------------------------
        # ê°™ì€ submissionìœ¼ë¡œ Attemptê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¦‰ì‹œ ì°¨ë‹¨
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1ï¸âƒ£ Exam ì •ì±… ë¡œë”©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2ï¸âƒ£ open_at / close_at ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3ï¸âƒ£ ë™ì‹œì„± ì•ˆì „: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4ï¸âƒ£ ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5ï¸âƒ£ ëŒ€í‘œ attempt êµì²´
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/clinic_target_service.py
==========================================================================================
# PATH: apps/domains/results/services/clinic_target_service.py
"""
ì—­í• 
- Admin/Teacherìš© "í´ë¦¬ë‹‰ ëŒ€ìƒì" ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œë‹¤.
- clinic_requiredì˜ ë‹¨ì¼ ì§„ì‹¤: progress.ClinicLink(is_auto=True)

ì„¤ê³„ ê³„ì•½ (ì¤‘ìš”)
1) ë‹¨ì¼ ì§„ì‹¤: enrollment_id (í•™ìƒ ì‹ë³„ì€ enrollment_idë¡œë§Œ)
2) clinic_required íŒë‹¨ì€ ClinicLink (ìë™ íŠ¸ë¦¬ê±°) ê¸°ì¤€
3) ì ìˆ˜/ì»¤íŠ¸ë¼ì¸/ì‚¬ìœ (reason)ëŠ” results/examsì—ì„œ íŒŒìƒ
4) Session â†” Exam ë§¤í•‘ì€ results.utils.session_exam.get_exams_for_session() ë‹¨ì¼ ì§„ì‹¤ ì‚¬ìš©

âš ï¸ í˜„ì‹¤ì  ì œì•½ (ë³´ë¥˜/ëª…ì‹œ)
- "ì„¸ì…˜ì— ì‹œí—˜ì´ ì—¬ëŸ¬ ê°œ"ì¸ êµ¬ì¡°ì—ì„œ, ClinicTargetì˜ exam_score/cutline_scoreëŠ” 1ê°œ ìˆ«ìë§Œ ë‹´ëŠ”ë‹¤.
  ë”°ë¼ì„œ ë³¸ ì„œë¹„ìŠ¤ëŠ” "ëŒ€í‘œ exam"ì„ 1ê°œ ì„ ì •í•´ì„œ í‘œê¸°í•œë‹¤.
  - ê¸°ë³¸ ì •ì±…: get_exams_for_session(session) ì¤‘ idê°€ ê°€ì¥ ì‘ì€ examì„ ëŒ€í‘œë¡œ ì‚¬ìš©
  - í–¥í›„ ì •ì±… í•„ìš” ì‹œ: ProgressPolicy(strategy)ë‚˜ ìš´ì˜ ê·œì¹™ì— ë”°ë¼ ë³€ê²½ ê°€ëŠ¥
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink
from apps.domains.exams.models import Exam
from apps.domains.results.models import Result, ResultFact, ExamAttempt

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_exams_for_session


def _safe_str(v: Any, default: str = "-") -> str:
    try:
        s = str(v)
        return s if s.strip() else default
    except Exception:
        return default


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _extract_invalid_reason_from_meta(meta: Any) -> Optional[str]:
    """
    ResultFact.meta / Attempt.meta / SubmissionAnswer.meta ë“± ë‹¤ì–‘í•œ ìœ„ì¹˜ì— ìˆì„ ìˆ˜ ìˆëŠ”
    invalid_reasonì„ ë°©ì–´ì ìœ¼ë¡œ ì¶”ì¶œí•œë‹¤.

    ê¸°ëŒ€ ê°€ëŠ¥í•œ í˜•íƒœ:
    meta = { "grading": { "invalid_reason": "LOW_CONFIDENCE" } }
    """
    if not isinstance(meta, dict):
        return None
    grading = meta.get("grading")
    if isinstance(grading, dict):
        v = grading.get("invalid_reason")
        return str(v) if v else None
    return None


def _is_low_confidence_for_attempt(*, exam_id: int, enrollment_id: int, attempt_id: Optional[int]) -> bool:
    """
    "ì‹ ë¢°ë„ ë‚®ìŒ" íŒì •ì€ í”„ë¡œì íŠ¸ êµ¬í˜„ì— ë”°ë¼:
    - Attempt.meta.grading.invalid_reason (ê°€ëŠ¥)
    - ResultFact.meta.grading.invalid_reason (ê°€ëŠ¥, í˜„ì¬ graderëŠ” ë¬¸í•­ metaì— ì‹¬ëŠ” í˜•íƒœ)
    ë‘˜ ë‹¤ ë°©ì–´ì ìœ¼ë¡œ ì²´í¬í•œë‹¤.
    """
    # 1) Attempt.meta (ìˆìœ¼ë©´ ìµœìš°ì„ )
    if attempt_id:
        a = ExamAttempt.objects.filter(id=int(attempt_id)).first()
        if a and hasattr(a, "meta"):
            reason = _extract_invalid_reason_from_meta(getattr(a, "meta", None))
            if (reason or "").upper() == "LOW_CONFIDENCE":
                return True

    # 2) ResultFact.meta (ëŒ€í‘œ attempt ê¸°ì¤€)
    if attempt_id:
        qs = (
            ResultFact.objects.filter(
                target_type="exam",
                target_id=int(exam_id),
                enrollment_id=int(enrollment_id),
                attempt_id=int(attempt_id),
            )
            .exclude(meta__isnull=True)
            .order_by("-id")[:200]  # ë°©ì–´: ë„ˆë¬´ í° scan ë°©ì§€
        )
        for f in qs:
            r = _extract_invalid_reason_from_meta(getattr(f, "meta", None))
            if (r or "").upper() == "LOW_CONFIDENCE":
                return True

    return False


def _get_student_name_by_enrollment_id(enrollment_id: int) -> str:
    """
    enrollment_id â†’ student_name ë§¤í•‘ì€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë„ë©”ì¸ì´ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ ë°©ì–´ì ìœ¼ë¡œ êµ¬í˜„.

    ìš°ì„ ìˆœìœ„:
    1) enrollments.SessionEnrollment (session-enrollments) ëª¨ë¸ì´ ìˆìœ¼ë©´ student_name í•„ë“œ/ì¡°ì¸ ì‚¬ìš©
    2) enrollment.Enrollment ëª¨ë¸ì´ ìˆìœ¼ë©´ student/user ì¡°ì¸ ì‹œë„
    3) ì‹¤íŒ¨ ì‹œ "-"
    """
    enrollment_id = int(enrollment_id)

    # 1) SessionEnrollment (ìˆìœ¼ë©´ ê°€ì¥ í™•ì‹¤)
    try:
        # í”„ë¡œì íŠ¸ì— ë”°ë¼ ì•± ê²½ë¡œê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
        # - apps.domains.enrollments.models.SessionEnrollment (ê°€ì¥ í”í•¨)
        # - apps.domains.enrollments.models.session_enrollment.SessionEnrollment ë“±
        from apps.domains.enrollments.models import SessionEnrollment  # type: ignore

        se = (
            SessionEnrollment.objects.filter(enrollment_id=enrollment_id)
            .order_by("-id")
            .first()
        )
        if se:
            # serializer ì‘ë‹µì— student_nameì´ ìˆë‹¤ê³  í–ˆë˜ ìŠ¤í™ê³¼ ì •í•©ì„±
            v = getattr(se, "student_name", None)
            if v:
                return _safe_str(v, "-")

            # ì¡°ì¸ì´ ê°€ëŠ¥í•˜ë©´ student.name
            st = getattr(se, "student", None)
            if st and hasattr(st, "name"):
                return _safe_str(getattr(st, "name", None), "-")
    except Exception:
        pass

    # 2) Enrollment (ê¸°ì¡´ results ì½”ë“œì—ì„œ ì‚¬ìš© ì¤‘)
    try:
        from apps.domains.enrollment.models import Enrollment  # type: ignore

        e = Enrollment.objects.filter(id=enrollment_id).select_related().first()
        if not e:
            return "-"

        # student FKê°€ ìˆìœ¼ë©´ ìš°ì„ 
        st = getattr(e, "student", None)
        if st and hasattr(st, "name"):
            return _safe_str(getattr(st, "name", None), "-")

        # userê°€ í•™ìƒ í”„ë¡œí•„ì„ ë“¤ê³  ìˆì„ ìˆ˜ë„
        u = getattr(e, "user", None)
        if u:
            nm = getattr(u, "name", None) or getattr(u, "username", None)
            return _safe_str(nm, "-")
    except Exception:
        pass

    return "-"


def _get_session_title(session: Session) -> str:
    """
    ì„¸ì…˜ íƒ€ì´í‹€ì€ í”„ë¡œì íŠ¸ë§ˆë‹¤ í‘œí˜„ì´ ë‹¬ë¼ì„œ:
    - __str__ ìš°ì„ 
    - lecture/title/order ë“± í›„ë³´ë¥¼ ë°©ì–´ì ìœ¼ë¡œ ì¡°í•©
    """
    s = _safe_str(session, "-")
    if s != "-" and s.lower() != "session object":
        return s

    lecture = getattr(session, "lecture", None)
    lecture_title = _safe_str(getattr(lecture, "title", None), "")
    order = getattr(session, "order", None)

    if lecture_title and order is not None:
        return f"{lecture_title} {int(order)}íšŒì°¨"
    if lecture_title:
        return lecture_title

    return f"Session#{int(getattr(session, 'id', 0) or 0)}"


@dataclass(frozen=True)
class ClinicTargetRow:
    enrollment_id: int
    student_name: str
    session_title: str
    reason: str  # "score" | "confidence"
    exam_score: float
    cutline_score: float
    created_at: Any


class ClinicTargetService:
    """
    Admin Clinic Targets

    ë‹¨ì¼ ì§„ì‹¤:
    - ëŒ€ìƒì ëª¨ìˆ˜: ClinicLink(is_auto=True)
    - enrollment_id ê¸°ì¤€
    """

    @staticmethod
    def list_admin_targets() -> List[Dict[str, Any]]:
        links = (
            ClinicLink.objects.filter(is_auto=True)
            # âœ… ìˆ˜ì •ì‚¬í•­(ì¶”ê°€): ì˜ˆì•½ ì™„ë£Œë¡œ ë¶„ë¦¬ëœ ëŒ€ìƒìëŠ” "ëŒ€ìƒì"ì—ì„œ ì œì™¸
            .filter(resolved_at__isnull=True)
            .select_related("session")
            .order_by("-created_at")  # ìµœì‹  ìë™ ëŒ€ìƒ ìš°ì„ 
        )

        out: List[Dict[str, Any]] = []

        # ì„¸ì…˜ë³„ exam í›„ë³´ ìºì‹œ (ì¿¼ë¦¬ ì ˆì•½)
        exams_cache: Dict[int, Optional[Exam]] = {}

        for link in links:
            session = getattr(link, "session", None)
            if not session:
                continue

            session_id = int(getattr(session, "id", 0) or 0)
            enrollment_id = int(getattr(link, "enrollment_id", 0) or 0)
            if not session_id or not enrollment_id:
                continue

            # ëŒ€í‘œ exam ì„ ì • (ì„¸ì…˜ì— ì‹œí—˜ì´ ì—¬ëŸ¬ ê°œë©´ 1ê°œë§Œ í‘œê¸°)
            if session_id not in exams_cache:
                exams = list(get_exams_for_session(session))
                if exams:
                    # âœ… ë³´ìˆ˜ì  ì •ì±…: idê°€ ê°€ì¥ ì‘ì€ examì„ ëŒ€í‘œë¡œ
                    ex = sorted(exams, key=lambda x: int(getattr(x, "id", 0) or 0))[0]
                    exams_cache[session_id] = ex
                else:
                    exams_cache[session_id] = None

            exam = exams_cache.get(session_id)
            if not exam:
                # ì„¸ì…˜ì— ì‹œí—˜ì´ ì—†ìœ¼ë©´ score/cutlineì€ 0ìœ¼ë¡œ ë‚´ë ¤ì„œ í™”ë©´ì´ ê¹¨ì§€ì§€ ì•Šê²Œ
                out.append({
                    "enrollment_id": enrollment_id,
                    "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                    "session_title": _get_session_title(session),
                    "reason": "score",
                    "exam_score": 0.0,
                    "cutline_score": 0.0,
                    "created_at": getattr(link, "created_at", None),
                })
                continue

            exam_id = int(getattr(exam, "id", 0) or 0)
            cutline = _safe_float(getattr(exam, "pass_score", 0.0), 0.0)

            # ëŒ€í‘œ ìŠ¤ëƒ…ìƒ· Result (ì‹œí—˜ ë‹¨ìœ„)
            result = (
                Result.objects.filter(
                    target_type="exam",
                    target_id=exam_id,
                    enrollment_id=enrollment_id,
                )
                .order_by("-id")
                .first()
            )

            exam_score = _safe_float(getattr(result, "total_score", 0.0) if result else 0.0, 0.0)
            attempt_id = int(getattr(result, "attempt_id", 0) or 0) if result else 0

            # reason íŒì •
            # - LOW_CONFIDENCE í”ì ì´ ìˆìœ¼ë©´ confidence
            # - ì•„ë‹ˆë©´ score
            reason = "confidence" if _is_low_confidence_for_attempt(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id if attempt_id else None,
            ) else "score"

            out.append({
                "enrollment_id": enrollment_id,
                "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                "session_title": _get_session_title(session),
                "reason": reason,
                "exam_score": float(exam_score),
                "cutline_score": float(cutline),
                "created_at": getattr(link, "created_at", None),
            })

        return out


==========================================================================================
# FILE: services/exam_grading_service.py
==========================================================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Tuple

from django.db import transaction
from django.shortcuts import get_object_or_404
from rest_framework.exceptions import ValidationError

from apps.domains.exams.models import Exam, AnswerKey, ExamQuestion
from apps.domains.exams.services.template_resolver import resolve_template_exam
from apps.domains.results.models import ExamResult


@dataclass(frozen=True)
class AutoGradeOutput:
    result: ExamResult
    updated: bool


class ExamGradingService:
    """
    results SSOT grading

    ê·œì¹™:
    - exam êµ¬ì¡°ëŠ” exams(template)ì—ì„œ resolve
    - ì œì¶œ ì›ë³¸ì€ submissionsì—ì„œ ê°€ì ¸ì˜¨ë‹¤
    - ê²°ê³¼/ì±„ì ì€ resultsì—ë§Œ ê¸°ë¡í•œë‹¤
    """

    def _get_submission_answers_number_based(self, submission) -> Dict[int, str]:
        """
        âœ… ì „ì œ: submissionsê°€ ê°ê´€ì‹ ë‹µì•ˆì„ "ë¬¸í•­ë²ˆí˜¸ ê¸°ë°˜"ìœ¼ë¡œ ë³´ê´€
        - ì˜ˆ: {"1": "A", "2": "C"}
        - ì–´ë””ì— ì €ì¥ë˜ì—ˆëŠ”ì§€ëŠ” í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¬ë¼ì„œ
          ì—¬ê¸°ì„  ì•ˆì „í•˜ê²Œ attribute í›„ë³´ë¥¼ ëª‡ ê°œ í™•ì¸.
        """
        candidates = [
            getattr(submission, "objective_answers", None),
            getattr(submission, "answers", None),
            getattr(submission, "payload", None),
            getattr(submission, "data", None),
        ]
        raw = None
        for c in candidates:
            if isinstance(c, dict) and c:
                raw = c
                break
        if raw is None:
            return {}

        # payload êµ¬ì¡°ê°€ {"objective": {...}} í˜•íƒœì¼ ìˆ˜ ìˆì–´ì„œ ë³´ì •
        if "objective" in raw and isinstance(raw.get("objective"), dict):
            raw = raw["objective"]

        out: Dict[int, str] = {}
        for k, v in (raw or {}).items():
            try:
                n = int(k)
            except Exception:
                continue
            out[n] = str(v or "").upper().strip()
        return out

    def _build_number_to_question(self, template_exam: Exam) -> Dict[int, ExamQuestion]:
        sheet = getattr(template_exam, "sheet", None)
        if not sheet:
            return {}
        qs = list(
            ExamQuestion.objects.filter(sheet=sheet).order_by("number")
        )
        return {int(q.number): q for q in qs}

    def _load_answer_key_map(self, template_exam: Exam) -> Dict[int, str]:
        ak = AnswerKey.objects.filter(exam=template_exam).first()
        if not ak:
            return {}
        # answers: {"<ExamQuestion.id>": "A"} ë¼ëŠ” ê³„ì•½
        out: Dict[int, str] = {}
        for k, v in (ak.answers or {}).items():
            try:
                qid = int(k)
            except Exception:
                continue
            out[qid] = str(v or "").upper().strip()
        return out

    def _calc_max_score(self, number_to_q: Dict[int, ExamQuestion]) -> float:
        # exams_question.score (float) í•©ì‚°
        return float(sum(float(q.score or 0.0) for q in number_to_q.values()))

    @transaction.atomic
    def auto_grade_objective(self, *, submission_id: int) -> AutoGradeOutput:
        Submission = __import__("apps.domains.submissions.models", fromlist=["Submission"]).Submission  # lazy import
        submission = get_object_or_404(Submission.objects.select_related("exam"), id=int(submission_id))

        regular_exam: Exam = submission.exam
        if regular_exam.exam_type != Exam.ExamType.REGULAR:
            raise ValidationError({"detail": "auto grading requires regular exam submission"})

        template_exam = resolve_template_exam(regular_exam)

        number_to_q = self._build_number_to_question(template_exam)
        answer_key_by_qid = self._load_answer_key_map(template_exam)
        submitted_by_num = self._get_submission_answers_number_based(submission)

        max_score = self._calc_max_score(number_to_q)

        breakdown: Dict[str, Any] = {}
        objective_score = 0.0

        for num, q in number_to_q.items():
            qid = int(q.id)
            correct = answer_key_by_qid.get(qid)  # "A".."E" or None
            submitted = submitted_by_num.get(int(num))

            earned = 0.0
            is_correct = False
            if correct and submitted:
                is_correct = (submitted == correct)
                if is_correct:
                    earned = float(q.score or 0.0)

            breakdown[str(num)] = {
                "question_id": qid,
                "submitted": submitted,
                "correct_answer": correct,
                "correct": bool(is_correct),
                "earned": float(earned),
                "max": float(q.score or 0.0),
            }
            objective_score += float(earned)

        # manual overridesëŠ” ê¸°ì¡´ ìœ ì§€
        obj, created = ExamResult.objects.select_for_update().get_or_create(
            submission=submission,
            defaults={
                "exam": regular_exam,
                "max_score": max_score,
                "objective_score": objective_score,
                "subjective_score": 0.0,
                "total_score": objective_score,
                "breakdown": breakdown,
                "manual_overrides": {},
            },
        )
        updated = not created

        if updated:
            if obj.status == ExamResult.Status.FINAL:
                raise ValidationError({"detail": "result is finalized; cannot auto-grade"})

            obj.exam = regular_exam
            obj.max_score = max_score
            obj.objective_score = objective_score
            obj.breakdown = breakdown

            # subjective_scoreëŠ” overrides ê¸°ë°˜ ì¬ê³„ì‚°
            subj = 0.0
            for _, ov in (obj.manual_overrides or {}).items():
                try:
                    subj += float(ov.get("earned") or 0.0)
                except Exception:
                    continue
            obj.subjective_score = subj
            obj.total_score = float(obj.objective_score) + float(obj.subjective_score)

            # pass/fail
            pass_score = float(regular_exam.pass_score or 0.0)
            obj.is_passed = bool(obj.total_score >= pass_score)

            obj.save(update_fields=[
                "exam", "max_score", "objective_score", "subjective_score", "total_score",
                "breakdown", "is_passed", "updated_at"
            ])

        else:
            # created caseì—ë„ pass/fail ê³„ì‚°
            pass_score = float(regular_exam.pass_score or 0.0)
            obj.is_passed = bool(obj.total_score >= pass_score)
            obj.save(update_fields=["is_passed", "updated_at"])

        return AutoGradeOutput(result=obj, updated=updated)

    @transaction.atomic
    def apply_manual_overrides(self, *, submission_id: int, overrides: Dict[str, Any]) -> ExamResult:
        Submission = __import__("apps.domains.submissions.models", fromlist=["Submission"]).Submission  # lazy import
        submission = get_object_or_404(Submission.objects.select_related("exam"), id=int(submission_id))

        obj = ExamResult.objects.select_for_update().filter(submission=submission).first()
        if not obj:
            raise ValidationError({"detail": "auto-grade first; result not found"})

        if obj.status == ExamResult.Status.FINAL:
            raise ValidationError({"detail": "result is finalized; cannot edit"})

        # merge
        merged = dict(obj.manual_overrides or {})
        for k, v in (overrides or {}).items():
            merged[str(k)] = {
                "earned": float((v or {}).get("earned") or 0.0),
                "comment": str((v or {}).get("comment") or ""),
            }

        obj.manual_overrides = merged

        # recompute subjective_score
        subj = 0.0
        for _, ov in merged.items():
            subj += float(ov.get("earned") or 0.0)

        obj.subjective_score = subj
        obj.total_score = float(obj.objective_score) + float(obj.subjective_score)

        pass_score = float(submission.exam.pass_score or 0.0)
        obj.is_passed = bool(obj.total_score >= pass_score)

        obj.save(update_fields=[
            "manual_overrides", "subjective_score", "total_score", "is_passed", "updated_at"
        ])
        return obj

    @transaction.atomic
    def finalize(self, *, submission_id: int) -> ExamResult:
        Submission = __import__("apps.domains.submissions.models", fromlist=["Submission"]).Submission  # lazy import
        submission = get_object_or_404(Submission.objects.select_related("exam"), id=int(submission_id))

        obj = ExamResult.objects.select_for_update().filter(submission=submission).first()
        if not obj:
            raise ValidationError({"detail": "auto-grade first; result not found"})

        if obj.status == ExamResult.Status.FINAL:
            return obj

        obj.finalize()
        return obj


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# ğŸ”½ submissions ë„ë©”ì¸ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# ğŸ”½ results ë„ë©”ì¸ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# ğŸ”½ exams ë„ë©”ì¸ (ì •ë‹µ / ë¬¸ì œ ì •ì˜)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey
# (ì„ íƒ) pass_scoreë¥¼ Examì—ì„œ ì½ì„ ìˆ˜ ìˆìœ¼ë©´ ì“°ê³ , ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ ìŠ¤í‚µ
try:
    from apps.domains.exams.models import Exam  # type: ignore
except Exception:  # pragma: no cover
    Exam = None  # type: ignore

# ======================================================
# ğŸ”½ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants (STEP 1 ê³ ì •)
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    ë¬¸ìì—´ ì •ê·œí™” (STEP 1 exact match ê³ ì •):
    - None ë°©ì–´
    - ê³µë°± ì œê±°
    - ëŒ€ë¬¸ì í†µì¼
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ì—ì„œ
    omr dict ë§Œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _ensure_dict(v: Any) -> Dict[str, Any]:
    return v if isinstance(v, dict) else {}


def _with_invalid_reason(meta: Any, reason: str) -> Dict[str, Any]:
    """
    âœ… STEP 1 í•µì‹¬:
    low_conf / blank / multi ë“± "ë¬´íš¨ ì²˜ë¦¬"ëŠ” 0ì  ì²˜ë¦¬ ë¿ ì•„ë‹ˆë¼
    **ì‚¬ìœ ë¥¼ append-onlyë¡œ ë‚¨ê²¨ì•¼ ìš´ì˜/ì¬ì²˜ë¦¬/í”„ë¡ íŠ¸ í‘œì‹œê°€ ê°€ëŠ¥**í•´ì§.
    """
    base = _ensure_dict(meta)
    out = dict(base)
    out.setdefault("grading", {})
    if isinstance(out["grading"], dict):
        out["grading"]["invalid_reason"] = reason
    return out


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
    # âœ… ê¸°ì¡´ metaë¥¼ ë°›ì•„ì„œ invalid_reasonì„ ì‹¬ëŠ”ë‹¤
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    OMR ê°ê´€ì‹ ì±„ì  v1 (STEP 1 ê³ ì •)

    âœ… ì •ì±…:
    - status != ok -> ë¬´íš¨ (0ì )
    - marking blank/multi -> ë¬´íš¨ (0ì )
    - confidence < threshold -> ë¬´íš¨ (0ì ) + LOW_CONFIDENCE ì‚¬ìœ  ì €ì¥  â­â­â­
    - detected != 1ê°œ -> ë¬´íš¨ (0ì )
    """
    st = (status or "").lower()
    mk = (marking or "").lower()

    # 1) statusê°€ okê°€ ì•„ë‹ˆë©´ ë¬´íš¨
    if st != "ok":
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_STATUS_NOT_OK")

    # 2) blank/multiëŠ” ë¬´íš¨
    if mk in ("blank", "multi"):
        reason = "OMR_BLANK" if mk == "blank" else "OMR_MULTI"
        return False, 0.0, _with_invalid_reason(original_meta, reason)

    # 3) ì‹ ë¢°ë„ ì²´í¬ (STEP 1: low confidence ìë™ 0ì  + ì‚¬ìœ  ì €ì¥)
    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0, _with_invalid_reason(original_meta, "LOW_CONFIDENCE")

    # 4) detected 1ê°œ ê°•ì œ
    if not detected or len(detected) != 1:
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_DETECTED_INVALID")

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    ì£¼ê´€ì‹ / fallback ì±„ì  (STEP 1: exact match)

    âœ… ì •ì±…:
    - empty => 0ì 
    - exact match only
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0, _with_invalid_reason(original_meta, "EMPTY_ANSWER")

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type ì¶”ë¡ 
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    âœ… AnswerKey v2 ê³ ì •

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


def _get_pass_score(exam_id: int) -> Optional[float]:
    """
    (ì„ íƒ) Exam.pass_scoreê°€ ìˆìœ¼ë©´ ì½ì–´ì„œ attempt/metaì— ê¸°ë¡.
    - ResultApplierê°€ ì´ë¯¸ is_passë¥¼ ê³„ì‚°í•œë‹¤ë©´ ì´ê±´ "ì§„ë‹¨/í‘œì‹œìš©" ì •ë³´ë¡œë§Œ ë‚¨ëŠ”ë‹¤.
    """
    if Exam is None:
        return None
    try:
        exam = Exam.objects.filter(id=int(exam_id)).first()
        if not exam:
            return None
        v = getattr(exam, "pass_score", None)
        return float(v) if v is not None else None
    except Exception:
        return None


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission â†’ ExamAttempt â†’ Result / ResultItem / ResultFact

    ğŸ”¥ v2 í•µì‹¬ ê³„ì•½:
    - SubmissionAnswer.exam_question_id ë§Œ ì‚¬ìš©
    - number / fallback ì™„ì „ ì œê±°
    - AnswerKey v2 ê³ ì •
    - âœ… STEP 1: LOW_CONF ë¬´íš¨ 0ì  + ì‚¬ìœ  ì €ì¥
    """

    # --------------------------------------------------
    # 0ï¸âƒ£ Submission ìƒíƒœ ì „ì´
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1ï¸âƒ£ ExamAttempt ìƒì„±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2ï¸âƒ£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3ï¸âƒ£ ExamQuestion ë¡œë”© (id ê¸°ì¤€)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        total_score = 0.0
        total_max_score = 0.0

        # --------------------------------------------------
        # 4ï¸âƒ£ ë¬¸í•­ë³„ ì±„ì 
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            # submissions meta
            original_meta = getattr(sa, "meta", None)
            omr = _get_omr_meta(original_meta)

            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            # âœ… STEP 1: low_confidence statusëŠ” ì¦‰ì‹œ ë¬´íš¨ ì²˜ë¦¬ (0ì +ì‚¬ìœ )
            if (status or "").lower() == "low_confidence":
                is_correct = False
                score = 0.0
                final_answer = ""
                final_meta = _with_invalid_reason(original_meta, "LOW_CONFIDENCE")
            else:
                answer_type = _infer_answer_type(q)

                if answer_type in ("choice", "omr", "multiple_choice"):
                    if omr_version.lower() in ("v1", "v2"):
                        is_correct, score, final_meta = _grade_choice_v1(
                            detected=[str(x) for x in detected],
                            marking=marking,
                            confidence=confidence,
                            status=status,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        # í‘œì‹œìš© answer: ê°ì§€ëœ ê°’ 1ê°œë©´ ê·¸ ê°’, ì•„ë‹ˆë©´ ""
                        final_answer = (
                            "".join([_norm(x) for x in detected]) if detected else ""
                        )
                    else:
                        # OMR metaê°€ ì—†ê±°ë‚˜ ë²„ì „ì´ ì—†ì„ ë•Œ: í…ìŠ¤íŠ¸ ê¸°ë°˜ exact match
                        is_correct, score, final_meta = _grade_short_v1(
                            answer_text=answer_text,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        final_answer = answer_text
                else:
                    # subjective: exact match (STEP 1)
                    is_correct, score, final_meta = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                        original_meta=original_meta,
                    )
                    final_answer = answer_text

            # ì ìˆ˜ ëˆ„ì 
            total_score += float(score)
            total_max_score += float(max_score)

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                # âœ… ìµœì¢… metaì—ëŠ” invalid_reasonì´ ë°˜ì˜ë  ìˆ˜ ìˆìŒ
                "meta": final_meta,
            })

        # --------------------------------------------------
        # 4-1) (ì„ íƒ) attempt/metaì— total/pass ì •ë³´ ê¸°ë¡
        # - ResultApplierê°€ ì‹¤ì œ ResultSummary.is_passë¥¼ ë§Œë“¤ë”ë¼ë„,
        #   attemptì—ëŠ” ìš´ì˜/ë””ë²„ê¹…ìš©ìœ¼ë¡œ ë‚¨ê²¨ë‘ë©´ ì¢‹ìŒ.
        # --------------------------------------------------
        try:
            pass_score = _get_pass_score(int(submission.target_id))
            meta = getattr(attempt, "meta", None)
            if isinstance(meta, dict):
                new_meta = dict(meta)
            else:
                new_meta = {}

            new_meta.setdefault("grading", {})
            if isinstance(new_meta["grading"], dict):
                new_meta["grading"]["total_score"] = float(total_score)
                new_meta["grading"]["total_max_score"] = float(total_max_score)
                if pass_score is not None:
                    new_meta["grading"]["pass_score"] = float(pass_score)
                    new_meta["grading"]["is_pass_inferred"] = bool(total_score >= pass_score)

            if hasattr(attempt, "meta"):
                attempt.meta = new_meta
                attempt.save(update_fields=["meta"])
        except Exception:
            # meta í•„ë“œê°€ ì—†ê±°ë‚˜ ì €ì¥ ì‹¤íŒ¨í•´ë„ grading ìì²´ëŠ” ê³„ì† ì§„í–‰
            pass

        # --------------------------------------------------
        # 5ï¸âƒ£ Result ë°˜ì˜
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6ï¸âƒ£ ìƒíƒœ ë§ˆë¬´ë¦¬
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/grading_entrypoint.py
==========================================================================================
# apps/domains/results/services/grading_entrypoint.py
from __future__ import annotations

from typing import Any

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.results.models import ExamResult
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import AttemptService
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class GradingEntrypoint:
    """
    âœ… Results ì±„ì  íŒŒì´í”„ë¼ì¸ ë‹¨ì¼ ì§„ì‹¤ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸

    grading_service â†’ ì´ í´ë˜ìŠ¤ë§Œ í˜¸ì¶œ
    """

    @staticmethod
    @transaction.atomic
    def run(*, submission_id: int) -> ExamResult:
        submission = Submission.objects.select_for_update().get(id=int(submission_id))

        # 1. Attempt í™•ë³´
        attempt = AttemptService.ensure_attempt(submission)

        # 2. ê²°ê³¼ ê³„ì‚° + ë°˜ì˜
        result = ResultApplier.apply(attempt)

        # 3. submission ìƒíƒœ í™•ì •
        submission.status = Submission.Status.DONE
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message", "updated_at"])

        # 4. progress íŒŒì´í”„ë¼ì¸ (ë¹„ë™ê¸°)
        dispatch_progress_pipeline(submission_id=submission.id)

        return result


==========================================================================================
# FILE: services/grading_policy.py
==========================================================================================
# # PATH: apps/domains/results/services/grading_policy.py

# NOTE:
# STEP 2 ì´í›„ grader ë¦¬íŒ©í† ë§ ì‹œ ì‚¬ìš©í•  ì •ì±… ëª¨ë“ˆ
# í˜„ì¬ëŠ” ë¯¸ì‚¬ìš©

# from __future__ import annotations

# from dataclasses import dataclass
# from typing import Any, Dict, Optional, Tuple


# # =========================================================
# # STEP 1 ì •ì±… ìƒìˆ˜ (ê³ ì •)
# # =========================================================

# MIN_OMR_CONFIDENCE = 0.70  # ì´ ë¯¸ë§Œì´ë©´ ìë™ ë¬´íš¨(0ì )


# def normalize_text(s: str) -> str:
#     """
#     ì£¼ê´€ì‹ exact match í‘œì¤€ ì •ê·œí™” (STEP 1 ê³ ì •)
#     - strip + lower
#     - ì¶”í›„ ê³µë°±/íŠ¹ìˆ˜ë¬¸ì ê·œì¹™ì€ ì—¬ê¸°ì„œë§Œ ë°”ê¾¸ë©´ ë¨
#     """
#     return (s or "").strip().lower()


# @dataclass(frozen=True)
# class OMRValidity:
#     is_valid: bool
#     invalid_reason: Optional[str] = None


# def evaluate_omr_validity(submission_answer_meta: Dict[str, Any]) -> OMRValidity:
#     """
#     SubmissionAnswer.meta["omr"] ê¸°ë°˜ìœ¼ë¡œ OMR ìœ íš¨ì„± íŒë‹¨ (STEP 1 ê³ ì •)
#     - low_confidenceë©´ 0ì  ì²˜ë¦¬
#     - ambiguous/multi/blankì€ ë„ˆì˜ ì±„ì  ì •ì±…ì— ë”°ë¼ 0ì /ë¶€ë¶„ì  ë“± í™•ì¥ ê°€ëŠ¥í•˜ì§€ë§Œ
#       STEP 1ì—ì„œëŠ” ìµœì†Œí•œ low_confëŠ” ë¬´ì¡°ê±´ ë¬´íš¨ë¡œ ê³ ì •.
#     """
#     omr = (submission_answer_meta or {}).get("omr") or {}
#     conf = omr.get("confidence")
#     status = str(omr.get("status") or "").lower()

#     try:
#         conf_f = float(conf) if conf is not None else None
#     except Exception:
#         conf_f = None

#     # âœ… ëª…ì‹œì ìœ¼ë¡œ low_confidenceë©´ ë¬´íš¨
#     if status == "low_confidence":
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     # âœ… confidence ê°’ì´ ìˆê³  ì„ê³„ì¹˜ ë¯¸ë§Œì´ë©´ ë¬´íš¨
#     if conf_f is not None and conf_f < MIN_OMR_CONFIDENCE:
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     return OMRValidity(is_valid=True, invalid_reason=None)


# def grade_subjective_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ì£¼ê´€ì‹ exact match ì±„ì  (STEP 1 ê³ ì •)
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def grade_choice_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ê°ê´€ì‹ exact match ê¸°ë³¸ (A/B/C/D)
#     - ë‹¤ì¤‘ë§ˆí‚¹ ì²˜ë¦¬/ë¶€ë¶„ì ì€ STEP 2 ì´í›„ í™•ì¥ í¬ì¸íŠ¸
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def evaluate_pass_fail(total_score: float, pass_score: float) -> bool:
#     """
#     ì‹œí—˜ ë‹¨ìœ„ pass/fail (STEP 1 ê³ ì •)
#     """
#     try:
#         return float(total_score) >= float(pass_score)
#     except Exception:
#         return False


==========================================================================================
# FILE: services/grading_service.py
==========================================================================================
# PATH: apps/domains/results/services/grading_service.py
from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Optional, Tuple

from django.db import transaction
from django.db.models import Q

from apps.domains.submissions.models import Submission

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class GradeOutcome:
    submission_id: int
    created_attempt_id: Optional[int]
    exam_result_id: Optional[int]
    finalized: bool
    detail: str


def _get_models():
    from apps.domains.results.models.exam_attempt import ExamAttempt
    from apps.domains.results.models.exam_result import ExamResult
    return ExamAttempt, ExamResult


def _get_services():
    from apps.domains.results.services.grading_entrypoint import GradingEntrypoint
    from apps.domains.results.services.attempt_service import AttemptService
    from apps.domains.results.services.applier import ResultApplier
    from apps.domains.progress.tasks.progress_pipeline_task import run_progress_pipeline
    return GradingEntrypoint, AttemptService, ResultApplier, run_progress_pipeline


@transaction.atomic
def grade_submission(submission_id: int) -> object:
    """
    Queue-less grading entry.

    Guarantees:
    - Idempotent: repeated calls won't corrupt results.
    - Converges to a stable representative attempt/result.
    - Does not require any external worker once answers are ready.

    Returns:
      An ExamResult instance (or compatible object) for existing callers.
    """
    ExamAttempt, ExamResult = _get_models()
    GradingEntrypoint, AttemptService, ResultApplier, run_progress_pipeline = _get_services()

    submission = (
        Submission.objects.select_for_update()
        .select_related()
        .get(id=submission_id)
    )

    # ------------------------------------------------------------
    # Guard: only grade when answers exist or this is an ONLINE flow.
    # ------------------------------------------------------------
    if submission.status in (Submission.Status.FAILED,):
        raise RuntimeError("cannot grade FAILED submission")

    # If answers are not ready, do nothing (worker will later submit results).
    # Keep behavior non-destructive.
    if submission.source != Submission.Source.ONLINE and submission.status not in (
        Submission.Status.ANSWERS_READY,
        Submission.Status.GRADING,
        Submission.Status.DONE,
    ):
        # Keep as-is; caller should not crash hard in some flows.
        return _existing_exam_result_or_none(submission_id)

    # ------------------------------------------------------------
    # If already has an ExamResult linked, prefer returning it.
    # ------------------------------------------------------------
    existing = ExamResult.objects.filter(submission_id=submission_id).order_by("-id").first()
    if existing:
        return existing

    # ------------------------------------------------------------
    # Transition submission into GRADING if appropriate.
    # ------------------------------------------------------------
    if submission.status not in (Submission.Status.DONE,):
        submission.status = Submission.Status.GRADING
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message", "updated_at"])

    # ------------------------------------------------------------
    # Create Attempt append-only + apply grading.
    # Existing services in your tree are used; no schema changes.
    # ------------------------------------------------------------
    attempt = AttemptService().create_attempt_for_submission(submission=submission)  # type: ignore

    # GradingEntrypoint performs:
    # - read answers/detected answers from submission/meta
    # - compare with AnswerKey/template resolved
    # - create ResultFact/ResultItems
    # - compute summary and pass/fail
    # - mark representative attempt
    GradingEntrypoint().run(attempt_id=attempt.id)  # type: ignore

    # Apply creates/updates ExamResult row (your results.0003 added this).
    exam_result = ResultApplier().apply_from_attempt(attempt_id=attempt.id)  # type: ignore

    # ------------------------------------------------------------
    # Finalize submission state.
    # ------------------------------------------------------------
    submission.status = Submission.Status.DONE
    submission.save(update_fields=["status", "updated_at"])

    # ------------------------------------------------------------
    # Progress pipeline hook (sync).
    # ------------------------------------------------------------
    try:
        run_progress_pipeline(exam_id=getattr(exam_result, "exam_id", None), submission_id=submission_id)
    except Exception:
        # Do not break grading response; log for ops.
        logger.exception("progress pipeline failed after grading (submission_id=%s)", submission_id)

    return exam_result


def _existing_exam_result_or_none(submission_id: int) -> object:
    ExamAttempt, ExamResult = _get_models()
    r = ExamResult.objects.filter(submission_id=submission_id).order_by("-id").first()
    if r:
        return r
    # Keep compatibility: return a lightweight object rather than None.
    return {"detail": "answers not ready", "submission_id": submission_id}


==========================================================================================
# FILE: services/question_stats_service.py
==========================================================================================
# apps/domains/results/services/question_stats_service.py
from __future__ import annotations

from typing import Dict, List, Optional
from django.db.models import Count, Avg, Max, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.models import ResultFact


class QuestionStatsService:
    """
    ì‹œí—˜ ë¬¸í•­ í†µê³„ ë‹¨ì¼ ì§„ì‹¤ (ì •ì„)

    ğŸ”¥ ê¸°ì¤€:
    - ResultFact (append-only)ë§Œ ì‚¬ìš©
    - Result / ResultItem / attempt êµì²´ ì—¬ë¶€ì™€ ë¬´ê´€
    - ìš´ì˜/í†µê³„/ë¶„ì„ ì¼ê´€ì„± ë³´ì¥
    """

    # ======================================================
    # A) ë¬¸í•­ë³„ ê¸°ë³¸ í†µê³„
    # ======================================================
    @staticmethod
    def per_question_stats(
        *,
        exam_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ë¬¸í•­ë³„ í†µê³„
        - ì‘ì‹œ ìˆ˜
        - ì •ë‹µ ìˆ˜
        - ì •ë‹µë¥ 
        - í‰ê·  ì ìˆ˜
        - ìµœëŒ€ ì ìˆ˜
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct=Count("id", filter=Q(is_correct=True)),
                avg_score=Avg("score"),
                max_score=Max("score"),
            )
            .annotate(
                accuracy=ExpressionWrapper(
                    F("correct") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                )
            )
            .order_by("question_id")
        )

        return [
            {
                "question_id": row["question_id"],
                "attempts": int(row["attempts"] or 0),
                "correct": int(row["correct"] or 0),
                "accuracy": round(float(row["accuracy"] or 0.0), 4),
                "avg_score": float(row["avg_score"] or 0.0),
                "max_score": float(row["max_score"] or 0.0),
            }
            for row in rows
        ]

    # ======================================================
    # B) ë¬¸í•­ ë‹¨ì¼ ì˜¤ë‹µ ë¶„í¬ (ì„ íƒì§€ ê¸°ì¤€)
    # ======================================================
    @staticmethod
    def wrong_choice_distribution(
        *,
        exam_id: int,
        question_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> Dict[str, int]:
        """
        ê°ê´€ì‹ ì˜¤ë‹µ ë¶„í¬
        - answer ê°’ ê¸°ì¤€
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            question_id=int(question_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = qs.values("answer").annotate(cnt=Count("id"))

        dist: Dict[str, int] = {}
        for r in rows:
            key = str(r["answer"] or "")
            dist[key] = int(r["cnt"] or 0)

        return dist

    # ======================================================
    # C) ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
    # ======================================================
    @staticmethod
    def top_n_wrong_questions(
        *,
        exam_id: int,
        n: int = 5,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(wrong_count=Count("id"))
            .order_by("-wrong_count")[: int(n)]
        )

        return [
            {
                "question_id": int(r["question_id"]),
                "wrong_count": int(r["wrong_count"]),
            }
            for r in rows
        ]


==========================================================================================
# FILE: services/session_score_summary_service.py
==========================================================================================
# apps/domains/results/services/session_score_summary_service.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.models import ExamAttempt
from apps.domains.progress.models import SessionProgress
from apps.domains.progress.models import ClinicLink
from apps.domains.lectures.models import Session

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_exam_ids_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class SessionScoreSummaryService:
    """
    âœ… Session ë‹¨ìœ„ ì„±ì  í†µê³„ (ìš´ì˜/ëŒ€ì‹œë³´ë“œ)

    ë‹¨ì¼ ì§„ì‹¤ ê·œì¹™:
    - ì ìˆ˜ í†µê³„: Result(ë‹¨, enrollment ì¤‘ë³µ ë°©ì–´ ì ìš©)
    - ì„¸ì…˜ í†µê³¼ìœ¨: SessionProgress.completed(í˜¹ì€ ì •ì±…ì— ë”°ë¼ exam_passed) ì¤‘ ë¬´ì—‡ì¸ì§€ 'ì •ì˜'ê°€ í•„ìš”í•˜ì§€ë§Œ
      ê¸°ì¡´ ì›ë³¸ì€ completedë¥¼ ì‚¬ìš©í–ˆìœ¼ë¯€ë¡œ ì›ë³¸ ì˜ë¯¸ë¥¼ ì¡´ì¤‘í•œë‹¤.
    - í´ë¦¬ë‹‰: ClinicLink (is_auto=True, enrollment distinct)

    âš ï¸ ì„¸ì…˜1:ì‹œí—˜N êµ¬ì¡° ë°˜ì˜:
    - sessionì— ì—°ê²°ëœ exam_idë“¤ì„ ëª¨ë‘ ê°€ì ¸ì™€ì„œ í†µê³„ë¥¼ ë§Œë“ ë‹¤.
    - ë‹¤ë§Œ "ì„¸ì…˜ ì „ì²´ ì ìˆ˜"ë¥¼ 1ê°œ ìˆ«ìë¡œ ë§Œë“¤ ë•ŒëŠ” ì§‘ê³„ ì „ëµì´ í•„ìš”í•¨.
      ì´ ì„œë¹„ìŠ¤ëŠ” "ì„¸ì…˜ ìš´ì˜ í†µê³„" ì„±ê²©ì´ë¯€ë¡œ:
        - ì ìˆ˜ ì§‘ê³„ëŠ” ìš°ì„  exams ì „ì²´ Resultë¥¼ í•©ì³ í‰ê· /ìµœì†Œ/ìµœëŒ€ë¥¼ êµ¬í•˜ëŠ” ë³´ìˆ˜ì  ë°©ì‹ìœ¼ë¡œ ì œê³µ.
      (ì •êµí•œ ì „ëµì€ AdminSessionExamsSummaryViewì—ì„œ examë³„ë¡œ ì œê³µí•˜ëŠ” ê²ƒì´ ì •ì„)
    """

    @staticmethod
    def build(*, session_id: int) -> dict:
        EMPTY_SUMMARY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "attempt_stats": {
                "avg_attempts": 0.0,
                "retake_ratio": 0.0,
            },
        }

        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return EMPTY_SUMMARY

        exam_ids = get_exam_ids_for_session(session)
        if not exam_ids:
            # ì„¸ì…˜ì— ì‹œí—˜ì´ ì—†ìœ¼ë©´ ì ìˆ˜ í†µê³„ëŠ” 0, pass/clinicì€ progressë¡œë§Œ íŒë‹¨ ê°€ëŠ¥
            progresses = SessionProgress.objects.filter(session=session)
            participant_count = progresses.count()
            pass_count = progresses.filter(completed=True).count()
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id").distinct().count()
            )
            return {
                **EMPTY_SUMMARY,
                "participant_count": int(participant_count),
                "pass_rate": round((pass_count / participant_count), 4) if participant_count else 0.0,
                "clinic_rate": round((clinic_count / participant_count), 4) if participant_count else 0.0,
            }

        # -------------------------------------------------
        # participant ëª¨ìˆ˜: SessionProgress ê¸°ì¤€(ì›ë³¸ ì¡´ì¤‘)
        # -------------------------------------------------
        progresses = SessionProgress.objects.filter(session=session)
        participant_count = progresses.count()

        # -------------------------------------------------
        # pass_rate: ì›ë³¸ì€ SessionProgress.completed ê¸°ì¤€
        # -------------------------------------------------
        pass_count = progresses.filter(completed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # clinic_rate: ClinicLink ê¸°ì¤€ ë‹¨ì¼í™”
        # -------------------------------------------------
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id")
            .distinct()
            .count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # ì ìˆ˜ í†µê³„:
        # - ì„¸ì…˜ì— ì—°ê²°ëœ ëª¨ë“  ì‹œí—˜ì˜ Resultë¥¼ ëª¨ì•„ì„œ í†µê³„
        # - enrollment ì¤‘ë³µ ë°©ì–´: examë³„ latest_results_per_enrollment ì ìš© í›„ í•©ì¹˜ê¸°
        # -------------------------------------------------
        all_results = []
        for exid in exam_ids:
            rs = list(latest_results_per_enrollment(target_type="exam", target_id=int(exid)))
            all_results.extend(rs)

        if not all_results:
            score_summary = {"avg_score": 0.0, "min_score": 0.0, "max_score": 0.0}
        else:
            scores = [float(r.total_score or 0.0) for r in all_results]
            score_summary = {
                "avg_score": (sum(scores) / len(scores)) if scores else 0.0,
                "min_score": min(scores) if scores else 0.0,
                "max_score": max(scores) if scores else 0.0,
            }

        # -------------------------------------------------
        # Attempt í†µê³„(ì¬ì‹œí—˜ ë¹„ìœ¨):
        # - ì„¸ì…˜ì— ì—°ê²°ëœ ëª¨ë“  ì‹œí—˜ì„ ëŒ€ìƒìœ¼ë¡œ attempt í†µê³„
        # -------------------------------------------------
        attempts = ExamAttempt.objects.filter(exam_id__in=[int(x) for x in exam_ids])

        per_enrollment = (
            attempts.values("enrollment_id")
            .annotate(cnt=Count("id"))
        )

        total_attempts = sum(int(r["cnt"] or 0) for r in per_enrollment)
        retake_users = sum(1 for r in per_enrollment if int(r["cnt"] or 0) > 1)

        avg_attempts = (total_attempts / participant_count) if participant_count else 0.0
        retake_ratio = (retake_users / participant_count) if participant_count else 0.0

        return {
            "participant_count": int(participant_count),
            "avg_score": float(score_summary["avg_score"]),
            "min_score": float(score_summary["min_score"]),
            "max_score": float(score_summary["max_score"]),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_rate": round(float(clinic_rate), 4),
            "attempt_stats": {
                "avg_attempts": round(float(avg_attempts), 2),
                "retake_ratio": round(float(retake_ratio), 4),
            },
        }


==========================================================================================
# FILE: services/wrong_note_service.py
==========================================================================================
# apps/domains/results/services/wrong_note_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Q
from django.utils import timezone

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import ExamQuestion, AnswerKey, Exam


# ======================================================
# Request DTO
# ======================================================
@dataclass(frozen=True)
class WrongNoteQuery:
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ íŒŒë¼ë¯¸í„°

    âœ… STEP 3-3 ìŠ¹ê²©
    - lecture_id/from_session_order í•„í„°ë¥¼ ì„œë¹„ìŠ¤ ì±…ì„ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¼
      (View/Worker/PDF ëª¨ë‘ ê°™ì€ ê·œì¹™ ì‚¬ìš©)

    - offset/limitì€ ë‹¨ìˆœ í˜ì´ì§€ë„¤ì´ì…˜
    """
    exam_id: Optional[int] = None
    lecture_id: Optional[int] = None
    from_session_order: int = 2

    offset: int = 0
    limit: int = 50


# ======================================================
# Internal helpers
# ======================================================
def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _has_relation(model, name: str) -> bool:
    """
    Exam ëª¨ë¸ì— íŠ¹ì • relation(name)ì´ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


def _get_exam_ids_by_lecture_and_order(*, lecture_id: int, from_order: int) -> List[int]:
    """
    lecture_id + from_session_orderë¡œ exam_id ëª©ë¡ êµ¬í•˜ê¸°

    âš ï¸ í”„ë¡œì íŠ¸ë³„ë¡œ Exam â†” Session reverse relation ì´ë¦„ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ:
    - sessions / session / session_set ...
    ê·¸ë˜ì„œ ê°€ëŠ¥í•œ í›„ë³´ë“¤ì„ ëª¨ë‘ ê²€ì‚¬í•´ ì•ˆì „í•˜ê²Œ í•„í„°ë§.

    âœ… ê·œì¹™:
    - ê´€ê³„ë¥¼ ëª» ì°¾ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜(=ì•ˆì „í•˜ê²Œ ê²°ê³¼ ì—†ìŒ)
    """
    exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

    # ìš°ì„ ìˆœìœ„ í›„ë³´ë“¤
    # 1) sessions
    if _has_relation(Exam, "sessions"):
        exam_qs = exam_qs.filter(sessions__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 2) session (1:1 í˜¹ì€ FK)
    if _has_relation(Exam, "session"):
        exam_qs = exam_qs.filter(session__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 3) session_set (Django default reverse name)
    if _has_relation(Exam, "session_set"):
        exam_qs = exam_qs.filter(session_set__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # ëª» ì°¾ìœ¼ë©´ ì•ˆì „í•˜ê²Œ none
    return []


def _get_answer_key_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey v2 (ê³ ì •):
      answers = { "123": "B", ... }  # key = ExamQuestion.id(str)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    answers = getattr(ak, "answers", None) if ak else None
    return answers if isinstance(answers, dict) else {}


# ======================================================
# Public API
# ======================================================
def list_wrong_notes_for_enrollment(
    *,
    enrollment_id: int,
    q: WrongNoteQuery,
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    âœ… í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ResultFact êµ¬ì¡°ì— ë§ëŠ” â€œì •ì„â€ êµ¬í˜„

    ResultFact = ë¬¸í•­ 1ê°œ ì´ë²¤íŠ¸(append-only)
      - question_id/answer/is_correct/score/max_score/meta/source ê°€ Factì— ì§ì ‘ ìˆìŒ

    ë°˜í™˜: (total_count, paged_items)
    """

    enrollment_id = int(enrollment_id)
    offset = max(int(q.offset or 0), 0)
    limit = max(min(int(q.limit or 50), 200), 1)

    base = ResultFact.objects.filter(
        enrollment_id=enrollment_id,
        target_type="exam",
        is_correct=False,          # ì˜¤ë‹µë§Œ
    )

    # 1) exam_id í•„í„°
    if q.exam_id is not None:
        base = base.filter(target_id=int(q.exam_id))

    # 2) lecture_id + from_session_order í•„í„° (STEP 3-3 ìŠ¹ê²©)
    if q.lecture_id is not None:
        exam_ids = _get_exam_ids_by_lecture_and_order(
            lecture_id=int(q.lecture_id),
            from_order=int(q.from_session_order or 2),
        )
        if not exam_ids:
            return 0, []
        base = base.filter(target_id__in=exam_ids)

    # ìµœì‹  ì˜¤ë‹µ ìš°ì„ 
    base = base.order_by("-id")

    total = base.count()

    facts = list(base[offset: offset + limit])

    # ì§ˆë¬¸ ì •ë³´/ì •ë‹µí‚¤ ë¶™ì´ê¸° ìœ„í•´ question_ids, exam_ids ìˆ˜ì§‘
    question_ids = [int(f.question_id) for f in facts]
    exam_ids = list({int(f.target_id) for f in facts})

    questions_map = (
        ExamQuestion.objects
        .filter(id__in=question_ids)
        .select_related("sheet")
        .in_bulk(field_name="id")
    )

    answer_key_cache: Dict[int, Dict[str, Any]] = {
        exid: _get_answer_key_map(exid) for exid in exam_ids
    }

    out: List[Dict[str, Any]] = []

    for f in facts:
        exid = int(f.target_id)
        qobj = questions_map.get(int(f.question_id))

        question_number = getattr(qobj, "number", None) if qobj else None
        answer_type = (getattr(qobj, "answer_type", "") or "") if qobj else ""

        correct_answer = ""
        if qobj:
            correct_answer = str(answer_key_cache.get(exid, {}).get(str(qobj.id)) or "")

        out.append({
            "exam_id": exid,
            "attempt_id": int(getattr(f, "attempt_id", 0) or 0),
            # attempt_created_at í•„ë“œê°€ ë”°ë¡œ ì—†ìœ¼ë‹ˆ created_atì„ ì‚¬ìš©
            "attempt_created_at": getattr(f, "created_at", None),

            "question_id": int(f.question_id),
            "question_number": _safe_int(question_number),
            "answer_type": str(answer_type),

            "student_answer": str(f.answer or ""),
            "correct_answer": str(correct_answer or ""),

            "is_correct": False,
            "score": float(f.score or 0.0),
            "max_score": float(f.max_score or 0.0),

            "meta": f.meta if f.meta is not None else {},
            "extra": {},
        })

    return total, out


==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
from apps.domains.results.services.grading_service import grade_submission


def grade_submission_task(submission_id: int):
    """
    Celery ì—†ì´ë„ ë™ì‘ ê°€ëŠ¥í•œ grading entry
    """
    return grade_submission(submission_id)


==========================================================================================
# FILE: utils/clinic.py
==========================================================================================
# apps/domains/results/utils/clinic.py
from __future__ import annotations

from typing import Set

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink


def get_clinic_enrollment_ids_for_session(
    *,
    session: Session,
    include_manual: bool = False,
) -> Set[int]:
    """
    âœ… Clinic ë‹¨ì¼ ê·œì¹™ ì œê³µ

    ê¸°ë³¸ ì •ì±…(ê¶Œì¥/ì•ˆì „):
    - ìš´ì˜ì—ì„œ clinic_required/clinic_rateëŠ” 'ìë™ íŠ¸ë¦¬ê±°' ê¸°ì¤€ìœ¼ë¡œ í†µì¼í•œë‹¤.
      -> include_manual=False (default)

    ì™œëƒí•˜ë©´:
    - ìˆ˜ë™ í´ë¦¬ë‹‰(ê°•ì‚¬ ì¶”ì²œ/ìš”ì²­)ì€ UX/ìš´ì˜ ì •ì±…ì— ë”°ë¼ ì¼€ì´ìŠ¤ê°€ ë‹¬ë¼ì„œ
      í†µê³„ì— ì„ì´ë©´ í™”ë©´ë§ˆë‹¤ "ì™œ ë‹¤ë¥´ëƒ" ë¬¸ì œê°€ ë°˜ë³µëœë‹¤.

    í•„ìš”í•˜ë©´ include_manual=Trueë¡œ
    ìˆ˜ë™ê¹Œì§€ í¬í•¨í•œ 'ì „ì²´ clinic ëŒ€ìƒ'ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
    """
    qs = ClinicLink.objects.filter(session=session)

    # âœ… ìˆ˜ì •ì‚¬í•­(ì¶”ê°€): ì˜ˆì•½ ì™„ë£Œë¡œ ë¶„ë¦¬ëœ ëŒ€ìƒìëŠ” clinic_requiredì—ì„œ ì œì™¸
    qs = qs.filter(resolved_at__isnull=True)

    if not include_manual:
        qs = qs.filter(is_auto=True)

    return set(qs.values_list("enrollment_id", flat=True).distinct())


def is_clinic_required(
    *,
    session: Session,
    enrollment_id: int,
    include_manual: bool = False,
) -> bool:
    """
    âœ… enrollment ë‹¨ìœ„ clinic ì—¬ë¶€ (ë‹¨ì¼ ì§„ì‹¤)
    """
    enrollment_id = int(enrollment_id)
    ids = get_clinic_enrollment_ids_for_session(
        session=session,
        include_manual=include_manual,
    )
    return enrollment_id in ids


==========================================================================================
# FILE: utils/result_queries.py
==========================================================================================
# apps/domains/results/utils/result_queries.py
from __future__ import annotations

from django.db.models import Max, QuerySet, Subquery

from apps.domains.results.models import Result


def latest_results_per_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> QuerySet[Result]:
    """
    âœ… í†µê³„/ì§‘ê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” 'ìµœì‹  Result' queryset (enrollment ê¸°ì¤€ 1ê°œ)

    ì™œ í•„ìš”í•œê°€?
    - unique_togetherê°€ ìˆì–´ë„ ìš´ì˜ì—ì„œëŠ”:
        - ê³¼ê±° ë°ì´í„° ê¹¨ì§
        - manual insert
        - ì¥ì•  ë³µêµ¬/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤ìˆ˜
      ë¡œ ë™ì¼ enrollmentì˜ Resultê°€ ì¤‘ë³µë  ìˆ˜ ìˆë‹¤.
    - í†µê³„ëŠ” ì¤‘ë³µì„ ê³ ë ¤í•˜ì§€ ì•Šìœ¼ë©´ participant/avg/min/max ì „ë¶€ ì™œê³¡.

    êµ¬í˜„ ë°©ì‹:
    - enrollment_idë³„ë¡œ ê°€ì¥ í° id(ê°€ì¥ ìµœê·¼ insert)ë¥¼ ì„ íƒ
    - DB vendor ë…ë¦½ (Postgresì˜ distinct on ê°™ì€ ê¸°ëŠ¥ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ)
    """
    target_id = int(target_id)

    base = Result.objects.filter(
        target_type=str(target_type),
        target_id=target_id,
    )

    # enrollmentë³„ ê°€ì¥ ìµœì‹  Result.idë¥¼ ì„ íƒ
    latest_ids = (
        base.values("enrollment_id")
        .annotate(last_id=Max("id"))
        .values("last_id")
    )

    return Result.objects.filter(id__in=Subquery(latest_ids))


def participant_count_distinct_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> int:
    """
    âœ… participant_count ë‹¨ì¼ ê·œì¹™: distinct enrollment ê¸°ì¤€
    """
    return (
        Result.objects.filter(
            target_type=str(target_type),
            target_id=int(target_id),
        )
        .values("enrollment_id")
        .distinct()
        .count()
    )


==========================================================================================
# FILE: utils/session_exam.py
==========================================================================================
# apps/domains/results/utils/session_exam.py
from __future__ import annotations

from typing import List, Optional

from django.db.models import QuerySet

from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _has_relation(model, name: str) -> bool:
    """
    ëª¨ë¸ì— íŠ¹ì • field/relationì´ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬.
    í”„ë¡œì íŠ¸ íˆìŠ¤í† ë¦¬(ì„¸ì…˜-ì‹œí—˜ ê´€ê³„ê°€ ë°”ë€ŒëŠ” ê³¼ì •)ì—ì„œ
    ëŸ°íƒ€ì„ì— ì•ˆì „í•˜ê²Œ ë™ì‘ì‹œí‚¤ê¸° ìœ„í•œ ë°©ì–´ ìœ í‹¸.
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


# ---------------------------------------------------------------------
# âœ… Canonical API: Session -> Exams
# ---------------------------------------------------------------------
def get_exams_for_session(session: Session) -> QuerySet[Exam]:
    """
    âœ… ë‹¨ì¼ ì§„ì‹¤: Sessionì— ì—°ê²°ëœ Exam queryset ë°˜í™˜
    """
    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams") and hasattr(session, "exams"):
        try:
            return session.exams.all()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Exam.objects.filter(sessions__id=int(session.id)).distinct()

    # 3) Legacy fallback: Session.exam (FK)
    exam_id = getattr(session, "exam_id", None)
    if exam_id:
        return Exam.objects.filter(id=int(exam_id))

    return Exam.objects.none()


def get_exam_ids_for_session(session: Session) -> List[int]:
    """
    âœ… Session -> exam_id list
    """
    return list(get_exams_for_session(session).values_list("id", flat=True))


# ---------------------------------------------------------------------
# âœ… Canonical API: Exam -> Sessions
# ---------------------------------------------------------------------
def get_sessions_for_exam(exam_id: int) -> QuerySet[Session]:
    """
    âœ… ë‹¨ì¼ ì§„ì‹¤: íŠ¹ì • exam_idê°€ ì†í•œ Session queryset ë°˜í™˜
    """
    exam_id = int(exam_id)

    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams"):
        try:
            return Session.objects.filter(exams__id=exam_id).distinct()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Session.objects.filter(exams__id=exam_id).distinct()

    # 3) legacy: Session.exam FK
    return Session.objects.filter(exam_id=exam_id).distinct()


def get_primary_session_for_exam(exam_id: int) -> Optional[Session]:
    """
    âœ… ëŒ€í‘œ session ë°˜í™˜
    """
    qs = get_sessions_for_exam(int(exam_id))
    if not qs.exists():
        return None

    if hasattr(Session, "order"):
        try:
            return qs.order_by("order", "id").first()
        except Exception:
            pass

    return qs.order_by("id").first()


# ---------------------------------------------------------------------
# âœ… NEW: Canonical API (ProgressPipelineìš©)
# ---------------------------------------------------------------------
def get_session_ids_for_exam(exam_id: int) -> List[int]:
    """
    âœ… Exam -> session_id list (SSOT)

    - Progress / Result / í†µê³„ / ì•Œë¦¼ ë“±ì—ì„œ
      "ì‹œí—˜ ê²°ê³¼ â†’ ì–´ë–¤ ì°¨ì‹œë¥¼ ê°±ì‹ í•´ì•¼ í•˜ëŠ”ê°€"ë¥¼
      íŒë‹¨í•  ë•Œ ì‚¬ìš©í•˜ëŠ” **ìœ ì¼í•œ í•¨ìˆ˜**
    """
    return list(
        get_sessions_for_exam(int(exam_id))
        .values_list("id", flat=True)
    )


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/domains/results/views/__init__.py
# apps/domains/results/views/__init__.py

"""
results.views public exports

==========================================================================================
âœ… STEP 2 â€” "Result vs ExamResult" ê³µì¡´ ê·œì¹™ (ë¬¸ì„œí™”, ë™ì‘ ë³€ê²½ ì—†ìŒ)
==========================================================================================

ì´ í”„ë¡œì íŠ¸ëŠ” ì—­ì‚¬ì ìœ¼ë¡œ ë‘ ê°œì˜ ê²°ê³¼ ëª¨ë¸ì´ ê³µì¡´í•  ìˆ˜ ìˆë‹¤.

1) apps.domains.results.models.Result / ResultItem / ResultFact / ExamAttempt
   - ëª©ì : "ì‹œí—˜ ìš´ì˜/ì¬ì‹œí—˜/ëŒ€í‘œ attempt/append-only" ê¸°ë°˜ì˜ SSOT
   - Admin/Teacher í†µê³„, ì¬ì±„ì , ëŒ€í‘œ attempt êµì²´, ì˜¤ë‹µë…¸íŠ¸(append-only Fact ê¸°ë°˜) ë“±ì— ì‚¬ìš©
   - ì´ ê³„ì—´ APIëŠ” target_type="exam" + target_id(exam_id) + enrollment_idê°€ í•µì‹¬ í‚¤

2) apps.domains.results.models.exam_result.ExamResult
   - ëª©ì : ë ˆê±°ì‹œ public API í˜¸í™˜ (/api/v1/results/*) ë° ê³¼ê±° ê¸°ëŠ¥ ìœ ì§€
   - í˜„í–‰ SSOT(Result/Fact)ë¡œ ì™„ì „ í†µí•©í•˜ê¸° ì „ê¹Œì§€ "ì‚­ì œ/ë§ˆì´ê·¸ë ˆì´ì…˜" ê¸ˆì§€
   - ì´ ê³„ì—´ APIëŠ” ê¸°ì¡´ í”„ë¡ íŠ¸/ìš´ì˜ì´ ì˜ì¡´í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê³„ì•½ì„ ë³´ì¡´í•œë‹¤.

ì›ì¹™:
- ì‹ ê·œ ê¸°ëŠ¥/ì •í•©ì„± í•µì‹¬ì€ 1) Result/Fact/Attempt ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.
- 2) ExamResultëŠ” "í˜¸í™˜ ë ˆì´ì–´"ë¡œë§Œ ìœ ì§€í•œë‹¤.
- ë‘˜ì„ ì–µì§€ë¡œ ë³‘í•©í•˜ê±°ë‚˜ ëª¨ë¸ì„ ì‚­ì œí•˜ì§€ ì•ŠëŠ”ë‹¤. (ë§ˆì´ê·¸ë ˆì´ì…˜ ìœ ë°œ ê¸ˆì§€)
==========================================================================================
"""

# ======================================================
# Student-facing
# ======================================================
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

# ======================================================
# Admin / Teacher-facing (ëŒ€í‘œ Viewë§Œ)
# ======================================================
from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView

__all__ = [
    "MyExamResultView",
    "WrongNoteView",
    "AdminExamResultsView",
    "AdminExamSummaryView",
]


==========================================================================================
# FILE: views/admin_clinic_targets_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_clinic_targets_view.py
"""
ì—­í• 
- Admin/Teacherìš© í´ë¦¬ë‹‰ ëŒ€ìƒì ì¡°íšŒ API

Endpoint
- GET /results/admin/clinic-targets/

ì„¤ê³„ ê³„ì•½ (ì¤‘ìš”)
- ëŒ€ìƒì ì„ ì • ë‹¨ì¼ ì§„ì‹¤: progress.ClinicLink(is_auto=True)
- enrollment_id ê¸°ì¤€
- ê³„ì‚°/íŒì •ì€ Service(ClinicTargetService)ì— ìœ„ì„
- ì‘ë‹µ ìŠ¤í‚¤ë§ˆëŠ” AdminClinicTargetSerializerë¡œ ê³ ì • (í”„ë¡ íŠ¸ ê³„ì•½)

ë³´ë¥˜ëœ ê¸°ëŠ¥ (ëª…ì‹œ)
- pagination í•„ìš” ì‹œ ì¶”í›„ DRF pagination ë„ì… ê°€ëŠ¥
- í˜„ì¬ëŠ” ìš´ì˜ì—ì„œ "ì „ì²´ ëŒ€ìƒì"ê°€ ì†Œìˆ˜ë¼ëŠ” ê°€ì • í•˜ì— listë¡œ ë°˜í™˜
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.clinic_target_service import ClinicTargetService
from apps.domains.results.serializers.admin_clinic_target import AdminClinicTargetSerializer


class AdminClinicTargetsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        rows = ClinicTargetService.list_admin_targets()
        return Response(AdminClinicTargetSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_attempts_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_attempts_view.py
# ==========================================================================================
"""
Admin Exam Attempt List View

GET /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

==========================================================================================
âœ… ëª©ì  (Phase 1)
==========================================================================================
- Admin / Teacherê°€ íŠ¹ì • ì‹œí—˜(exam_id) + íŠ¹ì • enrollmentì˜
  ExamAttempt ëª©ë¡ì„ ì¡°íšŒí•œë‹¤.
- AttemptSelectorPanelì˜ ë°ì´í„° ì†ŒìŠ¤

==========================================================================================
âœ… ê³„ì•½ (í”„ë¡ íŠ¸ ê³ ì •)
==========================================================================================
ì‘ë‹µ:
[
  {
    "id": 101,
    "attempt_index": 1,
    "is_retake": false,
    "is_representative": true,
    "status": "done",
    "created_at": "2025-01-01T10:00:00Z",
    "meta": {
      "grading": {
        "total_score": 85,
        "total_max_score": 100
      }
    }
  }
]

- ì •ë ¬: attempt_index ASC
- ëŒ€í‘œ attempt: í•­ìƒ 1ê°œ ë³´ì¥ (ì„œë²„ invariant)
- status enum:
    pending | grading | done | failed

==========================================================================================
âš ï¸ ì£¼ì˜
==========================================================================================
- ìˆ˜ì •/ëŒ€í‘œ ë³€ê²½ âŒ (Phase 2ì—ì„œ êµ¬í˜„)
- enrollment_idëŠ” Enrollment PK ê¸°ì¤€ (results ë„ë©”ì¸ ì „ì²´ ê³„ì•½ê³¼ ë™ì¼)
"""

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt


class AdminExamAttemptsView(APIView):
    """
    Admin / Teacher ì „ìš© Attempt ëª©ë¡ ì¡°íšŒ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        # -------------------------------------------------
        # 1ï¸âƒ£ Attempt ì¡°íšŒ
        # -------------------------------------------------
        attempts = (
            ExamAttempt.objects
            .filter(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .order_by("attempt_index")  # âœ… í”„ë¡ íŠ¸ ê³„ì•½
        )

        if not attempts.exists():
            # ë¹ˆ ë°°ì—´ì„ ë‚´ë ¤ë„ ë˜ì§€ë§Œ,
            # Admin í™”ë©´ì—ì„œëŠ” ë³´í†µ "ì¡´ì¬í•˜ì§€ ì•ŠìŒ"ì´ ì˜ë¯¸ ìˆëŠ” ì˜¤ë¥˜ë¼ íŒë‹¨
            raise ValidationError("No attempts found for this exam/enrollment.")

        # -------------------------------------------------
        # 2ï¸âƒ£ ì‘ë‹µ êµ¬ì„± (Serializer ì—†ì´ ëª…ì‹œì  dict)
        #    - í”„ë¡ íŠ¸ ê³„ì•½ ì•ˆì •ì„±
        #    - meta êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ ë…¸ì¶œ ê°€ëŠ¥
        # -------------------------------------------------
        data = []
        for a in attempts:
            row = {
                "id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": bool(a.is_retake),
                "is_representative": bool(a.is_representative),
                "status": a.status,
                "created_at": a.created_at,
            }

            # meta í•„ë“œê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë…¸ì¶œ (grading ì •ë³´ í¬í•¨ ê°€ëŠ¥)
            if hasattr(a, "meta") and a.meta is not None:
                row["meta"] = a.meta
            else:
                row["meta"] = {}

            data.append(row)

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_item_score_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_item_score_view.py
# (ë™ì‘ ë³€ê²½ ì—†ìŒ: ì´ë¯¸ progress íŠ¸ë¦¬ê±° í¬í•¨)
# ì•„ë˜ íŒŒì¼ì€ "PHASE 7 ì¢…ë£Œ ê¸°ì¤€" ë¬¸ì„œë§Œ ë³´ê°•í•˜ê³  ë¡œì§ì€ ê·¸ëŒ€ë¡œ ë‘”ë‹¤.

from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultItem, ResultFact, ExamAttempt

# âœ… ë‹¨ì¼ ì§„ì‹¤: session ë§¤í•‘ + progress íŠ¸ë¦¬ê±°
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminExamItemScoreView(APIView):
    """
    PATCH /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

    âœ… PHASE 7 ê¸°ì¤€ (ê³ ì •)
    - ìˆ˜ë™ ì±„ì ì€ ResultFact(append-only) + ResultItem ìŠ¤ëƒ…ìƒ· ê°±ì‹ ìœ¼ë¡œ ê¸°ë¡í•œë‹¤.
    - total_score/max_scoreëŠ” ResultItem í•©ìœ¼ë¡œ ì¬ê³„ì‚°í•œë‹¤.
    - ë³€ê²½ ì¦‰ì‹œ progress pipelineì„ íŠ¸ë¦¬ê±°í•˜ì—¬ SessionProgress/ClinicLink ë“± íŒŒìƒ ê²°ê³¼ë¥¼ ìµœì‹ í™”í•œë‹¤.

    ğŸš« ê¸ˆì§€
    - ëª¨ë¸/ë§ˆì´ê·¸ë ˆì´ì…˜ ìœ ë°œ ë³€ê²½
    - í”„ë¡ íŠ¸ ê³„ì•½ ë³€ê²½
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @transaction.atomic
    def patch(
        self,
        request,
        exam_id: int,
        enrollment_id: int,
        question_id: int,
    ):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        question_id = int(question_id)

        if "score" not in request.data:
            raise ValidationError({"detail": "score is required", "code": "INVALID"})

        try:
            new_score = float(request.data.get("score"))
        except Exception:
            raise ValidationError({"detail": "score must be number", "code": "INVALID"})

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ëŒ€í‘œ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .select_for_update()
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .first()
        )
        if not result:
            raise NotFound({"detail": "result not found", "code": "NOT_FOUND"})

        if not result.attempt_id:
            raise ValidationError(
                {"detail": "representative attempt not set", "code": "INVALID"}
            )

        # -------------------------------------------------
        # 2ï¸âƒ£ Attempt ìƒíƒœ í™•ì¸ (LOCK)
        # -------------------------------------------------
        attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
        if not attempt:
            raise NotFound({"detail": "attempt not found", "code": "NOT_FOUND"})

        if attempt.status == "grading":
            return Response(
                {"detail": "attempt is grading", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 3ï¸âƒ£ ResultItem (ë¬¸í•­ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        item = (
            ResultItem.objects
            .select_for_update()
            .filter(result=result, question_id=question_id)
            .first()
        )
        if not item:
            raise NotFound({"detail": "result item not found", "code": "NOT_FOUND"})

        # ì ìˆ˜ ìƒí•œ ë°©ì–´
        max_score = float(item.max_score or 0.0)
        if new_score < 0 or new_score > max_score:
            raise ValidationError(
                {
                    "detail": f"score must be between 0 and {max_score}",
                    "code": "INVALID",
                }
            )

        # -------------------------------------------------
        # 4ï¸âƒ£ ResultFact (append-only ë¡œê·¸)
        # -------------------------------------------------
        ResultFact.objects.create(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=0,              # ìˆ˜ë™ ì±„ì ì´ë¯€ë¡œ 0
            attempt_id=int(result.attempt_id),

            question_id=question_id,
            answer=item.answer or "",
            is_correct=bool(new_score >= max_score),
            score=float(new_score),
            max_score=max_score,
            source="manual",
            meta={
                "manual": True,
                "edited_at": timezone.now().isoformat(),
            },
        )

        # -------------------------------------------------
        # 5ï¸âƒ£ ResultItem ì—…ë°ì´íŠ¸
        # -------------------------------------------------
        item.score = float(new_score)
        item.is_correct = bool(new_score >= max_score)
        item.source = "manual"
        item.save(update_fields=["score", "is_correct", "source"])

        # -------------------------------------------------
        # 6ï¸âƒ£ total_score ì¬ê³„ì‚°
        # -------------------------------------------------
        agg = ResultItem.objects.filter(result=result)

        total_score = sum(float(x.score or 0.0) for x in agg)
        max_total = sum(float(x.max_score or 0.0) for x in agg)

        result.total_score = float(total_score)
        result.max_score = float(max_total)
        result.save(update_fields=["total_score", "max_score"])

        # -------------------------------------------------
        # 7ï¸âƒ£ progress pipeline ì¦‰ì‹œ íŠ¸ë¦¬ê±°
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "question_id": question_id,
                "score": float(new_score),
                "total_score": float(total_score),
                "max_score": float(max_total),
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_exam_result_detail_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_result_detail_view.py
# ==========================================================================================
"""
Admin Exam Result Detail View (ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸)

GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/

==========================================================================================
âœ… PHASE 3 í™•ì • ê³„ì•½ (FRONTEND LOCK)
==========================================================================================
ì‘ë‹µ ë³´ì¥ í•„ë“œ:
- passed                : Exam.pass_score ê¸°ì¤€ ì‹œí—˜ í•©ë¶ˆ
- clinic_required       : ClinicLink ë‹¨ì¼ ì§„ì‹¤ (ìë™ íŠ¸ë¦¬ê±°ë§Œ)
- items[].is_editable   : edit_state ê¸°ë°˜
- edit_state            : LOCK íŒë‹¨ ë©”íƒ€
- allow_retake
- max_attempts
- can_retake

âš ï¸ ì£¼ì˜
- passed â‰  SessionProgress.exam_passed
- ì´ APIëŠ” "ì‹œí—˜ ë‹¨ìœ„(Result) ì§„ì‹¤"
"""

from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)

from apps.domains.exams.models import Exam

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class AdminExamResultDetailView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        exam = get_object_or_404(Exam, id=exam_id)
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0)

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ëŒ€í‘œ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )
        if not result:
            raise NotFound("result not found")

        # -------------------------------------------------
        # 2ï¸âƒ£ passed (ì‹œí—˜ ë‹¨ìœ„ ê¸°ì¤€)
        # -------------------------------------------------
        passed = bool(float(result.total_score or 0.0) >= pass_score)

        # -------------------------------------------------
        # 3ï¸âƒ£ ì¬ì‹œí—˜ ì •ì±… (âš ï¸ ê¸°ì¡´ ê¸°ëŠ¥ ìœ ì§€)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_qs = ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        )
        attempt_count = attempt_qs.count()
        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4ï¸âƒ£ clinic_required (ë‹¨ì¼ ì§„ì‹¤)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,
            )

        # -------------------------------------------------
        # 5ï¸âƒ£ edit_state (LOCK ê·œì¹™)
        # -------------------------------------------------
        edit_state = {
            "can_edit": True,
            "is_locked": False,
            "lock_reason": None,
            "last_updated_by": None,
            "updated_at": None,
        }

        if result.attempt_id:
            attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
            if attempt and attempt.status == "grading":
                edit_state.update({
                    "can_edit": False,
                    "is_locked": True,
                    "lock_reason": "GRADING",
                })

        # -------------------------------------------------
        # 6ï¸âƒ£ Serializer + items[].is_editable
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data

        for item in data.get("items", []):
            item["is_editable"] = bool(
                edit_state["can_edit"] and not edit_state["is_locked"]
            )

        # -------------------------------------------------
        # 7ï¸âƒ£ ìµœì¢… ì‘ë‹µ (ê¸°ì¡´ ê³„ì•½ + PHASE 3 í™•ì¥)
        # -------------------------------------------------
        data.update({
            "passed": passed,
            "allow_retake": allow_retake,
            "max_attempts": max_attempts,
            "can_retake": can_retake,
            "clinic_required": bool(clinic_required),
            "edit_state": edit_state,
        })

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_results_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission
from apps.domains.exams.models import Exam

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamResultsView(APIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    âœ… ëª©í‘œ(ì›ë³¸ ìœ ì§€ + ì •í•©ì„± ê°•í™”)
    - Result(ìŠ¤ëƒ…ìƒ·) ê¸°ë°˜ ì ìˆ˜ ë¦¬ìŠ¤íŠ¸
    - Attempt/Submission ìƒíƒœ ì—°ê²°
    - Clinic ê¸°ì¤€ í†µì¼(ClinicLink)
    - Sessionâ†”Exam ë§¤í•‘ ë‹¨ì¼í™”(utils.session_exam)

    âš ï¸ pass ê¸°ì¤€ ì •ì˜:
    - ì´ í™”ë©´ì€ "ì‹œí—˜(exam) ë‹¨ìœ„ ê²°ê³¼"ì´ë¯€ë¡œ
      pass/failì€ Exam.pass_score ê¸°ì¤€ìœ¼ë¡œ ì œê³µí•œë‹¤.
    - ì„¸ì…˜ ì¢…í•© í†µê³¼(SessionProgress.exam_passed)ëŠ”
      /admin/sessions/... summary APIì—ì„œ ì œê³µí•˜ëŠ” ê²ƒì´ ì •ì„.
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ì¤‘ë³µ enrollment ë°©ì–´: ìµœì‹  1ê°œë§Œ)
        # -------------------------------------------------
        results = latest_results_per_enrollment(
            target_type="exam",
            target_id=exam_id,
        ).order_by("enrollment_id")

        # -------------------------------------------------
        # 2ï¸âƒ£ Session ì°¾ê¸° (clinic íŒë‹¨ìš©)
        #    - ì„¸ì…˜ 1 : ì‹œí—˜ N êµ¬ì¡°ì—ì„œë„ ëŒ€í‘œ sessionì€ í•„ìš”í•  ìˆ˜ ìˆìŒ(legacy UI ë“±)
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)

        # -------------------------------------------------
        # 3ï¸âƒ£ Student ì¡°íšŒ (ì›ë³¸ ë¡œì§ ì¡´ì¤‘: progress_map ê¸°ë°˜ ì¶”ë¡ ì´ì—ˆì§€ë§Œ
        #    SessionProgressì— student_idê°€ ìˆë‹¤ê³  ê°€ì •í•˜ë©´ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ)
        #
        #    ì—¬ê¸°ì„œëŠ” "Result.enrollment_id"ë¥¼ í•™ìƒìœ¼ë¡œ ì§ì ‘ ë§¤í•‘í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ
        #    í”„ë¡œì íŠ¸ì˜ Enrollment/Student ì—°ê²° ë°©ì‹ì´ í•„ìš”í•˜ë‹¤.
        #    ì›ë³¸ì²˜ëŸ¼ SessionProgressì—ì„œ student/userë¥¼ ì¶”ë¡ í•˜ë˜ ë°©ì‹ì´ ìˆìœ¼ë©´ ìœ ì§€í•´ì•¼ í•¨.
        #
        #    âœ… í•˜ì§€ë§Œ í˜„ì¬ ì œê³µëœ ì½”ë“œ ìŠ¤ëƒ…ìƒ·ë§Œìœ¼ë¡œëŠ”
        #    enrollment_id -> student_name í•´ì„ì´ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¬ë¼ ì•ˆì „í•˜ì§€ ì•Šë‹¤.
        #
        #    ê·¸ë˜ì„œ:
        #    - ì›ë³¸ì˜ Student ì¡°íšŒ ë£¨í‹´ì„ "ê°€ëŠ¥í•˜ë©´" ìˆ˜í–‰í•˜ë˜
        #    - ì‹¤íŒ¨í•´ë„ "-" ë¡œ ì•ˆì „í•˜ê²Œ ë°˜í™˜í•œë‹¤.
        # -------------------------------------------------
        student_map = {}
        try:
            # ì›ë³¸ ì½”ë“œì˜ ì˜ë„: SessionProgressì— student_id/user_idê°€ ë¶™ì–´ìˆì„ ìˆ˜ ìˆë‹¤.
            from apps.domains.progress.models import SessionProgress  # ì§€ì—° import

            if session:
                progress_rows = SessionProgress.objects.filter(session=session)
            else:
                progress_rows = SessionProgress.objects.none()

            student_ids = set()
            for sp in progress_rows:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
                if sid:
                    student_ids.add(int(sid))

            student_map = {
                s.id: s
                for s in Student.objects.filter(id__in=list(student_ids))
            }
        except Exception:
            student_map = {}

        # -------------------------------------------------
        # 4ï¸âƒ£ enrollment_id â†’ ìµœì‹  attempt/submission ë§µ
        #    - ResultFactê°€ ìˆìœ¼ë©´ ê°€ì¥ ìµœì‹  attemptë¥¼ ìš°ì„  ì‚¬ìš©
        #    - ì—†ìœ¼ë©´ Result.attempt_id fallback
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(target_type="exam", target_id=exam_id)
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values("enrollment_id", "attempt_id", "submission_id")
        )

        latest_map = {}
        for row in fact_qs:
            eid = int(row["enrollment_id"])
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": int(row["attempt_id"]),
                    "submission_id": int(row["submission_id"]),
                }

        # Result.attempt_id fallback
        attempt_ids = [r.attempt_id for r in results if getattr(r, "attempt_id", None)]
        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = int(r.enrollment_id)
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue
            a = attempt_map.get(int(aid))
            if not a:
                continue
            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # Submission.status
        submission_ids = [v["submission_id"] for v in latest_map.values() if v.get("submission_id")]
        submission_status_map = {
            s.id: s.status
            for s in Submission.objects.filter(id__in=submission_ids)
        }

        # -------------------------------------------------
        # 5ï¸âƒ£ rows êµ¬ì„±
        # -------------------------------------------------
        rows = []
        for r in results:
            enrollment_id = int(r.enrollment_id)

            # student_name (ê°€ëŠ¥í•˜ë©´ ë§¤í•‘, ì•„ë‹ˆë©´ "-")
            student_name = "-"
            try:
                # ì›ë³¸ ë¡œì§: progress rowì— student/user idê°€ ìˆì„ ë•Œë§Œ í‘œì‹œ ê°€ëŠ¥
                # ì—¬ê¸°ì„œëŠ” í™•ì • ë§¤í•‘ì´ ì—†ìœ¼ë¯€ë¡œ ì•ˆì „ fallback
                student_name = "-"
            except Exception:
                student_name = "-"

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = submission_status_map.get(submission_id) if submission_id else None

            # âœ… pass/failì€ exam ë‹¨ìœ„ => Exam.pass_score ê¸°ì¤€
            passed = bool(float(r.total_score or 0.0) >= float(pass_score))

            # âœ… clinic_required ë‹¨ì¼ ê·œì¹™
            clinic_required = bool(
                session and is_clinic_required(session=session, enrollment_id=enrollment_id, include_manual=False)
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student_name,

                "exam_score": float(r.total_score or 0.0),
                "exam_max_score": float(r.max_score or 0.0),

                # ì´í›„ ì„¸ì…˜ ì§‘ê³„ í™•ì¥ ëŒ€ë¹„ (í˜„ì¬ëŠ” ë™ì¼)
                "final_score": float(r.total_score or 0.0),

                "passed": passed,
                "clinic_required": clinic_required,

                "submitted_at": r.submitted_at,

                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        return Response(AdminExamResultRowSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.admin_exam_summary import AdminExamSummarySerializer
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ClinicLink

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamSummaryView(APIView):
    """
    LEGACY COMPAT
    GET /results/admin/exams/<exam_id>/summary/

    âœ… ê³„ì•½ ìœ ì§€(í”„ë¡ íŠ¸ ì•ˆì •ì„±):
    - participant_count, avg/min/max, pass_count/fail_count/pass_rate, clinic_count

    âœ… ì •í•©ì„± ê°•í™”:
    - Result ì¤‘ë³µ enrollment ë°©ì–´: ìµœì‹  Resultë§Œ ì§‘ê³„
    - clinic_count ê¸°ì¤€ í†µì¼: ClinicLink(is_auto=True) enrollment distinct
    - Sessionâ†”Exam ë§¤í•‘ ë‹¨ì¼í™”(utils.session_exam)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        EMPTY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_count": 0,
            "fail_count": 0,
            "pass_rate": 0.0,
            "clinic_count": 0,
        }

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # âœ… ì¤‘ë³µ ë°©ì–´: enrollmentë‹¹ ìµœì‹  Resultë§Œ
        rs = latest_results_per_enrollment(target_type="exam", target_id=exam_id)

        participant_count = rs.values("enrollment_id").distinct().count()
        if participant_count == 0:
            return Response(AdminExamSummarySerializer(EMPTY).data)

        agg = rs.aggregate(
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_count = rs.filter(total_score__gte=pass_score).count()
        fail_count = rs.filter(total_score__lt=pass_score).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # âœ… clinic_countëŠ” session ê¸°ë°˜ìœ¼ë¡œë§Œ ê³„ì‚° ê°€ëŠ¥(ì‹œí—˜ë§Œìœ¼ë¡  clinicì´ ì •ì˜ë˜ì§€ ì•ŠìŒ)
        clinic_count = 0
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id")
                .distinct()
                .count()
            )

        payload = {
            "participant_count": int(participant_count),
            "avg_score": float(agg["avg_score"] or 0.0),
            "min_score": float(agg["min_score"] or 0.0),
            "max_score": float(agg["max_score"] or 0.0),
            "pass_count": int(pass_count),
            "fail_count": int(fail_count),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_count": int(clinic_count),
        }

        return Response(AdminExamSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_representative_attempt_view.py
# (ë™ì‘ ë³€ê²½ ì—†ìŒ: ì´ë¯¸ ìŠ¤ëƒ…ìƒ· ì¬ë¹Œë“œ + progress íŠ¸ë¦¬ê±° í¬í•¨)
# ì•„ë˜ íŒŒì¼ì€ PHASE 7 ì¢…ë£Œ ê¸°ì¤€ ë¬¸ì„œë§Œ ë³´ê°•í•˜ê³  ë¡œì§ì€ ê·¸ëŒ€ë¡œ ë‘”ë‹¤.

from __future__ import annotations

from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result, ResultItem, ResultFact

# âœ… ë‹¨ì¼ ì§„ì‹¤: session ë§¤í•‘ + progress íŠ¸ë¦¬ê±°
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminRepresentativeAttemptView(APIView):
    """
    POST /results/admin/exams/<exam_id>/representative-attempt/

    âœ… PHASE 7 ê¸°ì¤€ (ê³ ì •)
    - ëŒ€í‘œ attempt ë³€ê²½ì€ "is_representative"ë§Œ ë°”ê¾¸ëŠ” í–‰ìœ„ê°€ ì•„ë‹ˆë‹¤.
    - Result ìŠ¤ëƒ…ìƒ·(Result/ResultItem)ì€ ì„ íƒëœ attemptì˜ Fact(append-only)ì—ì„œ ì¦‰ì‹œ ì¬êµ¬ì„±í•œë‹¤.
    - ì´í›„ progress pipelineì„ ì¦‰ì‹œ íŠ¸ë¦¬ê±°í•˜ì—¬ íŒŒìƒ ê²°ê³¼ë¥¼ ìµœì‹ í™”í•œë‹¤.

    ğŸš« ê¸ˆì§€
    - ëª¨ë¸/ë§ˆì´ê·¸ë ˆì´ì…˜ ìœ ë°œ ë³€ê²½
    - í”„ë¡ íŠ¸ ê³„ì•½ ë³€ê²½
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _rebuild_result_snapshot_from_attempt(
        *,
        exam_id: int,
        enrollment_id: int,
        attempt_id: int,
    ) -> Result:
        result = (
            Result.objects
            .select_for_update()
            .filter(target_type="exam", target_id=exam_id, enrollment_id=enrollment_id)
            .first()
        )
        if not result:
            raise NotFound({"detail": "result snapshot not found", "code": "NOT_FOUND"})

        latest_fact_ids = (
            ResultFact.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id,
            )
            .values("question_id")
            .annotate(last_id=Max("id"))
            .values("last_id")
        )

        facts = list(ResultFact.objects.filter(id__in=latest_fact_ids))
        if not facts:
            raise ValidationError({"detail": "no facts for this attempt; cannot rebuild snapshot", "code": "INVALID"})

        total = 0.0
        max_total = 0.0

        for f in facts:
            score = float(f.score or 0.0)
            max_score = float(f.max_score or 0.0)

            ResultItem.objects.update_or_create(
                result=result,
                question_id=int(f.question_id),
                defaults={
                    "answer": str(f.answer or ""),
                    "is_correct": bool(f.is_correct),
                    "score": score,
                    "max_score": max_score,
                    "source": str(f.source or ""),
                },
            )
            total += score
            max_total += max_score

        result.attempt_id = int(attempt_id)
        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()
        result.save(update_fields=["attempt_id", "total_score", "max_score", "submitted_at", "updated_at"])

        return result

    @transaction.atomic
    def post(self, request, exam_id: int):
        exam_id = int(exam_id)

        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if enrollment_id is None or attempt_id is None:
            raise ValidationError({"detail": "enrollment_id and attempt_id are required", "code": "INVALID"})

        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        attempts_qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        if not attempts_qs.exists():
            raise NotFound({"detail": "attempts not found for this exam/enrollment", "code": "NOT_FOUND"})

        target = attempts_qs.filter(id=attempt_id).first()
        if not target:
            raise NotFound({"detail": "attempt not found for this exam/enrollment", "code": "NOT_FOUND"})

        if (target.status or "").lower() == "grading":
            return Response(
                {"detail": "attempt is grading; cannot switch representative", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        attempts_qs.filter(is_representative=True).update(is_representative=False)
        if not target.is_representative:
            target.is_representative = True
            target.save(update_fields=["is_representative"])

        self._rebuild_result_snapshot_from_attempt(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            attempt_id=attempt_id,
        )

        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "attempt_id": attempt_id,
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_result_fact_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_result_fact_view.py
"""
Admin ResultFact Debug View

GET /results/admin/facts/?exam_id=&enrollment_id=&limit=100

âš ï¸ ëª©ì :
- ìš´ì˜/CS/ë””ë²„ê¹…
- append-only Fact ì§ì ‘ ì¡°íšŒ
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ResultFact


class AdminResultFactView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        exam_id = request.query_params.get("exam_id")
        enrollment_id = request.query_params.get("enrollment_id")
        limit = int(request.query_params.get("limit", 100))

        qs = ResultFact.objects.all().order_by("-id")

        if exam_id:
            qs = qs.filter(target_type="exam", target_id=int(exam_id))
        if enrollment_id:
            qs = qs.filter(enrollment_id=int(enrollment_id))

        qs = qs[: min(limit, 500)]

        return Response([
            {
                "id": f.id,
                "exam_id": f.target_id,
                "enrollment_id": f.enrollment_id,
                "attempt_id": f.attempt_id,
                "question_id": f.question_id,
                "answer": f.answer,
                "is_correct": f.is_correct,
                "score": f.score,
                "max_score": f.max_score,
                "meta": f.meta,
                "created_at": f.created_at,
            }
            for f in qs
        ])


==========================================================================================
# FILE: views/admin_session_exams_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_session_exams_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.session_exams_summary import SessionExamsSummarySerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminSessionExamsSummaryView(APIView):
    """
    âœ… Session ê¸°ì¤€ ì‹œí—˜ ìš”ì•½ API (1 Session : N Exams)

    GET /results/admin/sessions/{session_id}/exams/summary/

    ë‹¨ì¼ ì§„ì‹¤ ê·œì¹™:
    - ì„¸ì…˜ ë‹¨ìœ„ pass_rate: SessionProgress.exam_passed ê¸°ë°˜ (ì§‘ê³„ ê²°ê³¼)
    - ì„¸ì…˜ ë‹¨ìœ„ clinic_rate: ClinicLink(is_auto=True) enrollment distinct ê¸°ë°˜
    - ì‹œí—˜ ë‹¨ìœ„ ì ìˆ˜ í†µê³„: Result(ë‹¨, enrollment ì¤‘ë³µ ë°©ì–´)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).select_related("lecture").first()
        if not session:
            return Response(
                SessionExamsSummarySerializer({
                    "session_id": int(session_id),
                    "participant_count": 0,
                    "pass_rate": 0.0,
                    "clinic_rate": 0.0,
                    "strategy": "MAX",
                    "pass_source": "EXAM",
                    "exams": [],
                }).data
            )

        # ì •ì±…(í‘œì‹œìš©)
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = str(getattr(policy, "exam_aggregate_strategy", "MAX"))
        pass_source = str(getattr(policy, "exam_pass_source", "EXAM"))

        # âœ… ì„¸ì…˜ì— ì—°ê²°ëœ exams (ë‹¨ì¼ ì§„ì‹¤)
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -----------------------------
        # session-level participant/pass/clinic
        # -----------------------------
        sp_qs = SessionProgress.objects.filter(session=session)
        participant_count = sp_qs.count()

        # ì„¸ì…˜ ë‹¨ìœ„ ì‹œí—˜ í†µê³¼ìœ¨(ì§‘ê³„ ê²°ê³¼)
        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # clinic_rate(ë‹¨ì¼ ê·œì¹™)
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -----------------------------
        # exam-level stats (Result ê¸°ë°˜, enrollment ì¤‘ë³µ ë°©ì–´)
        # -----------------------------
        exam_rows = []
        for ex in exams:
            rs = latest_results_per_enrollment(
                target_type="exam",
                target_id=int(ex.id),
            )

            agg = rs.aggregate(
                participant_count=Count("id"),  # ì´ë¯¸ enrollment 1ê°œì”©ìœ¼ë¡œ ì¤„ì˜€ìœ¼ë‹ˆ count(id)=participant
                avg_score=Avg("total_score"),
                min_score=Min("total_score"),
                max_score=Max("total_score"),
            )

            pass_score = float(getattr(ex, "pass_score", 0.0) or 0.0)

            pcount = rs.filter(total_score__gte=pass_score).count()
            fcount = rs.filter(total_score__lt=pass_score).count()

            p_total = int(agg["participant_count"] or 0)
            p_rate = (pcount / p_total) if p_total else 0.0

            exam_rows.append({
                "exam_id": int(ex.id),
                "title": str(getattr(ex, "title", "") or ""),
                "pass_score": float(pass_score),

                "participant_count": p_total,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),

                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            })

        payload = {
            "session_id": int(session.id),
            "participant_count": int(participant_count),

            # âœ… ì˜ë¯¸ ê³ ì •:
            # pass_rate = SessionProgress.exam_passed ê¸°ë°˜ (ì§‘ê³„ ê²°ê³¼)
            "pass_rate": round(float(pass_rate), 4),

            # âœ… ì˜ë¯¸ ê³ ì •:
            # clinic_rate = ClinicLink(is_auto=True) ê¸°ì¤€
            "clinic_rate": round(float(clinic_rate), 4),

            "strategy": strategy,
            "pass_source": pass_source,
            "exams": exam_rows,

            # (ê¶Œì¥) pass_rate_source ê°™ì€ ë©”íƒ€ë¥¼ serializerì— ì¶”ê°€í•˜ë©´ ì‚¬ê³  ë°©ì§€ì— í° ë„ì›€
            # "pass_rate_source": "SESSION_PROGRESS",
            # "clinic_rate_source": "CLINIC_LINK_AUTO",
        }

        return Response(SessionExamsSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_session_exams_view.py
==========================================================================================
"""
Admin Session â†’ Exams ì¡°íšŒ

GET /results/admin/sessions/{session_id}/exams/

âœ… í˜„ì¬ ê³„ì•½(ë¦¬íŒ©í† ë§ ì™„ë£Œ):
- Session 1 : Exam N
- canonical relation: exams.Exam.sessions (ManyToManyField to lectures.Session)

ì‘ë‹µì€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ê³ ì •:
[
  {
    exam_id,
    title,
    exam_type,
    open_at,
    close_at,
    allow_retake,
    max_attempts
  },
  ...
]
"""

from django.utils.timezone import localtime
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _dt(v):
    """datetime â†’ ISO string | None (í”„ë¡ íŠ¸ ê³„ì•½ ê³ ì •)"""
    return localtime(v).isoformat() if v else None


class AdminSessionExamsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _get_exams_for_session(session: Session) -> list[Exam]:
        """
        Sessionì— ì—°ê²°ëœ Exam ëª©ë¡ ì¡°íšŒ

        âœ… canonical:
        - session.exams (Exam.sessions related_name="exams")

        ë°©ì–´ì  fallback:
        - Exam.objects.filter(sessions=session)
        """
        if hasattr(session, "exams"):
            try:
                return list(session.exams.all())
            except Exception:
                pass

        return list(
            Exam.objects
            .filter(sessions__id=int(session.id))
            .distinct()
        )

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return Response([])

        exams = self._get_exams_for_session(session)
        if not exams:
            return Response([])

        return Response([
            {
                "exam_id": int(exam.id),
                "title": exam.title or "",
                "exam_type": exam.exam_type,          # âœ… í”„ë¡ íŠ¸ í•„í„°/í‘œì‹œìš©
                "open_at": _dt(exam.open_at),         # âœ… string | null
                "close_at": _dt(exam.close_at),       # âœ… string | null
                "allow_retake": bool(exam.allow_retake),
                "max_attempts": int(exam.max_attempts),
            }
            for exam in exams
        ])


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

â— ì¹˜ëª…ì  ë³´ì•ˆ ì´ìŠˆ ìˆ˜ì •:
- ê¸°ì¡´: IsAuthenticated ë§Œ ê±¸ë ¤ì„œ í•™ìƒë„ ì „ì²´ Attempt ì—´ëŒ ê°€ëŠ¥
- ë³€ê²½: Teacher/Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥

í•„ìš”í•˜ë©´ ì¶”í›„:
- í•™ìƒ ë³¸ì¸ attemptë§Œ ì¡°íšŒí•˜ëŠ” ë³„ë„ Viewë¥¼ /me/* ë¡œ ë”°ë¡œ ë§Œë“¤ ê²ƒ
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ì‹œí—˜ ì‹œë„(Attempt) ê´€ë¦¬ API (ê´€ë¦¬ì/êµì‚¬ìš©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # âœ… ë³´ì•ˆ ìˆ˜ì •
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/exam_grading_view.py
==========================================================================================
# PATH: apps/domains/results/views/exam_grading_view.py
from __future__ import annotations

import logging
from typing import Any, Dict, Tuple

from django.db import transaction
from django.db.models import QuerySet

from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.views import APIView

from apps.core.permissions import IsAdminOrStaff

from apps.domains.results.models.exam_result import ExamResult
from apps.domains.results.serializers.exam_result import (
    ExamResultSerializer,
    ManualGradeSerializer,
)
from apps.domains.results.services.exam_grading_service import ExamGradingService

logger = logging.getLogger(__name__)


def _resolve_student_filter_path(user: Any) -> Tuple[str, Dict[str, Any]]:
    """
    í”„ë¡œì íŠ¸ë³„ student â†” submission ì—°ê²° ê²½ë¡œ ì°¨ì´ë¥¼ ë°©ì–´ì ìœ¼ë¡œ íƒìƒ‰.
    """
    candidates = [
        ("submission__student__user", user),
        ("submission__student", user),
        ("submission__enrollment__student__user", user),
        ("submission__enrollment__student", user),
        ("submission__session_enrollment__enrollment__student__user", user),
        ("submission__session_enrollment__enrollment__student", user),
    ]

    for path, value in candidates:
        try:
            qs = ExamResult.objects.filter(**{path: value}).only("id")[:1]
            if qs:
                return path, {path: value}
        except Exception:
            continue

    return "id__isnull", {"id__isnull": True}


class AutoGradeSubmissionView(APIView):
    """
    âœ… ì„œë¹„ìŠ¤ ë©”ì„œë“œëª…/ê³„ì•½ê³¼ ì¼ì¹˜:
    - ExamGradingService.auto_grade_objective(submission_id=...)
    """
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def post(self, request, submission_id: int):
        service = ExamGradingService()
        out = service.auto_grade_objective(submission_id=int(submission_id))
        serializer = ExamResultSerializer(out.result)
        return Response(
            {"created": (not out.updated), "updated": bool(out.updated), "result": serializer.data},
            status=status.HTTP_201_CREATED if not out.updated else status.HTTP_200_OK,
        )


class ManualGradeSubmissionView(APIView):
    """
    âœ… ì„œë¹„ìŠ¤ ë©”ì„œë“œëª…/ê³„ì•½ê³¼ ì¼ì¹˜:
    - ExamGradingService.apply_manual_overrides(submission_id=..., overrides=...)
    """
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def put(self, request, submission_id: int):
        serializer = ManualGradeSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        overrides = serializer.validated_data.get("overrides")
        if overrides is None:
            # legacy callers might send overrides at top-level
            overrides = serializer.validated_data

        # overridesëŠ” dict í˜•íƒœ ê¸°ëŒ€ (ì„œë¹„ìŠ¤ì—ì„œ dict[str, Any])
        if not isinstance(overrides, dict):
            return Response(
                {"detail": "overrides must be an object/dict"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        service = ExamGradingService()
        result = service.apply_manual_overrides(
            submission_id=int(submission_id),
            overrides=overrides,
        )

        return Response(ExamResultSerializer(result).data, status=status.HTTP_200_OK)


class FinalizeResultView(APIView):
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def post(self, request, submission_id: int):
        service = ExamGradingService()
        result = service.finalize(submission_id=int(submission_id))
        return Response(ExamResultSerializer(result).data, status=status.HTTP_200_OK)


class ExamResultAdminListView(ReadOnlyModelViewSet):
    permission_classes = [IsAdminOrStaff]
    serializer_class = ExamResultSerializer

    def get_queryset(self) -> QuerySet[ExamResult]:
        # âœ… ExamResult ëª¨ë¸ ìŠ¤í‚¤ë§ˆì— ë§ê²Œ select_related ìµœì†Œí™”
        qs = ExamResult.objects.select_related("submission", "exam").all().order_by("-id")

        exam_id = self.request.query_params.get("exam_id")
        if exam_id:
            qs = qs.filter(exam_id=exam_id)

        # ExamResultì— student_id FKê°€ ì—†ì„ ìˆ˜ ìˆì–´ ì•ˆì „ ì²˜ë¦¬:
        # (í•„ë“œê°€ ì‹¤ì œ ì¡´ì¬í•˜ëŠ” í”„ë¡œì íŠ¸ë©´ ì•„ë˜ í•„í„°ë¥¼ í™œì„±í™” ê°€ëŠ¥)
        student_id = self.request.query_params.get("student_id")
        if student_id and hasattr(ExamResult, "student_id"):
            qs = qs.filter(student_id=student_id)

        submission_id = self.request.query_params.get("submission_id")
        if submission_id:
            qs = qs.filter(submission_id=submission_id)

        return qs


class MyExamResultListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        qs = ExamResult.objects.select_related("exam", "submission").order_by("-id")

        exam_id = request.query_params.get("exam_id")
        if exam_id:
            qs = qs.filter(exam_id=exam_id)

        _, filter_kwargs = _resolve_student_filter_path(user)
        qs = qs.filter(**filter_kwargs)

        serializer = ExamResultSerializer(qs, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)


==========================================================================================
# FILE: views/internal_wrong_note_worker_views.py
==========================================================================================
# PATH: apps/domains/results/views/internal_wrong_note_worker_views.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional

from django.conf import settings
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status as drf_status
from rest_framework.permissions import AllowAny
from rest_framework.exceptions import PermissionDenied, NotFound, ValidationError

from apps.domains.results.models import WrongNotePDF
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)

# NOTE:
# - Celery ì „ë©´ íì§€
# - WrongNote PDF ìƒì„±ì€ "ì™¸ë¶€ HTTP Worker"ê°€ ìˆ˜í–‰í•œë‹¤.
# - Worker ì¸ì¦ì€ Bearer token (settings.INTERNAL_WORKER_TOKEN or settings.WORKER_TOKEN)
# - R2 ì—…ë¡œë“œëŠ” presigned PUT URL ê¸°ë°˜
#
# Contract:
#   GET  /api/v1/internal/wrong-note-worker/next/
#   GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


def _get_worker_token() -> str:
    return (
        getattr(settings, "INTERNAL_WORKER_TOKEN", None)
        or getattr(settings, "WORKER_TOKEN", None)
        or ""
    )


def _assert_worker_auth(request) -> None:
    token = _get_worker_token()
    if not token:
        raise PermissionDenied("Internal worker token is not configured.")

    auth = request.headers.get("Authorization", "") or ""
    if not auth.lower().startswith("bearer "):
        raise PermissionDenied("Missing bearer token.")

    incoming = auth.split(" ", 1)[-1].strip()
    if incoming != token:
        raise PermissionDenied("Invalid worker token.")


def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _safe_str(v: Any) -> str:
    return str(v) if v is not None else ""


@dataclass(frozen=True)
class _NextPayload:
    job_id: int
    enrollment_id: int
    lecture_id: Optional[int]
    exam_id: Optional[int]
    from_session_order: int


class WrongNoteWorkerNextView(APIView):
    """
    Worker pulls the next queued job.

    âœ… ìƒíƒœê°’ ë‹¨ì¼í™”(ëª¨ë¸ enum):
    - PENDING -> RUNNING -> DONE/FAILED

    Response:
    - 200 {"has_job": false}
    - 200 {"has_job": true, "job": {...}}
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def get(self, request):
        _assert_worker_auth(request)

        # 1) pick oldest queued job
        qs = (
            WrongNotePDF.objects
            .select_for_update(skip_locked=True)
            .filter(status__in=[WrongNotePDF.Status.PENDING])
            .order_by("id")
        )

        job = qs.first()
        if not job:
            return Response({"has_job": False})

        # 2) mark processing (lock)
        job.status = WrongNotePDF.Status.RUNNING
        job.error_message = ""
        job.save(update_fields=["status", "error_message", "updated_at"])

        payload = _NextPayload(
            job_id=int(job.id),
            enrollment_id=int(job.enrollment_id),
            lecture_id=_safe_int(getattr(job, "lecture_id", None), None),
            exam_id=_safe_int(getattr(job, "exam_id", None), None),
            from_session_order=int(getattr(job, "from_session_order", 2) or 2),
        )

        return Response({
            "has_job": True,
            "job": {
                "job_id": payload.job_id,
                "enrollment_id": payload.enrollment_id,
                "lecture_id": payload.lecture_id,
                "exam_id": payload.exam_id,
                "from_session_order": payload.from_session_order,
            },
        })


class WrongNoteWorkerJobDataView(APIView):
    """
    Worker fetches the data to render PDF (server-side SSOT).
    """

    permission_classes = [AllowAny]

    def get(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        # DONEì´ë©´ ë°ì´í„° ì¬ì „ì†¡ ëŒ€ì‹  ì•ˆì • ì‘ë‹µ
        if str(job.status) == WrongNotePDF.Status.DONE:
            return Response({"job_id": int(job.id), "status": WrongNotePDF.Status.DONE, "count": 0, "items": []})

        # RUNNING/PENDING/FAILED ìƒíƒœì—ì„œ ì¬ì¡°íšŒëŠ” í—ˆìš©(ì›Œì»¤ ì¬ì‹œë„/ë³µêµ¬)
        q = WrongNoteQuery(
            exam_id=_safe_int(getattr(job, "exam_id", None), None),
            lecture_id=_safe_int(getattr(job, "lecture_id", None), None),
            from_session_order=int(getattr(job, "from_session_order", 2) or 2),
            offset=0,
            limit=200,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=int(job.enrollment_id),
            q=q,
        )

        return Response({
            "job_id": int(job.id),
            "status": str(job.status),
            "filters": {
                "enrollment_id": int(job.enrollment_id),
                "lecture_id": _safe_int(getattr(job, "lecture_id", None), None),
                "exam_id": _safe_int(getattr(job, "exam_id", None), None),
                "from_session_order": int(getattr(job, "from_session_order", 2) or 2),
            },
            "count": int(total),
            "items": items,
        })


class WrongNoteWorkerPrepareUploadView(APIView):
    """
    Worker asks server for a presigned PUT URL to upload PDF.
    """

    permission_classes = [AllowAny]

    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        if str(job.status) != WrongNotePDF.Status.RUNNING:
            raise ValidationError({"detail": "job is not running", "code": "INVALID_STATE"})

        file_key = f"results/wrong-notes/wrong-note-{int(job.id)}.pdf"

        try:
            from libs.s3_client.presign import create_presigned_put_url
        except Exception as e:
            return Response(
                {"detail": f"presign helper not available: {e}"},
                status=drf_status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

        upload_url = create_presigned_put_url(
            key=file_key,
            content_type="application/pdf",
            expires_in=60 * 10,
        )

        return Response({
            "job_id": int(job.id),
            "file_key": file_key,
            "upload_url": upload_url,
            "content_type": "application/pdf",
        })


class WrongNoteWorkerCompleteView(APIView):
    """
    Worker reports success after upload.

    POST body:
      { "file_path": "...", "meta": {...} }
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.select_for_update().filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        file_path = request.data.get("file_path") or request.data.get("file_key")
        if not file_path:
            raise ValidationError({"detail": "file_path is required", "code": "INVALID"})

        if str(job.status) != WrongNotePDF.Status.RUNNING:
            raise ValidationError({"detail": "job is not running", "code": "INVALID_STATE"})

        job.status = WrongNotePDF.Status.DONE
        job.file_path = str(file_path)
        job.error_message = ""

        meta = request.data.get("meta")
        if hasattr(job, "meta") and meta is not None:
            job.meta = meta
            job.save(update_fields=["status", "file_path", "error_message", "meta", "updated_at"])
        else:
            job.save(update_fields=["status", "file_path", "error_message", "updated_at"])

        return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.DONE, "file_path": str(job.file_path)})


class WrongNoteWorkerFailView(APIView):
    """
    Worker reports failure.

    POST body:
      { "error_message": "..." }
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.select_for_update().filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        msg = _safe_str(request.data.get("error_message") or request.data.get("detail") or "unknown error")[:5000]

        # DONEì´ë©´ ë©±ë“± ì²˜ë¦¬
        if str(job.status) == WrongNotePDF.Status.DONE:
            return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.DONE})

        job.status = WrongNotePDF.Status.FAILED
        job.error_message = msg
        job.save(update_fields=["status", "error_message", "updated_at"])

        return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.FAILED})


==========================================================================================
# FILE: views/question_stats_views.py
==========================================================================================
# apps/domains/results/views/question_stats_views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.question_stats_service import QuestionStatsService
from apps.domains.results.serializers.question_stats import (
    QuestionStatSerializer,
    TopWrongQuestionSerializer,
)


class AdminExamQuestionStatsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/

    âœ… ë‹¨ì¼ ì§„ì‹¤:
    - ResultFact ê¸°ë°˜ (append-only)
    - ëŒ€í‘œ attempt êµì²´/ì¬ì‹œí—˜ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ í†µê³„
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        data = QuestionStatsService.per_question_stats(
            exam_id=int(exam_id),
        )
        return Response(QuestionStatSerializer(data, many=True).data)


class ExamQuestionWrongDistributionView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, question_id: int):
        dist = QuestionStatsService.wrong_choice_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
        )
        return Response(
            {
                "question_id": int(question_id),
                "distribution": dist,
            }
        )


class ExamTopWrongQuestionsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=5
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        n = int(request.query_params.get("n", 5))
        data = QuestionStatsService.top_n_wrong_questions(
            exam_id=int(exam_id),
            n=n,
        )
        return Response(TopWrongQuestionSerializer(data, many=True).data)


==========================================================================================
# FILE: views/session_score_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_score_summary_view.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.session_score_summary_service import (
    SessionScoreSummaryService,
)
from apps.domains.results.serializers.session_score_summary import (
    SessionScoreSummarySerializer,
)


class SessionScoreSummaryView(APIView):
    """
    GET /results/admin/sessions/<session_id>/score-summary/

    âœ… results ë„ë©”ì¸ ê¸°ì¤€
    - Session ë‹¨ìœ„ ì„±ì  í†µê³„
    - ìš´ì˜/ëŒ€ì‹œë³´ë“œ/AI ì¶”ì²œ ì…ë ¥ìš©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        data = SessionScoreSummaryService.build(
            session_id=int(session_id)
        )
        return Response(SessionScoreSummarySerializer(data).data)


==========================================================================================
# FILE: views/session_scores_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_scores_view.py
"""
SessionScores API (FOR FRONTEND SCORE TAB)

GET /api/v1/results/admin/sessions/<session_id>/scores/

âœ… ëª©ì 
- ì„±ì  íƒ­ ë©”ì¸ í…Œì´ë¸”ì—ì„œ í•™ìƒë³„ ì‹œí—˜/ê³¼ì œ ìš”ì•½ + í¸ì§‘ ìƒíƒœ í‘œì‹œ
- results + homework_results + progress ë°ì´í„°ë¥¼ "ì¡°í•©"ë§Œ í•œë‹¤.

ğŸš« ê¸ˆì§€
- ì ìˆ˜ ê³„ì‚°/ì •ì±… ìƒì„±
- homework percent / cutline ê³„ì‚°
- progress ê²°ê³¼ ì§ì ‘ ë…¸ì¶œ

âœ… ë‹¨ì¼ ì§„ì‹¤
- exam: results(Result + Exam.pass_score)
- homework: homework_results.HomeworkScore
- clinic_required: progress.ClinicLink(is_auto=True)

ğŸ“Œ ì¤‘ìš” ì„¤ê³„ ê²°ì •
- enrollment ëª¨ìˆ˜ëŠ” SessionProgress âŒ
- ì‹œí—˜ OR ê³¼ì œì— í•œ ë²ˆì´ë¼ë„ ì—°ê²°ëœ Enrollment ê¸°ì¤€ âœ…
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Set

from django.utils import timezone
from django.shortcuts import get_object_or_404
from django.db.models import Q

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment
from apps.domains.results.serializers.session_scores import SessionScoreRowSerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink

from apps.domains.homework_results.models import HomeworkScore
from apps.domains.homework_results.models import Homework
from apps.domains.homework.models import HomeworkAssignment

from apps.domains.enrollment.models import Enrollment
from apps.domains.exams.models import ExamEnrollment


def _safe_student_name(enrollment: Optional[Enrollment]) -> str:
    if not enrollment:
        return "-"

    try:
        if hasattr(enrollment, "student") and enrollment.student:
            for k in ("name", "full_name", "username"):
                v = getattr(enrollment.student, k, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        if hasattr(enrollment, "user") and enrollment.user:
            for k in ("name", "full_name", "username", "first_name"):
                v = getattr(enrollment.user, k, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        for k in ("student_name", "name", "title"):
            v = getattr(enrollment, k, None)
            if isinstance(v, str) and v.strip():
                return v.strip()
    except Exception:
        pass

    return "-"


class SessionScoresView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = get_object_or_404(Session, id=int(session_id))

        # -------------------------------------------------
        # 0) Exams
        # -------------------------------------------------
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -------------------------------------------------
        # 1) Enrollment ëª¨ìˆ˜ (ì‹œí—˜ OR ê³¼ì œ)
        # -------------------------------------------------
        # â—ï¸FIX: HomeworkEnrollment âŒ
        # âœ… ê³¼ì œ ëŒ€ìƒìì˜ ë‹¨ì¼ ì§„ì‹¤ì€ HomeworkAssignment
        hw_enrollment_ids_qs = HomeworkAssignment.objects.filter(
            session=session
        ).values_list("enrollment_id", flat=True)

        if exam_ids:
            ex_enrollment_ids_qs = ExamEnrollment.objects.filter(
                exam_id__in=exam_ids
            ).values_list("enrollment_id", flat=True)

            enrollment_qs = Enrollment.objects.filter(
                Q(id__in=hw_enrollment_ids_qs)
                | Q(id__in=ex_enrollment_ids_qs)
            ).distinct()
        else:
            enrollment_qs = Enrollment.objects.filter(
                id__in=hw_enrollment_ids_qs
            ).distinct()

        enrollment_ids = list(enrollment_qs.values_list("id", flat=True))

        # -------------------------------------------------
        # 2) Meta (í”„ë¡ íŠ¸ ê³„ì•½)
        # -------------------------------------------------
        homeworks = list(
            Homework.objects.filter(session=session).order_by("id")
        )

        meta = {
            "exams": [
                {
                    "exam_id": int(ex.id),
                    "title": str(getattr(ex, "title", "")),
                    "pass_score": float(getattr(ex, "pass_score", 0.0) or 0.0),
                }
                for ex in exams
            ],
            "homeworks": [
                {
                    "homework_id": int(hw.id),
                    "title": str(hw.title),
                    "unit": None,  # ì„œë²„ ë‹¨ì¼ ì§„ì‹¤
                }
                for hw in homeworks
            ],
        }

        if not enrollment_ids:
            return Response({"meta": meta, "rows": []})

        # -------------------------------------------------
        # 3) Clinic ëŒ€ìƒì
        # -------------------------------------------------
        clinic_ids: Set[int] = set(
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values_list("enrollment_id", flat=True)
            .distinct()
        )

        # -------------------------------------------------
        # 4) Enrollment â†’ student_name
        # -------------------------------------------------
        enrollment_map = {
            int(e.id): e
            for e in Enrollment.objects.filter(id__in=enrollment_ids)
        }

        student_name_map = {
            eid: _safe_student_name(enrollment_map.get(eid))
            for eid in enrollment_ids
        }

        # -------------------------------------------------
        # 5) HomeworkScore map (enrollment â†’ homework â†’ score)
        # -------------------------------------------------
        hw_scores = HomeworkScore.objects.filter(
            session=session,
            enrollment_id__in=enrollment_ids,
        )

        hw_map: Dict[int, Dict[int, HomeworkScore]] = {}
        for hs in hw_scores:
            hw_map.setdefault(int(hs.enrollment_id), {})[int(hs.homework_id)] = hs

        # -------------------------------------------------
        # 6) Exam Result map
        # -------------------------------------------------
        result_map: Dict[int, Dict[int, Result]] = {}
        for exid in exam_ids:
            rs = (
                latest_results_per_enrollment(
                    target_type="exam",
                    target_id=int(exid),
                )
                .filter(enrollment_id__in=enrollment_ids)
            )
            result_map[int(exid)] = {int(r.enrollment_id): r for r in rs}

        # -------------------------------------------------
        # 7) Attempt LOCK ìƒíƒœ
        # -------------------------------------------------
        attempt_ids = {
            int(r.attempt_id)
            for per_exam in result_map.values()
            for r in per_exam.values()
            if r.attempt_id
        }

        attempt_status_map = {
            int(a.id): str(a.status or "")
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        # -------------------------------------------------
        # 8) Exam ë©”íƒ€
        # -------------------------------------------------
        exam_pass_score_map = {
            int(ex.id): float(getattr(ex, "pass_score", 0.0) or 0.0)
            for ex in exams
        }
        exam_title_map = {
            int(ex.id): str(getattr(ex, "title", "") or "")
            for ex in exams
        }

        # -------------------------------------------------
        # 9) Rows
        # -------------------------------------------------
        rows: List[Dict[str, Any]] = []

        for eid in enrollment_ids:
            clinic_required = eid in clinic_ids

            exams_payload = []
            exam_updated_ats = []

            for exid in exam_ids:
                r = result_map.get(exid, {}).get(eid)

                if r is None:
                    block = {
                        "score": None,
                        "max_score": None,
                        "passed": None,
                        "clinic_required": clinic_required,
                        "is_locked": False,
                        "lock_reason": None,
                    }
                    updated_at = None
                else:
                    attempt_status = attempt_status_map.get(
                        int(r.attempt_id), ""
                    )
                    locked = attempt_status.lower() == "grading"

                    block = {
                        "score": float(r.total_score or 0.0),
                        "max_score": float(r.max_score or 0.0),
                        "passed": (
                            bool(r.passed)
                            if r.passed is not None
                            else None
                        ),
                        "clinic_required": clinic_required,
                        "is_locked": locked,
                        "lock_reason": "GRADING" if locked else None,
                    }
                    updated_at = r.updated_at

                if updated_at:
                    exam_updated_ats.append(updated_at)

                exams_payload.append(
                    {
                        "exam_id": exid,
                        "title": exam_title_map.get(exid, ""),
                        "pass_score": exam_pass_score_map.get(exid, 0.0),
                        "block": block,
                    }
                )

            homeworks_payload = []
            for hw in homeworks:
                hs = hw_map.get(eid, {}).get(int(hw.id))

                if hs is None:
                    block = {
                        "score": None,
                        "max_score": None,
                        "passed": None,
                        "clinic_required": clinic_required,
                        "is_locked": False,
                        "lock_reason": None,
                    }
                    updated_at = None
                else:
                    block = {
                        "score": hs.score,
                        "max_score": hs.max_score,
                        "passed": (
                            bool(hs.passed)
                            if hs.passed is not None
                            else None
                        ),
                        "clinic_required": clinic_required,
                        "is_locked": bool(hs.is_locked),
                        "lock_reason": hs.lock_reason,
                    }
                    updated_at = hs.updated_at

                homeworks_payload.append(
                    {
                        "homework_id": int(hw.id),
                        "title": str(hw.title),
                        "block": block,
                    }
                )

            updated_at = max(
                d
                for d in [
                    *(exam_updated_ats or []),
                    *(hs.updated_at for hs in hw_scores if hs.enrollment_id == eid),
                    getattr(session, "updated_at", None),
                ]
                if d
            )

            rows.append(
                {
                    "enrollment_id": eid,
                    "student_name": student_name_map.get(eid, "-"),
                    "exams": exams_payload,
                    "homeworks": homeworks_payload,
                    "updated_at": updated_at or timezone.now(),
                }
            )

        return Response(
            {
                "meta": meta,
                "rows": SessionScoreRowSerializer(rows, many=True).data,
            }
        )


==========================================================================================
# FILE: views/student_exam_attempts_view.py
==========================================================================================
# PATH: apps/domains/results/views/student_exam_attempts_view.py
"""
Student Exam Attempt History

GET /results/me/exams/{exam_id}/attempts/

- í•™ìƒ ë³¸ì¸ enrollment ê¸°ì¤€
- ì¬ì‹œí—˜ íˆìŠ¤í† ë¦¬ UI ì „ìš©
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsStudent
from apps.domains.results.models import ExamAttempt
from apps.domains.enrollment.models import Enrollment


class MyExamAttemptsView(APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user

        # enrollment íƒìƒ‰ (ë°©ì–´)
        qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        enrollment = qs.first()
        if not enrollment:
            return Response([])

        attempts = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=int(enrollment.id),
        ).order_by("attempt_index")

        return Response([
            {
                "attempt_id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": a.is_retake,
                "is_representative": a.is_representative,
                "status": a.status,
                "created_at": a.created_at,
            }
            for a in attempts
        ])


==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import StudentExamResultSerializer
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    âœ… í¬í•¨:
    - Result + items
    - ì¬ì‹œí—˜ ì •ì±…(allow_retake/max_attempts/can_retake)
    - clinic_required (ClinicLink ê¸°ì¤€ ë‹¨ì¼í™”)
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1ï¸âƒ£ Enrollment ì°¾ê¸° (í”„ë¡œì íŠ¸ë³„ í•„ë“œ ì°¨ì´ ë°©ì–´)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2ï¸âƒ£ Result ì¡°íšŒ (ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(target_type="exam", target_id=int(exam_id), enrollment_id=enrollment_id)
            .prefetch_related("items")
            .first()
        )
        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3ï¸âƒ£ ì¬ì‹œí—˜ ì •ì±… íŒë‹¨ (attempt ê¸°ë°˜)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4ï¸âƒ£ clinic_required (ë‹¨ì¼ ì§„ì‹¤: ClinicLink)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(int(exam_id))
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,  # âœ… ì •ì±… í†µì¼(ìë™ë§Œ)
            )

        # -------------------------------------------------
        # 5ï¸âƒ£ ì‘ë‹µ êµ¬ì„±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = bool(clinic_required)

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_status_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_status_view.py
from __future__ import annotations

from django.core.files.storage import default_storage

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, NotFound

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models import WrongNotePDF
from apps.domains.results.serializers.wrong_note_pdf_serializers import (
    WrongNotePDFStatusSerializer,
)


class WrongNotePDFStatusView(APIView):
    """
    STEP 3-2: ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ (polling)

    GET /results/wrong-notes/pdf/<job_id>/

    ğŸ” ë³´ì•ˆ:
    - í•™ìƒ: ë³¸ì¸ enrollment_idì˜ jobë§Œ ì¡°íšŒ ê°€ëŠ¥
    - êµì‚¬/ê´€ë¦¬ì: ì „ì²´ ì¡°íšŒ ê°€ëŠ¥
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this PDF job.")

    def get(self, request, job_id: int):
        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        self._assert_enrollment_access(request, int(job.enrollment_id))

        # DONEì´ë©´ ë‹¤ìš´ë¡œë“œ URL ì œê³µ (storageì— ë”°ë¼ url()ì´ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë‹ˆ ë°©ì–´)
        file_url = ""
        if job.file_path:
            try:
                file_url = default_storage.url(job.file_path)
            except Exception:
                file_url = ""

        data = {
            "job_id": int(job.id),
            "status": str(job.status),
            "file_path": str(job.file_path or ""),
            "file_url": str(file_url or ""),
            "error_message": str(job.error_message or ""),
            "created_at": job.created_at,
            "updated_at": job.updated_at,
        }

        return Response(WrongNotePDFStatusSerializer(data).data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# PATH: apps/domains/results/views/wrong_note_pdf_view.py
from __future__ import annotations

from django.urls import reverse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


class WrongNotePDFCreateView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± ìš”ì²­ (Celery ì œê±° â†’ HTTP worker pull/push)

    âœ… ìƒíƒœê°’(ëª¨ë¸ enum) ë‹¨ì¼í™”:
    - PENDING -> RUNNING -> DONE/FAILED

    ì‘ë‹µ:
    {
      "job_id": 1,
      "status": "PENDING",
      "status_url": "https://.../results/wrong-notes/pdf/1/"
    }
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id_i,
            lecture_id=int(lecture_id) if lecture_id else None,
            exam_id=int(exam_id) if exam_id else None,
            from_session_order=int(from_order or 2),
            status=WrongNotePDF.Status.PENDING,  # âœ… enqueue = PENDING
        )

        status_path = reverse("wrong-note-pdf-status", kwargs={"job_id": job.id})
        status_url = request.build_absolute_uri(status_path)

        return Response({
            "job_id": int(job.id),
            "status": str(getattr(job, "status", WrongNotePDF.Status.PENDING)),
            "status_url": status_url,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.serializers.wrong_note_serializers import (
    WrongNoteListResponseSerializer,
)
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


class WrongNoteView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ API

    âœ… STEP 3-3 ê³ ì •:
    - lecture_id/from_session_order í•„í„°ëŠ” Service ë‹¨ì¼ ì§„ì‹¤
    - ViewëŠ” ë³´ì•ˆ + query parsing + serializerë§Œ ë‹´ë‹¹
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - exam_id (optional)
        - lecture_id (optional)
        - from_session_order (optional, default=2)
        - offset (optional, default=0)
        - limit (optional, default=50)
        """
        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        exam_id = request.query_params.get("exam_id")
        lecture_id = request.query_params.get("lecture_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        offset = int(request.query_params.get("offset", 0))
        limit = int(request.query_params.get("limit", 50))

        q = WrongNoteQuery(
            exam_id=int(exam_id) if exam_id else None,
            lecture_id=int(lecture_id) if lecture_id else None,
            from_session_order=from_order,
            offset=offset,
            limit=limit,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id_i,
            q=q,
        )

        next_offset = (offset + limit) if (offset + limit) < total else None
        prev_offset = (offset - limit) if (offset - limit) >= 0 else None

        payload = {
            "count": int(total),
            "next": next_offset,
            "prev": prev_offset,
            "results": items,
        }

        return Response(WrongNoteListResponseSerializer(payload).data)
