====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ user.role / user.user_type / groups Îì± Îã§Î•º Ïàò ÏûàÏñ¥ÏÑú Î∞©Ïñ¥Ï†ÅÏúºÎ°ú.
    - ÏûàÏúºÎ©¥ Ïì∞Í≥†
    - ÏóÜÏúºÎ©¥ is_staff/is_superuserÎ°ú ÌåêÎã®
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # ÌîÑÎ°úÏ†ùÌä∏Ïóê Îî∞Îùº "TEACHER" Î¨∏ÏûêÏó¥Ïù¥ Îã§Î•º Ïàò ÏûàÏùå ‚Üí ÌïÑÏöîÏãú Ïó¨Í∏∞Îßå ÏàòÏ†ï
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # Î™ÖÏãúÏ†ÅÏúºÎ°ú teacher/admin ÏïÑÎãàÎ©¥ studentÎ°ú Ï∑®Í∏â(ÏùºÎ∞òÏ†ÅÏù∏ Ï†ïÏ±Ö)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/results/urls.py

from django.urls import path
from rest_framework.routers import DefaultRouter

# ======================================================
# Student Views
# ======================================================
from apps.domains.results.views.student_exam_result_view import MyExamResultView
from apps.domains.results.views.student_exam_attempts_view import (
    MyExamAttemptsView,
)

# ======================================================
# Admin / Teacher - Exam
# ======================================================
from apps.domains.results.views.admin_exam_results_view import (
    AdminExamResultsView,
)
from apps.domains.results.views.admin_exam_summary_view import (
    AdminExamSummaryView,
)
from apps.domains.results.views.admin_exam_result_detail_view import (
    AdminExamResultDetailView,
)
from apps.domains.results.views.admin_exam_item_score_view import (
    AdminExamItemScoreView,
)
from apps.domains.results.views.admin_representative_attempt_view import (
    AdminRepresentativeAttemptView,
)
from apps.domains.results.views.admin_exam_attempts_view import (
    AdminExamAttemptsView,
)

# ======================================================
# Admin / Teacher - Session
# ======================================================
from apps.domains.results.views.admin_session_exams_view import (
    AdminSessionExamsView,
)
from apps.domains.results.views.admin_session_exams_summary_view import (
    AdminSessionExamsSummaryView,
)
from apps.domains.results.views.session_score_summary_view import (
    SessionScoreSummaryView,
)
from apps.domains.results.views.session_scores_view import (
    SessionScoresView,
)

# ======================================================
# Admin / Teacher - Result / Fact
# ======================================================
from apps.domains.results.views.admin_result_fact_view import (
    AdminResultFactView,
)

# ======================================================
# Question Statistics
# ======================================================
from apps.domains.results.views.question_stats_views import (
    AdminExamQuestionStatsView,
    ExamQuestionWrongDistributionView,
    ExamTopWrongQuestionsView,
)

# ======================================================
# Wrong Note
# ======================================================
from apps.domains.results.views.wrong_note_view import (
    WrongNoteView,
)
from apps.domains.results.views.wrong_note_pdf_view import (
    WrongNotePDFCreateView,
)
from apps.domains.results.views.wrong_note_pdf_status_view import (
    WrongNotePDFStatusView,
)

# ======================================================
# ExamAttempt (ViewSet)
# ======================================================
from apps.domains.results.views.exam_attempt_view import (
    ExamAttemptViewSet,
)

# ======================================================
# Clinic Targets (results domain)
# ======================================================
from apps.domains.results.views.admin_clinic_targets_view import (
    AdminClinicTargetsView,
)

# ======================================================
# Clinic Bookings (SAFE ALIAS)
# ------------------------------------------------------
# results ÎèÑÎ©îÏù∏Ïóê ViewÎ•º ÏÉàÎ°ú ÎßåÎì§ÏßÄ ÏïäÍ≥†,
# clinic ÎèÑÎ©îÏù∏Ïùò ParticipantViewSetÏùÑ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©ÌïúÎã§.
# - Îã®Ïùº Source of Truth Ïú†ÏßÄ
# - Ï§ëÎ≥µ Î°úÏßÅ Î∞©ÏßÄ
# - URL Íµ¨Ï°∞Îäî results Í∏∞Ï§Ä Ïú†ÏßÄ
# ======================================================
from apps.domains.clinic.views import (
    ParticipantViewSet as AdminClinicBookingViewSet,
)

# ======================================================
# URL Patterns
# ======================================================
urlpatterns = [
    # ----------------------------
    # Student
    # ----------------------------
    path(
        "me/exams/<int:exam_id>/",
        MyExamResultView.as_view(),
        name="my-exam-result",
    ),
    path(
        "me/exams/<int:exam_id>/attempts/",
        MyExamAttemptsView.as_view(),
        name="my-exam-attempts",
    ),

    # ----------------------------
    # Admin / Teacher - Exam
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/summary/",
        AdminExamSummaryView.as_view(),
        name="admin-exam-summary",
    ),
    path(
        "admin/exams/<int:exam_id>/results/",
        AdminExamResultsView.as_view(),
        name="admin-exam-results",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/",
        AdminExamResultDetailView.as_view(),
        name="admin-exam-result-detail",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/items/<int:question_id>/",
        AdminExamItemScoreView.as_view(),
        name="admin-exam-item-score",
    ),
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/attempts/",
        AdminExamAttemptsView.as_view(),
        name="admin-exam-attempts",
    ),

    # ----------------------------
    # Admin / Teacher - Question Stats
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/",
        AdminExamQuestionStatsView.as_view(),
        name="admin-exam-question-stats",
    ),
    path(
        "admin/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamQuestionWrongDistributionView.as_view(),
        name="admin-exam-question-wrong-distribution",
    ),
    path(
        "admin/exams/<int:exam_id>/questions/top-wrong/",
        ExamTopWrongQuestionsView.as_view(),
        name="admin-exam-top-wrong-questions",
    ),

    # ----------------------------
    # Admin / Teacher - Session
    # ----------------------------
    path(
        "admin/sessions/<int:session_id>/score-summary/",
        SessionScoreSummaryView.as_view(),
        name="session-score-summary",
    ),
    path(
        "admin/sessions/<int:session_id>/scores/",
        SessionScoresView.as_view(),
        name="admin-session-scores",
    ),
    path(
        "admin/sessions/<int:session_id>/exams/",
        AdminSessionExamsView.as_view(),
        name="admin-session-exams",
    ),
    path(
        "admin/sessions/<int:session_id>/exams/summary/",
        AdminSessionExamsSummaryView.as_view(),
        name="admin-session-exams-summary",
    ),

    # ----------------------------
    # Admin / Teacher - Result Fact
    # ----------------------------
    path(
        "admin/facts/",
        AdminResultFactView.as_view(),
        name="admin-result-facts",
    ),

    # ----------------------------
    # Admin / Teacher - Clinic
    # ----------------------------
    path(
        "admin/clinic-targets/",
        AdminClinicTargetsView.as_view(),
        name="admin-clinic-targets",
    ),

    # ----------------------------
    # Wrong Notes
    # ----------------------------
    path(
        "wrong-notes",
        WrongNoteView.as_view(),
        name="wrong-note",
    ),
    path(
        "wrong-notes/pdf/",
        WrongNotePDFCreateView.as_view(),
        name="wrong-note-pdf-create",
    ),
    path(
        "wrong-notes/pdf/<int:job_id>/",
        WrongNotePDFStatusView.as_view(),
        name="wrong-note-pdf-status",
    ),
]

# ======================================================
# Routers
# ======================================================
router = DefaultRouter()
router.register(
    "exam-attempts",
    ExamAttemptViewSet,
)
router.register(
    "admin/clinic-bookings",
    AdminClinicBookingViewSet,
    basename="admin-clinic-bookings",
)

urlpatterns += router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="Ïù¥ FactÎ•º ÏÉùÏÑ±Ìïú ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="Ïù¥ attemptÎ•º Î∞úÏÉùÏãúÌÇ® submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1Î∂ÄÌÑ∞ ÏãúÏûë")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="Ïù¥ ResultÍ∞Ä Ï∞∏Ï°∞ÌïòÎäî ÎåÄÌëú ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_add_exam_attempt_meta.py
==========================================================================================
# apps/domains/results/migrations/0002_add_exam_attempt_meta.py
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("results", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="examattempt",
            name="meta",
            field=models.JSONField(
                null=True,
                blank=True,
                help_text=(
                    "Attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞. "
                    "OMR/AI ÌåêÎèÖ Ï†ïÎ≥¥, total_score, pass_score, "
                    "Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞ Îì± Ïö¥ÏòÅ/Î∂ÑÏÑùÏö© Ï†ïÎ≥¥ Ï†ÄÏû•."
                ),
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF

# ‚ùå SubmissionAnswer Ï†úÍ±∞Îê® (raw inputÏùÄ submissions ÎèÑÎ©îÏù∏ Ï±ÖÏûÑ)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
# apps/domains/results/models/exam_attempt.py
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    ÌïôÏÉùÏùò 'ÏãúÌóò 1Ìöå ÏùëÏãú'Î•º ÎÇòÌÉÄÎÇ¥Îäî ÏóîÌã∞Ìã∞ (append-only)

    üî• ÌïµÏã¨ Ï±ÖÏûÑ
    - Submission Îã®ÏúÑÍ∞Ä ÏïÑÎãå 'ÏãúÌóò ÏùëÏãú ÏÇ¨Ïã§'Ïùò Í≥†Ï†ï
    - Result / ResultFact / Progress ÏßëÍ≥ÑÏùò Í∏∞Ï§ÄÏ†ê
    - Ïû¨ÏãúÌóò/ÎåÄÌëú attempt ÍµêÏ≤¥Ïùò Îã®ÏúÑ

    ‚úÖ ÏÑ§Í≥Ñ Í≥†Ï†ï ÏÇ¨Ìï≠
    --------------------------------------------------
    1) ExamAttemptÎäî append-only Í∞úÎÖêÏù¥Îã§.
       - Í∏∞Ï°¥ attemptÎ•º ÏàòÏ†ïÌïòÏßÄ ÏïäÎäîÎã§.
       - ÎåÄÌëú attempt Î≥ÄÍ≤ΩÏùÄ is_representative ÌîåÎûòÍ∑∏Î°úÎßå Ï≤òÎ¶¨ÌïúÎã§.

    2) Result / ResultItemÏùÄ Ìï≠ÏÉÅ
       "ÎåÄÌëú attempt(is_representative=True)"Î•º Í∞ÄÎ¶¨ÌÇ§Îäî snapshotÏù¥Îã§.

    3) meta ÌïÑÎìúÎäî attempt Îã®ÏúÑÏùò 'Ïö¥ÏòÅ/Î∂ÑÏÑù/Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞'Î•º Ï†ÄÏû•ÌïúÎã§.
       - OMR Ïã†Î¢∞ÎèÑ
       - AI ÌåêÎèÖ Í≤∞Í≥º
       - total_score / pass_score Ïä§ÎÉÖÏÉ∑
       - Ïû¨Ï±ÑÏ†ê ÏÇ¨Ïú† Îì±
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # SubmissionÏùÄ ÏãúÎèÑÏùò ÏõêÏù∏(event)
    submission_id = models.PositiveIntegerField(
        help_text="Ïù¥ attemptÎ•º Î∞úÏÉùÏãúÌÇ® submission"
    )

    # 1Î∂ÄÌÑ∞ ÏãúÏûë (ÏãúÌóò nÎ≤àÏß∏ ÏùëÏãú)
    attempt_index = models.PositiveIntegerField(help_text="1Î∂ÄÌÑ∞ ÏãúÏûë")

    # Ïû¨ÏãúÌóò Ïó¨Î∂Ä (attempt_index > 1 Í≥º ÏùòÎØ∏Ï†ÅÏúºÎ°ú ÎèôÏùºÌïòÏßÄÎßå, Ï°∞Ìöå ÏµúÏ†ÅÌôîÏö©)
    is_retake = models.BooleanField(default=False)

    # ÏÑúÎ≤ÑÍ∞Ä ÌåêÎã®ÌïòÎäî ÎåÄÌëú attempt
    # ResultÎäî Ìï≠ÏÉÅ Ïù¥ attemptÎ•º Í∏∞Ï§ÄÏúºÎ°ú snapshotÏùÑ ÎßåÎì†Îã§.
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ÏÉùÏÑ±Îê®
            ("grading", "Grading"),     # Ï±ÑÏ†ê Ï§ë
            ("done", "Done"),           # Ï±ÑÏ†ê ÏôÑÎ£å
            ("failed", "Failed"),       # Ï±ÑÏ†ê Ïã§Ìå®
        ],
        default="pending",
    )

    # ==================================================
    # ‚úÖ NEW: attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ (ÏÑ§Í≥Ñ ÌïÑÏàò)
    # ==================================================
    meta = models.JSONField(
        null=True,
        blank=True,
        help_text=(
            "Attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞. "
            "OMR/AI ÌåêÎèÖ Ï†ïÎ≥¥, total_score, pass_score, "
            "Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞ Îì± Ïö¥ÏòÅ/Î∂ÑÏÑùÏö© Ï†ïÎ≥¥ Ï†ÄÏû•."
        ),
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ÏãúÌóò/ÏàôÏ†ú Í≤∞Í≥º ÏµúÏã† Ïä§ÎÉÖÏÉ∑ (Ï°∞ÌöåÏö©)
    Í≥ÑÏÇ∞ ÏóÜÏùå

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ
    - attempt_id: Ïù¥ ResultÍ∞Ä Ïñ¥Îñ§ ExamAttempt(ÏãúÎèÑ)Î•º ÎåÄÌëúÌïòÎäîÏßÄ Ï∂îÏ†Å Í∞ÄÎä•
    - Ïû¨ÏãúÌóò/ÎåÄÌëú attempt ÍµêÏ≤¥ ÏãúÏóêÎèÑ "Ïñ¥Îñ§ attempt Í≤∞Í≥ºÏù∏ÏßÄ" Î™ÖÌôïÌï¥Ïßê

    ‚ö†Ô∏è Ï£ºÏùò:
    - Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ attempt_idÎäî ÏùºÎã® NULL ÌóàÏö©ÏúºÎ°ú Îì§Ïñ¥Í∞ê (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÏóêÏÑú null=True)
    - Ïö¥ÏòÅÏóêÏÑú Î∞±ÌïÑ ÌõÑ null=FalseÎ°ú tighten ÌïòÎäî 2Îã®Í≥ÑÍ∞Ä Ï†ïÏÑù
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # ‚úÖ Ïñ¥Îñ§ attemptÏùò Í≤∞Í≥ºÏù∏ÏßÄ Ï∂îÏ†Å (ÎåÄÌëú attempt Í∏∞Ï§Ä)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="Ïù¥ ResultÍ∞Ä Ï∞∏Ï°∞ÌïòÎäî ÎåÄÌëú ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    Í≤∞Í≥º Fact (append-only, Î∂àÎ≥Ä)
    - ÏßëÍ≥Ñ/ÌÜµÍ≥Ñ/Ïù¥Î≤§Ìä∏ Î°úÍ∑∏Ïóê Í∞ÄÍπåÏõÄ

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ
    - attempt_id: Ïù¥ FactÍ∞Ä Ïñ¥Îäê attemptÏóêÏÑú ÎÇòÏò® Ïù¥Î≤§Ìä∏Ïù∏ÏßÄ Ï∂îÏ†Å Í∞ÄÎä•

    ‚ö†Ô∏è Î¶¨Ìå©ÌÜ†ÎßÅ Î©îÎ™® (Ï§ëÏöî)
    ÏßÄÍ∏àÏùÄ ResultFactÍ∞Ä answer/score/meta/sourceÍπåÏßÄ Îì§Í≥† ÏûàÏùå.
    Ïû•Í∏∞Ï†ÅÏúºÎ°úÎäî:
      - ResultFact = "ÏßëÍ≥ÑÏö© Ïù¥Î≤§Ìä∏"
      - ÏÉÅÏÑ∏/Ï±ÑÏ†êÍ≤∞Í≥º = results.SubmissionAnswer Í∞Ä Îì§Í≥† Í∞ÄÎäî Í≤å Ï†ïÏÑù
    Îã§Îßå ÏßÄÍ∏à Îã®Í≥ÑÏóêÏÑúÎäî analytics Ï†úÍ±∞ + Îã®Ïàú Ïö¥ÏòÅÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # ‚úÖ Ïñ¥Îñ§ attemptÏóêÏÑú ÏÉùÏÑ±Îêú FactÏù∏ÏßÄ
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="Ïù¥ FactÎ•º ÏÉùÏÑ±Ìïú ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    Î¨∏Ìï≠Î≥Ñ ÏµúÏã† Í≤∞Í≥º ÏÉÅÌÉú (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/admin_clinic_target.py
==========================================================================================
# PATH: apps/domains/results/serializers/admin_clinic_target.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© "ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê" Î¶¨Ïä§Ìä∏ ÏùëÎãµ Í≥ÑÏïΩÏùÑ Í≥†Ï†ïÌïúÎã§.

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
- Clinic ÎåÄÏÉÅÏûê ÏÑ†Ï†ï/ÌåêÎã®ÏùÄ results ÎèÑÎ©îÏù∏Ïùò Îã®Ïùº ÏßÑÏã§Ïù¥Îã§.
- enrollment_id Í∏∞Ï§Ä(Îã®Ïùº ÏßÑÏã§)ÏúºÎ°ú ÎÇ¥Î†§Ï§ÄÎã§.
- ÌîÑÎ°†Ìä∏Ïùò ClinicTarget ÌÉÄÏûÖÍ≥º 1:1Î°ú ÎßûÏ∂òÎã§.

Î≥¥Î•òÎêú Í∏∞Îä• (Î™ÖÏãú)
- reasonÏùò ÏÑ∏Î∂Ä ÌåêÏ†ï(Ï†êÏàò/Ïã†Î¢∞ÎèÑ)ÏùÄ ÏÑúÎπÑÏä§ÏóêÏÑú Î≥¥ÏàòÏ†ÅÏúºÎ°ú ÌåêÏ†ïÌïúÎã§.
  (ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ LOW_CONFIDENCE Ïã†Ìò∏Í∞Ä Attempt.metaÏóê ÏûàÏùÑ ÏàòÎèÑ, ResultFact.metaÏóê ÏûàÏùÑ ÏàòÎèÑ ÏûàÏñ¥ Î∞©Ïñ¥ Íµ¨ÌòÑ)
"""

from rest_framework import serializers


class AdminClinicTargetSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    session_title = serializers.CharField()

    reason = serializers.ChoiceField(choices=["score", "confidence"])

    exam_score = serializers.FloatField()
    cutline_score = serializers.FloatField()

    created_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    # =====================================
    # üîß PATCH: Ï†êÏàò ÌïÑÎìú Î™ÖÏãúÏ†Å Î∂ÑÎ¶¨
    # - SessionScores / AdminExamResults Í≥µÏö© Í≥ÑÏïΩ
    # - ÌîÑÎ°†Ìä∏ ÏàòÏ†ï ÏóÜÏù¥ ÌôïÏû• Í∞ÄÎä•
    # =====================================
    exam_score = serializers.FloatField()
    exam_max_score = serializers.FloatField()

    final_score = serializers.FloatField()
    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # üî• Submission Ïó∞Îèô ÌïÑÎìú (Í∏∞Ï°¥ Ïú†ÏßÄ)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (Ïã†Í∑ú)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/question_stats.py
==========================================================================================
# apps/domains/results/serializers/question_stats.py

from rest_framework import serializers


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct = serializers.IntegerField()
    accuracy = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    distribution = serializers.DictField(
        child=serializers.IntegerField()
    )


class TopWrongQuestionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    wrong_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/session_exams_summary.py
==========================================================================================
# apps/domains/results/serializers/session_exams_summary.py
from rest_framework import serializers


class SessionExamRowSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    participant_count = serializers.IntegerField()
    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()


class SessionExamsSummarySerializer(serializers.Serializer):
    session_id = serializers.IntegerField()

    participant_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    strategy = serializers.CharField()
    pass_source = serializers.CharField()

    exams = SessionExamRowSerializer(many=True)


==========================================================================================
# FILE: serializers/session_score_summary.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_score_summary.py

from rest_framework import serializers


class SessionScoreSummarySerializer(serializers.Serializer):
    """
    ÏÑ∏ÏÖò Îã®ÏúÑ ÏÑ±Ï†Å ÏöîÏïΩ (Ïö¥ÏòÅ/ÌÜµÍ≥ÑÏö©)

    ‚ö†Ô∏è Ï£ºÏùò
    - Result / ResultFact / Progress Í≤∞Í≥ºÎßå ÏÇ¨Ïö©
    - attempt ÍµêÏ≤¥ÏôÄ Î¨¥Í¥ÄÌïòÍ≤å Ìï≠ÏÉÅ ÏùºÍ¥ÄÎêú Í∞í
    """

    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    attempt_stats = serializers.DictField()


==========================================================================================
# FILE: serializers/session_scores.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_scores.py
"""
SessionScores Serializer (Score Tab)

‚úÖ ÏÑ§Í≥Ñ Í≥†Ï†ï(Ï§ëÏöî)
- Ïù¥ SerializerÎäî "ÌëúÏãúÏö© DTO" Ïù¥Îã§.
- ÎèÑÎ©îÏù∏ Î°úÏßÅ/ÌåêÏ†ï/Ï†ïÏ±Ö Í≥ÑÏÇ∞ÏùÑ ÌïòÏßÄ ÏïäÎäîÎã§.
- ViewÏóêÏÑú ÎßåÎì§Ïñ¥Ï§Ä dictÎ•º Í∑∏ÎåÄÎ°ú validate/serializeÎßå ÏàòÌñâÌïúÎã§.

‚úÖ ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ
- score === null ÏùÄ "ÎØ∏ÏÇ∞Ï∂ú/ÎØ∏ÏùëÏãú/Ï≤òÎ¶¨Ï§ë" ÏùòÎØ∏ (0Í≥º Íµ¨Î∂Ñ)
- is_locked / lock_reason ÏùÄ ÏûÖÎ†• ÎπÑÌôúÏÑ±Ìôî + tooltip Ïö©ÎèÑ
"""

from __future__ import annotations

from rest_framework import serializers


class ScoreBlockSerializer(serializers.Serializer):
    score = serializers.FloatField(allow_null=True)
    max_score = serializers.FloatField(allow_null=True)

    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    is_locked = serializers.BooleanField()
    lock_reason = serializers.CharField(allow_null=True, allow_blank=True)


class ExamScoreBlockSerializer(serializers.Serializer):
    """
    ‚úÖ Session 1:N Exam ÎåÄÏùë
    - exam_id + title + pass_score (meta ÏóÜÏù¥ÎèÑ row ÏûêÏ≤¥Î°ú ÌëúÏãú Í∞ÄÎä•)
    - ÎÇ¥Î∂Ä score blockÏùÄ ScoreBlockSerializerÎ•º Ïû¨ÏÇ¨Ïö©
    """

    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    block = ScoreBlockSerializer()


class SessionScoreRowSerializer(serializers.Serializer):
    """
    ‚úÖ ÏÑ±Ï†Å ÌÉ≠ Î©îÏù∏ ÌÖåÏù¥Î∏î Row
    - ÌïôÏÉù 1Î™ÖÎãπ 1 Row
    - exams: ÏãúÌóò ÏöîÏïΩ Î¶¨Ïä§Ìä∏(1:N)
    - homework: Í≥ºÏ†ú ÏöîÏïΩ(ÏÑ∏ÏÖò Îã®ÏúÑ Ïä§ÎÉÖÏÉ∑)
    """

    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField(allow_blank=True)

    exams = ExamScoreBlockSerializer(many=True)
    homework = ScoreBlockSerializer()

    updated_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    ‚úÖ ÌïôÏÉù ÌôîÎ©¥: Î¨∏Ìï≠Î≥Ñ Í≤∞Í≥º
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    ‚úÖ ÌïôÏÉù ÌôîÎ©¥: ÏãúÌóò Í≤∞Í≥º(Ï¥ùÏ†ê + Î¨∏Ìï≠Î≥Ñ) + Ïû¨ÏãúÌóò Î≤ÑÌäº ÌåêÎã®Í∞í

    ÏÑ§Í≥Ñ:
    - Result Î™®Îç∏ ÏûêÏ≤¥Îäî 'Ïä§ÎÉÖÏÉ∑'Ïù¥ÎØÄÎ°ú
      allow_retake/max_attempts/can_retakeÎäî Exam Ï†ïÏ±Ö + Attempt ÏÉÅÌÉúÎ°ú Í≥ÑÏÇ∞Ìï¥ÏÑú ÎÇ¥Î†§Ï§ÄÎã§.
    - Ïù¥ Í∞íÎì§ÏùÄ "ÏùëÎãµ ÌïÑÎìú"Ïù¥ÏßÄ Result DB ÌïÑÎìúÍ∞Ä ÏïÑÎãàÎã§.
      ‚Üí ViewÏóêÏÑú Í≥ÑÏÇ∞ ÌõÑ dataÏóê Ï£ºÏûÖÌïòÎäî Î∞©ÏãùÏù¥ Í∞ÄÏû• Îã®Ïàú/Î™ÖÌôï.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # ‚úÖ STEP 2: ÌîÑÎ°†Ìä∏ Ïû¨ÏãúÌóò Î≤ÑÌäº ÌåêÎã®Ïö© (ÏùëÎãµ Ï†ÑÏö© ÌïÑÎìú)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # ‚úÖ STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: serializers/wrong_note_pdf_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_pdf_serializers.py
from __future__ import annotations

from rest_framework import serializers


class WrongNotePDFStatusSerializer(serializers.Serializer):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF Job ÏÉÅÌÉú Ï°∞Ìöå ÏùëÎãµ

    ‚úÖ ÌîÑÎ°†Ìä∏ Ìè¥ÎßÅÏö© ÏµúÏÜå ÌïÑÎìú
    - status: PENDING/RUNNING/DONE/FAILED
    - file_url: DONEÏùº Îïå Îã§Ïö¥Î°úÎìú URL
    - error_message: FAILEDÏùº Îïå ÌëúÏãú
    """
    job_id = serializers.IntegerField()
    status = serializers.CharField()
    file_path = serializers.CharField(allow_blank=True)
    file_url = serializers.CharField(allow_blank=True, allow_null=True)
    error_message = serializers.CharField(allow_blank=True)
    created_at = serializers.DateTimeField()
    updated_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/wrong_note_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_serializers.py
from __future__ import annotations

from typing import Any, Dict, Optional
from rest_framework import serializers


class WrongNoteItemSerializer(serializers.Serializer):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Îã®Ïùº Î¨∏Ìï≠ ÏïÑÏù¥ÌÖú

    ‚úÖ ÏùòÎèÑ:
    - ResultFact/ResultItem Íµ¨Ï°∞Í∞Ä ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ Ï°∞Í∏à Îã¨ÎùºÎèÑ
      ViewÏóêÏÑú dictÎ°ú ÎßåÎì§Ïñ¥ serialize Í∞ÄÎä•ÌïòÍ≤å "Îã®Ïàú Serializer"Î°ú Í≥†Ï†ï
    """

    exam_id = serializers.IntegerField()
    attempt_id = serializers.IntegerField()
    attempt_created_at = serializers.DateTimeField(allow_null=True)

    question_id = serializers.IntegerField()
    question_number = serializers.IntegerField(required=False, allow_null=True)
    answer_type = serializers.CharField(required=False, allow_blank=True)

    # ÌïôÏÉù Îãµ / Ï†ïÎãµ / Ï†êÏàò
    student_answer = serializers.CharField(required=False, allow_blank=True)
    correct_answer = serializers.CharField(required=False, allow_blank=True)

    is_correct = serializers.BooleanField()
    score = serializers.FloatField()
    max_score = serializers.FloatField()

    # ÏõêÎ≥∏ Î©îÌÉÄ (OMR/AI Ìè¨Ìï®)
    meta = serializers.JSONField(required=False)

    # ÏòµÏÖò: ÌîÑÎ°†Ìä∏ UXÏö© (Î¨∏Ï†ú ÏßÄÎ¨∏/ÏÑ†ÏßÄ/Ìï¥ÏÑ§ Îì±ÏùÄ ÌôïÏû• Ìè¨Ïù∏Ìä∏)
    extra = serializers.JSONField(required=False)


class WrongNoteListResponseSerializer(serializers.Serializer):
    """
    ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ìè¨Ìï® ÏùëÎãµ
    """
    count = serializers.IntegerField()
    next = serializers.IntegerField(allow_null=True)   # Îã§Ïùå offset
    prev = serializers.IntegerField(allow_null=True)   # Ïù¥Ï†Ñ offset
    results = WrongNoteItemSerializer(many=True)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    Í≥ÑÏÇ∞Îêú Í≤∞Í≥ºÎ•º Î∞õÏïÑ resultsÏóê Î∞òÏòÅ
    ‚ùå Í≥ÑÏÇ∞ ÏóÜÏùå (Í≥ÑÏÇ∞ÏùÄ graderÍ∞Ä Ìï®)

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ:
    - apply()Í∞Ä attempt_idÎ•º Î∞õÏïÑÏÑú Result / ResultFactÏóê Ï†ÄÏû•

    ‚úÖ Ïö¥ÏòÅ ÏïàÏ†ÑÏÑ± Ìå®Ïπò (Critical #4)
    - ResultFact / ResultItemÏóê Îì§Ïñ¥Í∞ÄÎäî Í∞íÏùÄ "Ìï≠ÏÉÅ ÌÉÄÏûÖÏù¥ Î≥¥Ïû•ÎêúÎã§"Îäî Ï†ÑÏ†úÍ∞Ä Ïö¥ÏòÅÏóêÏÑú Íπ®Ïßà Ïàò ÏûàÏùå
      (blank, meta-only, None, Ïà´Ïûê/Î¶¨Ïä§Ìä∏ Îì±)
    - Îî∞ÎùºÏÑú Ïó¨Í∏∞ÏÑú ÏµúÏÜå Ï∫êÏä§ÌåÖ/ÎîîÌè¥Ìä∏Î•º Í∞ïÏ†úÌï¥ DB insert ÏïàÏ†ïÏÑ±ÏùÑ Ïò¨Î¶∞Îã§.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # ‚úÖ Ï∂îÍ∞Ä
        items: list[dict],
    ) -> Result:
        """
        items format (Í∂åÏû•):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # ‚úÖ ÎåÄÌëú attempt Ï∂îÏ†Å (ÎçÆÏñ¥Ïì∞ÎäîÍ≤å Ï†ïÏÉÅ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # ‚úÖ Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1Ô∏è‚É£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2Ô∏è‚É£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ÏÉùÏÑ±/Í¥ÄÎ¶¨ Ï†ÑÎã¥

    üî• Critical Ìå®Ïπò:
    - Í∞ôÏùÄ submission_idÎ°ú AttemptÍ∞Ä Ï§ëÎ≥µ ÏÉùÏÑ±ÎêòÎäî Í≤ÉÏùÑ Ï∞®Îã®
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # üî¥ CRITICAL #2
        # -------------------------------------------------
        # Í∞ôÏùÄ submissionÏúºÎ°ú AttemptÍ∞Ä Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ï¶âÏãú Ï∞®Îã®
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1Ô∏è‚É£ Exam Ï†ïÏ±Ö Î°úÎî©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2Ô∏è‚É£ open_at / close_at Ï†ïÏ±Ö Í∞ïÏ†ú
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3Ô∏è‚É£ ÎèôÏãúÏÑ± ÏïàÏ†Ñ: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4Ô∏è‚É£ Ï†ïÏ±Ö Í∞ïÏ†ú
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5Ô∏è‚É£ ÎåÄÌëú attempt ÍµêÏ≤¥
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/clinic_target_service.py
==========================================================================================
# PATH: apps/domains/results/services/clinic_target_service.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© "ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê" Î¶¨Ïä§Ìä∏Î•º ÏÉùÏÑ±ÌïúÎã§.
- clinic_requiredÏùò Îã®Ïùº ÏßÑÏã§: progress.ClinicLink(is_auto=True)

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
1) Îã®Ïùº ÏßÑÏã§: enrollment_id (ÌïôÏÉù ÏãùÎ≥ÑÏùÄ enrollment_idÎ°úÎßå)
2) clinic_required ÌåêÎã®ÏùÄ ClinicLink (ÏûêÎèô Ìä∏Î¶¨Í±∞) Í∏∞Ï§Ä
3) Ï†êÏàò/Ïª§Ìä∏ÎùºÏù∏/ÏÇ¨Ïú†(reason)Îäî results/examsÏóêÏÑú ÌååÏÉù
4) Session ‚Üî Exam Îß§ÌïëÏùÄ results.utils.session_exam.get_exams_for_session() Îã®Ïùº ÏßÑÏã§ ÏÇ¨Ïö©

‚ö†Ô∏è ÌòÑÏã§Ï†Å Ï†úÏïΩ (Î≥¥Î•ò/Î™ÖÏãú)
- "ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ Ïó¨Îü¨ Í∞ú"Ïù∏ Íµ¨Ï°∞ÏóêÏÑú, ClinicTargetÏùò exam_score/cutline_scoreÎäî 1Í∞ú Ïà´ÏûêÎßå Îã¥ÎäîÎã§.
  Îî∞ÎùºÏÑú Î≥∏ ÏÑúÎπÑÏä§Îäî "ÎåÄÌëú exam"ÏùÑ 1Í∞ú ÏÑ†Ï†ïÌï¥ÏÑú ÌëúÍ∏∞ÌïúÎã§.
  - Í∏∞Î≥∏ Ï†ïÏ±Ö: get_exams_for_session(session) Ï§ë idÍ∞Ä Í∞ÄÏû• ÏûëÏùÄ examÏùÑ ÎåÄÌëúÎ°ú ÏÇ¨Ïö©
  - Ìñ•ÌõÑ Ï†ïÏ±Ö ÌïÑÏöî Ïãú: ProgressPolicy(strategy)ÎÇò Ïö¥ÏòÅ Í∑úÏπôÏóê Îî∞Îùº Î≥ÄÍ≤Ω Í∞ÄÎä•
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink
from apps.domains.exams.models import Exam
from apps.domains.results.models import Result, ResultFact, ExamAttempt

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exams_for_session


def _safe_str(v: Any, default: str = "-") -> str:
    try:
        s = str(v)
        return s if s.strip() else default
    except Exception:
        return default


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _extract_invalid_reason_from_meta(meta: Any) -> Optional[str]:
    """
    ResultFact.meta / Attempt.meta / SubmissionAnswer.meta Îì± Îã§ÏñëÌïú ÏúÑÏπòÏóê ÏûàÏùÑ Ïàò ÏûàÎäî
    invalid_reasonÏùÑ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï∂îÏ∂úÌïúÎã§.

    Í∏∞ÎåÄ Í∞ÄÎä•Ìïú ÌòïÌÉú:
    meta = { "grading": { "invalid_reason": "LOW_CONFIDENCE" } }
    """
    if not isinstance(meta, dict):
        return None
    grading = meta.get("grading")
    if isinstance(grading, dict):
        v = grading.get("invalid_reason")
        return str(v) if v else None
    return None


def _is_low_confidence_for_attempt(*, exam_id: int, enrollment_id: int, attempt_id: Optional[int]) -> bool:
    """
    "Ïã†Î¢∞ÎèÑ ÎÇÆÏùå" ÌåêÏ†ïÏùÄ ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÌòÑÏóê Îî∞Îùº:
    - Attempt.meta.grading.invalid_reason (Í∞ÄÎä•)
    - ResultFact.meta.grading.invalid_reason (Í∞ÄÎä•, ÌòÑÏû¨ graderÎäî Î¨∏Ìï≠ metaÏóê Ïã¨Îäî ÌòïÌÉú)
    Îëò Îã§ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï≤¥ÌÅ¨ÌïúÎã§.
    """
    # 1) Attempt.meta (ÏûàÏúºÎ©¥ ÏµúÏö∞ÏÑ†)
    if attempt_id:
        a = ExamAttempt.objects.filter(id=int(attempt_id)).first()
        if a and hasattr(a, "meta"):
            reason = _extract_invalid_reason_from_meta(getattr(a, "meta", None))
            if (reason or "").upper() == "LOW_CONFIDENCE":
                return True

    # 2) ResultFact.meta (ÎåÄÌëú attempt Í∏∞Ï§Ä)
    if attempt_id:
        qs = (
            ResultFact.objects.filter(
                target_type="exam",
                target_id=int(exam_id),
                enrollment_id=int(enrollment_id),
                attempt_id=int(attempt_id),
            )
            .exclude(meta__isnull=True)
            .order_by("-id")[:200]  # Î∞©Ïñ¥: ÎÑàÎ¨¥ ÌÅ∞ scan Î∞©ÏßÄ
        )
        for f in qs:
            r = _extract_invalid_reason_from_meta(getattr(f, "meta", None))
            if (r or "").upper() == "LOW_CONFIDENCE":
                return True

    return False


def _get_student_name_by_enrollment_id(enrollment_id: int) -> str:
    """
    enrollment_id ‚Üí student_name Îß§ÌïëÏùÄ ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ ÎèÑÎ©îÏù∏Ïù¥ Îã§Î•º Ïàò ÏûàÏñ¥ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Íµ¨ÌòÑ.

    Ïö∞ÏÑ†ÏàúÏúÑ:
    1) enrollments.SessionEnrollment (session-enrollments) Î™®Îç∏Ïù¥ ÏûàÏúºÎ©¥ student_name ÌïÑÎìú/Ï°∞Ïù∏ ÏÇ¨Ïö©
    2) enrollment.Enrollment Î™®Îç∏Ïù¥ ÏûàÏúºÎ©¥ student/user Ï°∞Ïù∏ ÏãúÎèÑ
    3) Ïã§Ìå® Ïãú "-"
    """
    enrollment_id = int(enrollment_id)

    # 1) SessionEnrollment (ÏûàÏúºÎ©¥ Í∞ÄÏû• ÌôïÏã§)
    try:
        # ÌîÑÎ°úÏ†ùÌä∏Ïóê Îî∞Îùº Ïï± Í≤ΩÎ°úÍ∞Ä Îã§Î•º Ïàò ÏûàÏùå
        # - apps.domains.enrollments.models.SessionEnrollment (Í∞ÄÏû• ÌùîÌï®)
        # - apps.domains.enrollments.models.session_enrollment.SessionEnrollment Îì±
        from apps.domains.enrollments.models import SessionEnrollment  # type: ignore

        se = (
            SessionEnrollment.objects.filter(enrollment_id=enrollment_id)
            .order_by("-id")
            .first()
        )
        if se:
            # serializer ÏùëÎãµÏóê student_nameÏù¥ ÏûàÎã§Í≥† ÌñàÎçò Ïä§ÌéôÍ≥º Ï†ïÌï©ÏÑ±
            v = getattr(se, "student_name", None)
            if v:
                return _safe_str(v, "-")

            # Ï°∞Ïù∏Ïù¥ Í∞ÄÎä•ÌïòÎ©¥ student.name
            st = getattr(se, "student", None)
            if st and hasattr(st, "name"):
                return _safe_str(getattr(st, "name", None), "-")
    except Exception:
        pass

    # 2) Enrollment (Í∏∞Ï°¥ results ÏΩîÎìúÏóêÏÑú ÏÇ¨Ïö© Ï§ë)
    try:
        from apps.domains.enrollment.models import Enrollment  # type: ignore

        e = Enrollment.objects.filter(id=enrollment_id).select_related().first()
        if not e:
            return "-"

        # student FKÍ∞Ä ÏûàÏúºÎ©¥ Ïö∞ÏÑ†
        st = getattr(e, "student", None)
        if st and hasattr(st, "name"):
            return _safe_str(getattr(st, "name", None), "-")

        # userÍ∞Ä ÌïôÏÉù ÌîÑÎ°úÌïÑÏùÑ Îì§Í≥† ÏûàÏùÑ ÏàòÎèÑ
        u = getattr(e, "user", None)
        if u:
            nm = getattr(u, "name", None) or getattr(u, "username", None)
            return _safe_str(nm, "-")
    except Exception:
        pass

    return "-"


def _get_session_title(session: Session) -> str:
    """
    ÏÑ∏ÏÖò ÌÉÄÏù¥ÌãÄÏùÄ ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ ÌëúÌòÑÏù¥ Îã¨ÎùºÏÑú:
    - __str__ Ïö∞ÏÑ†
    - lecture/title/order Îì± ÌõÑÎ≥¥Î•º Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï°∞Ìï©
    """
    s = _safe_str(session, "-")
    if s != "-" and s.lower() != "session object":
        return s

    lecture = getattr(session, "lecture", None)
    lecture_title = _safe_str(getattr(lecture, "title", None), "")
    order = getattr(session, "order", None)

    if lecture_title and order is not None:
        return f"{lecture_title} {int(order)}ÌöåÏ∞®"
    if lecture_title:
        return lecture_title

    return f"Session#{int(getattr(session, 'id', 0) or 0)}"


@dataclass(frozen=True)
class ClinicTargetRow:
    enrollment_id: int
    student_name: str
    session_title: str
    reason: str  # "score" | "confidence"
    exam_score: float
    cutline_score: float
    created_at: Any


class ClinicTargetService:
    """
    Admin Clinic Targets

    Îã®Ïùº ÏßÑÏã§:
    - ÎåÄÏÉÅÏûê Î™®Ïàò: ClinicLink(is_auto=True)
    - enrollment_id Í∏∞Ï§Ä
    """

    @staticmethod
    def list_admin_targets() -> List[Dict[str, Any]]:
        links = (
            ClinicLink.objects.filter(is_auto=True)
            # ‚úÖ ÏàòÏ†ïÏÇ¨Ìï≠(Ï∂îÍ∞Ä): ÏòàÏïΩ ÏôÑÎ£åÎ°ú Î∂ÑÎ¶¨Îêú ÎåÄÏÉÅÏûêÎäî "ÎåÄÏÉÅÏûê"ÏóêÏÑú Ï†úÏô∏
            .filter(resolved_at__isnull=True)
            .select_related("session")
            .order_by("-created_at")  # ÏµúÏã† ÏûêÎèô ÎåÄÏÉÅ Ïö∞ÏÑ†
        )

        out: List[Dict[str, Any]] = []

        # ÏÑ∏ÏÖòÎ≥Ñ exam ÌõÑÎ≥¥ Ï∫êÏãú (ÏøºÎ¶¨ Ï†àÏïΩ)
        exams_cache: Dict[int, Optional[Exam]] = {}

        for link in links:
            session = getattr(link, "session", None)
            if not session:
                continue

            session_id = int(getattr(session, "id", 0) or 0)
            enrollment_id = int(getattr(link, "enrollment_id", 0) or 0)
            if not session_id or not enrollment_id:
                continue

            # ÎåÄÌëú exam ÏÑ†Ï†ï (ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ Ïó¨Îü¨ Í∞úÎ©¥ 1Í∞úÎßå ÌëúÍ∏∞)
            if session_id not in exams_cache:
                exams = list(get_exams_for_session(session))
                if exams:
                    # ‚úÖ Î≥¥ÏàòÏ†Å Ï†ïÏ±Ö: idÍ∞Ä Í∞ÄÏû• ÏûëÏùÄ examÏùÑ ÎåÄÌëúÎ°ú
                    ex = sorted(exams, key=lambda x: int(getattr(x, "id", 0) or 0))[0]
                    exams_cache[session_id] = ex
                else:
                    exams_cache[session_id] = None

            exam = exams_cache.get(session_id)
            if not exam:
                # ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ ÏóÜÏúºÎ©¥ score/cutlineÏùÄ 0ÏúºÎ°ú ÎÇ¥Î†§ÏÑú ÌôîÎ©¥Ïù¥ Íπ®ÏßÄÏßÄ ÏïäÍ≤å
                out.append({
                    "enrollment_id": enrollment_id,
                    "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                    "session_title": _get_session_title(session),
                    "reason": "score",
                    "exam_score": 0.0,
                    "cutline_score": 0.0,
                    "created_at": getattr(link, "created_at", None),
                })
                continue

            exam_id = int(getattr(exam, "id", 0) or 0)
            cutline = _safe_float(getattr(exam, "pass_score", 0.0), 0.0)

            # ÎåÄÌëú Ïä§ÎÉÖÏÉ∑ Result (ÏãúÌóò Îã®ÏúÑ)
            result = (
                Result.objects.filter(
                    target_type="exam",
                    target_id=exam_id,
                    enrollment_id=enrollment_id,
                )
                .order_by("-id")
                .first()
            )

            exam_score = _safe_float(getattr(result, "total_score", 0.0) if result else 0.0, 0.0)
            attempt_id = int(getattr(result, "attempt_id", 0) or 0) if result else 0

            # reason ÌåêÏ†ï
            # - LOW_CONFIDENCE ÌùîÏ†ÅÏù¥ ÏûàÏúºÎ©¥ confidence
            # - ÏïÑÎãàÎ©¥ score
            reason = "confidence" if _is_low_confidence_for_attempt(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id if attempt_id else None,
            ) else "score"

            out.append({
                "enrollment_id": enrollment_id,
                "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                "session_title": _get_session_title(session),
                "reason": reason,
                "exam_score": float(exam_score),
                "cutline_score": float(cutline),
                "created_at": getattr(link, "created_at", None),
            })

        return out


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# üîΩ submissions ÎèÑÎ©îÏù∏ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# üîΩ results ÎèÑÎ©îÏù∏ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# üîΩ exams ÎèÑÎ©îÏù∏ (Ï†ïÎãµ / Î¨∏Ï†ú Ï†ïÏùò)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey
# (ÏÑ†ÌÉù) pass_scoreÎ•º ExamÏóêÏÑú ÏùΩÏùÑ Ïàò ÏûàÏúºÎ©¥ Ïì∞Í≥†, ÏóÜÏúºÎ©¥ ÏïàÏ†ÑÌïòÍ≤å Ïä§ÌÇµ
try:
    from apps.domains.exams.models import Exam  # type: ignore
except Exception:  # pragma: no cover
    Exam = None  # type: ignore

# ======================================================
# üîΩ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants (STEP 1 Í≥†Ï†ï)
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    Î¨∏ÏûêÏó¥ Ï†ïÍ∑úÌôî (STEP 1 exact match Í≥†Ï†ï):
    - None Î∞©Ïñ¥
    - Í≥µÎ∞± Ï†úÍ±∞
    - ÎåÄÎ¨∏Ïûê ÌÜµÏùº
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ÏóêÏÑú
    omr dict Îßå ÏïàÏ†ÑÌïòÍ≤å Ï∂îÏ∂ú
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _ensure_dict(v: Any) -> Dict[str, Any]:
    return v if isinstance(v, dict) else {}


def _with_invalid_reason(meta: Any, reason: str) -> Dict[str, Any]:
    """
    ‚úÖ STEP 1 ÌïµÏã¨:
    low_conf / blank / multi Îì± "Î¨¥Ìö® Ï≤òÎ¶¨"Îäî 0Ï†ê Ï≤òÎ¶¨ Îøê ÏïÑÎãàÎùº
    **ÏÇ¨Ïú†Î•º append-onlyÎ°ú ÎÇ®Í≤®Ïïº Ïö¥ÏòÅ/Ïû¨Ï≤òÎ¶¨/ÌîÑÎ°†Ìä∏ ÌëúÏãúÍ∞Ä Í∞ÄÎä•**Ìï¥Ïßê.
    """
    base = _ensure_dict(meta)
    out = dict(base)
    out.setdefault("grading", {})
    if isinstance(out["grading"], dict):
        out["grading"]["invalid_reason"] = reason
    return out


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
    # ‚úÖ Í∏∞Ï°¥ metaÎ•º Î∞õÏïÑÏÑú invalid_reasonÏùÑ Ïã¨ÎäîÎã§
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    OMR Í∞ùÍ¥ÄÏãù Ï±ÑÏ†ê v1 (STEP 1 Í≥†Ï†ï)

    ‚úÖ Ï†ïÏ±Ö:
    - status != ok -> Î¨¥Ìö® (0Ï†ê)
    - marking blank/multi -> Î¨¥Ìö® (0Ï†ê)
    - confidence < threshold -> Î¨¥Ìö® (0Ï†ê) + LOW_CONFIDENCE ÏÇ¨Ïú† Ï†ÄÏû•  ‚≠ê‚≠ê‚≠ê
    - detected != 1Í∞ú -> Î¨¥Ìö® (0Ï†ê)
    """
    st = (status or "").lower()
    mk = (marking or "").lower()

    # 1) statusÍ∞Ä okÍ∞Ä ÏïÑÎãàÎ©¥ Î¨¥Ìö®
    if st != "ok":
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_STATUS_NOT_OK")

    # 2) blank/multiÎäî Î¨¥Ìö®
    if mk in ("blank", "multi"):
        reason = "OMR_BLANK" if mk == "blank" else "OMR_MULTI"
        return False, 0.0, _with_invalid_reason(original_meta, reason)

    # 3) Ïã†Î¢∞ÎèÑ Ï≤¥ÌÅ¨ (STEP 1: low confidence ÏûêÎèô 0Ï†ê + ÏÇ¨Ïú† Ï†ÄÏû•)
    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0, _with_invalid_reason(original_meta, "LOW_CONFIDENCE")

    # 4) detected 1Í∞ú Í∞ïÏ†ú
    if not detected or len(detected) != 1:
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_DETECTED_INVALID")

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    Ï£ºÍ¥ÄÏãù / fallback Ï±ÑÏ†ê (STEP 1: exact match)

    ‚úÖ Ï†ïÏ±Ö:
    - empty => 0Ï†ê
    - exact match only
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0, _with_invalid_reason(original_meta, "EMPTY_ANSWER")

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type Ï∂îÎ°†
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    ‚úÖ AnswerKey v2 Í≥†Ï†ï

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


def _get_pass_score(exam_id: int) -> Optional[float]:
    """
    (ÏÑ†ÌÉù) Exam.pass_scoreÍ∞Ä ÏûàÏúºÎ©¥ ÏùΩÏñ¥ÏÑú attempt/metaÏóê Í∏∞Î°ù.
    - ResultApplierÍ∞Ä Ïù¥ÎØ∏ is_passÎ•º Í≥ÑÏÇ∞ÌïúÎã§Î©¥ Ïù¥Í±¥ "ÏßÑÎã®/ÌëúÏãúÏö©" Ï†ïÎ≥¥Î°úÎßå ÎÇ®ÎäîÎã§.
    """
    if Exam is None:
        return None
    try:
        exam = Exam.objects.filter(id=int(exam_id)).first()
        if not exam:
            return None
        v = getattr(exam, "pass_score", None)
        return float(v) if v is not None else None
    except Exception:
        return None


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission ‚Üí ExamAttempt ‚Üí Result / ResultItem / ResultFact

    üî• v2 ÌïµÏã¨ Í≥ÑÏïΩ:
    - SubmissionAnswer.exam_question_id Îßå ÏÇ¨Ïö©
    - number / fallback ÏôÑÏ†Ñ Ï†úÍ±∞
    - AnswerKey v2 Í≥†Ï†ï
    - ‚úÖ STEP 1: LOW_CONF Î¨¥Ìö® 0Ï†ê + ÏÇ¨Ïú† Ï†ÄÏû•
    """

    # --------------------------------------------------
    # 0Ô∏è‚É£ Submission ÏÉÅÌÉú Ï†ÑÏù¥
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1Ô∏è‚É£ ExamAttempt ÏÉùÏÑ±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2Ô∏è‚É£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3Ô∏è‚É£ ExamQuestion Î°úÎî© (id Í∏∞Ï§Ä)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        total_score = 0.0
        total_max_score = 0.0

        # --------------------------------------------------
        # 4Ô∏è‚É£ Î¨∏Ìï≠Î≥Ñ Ï±ÑÏ†ê
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            # submissions meta
            original_meta = getattr(sa, "meta", None)
            omr = _get_omr_meta(original_meta)

            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            # ‚úÖ STEP 1: low_confidence statusÎäî Ï¶âÏãú Î¨¥Ìö® Ï≤òÎ¶¨ (0Ï†ê+ÏÇ¨Ïú†)
            if (status or "").lower() == "low_confidence":
                is_correct = False
                score = 0.0
                final_answer = ""
                final_meta = _with_invalid_reason(original_meta, "LOW_CONFIDENCE")
            else:
                answer_type = _infer_answer_type(q)

                if answer_type in ("choice", "omr", "multiple_choice"):
                    if omr_version.lower() in ("v1", "v2"):
                        is_correct, score, final_meta = _grade_choice_v1(
                            detected=[str(x) for x in detected],
                            marking=marking,
                            confidence=confidence,
                            status=status,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        # ÌëúÏãúÏö© answer: Í∞êÏßÄÎêú Í∞í 1Í∞úÎ©¥ Í∑∏ Í∞í, ÏïÑÎãàÎ©¥ ""
                        final_answer = (
                            "".join([_norm(x) for x in detected]) if detected else ""
                        )
                    else:
                        # OMR metaÍ∞Ä ÏóÜÍ±∞ÎÇò Î≤ÑÏ†ÑÏù¥ ÏóÜÏùÑ Îïå: ÌÖçÏä§Ìä∏ Í∏∞Î∞ò exact match
                        is_correct, score, final_meta = _grade_short_v1(
                            answer_text=answer_text,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        final_answer = answer_text
                else:
                    # subjective: exact match (STEP 1)
                    is_correct, score, final_meta = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                        original_meta=original_meta,
                    )
                    final_answer = answer_text

            # Ï†êÏàò ÎàÑÏ†Å
            total_score += float(score)
            total_max_score += float(max_score)

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                # ‚úÖ ÏµúÏ¢Ö metaÏóêÎäî invalid_reasonÏù¥ Î∞òÏòÅÎê† Ïàò ÏûàÏùå
                "meta": final_meta,
            })

        # --------------------------------------------------
        # 4-1) (ÏÑ†ÌÉù) attempt/metaÏóê total/pass Ï†ïÎ≥¥ Í∏∞Î°ù
        # - ResultApplierÍ∞Ä Ïã§Ï†ú ResultSummary.is_passÎ•º ÎßåÎì§ÎçîÎùºÎèÑ,
        #   attemptÏóêÎäî Ïö¥ÏòÅ/ÎîîÎ≤ÑÍπÖÏö©ÏúºÎ°ú ÎÇ®Í≤®ÎëêÎ©¥ Ï¢ãÏùå.
        # --------------------------------------------------
        try:
            pass_score = _get_pass_score(int(submission.target_id))
            meta = getattr(attempt, "meta", None)
            if isinstance(meta, dict):
                new_meta = dict(meta)
            else:
                new_meta = {}

            new_meta.setdefault("grading", {})
            if isinstance(new_meta["grading"], dict):
                new_meta["grading"]["total_score"] = float(total_score)
                new_meta["grading"]["total_max_score"] = float(total_max_score)
                if pass_score is not None:
                    new_meta["grading"]["pass_score"] = float(pass_score)
                    new_meta["grading"]["is_pass_inferred"] = bool(total_score >= pass_score)

            if hasattr(attempt, "meta"):
                attempt.meta = new_meta
                attempt.save(update_fields=["meta"])
        except Exception:
            # meta ÌïÑÎìúÍ∞Ä ÏóÜÍ±∞ÎÇò Ï†ÄÏû• Ïã§Ìå®Ìï¥ÎèÑ grading ÏûêÏ≤¥Îäî Í≥ÑÏÜç ÏßÑÌñâ
            pass

        # --------------------------------------------------
        # 5Ô∏è‚É£ Result Î∞òÏòÅ
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6Ô∏è‚É£ ÏÉÅÌÉú ÎßàÎ¨¥Î¶¨
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/grading_policy.py
==========================================================================================
# # PATH: apps/domains/results/services/grading_policy.py

# NOTE:
# STEP 2 Ïù¥ÌõÑ grader Î¶¨Ìå©ÌÜ†ÎßÅ Ïãú ÏÇ¨Ïö©Ìï† Ï†ïÏ±Ö Î™®Îìà
# ÌòÑÏû¨Îäî ÎØ∏ÏÇ¨Ïö©

# from __future__ import annotations

# from dataclasses import dataclass
# from typing import Any, Dict, Optional, Tuple


# # =========================================================
# # STEP 1 Ï†ïÏ±Ö ÏÉÅÏàò (Í≥†Ï†ï)
# # =========================================================

# MIN_OMR_CONFIDENCE = 0.70  # Ïù¥ ÎØ∏ÎßåÏù¥Î©¥ ÏûêÎèô Î¨¥Ìö®(0Ï†ê)


# def normalize_text(s: str) -> str:
#     """
#     Ï£ºÍ¥ÄÏãù exact match ÌëúÏ§Ä Ï†ïÍ∑úÌôî (STEP 1 Í≥†Ï†ï)
#     - strip + lower
#     - Ï∂îÌõÑ Í≥µÎ∞±/ÌäπÏàòÎ¨∏Ïûê Í∑úÏπôÏùÄ Ïó¨Í∏∞ÏÑúÎßå Î∞îÍæ∏Î©¥ Îê®
#     """
#     return (s or "").strip().lower()


# @dataclass(frozen=True)
# class OMRValidity:
#     is_valid: bool
#     invalid_reason: Optional[str] = None


# def evaluate_omr_validity(submission_answer_meta: Dict[str, Any]) -> OMRValidity:
#     """
#     SubmissionAnswer.meta["omr"] Í∏∞Î∞òÏúºÎ°ú OMR Ïú†Ìö®ÏÑ± ÌåêÎã® (STEP 1 Í≥†Ï†ï)
#     - low_confidenceÎ©¥ 0Ï†ê Ï≤òÎ¶¨
#     - ambiguous/multi/blankÏùÄ ÎÑàÏùò Ï±ÑÏ†ê Ï†ïÏ±ÖÏóê Îî∞Îùº 0Ï†ê/Î∂ÄÎ∂ÑÏ†ê Îì± ÌôïÏû• Í∞ÄÎä•ÌïòÏßÄÎßå
#       STEP 1ÏóêÏÑúÎäî ÏµúÏÜåÌïú low_confÎäî Î¨¥Ï°∞Í±¥ Î¨¥Ìö®Î°ú Í≥†Ï†ï.
#     """
#     omr = (submission_answer_meta or {}).get("omr") or {}
#     conf = omr.get("confidence")
#     status = str(omr.get("status") or "").lower()

#     try:
#         conf_f = float(conf) if conf is not None else None
#     except Exception:
#         conf_f = None

#     # ‚úÖ Î™ÖÏãúÏ†ÅÏúºÎ°ú low_confidenceÎ©¥ Î¨¥Ìö®
#     if status == "low_confidence":
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     # ‚úÖ confidence Í∞íÏù¥ ÏûàÍ≥† ÏûÑÍ≥ÑÏπò ÎØ∏ÎßåÏù¥Î©¥ Î¨¥Ìö®
#     if conf_f is not None and conf_f < MIN_OMR_CONFIDENCE:
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     return OMRValidity(is_valid=True, invalid_reason=None)


# def grade_subjective_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     Ï£ºÍ¥ÄÏãù exact match Ï±ÑÏ†ê (STEP 1 Í≥†Ï†ï)
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def grade_choice_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     Í∞ùÍ¥ÄÏãù exact match Í∏∞Î≥∏ (A/B/C/D)
#     - Îã§Ï§ëÎßàÌÇπ Ï≤òÎ¶¨/Î∂ÄÎ∂ÑÏ†êÏùÄ STEP 2 Ïù¥ÌõÑ ÌôïÏû• Ìè¨Ïù∏Ìä∏
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def evaluate_pass_fail(total_score: float, pass_score: float) -> bool:
#     """
#     ÏãúÌóò Îã®ÏúÑ pass/fail (STEP 1 Í≥†Ï†ï)
#     """
#     try:
#         return float(total_score) >= float(pass_score)
#     except Exception:
#         return False


==========================================================================================
# FILE: services/question_stats_service.py
==========================================================================================
# apps/domains/results/services/question_stats_service.py
from __future__ import annotations

from typing import Dict, List, Optional
from django.db.models import Count, Avg, Max, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.models import ResultFact


class QuestionStatsService:
    """
    ÏãúÌóò Î¨∏Ìï≠ ÌÜµÍ≥Ñ Îã®Ïùº ÏßÑÏã§ (Ï†ïÏÑù)

    üî• Í∏∞Ï§Ä:
    - ResultFact (append-only)Îßå ÏÇ¨Ïö©
    - Result / ResultItem / attempt ÍµêÏ≤¥ Ïó¨Î∂ÄÏôÄ Î¨¥Í¥Ä
    - Ïö¥ÏòÅ/ÌÜµÍ≥Ñ/Î∂ÑÏÑù ÏùºÍ¥ÄÏÑ± Î≥¥Ïû•
    """

    # ======================================================
    # A) Î¨∏Ìï≠Î≥Ñ Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    # ======================================================
    @staticmethod
    def per_question_stats(
        *,
        exam_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        Î¨∏Ìï≠Î≥Ñ ÌÜµÍ≥Ñ
        - ÏùëÏãú Ïàò
        - Ï†ïÎãµ Ïàò
        - Ï†ïÎãµÎ•†
        - ÌèâÍ∑† Ï†êÏàò
        - ÏµúÎåÄ Ï†êÏàò
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct=Count("id", filter=Q(is_correct=True)),
                avg_score=Avg("score"),
                max_score=Max("score"),
            )
            .annotate(
                accuracy=ExpressionWrapper(
                    F("correct") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                )
            )
            .order_by("question_id")
        )

        return [
            {
                "question_id": row["question_id"],
                "attempts": int(row["attempts"] or 0),
                "correct": int(row["correct"] or 0),
                "accuracy": round(float(row["accuracy"] or 0.0), 4),
                "avg_score": float(row["avg_score"] or 0.0),
                "max_score": float(row["max_score"] or 0.0),
            }
            for row in rows
        ]

    # ======================================================
    # B) Î¨∏Ìï≠ Îã®Ïùº Ïò§Îãµ Î∂ÑÌè¨ (ÏÑ†ÌÉùÏßÄ Í∏∞Ï§Ä)
    # ======================================================
    @staticmethod
    def wrong_choice_distribution(
        *,
        exam_id: int,
        question_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> Dict[str, int]:
        """
        Í∞ùÍ¥ÄÏãù Ïò§Îãµ Î∂ÑÌè¨
        - answer Í∞í Í∏∞Ï§Ä
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            question_id=int(question_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = qs.values("answer").annotate(cnt=Count("id"))

        dist: Dict[str, int] = {}
        for r in rows:
            key = str(r["answer"] or "")
            dist[key] = int(r["cnt"] or 0)

        return dist

    # ======================================================
    # C) Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ Î¨∏Ìï≠ TOP N
    # ======================================================
    @staticmethod
    def top_n_wrong_questions(
        *,
        exam_id: int,
        n: int = 5,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ Î¨∏Ìï≠ TOP N
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(wrong_count=Count("id"))
            .order_by("-wrong_count")[: int(n)]
        )

        return [
            {
                "question_id": int(r["question_id"]),
                "wrong_count": int(r["wrong_count"]),
            }
            for r in rows
        ]


==========================================================================================
# FILE: services/session_score_summary_service.py
==========================================================================================
# apps/domains/results/services/session_score_summary_service.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.models import ExamAttempt
from apps.domains.progress.models import SessionProgress
from apps.domains.progress.models import ClinicLink
from apps.domains.lectures.models import Session

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exam_ids_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class SessionScoreSummaryService:
    """
    ‚úÖ Session Îã®ÏúÑ ÏÑ±Ï†Å ÌÜµÍ≥Ñ (Ïö¥ÏòÅ/ÎåÄÏãúÎ≥¥Îìú)

    Îã®Ïùº ÏßÑÏã§ Í∑úÏπô:
    - Ï†êÏàò ÌÜµÍ≥Ñ: Result(Îã®, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥ Ï†ÅÏö©)
    - ÏÑ∏ÏÖò ÌÜµÍ≥ºÏú®: SessionProgress.completed(ÌòπÏùÄ Ï†ïÏ±ÖÏóê Îî∞Îùº exam_passed) Ï§ë Î¨¥ÏóáÏù∏ÏßÄ 'Ï†ïÏùò'Í∞Ä ÌïÑÏöîÌïòÏßÄÎßå
      Í∏∞Ï°¥ ÏõêÎ≥∏ÏùÄ completedÎ•º ÏÇ¨Ïö©ÌñàÏúºÎØÄÎ°ú ÏõêÎ≥∏ ÏùòÎØ∏Î•º Ï°¥Ï§ëÌïúÎã§.
    - ÌÅ¥Î¶¨Îãâ: ClinicLink (is_auto=True, enrollment distinct)

    ‚ö†Ô∏è ÏÑ∏ÏÖò1:ÏãúÌóòN Íµ¨Ï°∞ Î∞òÏòÅ:
    - sessionÏóê Ïó∞Í≤∞Îêú exam_idÎì§ÏùÑ Î™®Îëê Í∞ÄÏ†∏ÏôÄÏÑú ÌÜµÍ≥ÑÎ•º ÎßåÎì†Îã§.
    - Îã§Îßå "ÏÑ∏ÏÖò Ï†ÑÏ≤¥ Ï†êÏàò"Î•º 1Í∞ú Ïà´ÏûêÎ°ú ÎßåÎì§ ÎïåÎäî ÏßëÍ≥Ñ Ï†ÑÎûµÏù¥ ÌïÑÏöîÌï®.
      Ïù¥ ÏÑúÎπÑÏä§Îäî "ÏÑ∏ÏÖò Ïö¥ÏòÅ ÌÜµÍ≥Ñ" ÏÑ±Í≤©Ïù¥ÎØÄÎ°ú:
        - Ï†êÏàò ÏßëÍ≥ÑÎäî Ïö∞ÏÑ† exams Ï†ÑÏ≤¥ ResultÎ•º Ìï©Ï≥ê ÌèâÍ∑†/ÏµúÏÜå/ÏµúÎåÄÎ•º Íµ¨ÌïòÎäî Î≥¥ÏàòÏ†Å Î∞©ÏãùÏúºÎ°ú Ï†úÍ≥µ.
      (Ï†ïÍµêÌïú Ï†ÑÎûµÏùÄ AdminSessionExamsSummaryViewÏóêÏÑú examÎ≥ÑÎ°ú Ï†úÍ≥µÌïòÎäî Í≤ÉÏù¥ Ï†ïÏÑù)
    """

    @staticmethod
    def build(*, session_id: int) -> dict:
        EMPTY_SUMMARY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "attempt_stats": {
                "avg_attempts": 0.0,
                "retake_ratio": 0.0,
            },
        }

        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return EMPTY_SUMMARY

        exam_ids = get_exam_ids_for_session(session)
        if not exam_ids:
            # ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ ÏóÜÏúºÎ©¥ Ï†êÏàò ÌÜµÍ≥ÑÎäî 0, pass/clinicÏùÄ progressÎ°úÎßå ÌåêÎã® Í∞ÄÎä•
            progresses = SessionProgress.objects.filter(session=session)
            participant_count = progresses.count()
            pass_count = progresses.filter(completed=True).count()
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id").distinct().count()
            )
            return {
                **EMPTY_SUMMARY,
                "participant_count": int(participant_count),
                "pass_rate": round((pass_count / participant_count), 4) if participant_count else 0.0,
                "clinic_rate": round((clinic_count / participant_count), 4) if participant_count else 0.0,
            }

        # -------------------------------------------------
        # participant Î™®Ïàò: SessionProgress Í∏∞Ï§Ä(ÏõêÎ≥∏ Ï°¥Ï§ë)
        # -------------------------------------------------
        progresses = SessionProgress.objects.filter(session=session)
        participant_count = progresses.count()

        # -------------------------------------------------
        # pass_rate: ÏõêÎ≥∏ÏùÄ SessionProgress.completed Í∏∞Ï§Ä
        # -------------------------------------------------
        pass_count = progresses.filter(completed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # clinic_rate: ClinicLink Í∏∞Ï§Ä Îã®ÏùºÌôî
        # -------------------------------------------------
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id")
            .distinct()
            .count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # Ï†êÏàò ÌÜµÍ≥Ñ:
        # - ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú Î™®Îì† ÏãúÌóòÏùò ResultÎ•º Î™®ÏïÑÏÑú ÌÜµÍ≥Ñ
        # - enrollment Ï§ëÎ≥µ Î∞©Ïñ¥: examÎ≥Ñ latest_results_per_enrollment Ï†ÅÏö© ÌõÑ Ìï©ÏπòÍ∏∞
        # -------------------------------------------------
        all_results = []
        for exid in exam_ids:
            rs = list(latest_results_per_enrollment(target_type="exam", target_id=int(exid)))
            all_results.extend(rs)

        if not all_results:
            score_summary = {"avg_score": 0.0, "min_score": 0.0, "max_score": 0.0}
        else:
            scores = [float(r.total_score or 0.0) for r in all_results]
            score_summary = {
                "avg_score": (sum(scores) / len(scores)) if scores else 0.0,
                "min_score": min(scores) if scores else 0.0,
                "max_score": max(scores) if scores else 0.0,
            }

        # -------------------------------------------------
        # Attempt ÌÜµÍ≥Ñ(Ïû¨ÏãúÌóò ÎπÑÏú®):
        # - ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú Î™®Îì† ÏãúÌóòÏùÑ ÎåÄÏÉÅÏúºÎ°ú attempt ÌÜµÍ≥Ñ
        # -------------------------------------------------
        attempts = ExamAttempt.objects.filter(exam_id__in=[int(x) for x in exam_ids])

        per_enrollment = (
            attempts.values("enrollment_id")
            .annotate(cnt=Count("id"))
        )

        total_attempts = sum(int(r["cnt"] or 0) for r in per_enrollment)
        retake_users = sum(1 for r in per_enrollment if int(r["cnt"] or 0) > 1)

        avg_attempts = (total_attempts / participant_count) if participant_count else 0.0
        retake_ratio = (retake_users / participant_count) if participant_count else 0.0

        return {
            "participant_count": int(participant_count),
            "avg_score": float(score_summary["avg_score"]),
            "min_score": float(score_summary["min_score"]),
            "max_score": float(score_summary["max_score"]),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_rate": round(float(clinic_rate), 4),
            "attempt_stats": {
                "avg_attempts": round(float(avg_attempts), 2),
                "retake_ratio": round(float(retake_ratio), 4),
            },
        }


==========================================================================================
# FILE: services/wrong_note_service.py
==========================================================================================
# apps/domains/results/services/wrong_note_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Q
from django.utils import timezone

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import ExamQuestion, AnswerKey, Exam


# ======================================================
# Request DTO
# ======================================================
@dataclass(frozen=True)
class WrongNoteQuery:
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå ÌååÎùºÎØ∏ÌÑ∞

    ‚úÖ STEP 3-3 ÏäπÍ≤©
    - lecture_id/from_session_order ÌïÑÌÑ∞Î•º ÏÑúÎπÑÏä§ Ï±ÖÏûÑÏúºÎ°ú ÎÅåÏñ¥Ïò¨Î¶º
      (View/Worker/PDF Î™®Îëê Í∞ôÏùÄ Í∑úÏπô ÏÇ¨Ïö©)

    - offset/limitÏùÄ Îã®Ïàú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò
    """
    exam_id: Optional[int] = None
    lecture_id: Optional[int] = None
    from_session_order: int = 2

    offset: int = 0
    limit: int = 50


# ======================================================
# Internal helpers
# ======================================================
def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _has_relation(model, name: str) -> bool:
    """
    Exam Î™®Îç∏Ïóê ÌäπÏ†ï relation(name)Ïù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ Í≤ÄÏÇ¨
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


def _get_exam_ids_by_lecture_and_order(*, lecture_id: int, from_order: int) -> List[int]:
    """
    lecture_id + from_session_orderÎ°ú exam_id Î™©Î°ù Íµ¨ÌïòÍ∏∞

    ‚ö†Ô∏è ÌîÑÎ°úÏ†ùÌä∏Î≥ÑÎ°ú Exam ‚Üî Session reverse relation Ïù¥Î¶ÑÏù¥ Îã§Î•º Ïàò ÏûàÏùå:
    - sessions / session / session_set ...
    Í∑∏ÎûòÏÑú Í∞ÄÎä•Ìïú ÌõÑÎ≥¥Îì§ÏùÑ Î™®Îëê Í≤ÄÏÇ¨Ìï¥ ÏïàÏ†ÑÌïòÍ≤å ÌïÑÌÑ∞ÎßÅ.

    ‚úÖ Í∑úÏπô:
    - Í¥ÄÍ≥ÑÎ•º Î™ª Ï∞æÏúºÎ©¥ Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò(=ÏïàÏ†ÑÌïòÍ≤å Í≤∞Í≥º ÏóÜÏùå)
    """
    exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

    # Ïö∞ÏÑ†ÏàúÏúÑ ÌõÑÎ≥¥Îì§
    # 1) sessions
    if _has_relation(Exam, "sessions"):
        exam_qs = exam_qs.filter(sessions__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 2) session (1:1 ÌòπÏùÄ FK)
    if _has_relation(Exam, "session"):
        exam_qs = exam_qs.filter(session__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 3) session_set (Django default reverse name)
    if _has_relation(Exam, "session_set"):
        exam_qs = exam_qs.filter(session_set__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # Î™ª Ï∞æÏúºÎ©¥ ÏïàÏ†ÑÌïòÍ≤å none
    return []


def _get_answer_key_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey v2 (Í≥†Ï†ï):
      answers = { "123": "B", ... }  # key = ExamQuestion.id(str)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    answers = getattr(ak, "answers", None) if ak else None
    return answers if isinstance(answers, dict) else {}


# ======================================================
# Public API
# ======================================================
def list_wrong_notes_for_enrollment(
    *,
    enrollment_id: int,
    q: WrongNoteQuery,
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    ‚úÖ ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Ïùò ResultFact Íµ¨Ï°∞Ïóê ÎßûÎäî ‚ÄúÏ†ïÏÑù‚Äù Íµ¨ÌòÑ

    ResultFact = Î¨∏Ìï≠ 1Í∞ú Ïù¥Î≤§Ìä∏(append-only)
      - question_id/answer/is_correct/score/max_score/meta/source Í∞Ä FactÏóê ÏßÅÏ†ë ÏûàÏùå

    Î∞òÌôò: (total_count, paged_items)
    """

    enrollment_id = int(enrollment_id)
    offset = max(int(q.offset or 0), 0)
    limit = max(min(int(q.limit or 50), 200), 1)

    base = ResultFact.objects.filter(
        enrollment_id=enrollment_id,
        target_type="exam",
        is_correct=False,          # Ïò§ÎãµÎßå
    )

    # 1) exam_id ÌïÑÌÑ∞
    if q.exam_id is not None:
        base = base.filter(target_id=int(q.exam_id))

    # 2) lecture_id + from_session_order ÌïÑÌÑ∞ (STEP 3-3 ÏäπÍ≤©)
    if q.lecture_id is not None:
        exam_ids = _get_exam_ids_by_lecture_and_order(
            lecture_id=int(q.lecture_id),
            from_order=int(q.from_session_order or 2),
        )
        if not exam_ids:
            return 0, []
        base = base.filter(target_id__in=exam_ids)

    # ÏµúÏã† Ïò§Îãµ Ïö∞ÏÑ†
    base = base.order_by("-id")

    total = base.count()

    facts = list(base[offset: offset + limit])

    # ÏßàÎ¨∏ Ï†ïÎ≥¥/Ï†ïÎãµÌÇ§ Î∂ôÏù¥Í∏∞ ÏúÑÌï¥ question_ids, exam_ids ÏàòÏßë
    question_ids = [int(f.question_id) for f in facts]
    exam_ids = list({int(f.target_id) for f in facts})

    questions_map = (
        ExamQuestion.objects
        .filter(id__in=question_ids)
        .select_related("sheet")
        .in_bulk(field_name="id")
    )

    answer_key_cache: Dict[int, Dict[str, Any]] = {
        exid: _get_answer_key_map(exid) for exid in exam_ids
    }

    out: List[Dict[str, Any]] = []

    for f in facts:
        exid = int(f.target_id)
        qobj = questions_map.get(int(f.question_id))

        question_number = getattr(qobj, "number", None) if qobj else None
        answer_type = (getattr(qobj, "answer_type", "") or "") if qobj else ""

        correct_answer = ""
        if qobj:
            correct_answer = str(answer_key_cache.get(exid, {}).get(str(qobj.id)) or "")

        out.append({
            "exam_id": exid,
            "attempt_id": int(getattr(f, "attempt_id", 0) or 0),
            # attempt_created_at ÌïÑÎìúÍ∞Ä Îî∞Î°ú ÏóÜÏúºÎãà created_atÏùÑ ÏÇ¨Ïö©
            "attempt_created_at": getattr(f, "created_at", None),

            "question_id": int(f.question_id),
            "question_number": _safe_int(question_number),
            "answer_type": str(answer_type),

            "student_answer": str(f.answer or ""),
            "correct_answer": str(correct_answer or ""),

            "is_correct": False,
            "score": float(f.score or 0.0),
            "max_score": float(f.max_score or 0.0),

            "meta": f.meta if f.meta is not None else {},
            "extra": {},
        })

    return total, out


==========================================================================================
# FILE: tasks/__init__.py
==========================================================================================



==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from __future__ import annotations

import logging
from celery import shared_task

logger = logging.getLogger(__name__)


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={"max_retries": 3},
    retry_backoff=True,
    retry_jitter=True,
)
def grade_submission_task(self, submission_id: int) -> None:
    """
    STEP 1 ÌôïÏ†ï:
    - Ï±ÑÏ†ê ÌÉúÏä§ÌÅ¨Îäî ÏûêÎèô Ïû¨ÏãúÎèÑ 3Ìöå
    - Ïã§Ï†ú Ï±ÑÏ†ê ÏßÑÏûÖÏ†êÏùÄ results.services.grader.grade_submission_to_results

    üîß FIX:
    - Í∏∞Ï°¥ grade_submission ÏùÄ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå
    - Ïã§Ï†ú Íµ¨ÌòÑÎêú Ìï®ÏàòÎ™ÖÏúºÎ°ú Ï†ïÌôïÌûà Ïó∞Í≤∞
    """
    from apps.domains.submissions.models import Submission
    from apps.domains.results.services.grader import (
        grade_submission_to_results,
    )

    submission = Submission.objects.get(id=int(submission_id))

    logger.info("grading start: submission_id=%s", submission_id)
    grade_submission_to_results(submission)
    logger.info("grading done: submission_id=%s", submission_id)


==========================================================================================
# FILE: tasks/progress_pipeline_task.py
==========================================================================================
# apps/domains/progress/tasks/progress_pipeline_task.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.progress.services.progress_pipeline import ProgressPipeline


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def run_progress_pipeline_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)

    result = Result.objects.filter(
        target_type=submission.target_type,
        target_id=submission.target_id,
        enrollment_id=submission.enrollment_id,
    ).first()

    if not result:
        return False

    ProgressPipeline.run_by_submission(
        submission=submission,
        result=result,
    )

    return True


==========================================================================================
# FILE: tasks/wrong_note_pdf_tasks.py
==========================================================================================
# apps/domains/results/tasks/wrong_note_pdf_tasks.py
from __future__ import annotations

from io import BytesIO
from typing import Optional

from celery import shared_task
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

from apps.domains.results.models import WrongNotePDF
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


# ======================================================
# ‚úÖ STEP 1: reportlab ÏßÄÏó∞ import (Ï†ïÏÑù)
# - API ÏÑúÎ≤Ñ / migrate / runserver ÌôòÍ≤ΩÏóêÏÑú reportlabÏù¥ ÏóÜÏñ¥ÎèÑ OK
# - PDF worker ÌôòÍ≤ΩÏóêÏÑúÎßå reportlab ÌïÑÏöî
# ======================================================
def _import_reportlab():
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas
        return A4, canvas
    except ImportError as e:
        raise RuntimeError(
            "reportlab is required only on PDF worker environment"
        ) from e


@shared_task(bind=True, max_retries=3, default_retry_delay=10)
def generate_wrong_note_pdf_task(self, job_id: int) -> None:
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± Worker (Celery)

    ‚úÖ STEP 3-3 Î∞òÏòÅ:
    - lecture_id/from_session_order ÌïÑÌÑ∞ÍπåÏßÄ serviceÎ°ú ÌÜµÏùº

    ‚úÖ STEP 1 (Ï§ëÏöî):
    - reportlab ÏßÄÏó∞ import Ï†ÅÏö©
      -> Ïù¥ taskÍ∞Ä Ïã§Ï†ú Ïã§ÌñâÎê† ÎïåÎßå reportlab import
    """

    job = WrongNotePDF.objects.filter(id=int(job_id)).first()
    if not job:
        return

    # Î©±Îì±ÏÑ±/Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
    if job.status == WrongNotePDF.Status.DONE:
        return
    if job.status == WrongNotePDF.Status.RUNNING:
        return

    def _set_status(status: str, error: str = "") -> None:
        job.status = status
        job.error_message = (error or "")[:2000]
        job.save(update_fields=["status", "error_message"])

    try:
        _set_status(WrongNotePDF.Status.RUNNING)

        enrollment_id = int(job.enrollment_id)

        q = WrongNoteQuery(
            exam_id=int(job.exam_id) if job.exam_id else None,
            lecture_id=int(job.lecture_id) if job.lecture_id else None,
            from_session_order=int(job.from_session_order or 2),
            offset=0,
            limit=200,  # PDFÎäî Ïö∞ÏÑ† ÏÉÅÏúÑ 200Í∞ú
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id,
            q=q,
        )

        # --------------------------------------------------
        # ‚úÖ STEP 1: reportlabÏùÄ "Ïã§Ï†ú PDF ÏÉùÏÑ± ÏãúÏ†ê"ÏóêÎßå import
        # --------------------------------------------------
        A4, canvas = _import_reportlab()

        # ------------------------------
        # PDF ÏÉùÏÑ± (ÏµúÏÜå Íµ¨ÌòÑ: ÌÖçÏä§Ìä∏ Î¶¨Ïä§Ìä∏)
        # ------------------------------
        buf = BytesIO()
        c = canvas.Canvas(buf, pagesize=A4)
        _, height = A4

        y = height - 48
        c.setFont("Helvetica-Bold", 14)
        c.drawString(40, y, "Wrong Notes")
        y -= 20

        c.setFont("Helvetica", 10)
        c.drawString(40, y, f"Enrollment: {enrollment_id}")
        y -= 14
        c.drawString(40, y, f"Total wrong items: {total}")
        y -= 20

        for idx, it in enumerate(items, start=1):
            if y < 80:
                c.showPage()
                y = height - 60
                c.setFont("Helvetica", 10)

            line = (
                f"{idx}. "
                f"Exam {it.get('exam_id')} / "
                f"Q{it.get('question_number') or it.get('question_id')} "
                f"| ans={it.get('student_answer','')} "
                f"| correct={it.get('correct_answer','')} "
                f"| score={it.get('score',0)}/{it.get('max_score',0)}"
            )
            c.drawString(40, y, line[:120])
            y -= 14

        c.showPage()
        c.save()
        buf.seek(0)

        key = f"results/wrong_notes/{int(job.id)}.pdf"
        default_storage.save(key, ContentFile(buf.read()))

        job.file_path = key
        job.status = WrongNotePDF.Status.DONE
        job.error_message = ""
        job.save(update_fields=["file_path", "status", "error_message"])

    except Exception as e:
        msg = str(e)
        try:
            _set_status(WrongNotePDF.Status.FAILED, msg)
        finally:
            # ‚úÖ Í∏∞Ï°¥ ÎèôÏûë Ï°¥Ï§ë: retryÎ°ú Ïû¨ÏãúÎèÑ
            raise self.retry(exc=e)


==========================================================================================
# FILE: utils/clinic.py
==========================================================================================
# apps/domains/results/utils/clinic.py
from __future__ import annotations

from typing import Set

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink


def get_clinic_enrollment_ids_for_session(
    *,
    session: Session,
    include_manual: bool = False,
) -> Set[int]:
    """
    ‚úÖ Clinic Îã®Ïùº Í∑úÏπô Ï†úÍ≥µ

    Í∏∞Î≥∏ Ï†ïÏ±Ö(Í∂åÏû•/ÏïàÏ†Ñ):
    - Ïö¥ÏòÅÏóêÏÑú clinic_required/clinic_rateÎäî 'ÏûêÎèô Ìä∏Î¶¨Í±∞' Í∏∞Ï§ÄÏúºÎ°ú ÌÜµÏùºÌïúÎã§.
      -> include_manual=False (default)

    ÏôúÎÉêÌïòÎ©¥:
    - ÏàòÎèô ÌÅ¥Î¶¨Îãâ(Í∞ïÏÇ¨ Ï∂îÏ≤ú/ÏöîÏ≤≠)ÏùÄ UX/Ïö¥ÏòÅ Ï†ïÏ±ÖÏóê Îî∞Îùº ÏºÄÏù¥Ïä§Í∞Ä Îã¨ÎùºÏÑú
      ÌÜµÍ≥ÑÏóê ÏÑûÏù¥Î©¥ ÌôîÎ©¥ÎßàÎã§ "Ïôú Îã§Î•¥ÎÉê" Î¨∏Ï†úÍ∞Ä Î∞òÎ≥µÎêúÎã§.

    ÌïÑÏöîÌïòÎ©¥ include_manual=TrueÎ°ú
    ÏàòÎèôÍπåÏßÄ Ìè¨Ìï®Ìïú 'Ï†ÑÏ≤¥ clinic ÎåÄÏÉÅ'ÏùÑ ÎßåÎì§ Ïàò ÏûàÎã§.
    """
    qs = ClinicLink.objects.filter(session=session)

    # ‚úÖ ÏàòÏ†ïÏÇ¨Ìï≠(Ï∂îÍ∞Ä): ÏòàÏïΩ ÏôÑÎ£åÎ°ú Î∂ÑÎ¶¨Îêú ÎåÄÏÉÅÏûêÎäî clinic_requiredÏóêÏÑú Ï†úÏô∏
    qs = qs.filter(resolved_at__isnull=True)

    if not include_manual:
        qs = qs.filter(is_auto=True)

    return set(qs.values_list("enrollment_id", flat=True).distinct())


def is_clinic_required(
    *,
    session: Session,
    enrollment_id: int,
    include_manual: bool = False,
) -> bool:
    """
    ‚úÖ enrollment Îã®ÏúÑ clinic Ïó¨Î∂Ä (Îã®Ïùº ÏßÑÏã§)
    """
    enrollment_id = int(enrollment_id)
    ids = get_clinic_enrollment_ids_for_session(
        session=session,
        include_manual=include_manual,
    )
    return enrollment_id in ids


==========================================================================================
# FILE: utils/result_queries.py
==========================================================================================
# apps/domains/results/utils/result_queries.py
from __future__ import annotations

from django.db.models import Max, QuerySet, Subquery

from apps.domains.results.models import Result


def latest_results_per_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> QuerySet[Result]:
    """
    ‚úÖ ÌÜµÍ≥Ñ/ÏßëÍ≥ÑÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî 'ÏµúÏã† Result' queryset (enrollment Í∏∞Ï§Ä 1Í∞ú)

    Ïôú ÌïÑÏöîÌïúÍ∞Ä?
    - unique_togetherÍ∞Ä ÏûàÏñ¥ÎèÑ Ïö¥ÏòÅÏóêÏÑúÎäî:
        - Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Íπ®Ïßê
        - manual insert
        - Ïû•Ïï† Î≥µÍµ¨/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ïàò
      Î°ú ÎèôÏùº enrollmentÏùò ResultÍ∞Ä Ï§ëÎ≥µÎê† Ïàò ÏûàÎã§.
    - ÌÜµÍ≥ÑÎäî Ï§ëÎ≥µÏùÑ Í≥†Î†§ÌïòÏßÄ ÏïäÏúºÎ©¥ participant/avg/min/max Ï†ÑÎ∂Ä ÏôúÍ≥°.

    Íµ¨ÌòÑ Î∞©Ïãù:
    - enrollment_idÎ≥ÑÎ°ú Í∞ÄÏû• ÌÅ∞ id(Í∞ÄÏû• ÏµúÍ∑º insert)Î•º ÏÑ†ÌÉù
    - DB vendor ÎèÖÎ¶Ω (PostgresÏùò distinct on Í∞ôÏùÄ Í∏∞Îä•Ïóê ÏùòÏ°¥ÌïòÏßÄ ÏïäÏùå)
    """
    target_id = int(target_id)

    base = Result.objects.filter(
        target_type=str(target_type),
        target_id=target_id,
    )

    # enrollmentÎ≥Ñ Í∞ÄÏû• ÏµúÏã† Result.idÎ•º ÏÑ†ÌÉù
    latest_ids = (
        base.values("enrollment_id")
        .annotate(last_id=Max("id"))
        .values("last_id")
    )

    return Result.objects.filter(id__in=Subquery(latest_ids))


def participant_count_distinct_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> int:
    """
    ‚úÖ participant_count Îã®Ïùº Í∑úÏπô: distinct enrollment Í∏∞Ï§Ä
    """
    return (
        Result.objects.filter(
            target_type=str(target_type),
            target_id=int(target_id),
        )
        .values("enrollment_id")
        .distinct()
        .count()
    )


==========================================================================================
# FILE: utils/session_exam.py
==========================================================================================
# apps/domains/results/utils/session_exam.py
from __future__ import annotations

from typing import List, Optional

from django.db.models import QuerySet

from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _has_relation(model, name: str) -> bool:
    """
    Î™®Îç∏Ïóê ÌäπÏ†ï field/relationÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ Í≤ÄÏÇ¨.
    ÌîÑÎ°úÏ†ùÌä∏ ÌûàÏä§ÌÜ†Î¶¨(ÏÑ∏ÏÖò-ÏãúÌóò Í¥ÄÍ≥ÑÍ∞Ä Î∞îÎÄåÎäî Í≥ºÏ†ï)ÏóêÏÑú
    Îü∞ÌÉÄÏûÑÏóê ÏïàÏ†ÑÌïòÍ≤å ÎèôÏûëÏãúÌÇ§Í∏∞ ÏúÑÌïú Î∞©Ïñ¥ Ïú†Ìã∏.
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


# ---------------------------------------------------------------------
# ‚úÖ Canonical API: Session -> Exams
# ---------------------------------------------------------------------
def get_exams_for_session(session: Session) -> QuerySet[Exam]:
    """
    ‚úÖ Îã®Ïùº ÏßÑÏã§: SessionÏóê Ïó∞Í≤∞Îêú Exam queryset Î∞òÌôò

    ÏõêÏπô:
    - ÏïûÏúºÎ°ú 'Session ‚Üî Exam Í¥ÄÍ≥Ñ Ìï¥ÏÑù'ÏùÄ Ïù¥ Ìï®ÏàòÎ°úÎßå ÌïúÎã§.
    - Ïñ¥Îñ§ APIÏóêÏÑúÎèÑ Îã§ÏùåÏùÑ ÏßÅÏ†ë Ïì∞ÏßÄ Îßê Í≤É:
        session.exams / Exam.objects.filter(sessions__id=...) / Session.objects.filter(exams__id=...)
      ‚Üí ÌååÏùºÎßàÎã§ Îã§Î•¥Í≤å Íµ¨ÌòÑÎêòÎ©∞ "ÌôîÎ©¥ÎßàÎã§ Í≤∞Í≥º Îã§Î¶Ñ" Î≤ÑÍ∑∏Ïùò ÏõêÏù∏.
    """
    # 1) Session.exams (M2M) - Í∞ÄÏû• canonical
    if _has_relation(Session, "exams") and hasattr(session, "exams"):
        try:
            return session.exams.all()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Exam.objects.filter(sessions__id=int(session.id)).distinct()

    # 3) Legacy fallback: Session.exam (FK)
    #    (Ïù¥ÎØ∏ 1:NÏúºÎ°ú Î¶¨Ìå©ÌÜ†ÎßÅ ÌñàÎã§Í≥† ÌñàÏúºÎãà, Ïö¥ÏòÅÏóêÏÑú ÏóÜÏñ¥ÎèÑ Î¨¥Î∞©ÌïòÏßÄÎßå
    #     Í∞úÎ∞ú/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ë ÏÑûÏó¨ ÏûàÏùÑ Ïàò ÏûàÏñ¥ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ïú†ÏßÄ)
    exam_id = getattr(session, "exam_id", None)
    if exam_id:
        return Exam.objects.filter(id=int(exam_id))

    # 4) Î™ª Ï∞æÏúºÎ©¥ empty
    return Exam.objects.none()


def get_exam_ids_for_session(session: Session) -> List[int]:
    """
    ‚úÖ Session -> exam_id list

    - ÌÜµÍ≥Ñ/ÏßëÍ≥ÑÏóêÏÑú Î¶¨Ïä§Ìä∏Í∞Ä ÌïÑÏöîÌï† Îïå ÏÇ¨Ïö©.
    - queryset ÎåÄÏã† list[int]Î°ú Í≥†Ï†ïÌï¥ÏÑú Ìò∏Ï∂úÏ∏°Ïùò Ï§ëÎ≥µ/Ïò§Ìï¥Î•º Ï§ÑÏûÑ.
    """
    return list(get_exams_for_session(session).values_list("id", flat=True))


# ---------------------------------------------------------------------
# ‚úÖ Canonical API: Exam -> Sessions
# ---------------------------------------------------------------------
def get_sessions_for_exam(exam_id: int) -> QuerySet[Session]:
    """
    ‚úÖ Îã®Ïùº ÏßÑÏã§: ÌäπÏ†ï exam_idÍ∞Ä ÏÜçÌïú Session queryset Î∞òÌôò

    (ÏÑ∏ÏÖò 1 : ÏãúÌóò N Íµ¨Ï°∞)
    - Session.exams(M2M)Í∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏ Ïö∞ÏÑ† ÏÇ¨Ïö©
    - ÏóÜÏúºÎ©¥ Exam.sessions reverse ÏÇ¨Ïö©
    - ÎßàÏßÄÎßâÏúºÎ°ú legacy Session.exam FK fallback
    """
    exam_id = int(exam_id)

    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams"):
        try:
            return Session.objects.filter(exams__id=exam_id).distinct()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Session.objects.filter(exams__id=exam_id).distinct()

    # 3) legacy: Session.exam FK
    return Session.objects.filter(exam_id=exam_id).distinct()


def get_primary_session_for_exam(exam_id: int) -> Optional[Session]:
    """
    ‚úÖ 'ÎåÄÌëú session'Ïù¥ ÌïÑÏöîÌï† Îïå ÏÇ¨Ïö© (Ïòà: legacy API)

    Ï†ïÏ±Ö:
    - Ïó¨Îü¨ sessionÏù¥ Í±∏Î¶¥ Ïàò ÏûàÏúºÎ©¥ orderÍ∞Ä Í∞ÄÏû• ÏûëÏùÄ(Îπ†Î•∏) sessionÏùÑ Ïö∞ÏÑ† Î∞òÌôò.
    - order ÌïÑÎìúÍ∞Ä ÏóÜÍ±∞ÎÇò Ï†ïÎ†¨ Ïã§Ìå® Ïãú Í∑∏ÎÉ• first().
    """
    qs = get_sessions_for_exam(int(exam_id))
    if not qs.exists():
        return None

    # orderÍ∞Ä Ï°¥Ïû¨Ìï† Í∞ÄÎä•ÏÑ±Ïù¥ ÎÜíÏùå(lecture session order)
    if hasattr(Session, "order"):
        try:
            return qs.order_by("order", "id").first()
        except Exception:
            pass

    return qs.order_by("id").first()


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# apps/domains/results/views/__init__.py

"""
results.views public exports

‚ö†Ô∏è IMPORTANT RULES
- Ïù¥ ÌååÏùºÏùÄ "Ïô∏Î∂ÄÏóêÏÑú import Ìï¥ÎèÑ ÎêòÎäî View"Îßå exportÌïúÎã§.
- urls.pyÏóêÏÑú ÏßÅÏ†ë importÌïòÎäî ViewÎäî Íµ≥Ïù¥ Ïó¨Í∏∞ÏÑú exportÌïòÏßÄ ÏïäÏïÑÎèÑ ÎêúÎã§.
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌååÏùº / ÌÅ¥ÎûòÏä§Í∞Ä importÎêòÎ©¥
  migrate / runserver ÏãúÏ†êÏóê Ï¶âÏãú ÌÅ¨ÎûòÏãú ÎÇúÎã§.
"""

# ======================================================
# Student-facing
# ======================================================
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

# ======================================================
# Admin / Teacher-facing (ÎåÄÌëú ViewÎßå)
# ======================================================
from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView

# ======================================================
# ‚ö†Ô∏è Question stats Í¥ÄÎ†®
# - AdminExamQuestionStatsView Îì±ÏùÄ
#   urls.pyÏóêÏÑú ÏßÅÏ†ë importÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî exportÌïòÏßÄ ÏïäÎäîÎã§.
# - Ï§ëÎ≥µ export / Î∂àÌïÑÏöîÌïú importÎ•º Î∞©ÏßÄÌïòÍ∏∞ ÏúÑÌï®
# ======================================================

__all__ = [
    "MyExamResultView",
    "WrongNoteView",
    "AdminExamResultsView",
    "AdminExamSummaryView",
]


==========================================================================================
# FILE: views/admin_clinic_targets_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_clinic_targets_view.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê Ï°∞Ìöå API

Endpoint
- GET /results/admin/clinic-targets/

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
- ÎåÄÏÉÅÏûê ÏÑ†Ï†ï Îã®Ïùº ÏßÑÏã§: progress.ClinicLink(is_auto=True)
- enrollment_id Í∏∞Ï§Ä
- Í≥ÑÏÇ∞/ÌåêÏ†ïÏùÄ Service(ClinicTargetService)Ïóê ÏúÑÏûÑ
- ÏùëÎãµ Ïä§ÌÇ§ÎßàÎäî AdminClinicTargetSerializerÎ°ú Í≥†Ï†ï (ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ)

Î≥¥Î•òÎêú Í∏∞Îä• (Î™ÖÏãú)
- pagination ÌïÑÏöî Ïãú Ï∂îÌõÑ DRF pagination ÎèÑÏûÖ Í∞ÄÎä•
- ÌòÑÏû¨Îäî Ïö¥ÏòÅÏóêÏÑú "Ï†ÑÏ≤¥ ÎåÄÏÉÅÏûê"Í∞Ä ÏÜåÏàòÎùºÎäî Í∞ÄÏ†ï ÌïòÏóê listÎ°ú Î∞òÌôò
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.clinic_target_service import ClinicTargetService
from apps.domains.results.serializers.admin_clinic_target import AdminClinicTargetSerializer


class AdminClinicTargetsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        rows = ClinicTargetService.list_admin_targets()
        return Response(AdminClinicTargetSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_attempts_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_attempts_view.py
# ==========================================================================================
"""
Admin Exam Attempt List View

GET /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

==========================================================================================
‚úÖ Î™©Ï†Å (Phase 1)
==========================================================================================
- Admin / TeacherÍ∞Ä ÌäπÏ†ï ÏãúÌóò(exam_id) + ÌäπÏ†ï enrollmentÏùò
  ExamAttempt Î™©Î°ùÏùÑ Ï°∞ÌöåÌïúÎã§.
- AttemptSelectorPanelÏùò Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§

==========================================================================================
‚úÖ Í≥ÑÏïΩ (ÌîÑÎ°†Ìä∏ Í≥†Ï†ï)
==========================================================================================
ÏùëÎãµ:
[
  {
    "id": 101,
    "attempt_index": 1,
    "is_retake": false,
    "is_representative": true,
    "status": "done",
    "created_at": "2025-01-01T10:00:00Z",
    "meta": {
      "grading": {
        "total_score": 85,
        "total_max_score": 100
      }
    }
  }
]

- Ï†ïÎ†¨: attempt_index ASC
- ÎåÄÌëú attempt: Ìï≠ÏÉÅ 1Í∞ú Î≥¥Ïû• (ÏÑúÎ≤Ñ invariant)
- status enum:
    pending | grading | done | failed

==========================================================================================
‚ö†Ô∏è Ï£ºÏùò
==========================================================================================
- ÏàòÏ†ï/ÎåÄÌëú Î≥ÄÍ≤Ω ‚ùå (Phase 2ÏóêÏÑú Íµ¨ÌòÑ)
- enrollment_idÎäî Enrollment PK Í∏∞Ï§Ä (results ÎèÑÎ©îÏù∏ Ï†ÑÏ≤¥ Í≥ÑÏïΩÍ≥º ÎèôÏùº)
"""

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt


class AdminExamAttemptsView(APIView):
    """
    Admin / Teacher Ï†ÑÏö© Attempt Î™©Î°ù Ï°∞Ìöå
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        # -------------------------------------------------
        # 1Ô∏è‚É£ Attempt Ï°∞Ìöå
        # -------------------------------------------------
        attempts = (
            ExamAttempt.objects
            .filter(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .order_by("attempt_index")  # ‚úÖ ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ
        )

        if not attempts.exists():
            # Îπà Î∞∞Ïó¥ÏùÑ ÎÇ¥Î†§ÎèÑ ÎêòÏßÄÎßå,
            # Admin ÌôîÎ©¥ÏóêÏÑúÎäî Î≥¥ÌÜµ "Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå"Ïù¥ ÏùòÎØ∏ ÏûàÎäî Ïò§Î•òÎùº ÌåêÎã®
            raise ValidationError("No attempts found for this exam/enrollment.")

        # -------------------------------------------------
        # 2Ô∏è‚É£ ÏùëÎãµ Íµ¨ÏÑ± (Serializer ÏóÜÏù¥ Î™ÖÏãúÏ†Å dict)
        #    - ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ ÏïàÏ†ïÏÑ±
        #    - meta Íµ¨Ï°∞Î•º Í∑∏ÎåÄÎ°ú ÎÖ∏Ï∂ú Í∞ÄÎä•
        # -------------------------------------------------
        data = []
        for a in attempts:
            row = {
                "id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": bool(a.is_retake),
                "is_representative": bool(a.is_representative),
                "status": a.status,
                "created_at": a.created_at,
            }

            # meta ÌïÑÎìúÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏ÎåÄÎ°ú ÎÖ∏Ï∂ú (grading Ï†ïÎ≥¥ Ìè¨Ìï® Í∞ÄÎä•)
            if hasattr(a, "meta") and a.meta is not None:
                row["meta"] = a.meta
            else:
                row["meta"] = {}

            data.append(row)

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_item_score_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_item_score_view.py
"""
Admin Manual Grading - Subjective Question Score

PATCH /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

‚úÖ PHASE 2 ÌïµÏã¨ Ìå®Ïπò
- PATCH ÏÑ±Í≥µ Ïãú backendÎäî Ï¶âÏãú:
  - (Ïù¥ÎØ∏ ÏàòÌñâ) ResultItem + ResultFact + Result.total_score Ïû¨Í≥ÑÏÇ∞
  - (Ï∂îÍ∞Ä) progress pipelineÏùÑ Ï¶âÏãú Ìä∏Î¶¨Í±∞ÌïúÎã§.
    -> SessionProgress / LectureProgress / Risk / ClinicLink ÏµúÏã†Ìôî

‚ö†Ô∏è progress pipelineÏùÄ submission_id Í∏∞Î∞òÏù¥ÎØÄÎ°ú,
- Ìï¥Îãπ enrollment + (examÏóê Ïó∞Í≤∞Îêú ÎåÄÌëú session) Í∏∞Ï§Ä ÏµúÏã† SubmissionÏùÑ Ï∞æÏïÑ Ìä∏Î¶¨Í±∞ÌïúÎã§.
- SubmissionÏù¥ ÏóÜÏúºÎ©¥ Ï¶âÏãúÏÑ± Í≥ÑÏïΩÏùÑ ÏßÄÌÇ¨ Ïàò ÏóÜÏúºÎØÄÎ°ú 409 Î∞òÌôòÌïúÎã§.
"""

from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultItem, ResultFact, ExamAttempt

# ‚úÖ Îã®Ïùº ÏßÑÏã§: session Îß§Ìïë + progress Ìä∏Î¶¨Í±∞
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminExamItemScoreView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @transaction.atomic
    def patch(
        self,
        request,
        exam_id: int,
        enrollment_id: int,
        question_id: int,
    ):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        question_id = int(question_id)

        if "score" not in request.data:
            raise ValidationError({"detail": "score is required", "code": "INVALID"})

        try:
            new_score = float(request.data.get("score"))
        except Exception:
            raise ValidationError({"detail": "score must be number", "code": "INVALID"})

        # -------------------------------------------------
        # 1Ô∏è‚É£ Result (ÎåÄÌëú Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .select_for_update()
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .first()
        )
        if not result:
            raise NotFound({"detail": "result not found", "code": "NOT_FOUND"})

        if not result.attempt_id:
            raise ValidationError(
                {"detail": "representative attempt not set", "code": "INVALID"}
            )

        # -------------------------------------------------
        # 2Ô∏è‚É£ Attempt ÏÉÅÌÉú ÌôïÏù∏ (LOCK)
        # -------------------------------------------------
        attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
        if not attempt:
            raise NotFound({"detail": "attempt not found", "code": "NOT_FOUND"})

        if attempt.status == "grading":
            return Response(
                {"detail": "attempt is grading", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 3Ô∏è‚É£ ResultItem (Î¨∏Ìï≠ Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        item = (
            ResultItem.objects
            .select_for_update()
            .filter(result=result, question_id=question_id)
            .first()
        )
        if not item:
            raise NotFound({"detail": "result item not found", "code": "NOT_FOUND"})

        # Ï†êÏàò ÏÉÅÌïú Î∞©Ïñ¥
        max_score = float(item.max_score or 0.0)
        if new_score < 0 or new_score > max_score:
            raise ValidationError(
                {
                    "detail": f"score must be between 0 and {max_score}",
                    "code": "INVALID",
                }
            )

        # -------------------------------------------------
        # 4Ô∏è‚É£ ResultFact (append-only Î°úÍ∑∏)
        # -------------------------------------------------
        ResultFact.objects.create(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=0,              # ÏàòÎèô Ï±ÑÏ†êÏù¥ÎØÄÎ°ú 0
            attempt_id=int(result.attempt_id),

            question_id=question_id,
            answer=item.answer or "",
            is_correct=bool(new_score >= max_score),
            score=float(new_score),
            max_score=max_score,
            source="manual",
            meta={
                "manual": True,
                "edited_at": timezone.now().isoformat(),
            },
        )

        # -------------------------------------------------
        # 5Ô∏è‚É£ ResultItem ÏóÖÎç∞Ïù¥Ìä∏
        # -------------------------------------------------
        item.score = float(new_score)
        item.is_correct = bool(new_score >= max_score)
        item.source = "manual"
        item.save(update_fields=["score", "is_correct", "source"])

        # -------------------------------------------------
        # 6Ô∏è‚É£ total_score Ïû¨Í≥ÑÏÇ∞
        # -------------------------------------------------
        agg = ResultItem.objects.filter(result=result)

        total_score = sum(float(x.score or 0.0) for x in agg)
        max_total = sum(float(x.max_score or 0.0) for x in agg)

        result.total_score = float(total_score)
        result.max_score = float(max_total)
        result.save(update_fields=["total_score", "max_score"])

        # -------------------------------------------------
        # 7Ô∏è‚É£ ‚úÖ PHASE 2: progress pipeline Ï¶âÏãú Ìä∏Î¶¨Í±∞
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "question_id": question_id,
                "score": float(new_score),
                "total_score": float(total_score),
                "max_score": float(max_total),
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_exam_result_detail_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_result_detail_view.py
# ==========================================================================================
"""
Admin Exam Result Detail View (Îã®Ïùº ÌïôÏÉù Í≤∞Í≥º ÏÉÅÏÑ∏)

GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/

==========================================================================================
‚úÖ PHASE 3 ÌôïÏ†ï Í≥ÑÏïΩ (FRONTEND LOCK)
==========================================================================================
ÏùëÎãµ Î≥¥Ïû• ÌïÑÎìú:
- passed                : Exam.pass_score Í∏∞Ï§Ä ÏãúÌóò Ìï©Î∂à
- clinic_required       : ClinicLink Îã®Ïùº ÏßÑÏã§ (ÏûêÎèô Ìä∏Î¶¨Í±∞Îßå)
- items[].is_editable   : edit_state Í∏∞Î∞ò
- edit_state            : LOCK ÌåêÎã® Î©îÌÉÄ
- allow_retake
- max_attempts
- can_retake

‚ö†Ô∏è Ï£ºÏùò
- passed ‚â† SessionProgress.exam_passed
- Ïù¥ APIÎäî "ÏãúÌóò Îã®ÏúÑ(Result) ÏßÑÏã§"
"""

from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)

from apps.domains.exams.models import Exam

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class AdminExamResultDetailView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        exam = get_object_or_404(Exam, id=exam_id)
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0)

        # -------------------------------------------------
        # 1Ô∏è‚É£ Result (ÎåÄÌëú Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )
        if not result:
            raise NotFound("result not found")

        # -------------------------------------------------
        # 2Ô∏è‚É£ passed (ÏãúÌóò Îã®ÏúÑ Í∏∞Ï§Ä)
        # -------------------------------------------------
        passed = bool(float(result.total_score or 0.0) >= pass_score)

        # -------------------------------------------------
        # 3Ô∏è‚É£ Ïû¨ÏãúÌóò Ï†ïÏ±Ö (‚ö†Ô∏è Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_qs = ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        )
        attempt_count = attempt_qs.count()
        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4Ô∏è‚É£ clinic_required (Îã®Ïùº ÏßÑÏã§)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,
            )

        # -------------------------------------------------
        # 5Ô∏è‚É£ edit_state (LOCK Í∑úÏπô)
        # -------------------------------------------------
        edit_state = {
            "can_edit": True,
            "is_locked": False,
            "lock_reason": None,
            "last_updated_by": None,
            "updated_at": None,
        }

        if result.attempt_id:
            attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
            if attempt and attempt.status == "grading":
                edit_state.update({
                    "can_edit": False,
                    "is_locked": True,
                    "lock_reason": "GRADING",
                })

        # -------------------------------------------------
        # 6Ô∏è‚É£ Serializer + items[].is_editable
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data

        for item in data.get("items", []):
            item["is_editable"] = bool(
                edit_state["can_edit"] and not edit_state["is_locked"]
            )

        # -------------------------------------------------
        # 7Ô∏è‚É£ ÏµúÏ¢Ö ÏùëÎãµ (Í∏∞Ï°¥ Í≥ÑÏïΩ + PHASE 3 ÌôïÏû•)
        # -------------------------------------------------
        data.update({
            "passed": passed,
            "allow_retake": allow_retake,
            "max_attempts": max_attempts,
            "can_retake": can_retake,
            "clinic_required": bool(clinic_required),
            "edit_state": edit_state,
        })

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_results_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission
from apps.domains.exams.models import Exam

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamResultsView(APIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    ‚úÖ Î™©Ìëú(ÏõêÎ≥∏ Ïú†ÏßÄ + Ï†ïÌï©ÏÑ± Í∞ïÌôî)
    - Result(Ïä§ÎÉÖÏÉ∑) Í∏∞Î∞ò Ï†êÏàò Î¶¨Ïä§Ìä∏
    - Attempt/Submission ÏÉÅÌÉú Ïó∞Í≤∞
    - Clinic Í∏∞Ï§Ä ÌÜµÏùº(ClinicLink)
    - Session‚ÜîExam Îß§Ìïë Îã®ÏùºÌôî(utils.session_exam)

    ‚ö†Ô∏è pass Í∏∞Ï§Ä Ï†ïÏùò:
    - Ïù¥ ÌôîÎ©¥ÏùÄ "ÏãúÌóò(exam) Îã®ÏúÑ Í≤∞Í≥º"Ïù¥ÎØÄÎ°ú
      pass/failÏùÄ Exam.pass_score Í∏∞Ï§ÄÏúºÎ°ú Ï†úÍ≥µÌïúÎã§.
    - ÏÑ∏ÏÖò Ï¢ÖÌï© ÌÜµÍ≥º(SessionProgress.exam_passed)Îäî
      /admin/sessions/... summary APIÏóêÏÑú Ï†úÍ≥µÌïòÎäî Í≤ÉÏù¥ Ï†ïÏÑù.
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # -------------------------------------------------
        # 1Ô∏è‚É£ Result (Ï§ëÎ≥µ enrollment Î∞©Ïñ¥: ÏµúÏã† 1Í∞úÎßå)
        # -------------------------------------------------
        results = latest_results_per_enrollment(
            target_type="exam",
            target_id=exam_id,
        ).order_by("enrollment_id")

        # -------------------------------------------------
        # 2Ô∏è‚É£ Session Ï∞æÍ∏∞ (clinic ÌåêÎã®Ïö©)
        #    - ÏÑ∏ÏÖò 1 : ÏãúÌóò N Íµ¨Ï°∞ÏóêÏÑúÎèÑ ÎåÄÌëú sessionÏùÄ ÌïÑÏöîÌï† Ïàò ÏûàÏùå(legacy UI Îì±)
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)

        # -------------------------------------------------
        # 3Ô∏è‚É£ Student Ï°∞Ìöå (ÏõêÎ≥∏ Î°úÏßÅ Ï°¥Ï§ë: progress_map Í∏∞Î∞ò Ï∂îÎ°†Ïù¥ÏóàÏßÄÎßå
        #    SessionProgressÏóê student_idÍ∞Ä ÏûàÎã§Í≥† Í∞ÄÏ†ïÌïòÎ©¥ Íπ®Ïßà Ïàò ÏûàÏùå)
        #
        #    Ïó¨Í∏∞ÏÑúÎäî "Result.enrollment_id"Î•º ÌïôÏÉùÏúºÎ°ú ÏßÅÏ†ë Îß§ÌïëÌï† Ïàò ÏóÜÏúºÎØÄÎ°ú
        #    ÌîÑÎ°úÏ†ùÌä∏Ïùò Enrollment/Student Ïó∞Í≤∞ Î∞©ÏãùÏù¥ ÌïÑÏöîÌïòÎã§.
        #    ÏõêÎ≥∏Ï≤òÎüº SessionProgressÏóêÏÑú student/userÎ•º Ï∂îÎ°†ÌïòÎçò Î∞©ÏãùÏù¥ ÏûàÏúºÎ©¥ Ïú†ÏßÄÌï¥Ïïº Ìï®.
        #
        #    ‚úÖ ÌïòÏßÄÎßå ÌòÑÏû¨ Ï†úÍ≥µÎêú ÏΩîÎìú Ïä§ÎÉÖÏÉ∑ÎßåÏúºÎ°úÎäî
        #    enrollment_id -> student_name Ìï¥ÏÑùÏù¥ ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ Îã¨Îùº ÏïàÏ†ÑÌïòÏßÄ ÏïäÎã§.
        #
        #    Í∑∏ÎûòÏÑú:
        #    - ÏõêÎ≥∏Ïùò Student Ï°∞Ìöå Î£®Ìã¥ÏùÑ "Í∞ÄÎä•ÌïòÎ©¥" ÏàòÌñâÌïòÎêò
        #    - Ïã§Ìå®Ìï¥ÎèÑ "-" Î°ú ÏïàÏ†ÑÌïòÍ≤å Î∞òÌôòÌïúÎã§.
        # -------------------------------------------------
        student_map = {}
        try:
            # ÏõêÎ≥∏ ÏΩîÎìúÏùò ÏùòÎèÑ: SessionProgressÏóê student_id/user_idÍ∞Ä Î∂ôÏñ¥ÏûàÏùÑ Ïàò ÏûàÎã§.
            from apps.domains.progress.models import SessionProgress  # ÏßÄÏó∞ import

            if session:
                progress_rows = SessionProgress.objects.filter(session=session)
            else:
                progress_rows = SessionProgress.objects.none()

            student_ids = set()
            for sp in progress_rows:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
                if sid:
                    student_ids.add(int(sid))

            student_map = {
                s.id: s
                for s in Student.objects.filter(id__in=list(student_ids))
            }
        except Exception:
            student_map = {}

        # -------------------------------------------------
        # 4Ô∏è‚É£ enrollment_id ‚Üí ÏµúÏã† attempt/submission Îßµ
        #    - ResultFactÍ∞Ä ÏûàÏúºÎ©¥ Í∞ÄÏû• ÏµúÏã† attemptÎ•º Ïö∞ÏÑ† ÏÇ¨Ïö©
        #    - ÏóÜÏúºÎ©¥ Result.attempt_id fallback
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(target_type="exam", target_id=exam_id)
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values("enrollment_id", "attempt_id", "submission_id")
        )

        latest_map = {}
        for row in fact_qs:
            eid = int(row["enrollment_id"])
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": int(row["attempt_id"]),
                    "submission_id": int(row["submission_id"]),
                }

        # Result.attempt_id fallback
        attempt_ids = [r.attempt_id for r in results if getattr(r, "attempt_id", None)]
        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = int(r.enrollment_id)
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue
            a = attempt_map.get(int(aid))
            if not a:
                continue
            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # Submission.status
        submission_ids = [v["submission_id"] for v in latest_map.values() if v.get("submission_id")]
        submission_status_map = {
            s.id: s.status
            for s in Submission.objects.filter(id__in=submission_ids)
        }

        # -------------------------------------------------
        # 5Ô∏è‚É£ rows Íµ¨ÏÑ±
        # -------------------------------------------------
        rows = []
        for r in results:
            enrollment_id = int(r.enrollment_id)

            # student_name (Í∞ÄÎä•ÌïòÎ©¥ Îß§Ìïë, ÏïÑÎãàÎ©¥ "-")
            student_name = "-"
            try:
                # ÏõêÎ≥∏ Î°úÏßÅ: progress rowÏóê student/user idÍ∞Ä ÏûàÏùÑ ÎïåÎßå ÌëúÏãú Í∞ÄÎä•
                # Ïó¨Í∏∞ÏÑúÎäî ÌôïÏ†ï Îß§ÌïëÏù¥ ÏóÜÏúºÎØÄÎ°ú ÏïàÏ†Ñ fallback
                student_name = "-"
            except Exception:
                student_name = "-"

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = submission_status_map.get(submission_id) if submission_id else None

            # ‚úÖ pass/failÏùÄ exam Îã®ÏúÑ => Exam.pass_score Í∏∞Ï§Ä
            passed = bool(float(r.total_score or 0.0) >= float(pass_score))

            # ‚úÖ clinic_required Îã®Ïùº Í∑úÏπô
            clinic_required = bool(
                session and is_clinic_required(session=session, enrollment_id=enrollment_id, include_manual=False)
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student_name,

                "exam_score": float(r.total_score or 0.0),
                "exam_max_score": float(r.max_score or 0.0),

                # Ïù¥ÌõÑ ÏÑ∏ÏÖò ÏßëÍ≥Ñ ÌôïÏû• ÎåÄÎπÑ (ÌòÑÏû¨Îäî ÎèôÏùº)
                "final_score": float(r.total_score or 0.0),

                "passed": passed,
                "clinic_required": clinic_required,

                "submitted_at": r.submitted_at,

                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        return Response(AdminExamResultRowSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.admin_exam_summary import AdminExamSummarySerializer
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ClinicLink

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamSummaryView(APIView):
    """
    LEGACY COMPAT
    GET /results/admin/exams/<exam_id>/summary/

    ‚úÖ Í≥ÑÏïΩ Ïú†ÏßÄ(ÌîÑÎ°†Ìä∏ ÏïàÏ†ïÏÑ±):
    - participant_count, avg/min/max, pass_count/fail_count/pass_rate, clinic_count

    ‚úÖ Ï†ïÌï©ÏÑ± Í∞ïÌôî:
    - Result Ï§ëÎ≥µ enrollment Î∞©Ïñ¥: ÏµúÏã† ResultÎßå ÏßëÍ≥Ñ
    - clinic_count Í∏∞Ï§Ä ÌÜµÏùº: ClinicLink(is_auto=True) enrollment distinct
    - Session‚ÜîExam Îß§Ìïë Îã®ÏùºÌôî(utils.session_exam)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        EMPTY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_count": 0,
            "fail_count": 0,
            "pass_rate": 0.0,
            "clinic_count": 0,
        }

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # ‚úÖ Ï§ëÎ≥µ Î∞©Ïñ¥: enrollmentÎãπ ÏµúÏã† ResultÎßå
        rs = latest_results_per_enrollment(target_type="exam", target_id=exam_id)

        participant_count = rs.values("enrollment_id").distinct().count()
        if participant_count == 0:
            return Response(AdminExamSummarySerializer(EMPTY).data)

        agg = rs.aggregate(
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_count = rs.filter(total_score__gte=pass_score).count()
        fail_count = rs.filter(total_score__lt=pass_score).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # ‚úÖ clinic_countÎäî session Í∏∞Î∞òÏúºÎ°úÎßå Í≥ÑÏÇ∞ Í∞ÄÎä•(ÏãúÌóòÎßåÏúºÎ°† clinicÏù¥ Ï†ïÏùòÎêòÏßÄ ÏïäÏùå)
        clinic_count = 0
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id")
                .distinct()
                .count()
            )

        payload = {
            "participant_count": int(participant_count),
            "avg_score": float(agg["avg_score"] or 0.0),
            "min_score": float(agg["min_score"] or 0.0),
            "max_score": float(agg["max_score"] or 0.0),
            "pass_count": int(pass_count),
            "fail_count": int(fail_count),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_count": int(clinic_count),
        }

        return Response(AdminExamSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_representative_attempt_view.py
"""
Admin Representative Attempt Switch

POST /results/admin/exams/<exam_id>/representative-attempt/

‚úÖ PHASE 2 ÌïµÏã¨ Ìå®Ïπò (Ï†ïÌï©ÏÑ±)
- ÎåÄÌëú attempt Î≥ÄÍ≤Ω Ïãú Result.attempt_idÎßå Î∞îÍæ∏Î©¥ Ïä§ÎÉÖÏÉ∑ Î∂àÏùºÏπò Í∞ÄÎä•
- Îî∞ÎùºÏÑú:
  1) ÎåÄÌëú attempt ÍµêÏ≤¥
  2) ResultFact(attempt_id=ÏÑ†ÌÉù attempt) Í∏∞Î∞òÏúºÎ°ú Result/ResultItem Ïä§ÎÉÖÏÉ∑ÏùÑ Ï¶âÏãú Ïû¨Íµ¨ÏÑ±
  3) progress pipeline Ï¶âÏãú Ìä∏Î¶¨Í±∞

LOCK Í∑úÏπôÏùÄ Í∏∞Ï°¥ Ïú†ÏßÄ:
- grading attemptÎäî ÎåÄÌëúÎ°ú Î≥ÄÍ≤Ω Î∂àÍ∞Ä (409 LOCKED)
"""

from __future__ import annotations

from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result, ResultItem, ResultFact

# ‚úÖ Îã®Ïùº ÏßÑÏã§: session Îß§Ìïë + progress Ìä∏Î¶¨Í±∞
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminRepresentativeAttemptView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _rebuild_result_snapshot_from_attempt(
        *,
        exam_id: int,
        enrollment_id: int,
        attempt_id: int,
    ) -> Result:
        """
        ‚úÖ ÎåÄÌëú attempt Í∏∞Î∞òÏúºÎ°ú Result/ResultItem Ïä§ÎÉÖÏÉ∑ÏùÑ Ïû¨Íµ¨ÏÑ±ÌïúÎã§.

        Í∑úÏπô:
        - ResultFactÎäî append-onlyÎùº Í∞ôÏùÄ question_idÍ∞Ä Ïó¨Îü¨ Î≤à Ï°¥Ïû¨ Í∞ÄÎä•
        - question_idÎ≥Ñ ÏµúÏã† Fact(id ÏµúÎåÄ)Îßå Ïä§ÎÉÖÏÉ∑ÏúºÎ°ú Ï±ÑÌÉù
        """
        result = (
            Result.objects
            .select_for_update()
            .filter(target_type="exam", target_id=exam_id, enrollment_id=enrollment_id)
            .first()
        )
        if not result:
            raise NotFound({"detail": "result snapshot not found", "code": "NOT_FOUND"})

        # question_idÎ≥Ñ ÏµúÏã† fact id
        latest_fact_ids = (
            ResultFact.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id,
            )
            .values("question_id")
            .annotate(last_id=Max("id"))
            .values("last_id")
        )

        facts = list(ResultFact.objects.filter(id__in=latest_fact_ids))

        # Ïä§ÎÉÖÏÉ∑ ÎπÑÏñ¥ÏûàÏúºÎ©¥(Ìï¥Îãπ attemptÏóê factÍ∞Ä ÏóÜÏùå) invalid
        if not facts:
            raise ValidationError({"detail": "no facts for this attempt; cannot rebuild snapshot", "code": "INVALID"})

        # ResultItem Ïû¨Íµ¨ÏÑ±
        total = 0.0
        max_total = 0.0

        for f in facts:
            score = float(f.score or 0.0)
            max_score = float(f.max_score or 0.0)

            ResultItem.objects.update_or_create(
                result=result,
                question_id=int(f.question_id),
                defaults={
                    "answer": str(f.answer or ""),
                    "is_correct": bool(f.is_correct),
                    "score": score,
                    "max_score": max_score,
                    "source": str(f.source or ""),
                },
            )
            total += score
            max_total += max_score

        # Result Ïä§ÎÉÖÏÉ∑ Í∞±Ïã†
        result.attempt_id = int(attempt_id)
        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()
        result.save(update_fields=["attempt_id", "total_score", "max_score", "submitted_at", "updated_at"])

        return result

    @transaction.atomic
    def post(self, request, exam_id: int):
        exam_id = int(exam_id)

        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if enrollment_id is None or attempt_id is None:
            raise ValidationError({"detail": "enrollment_id and attempt_id are required", "code": "INVALID"})

        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        # -------------------------------------------------
        # 1) Î≤îÏúÑ Ïû†Í∏à + ÎåÄÏÉÅ attempt Í≤ÄÏ¶ù
        # -------------------------------------------------
        attempts_qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        if not attempts_qs.exists():
            raise NotFound({"detail": "attempts not found for this exam/enrollment", "code": "NOT_FOUND"})

        target = attempts_qs.filter(id=attempt_id).first()
        if not target:
            raise NotFound({"detail": "attempt not found for this exam/enrollment", "code": "NOT_FOUND"})

        # -------------------------------------------------
        # 2) LOCKED Ï†ïÏ±Ö
        # -------------------------------------------------
        if (target.status or "").lower() == "grading":
            return Response(
                {"detail": "attempt is grading; cannot switch representative", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 3) ÎåÄÌëú attempt ÍµêÏ≤¥ (DB invariant)
        # -------------------------------------------------
        attempts_qs.filter(is_representative=True).update(is_representative=False)
        if not target.is_representative:
            target.is_representative = True
            target.save(update_fields=["is_representative"])

        # -------------------------------------------------
        # 4) ‚úÖ PHASE 2: Ïä§ÎÉÖÏÉ∑ Ïû¨ÎπåÎìú (Ï†ïÌï©ÏÑ±)
        # -------------------------------------------------
        self._rebuild_result_snapshot_from_attempt(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            attempt_id=attempt_id,
        )

        # -------------------------------------------------
        # 5) ‚úÖ PHASE 2: progress pipeline Ï¶âÏãú Ìä∏Î¶¨Í±∞
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "attempt_id": attempt_id,
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_result_fact_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_result_fact_view.py
"""
Admin ResultFact Debug View

GET /results/admin/facts/?exam_id=&enrollment_id=&limit=100

‚ö†Ô∏è Î™©Ï†Å:
- Ïö¥ÏòÅ/CS/ÎîîÎ≤ÑÍπÖ
- append-only Fact ÏßÅÏ†ë Ï°∞Ìöå
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ResultFact


class AdminResultFactView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        exam_id = request.query_params.get("exam_id")
        enrollment_id = request.query_params.get("enrollment_id")
        limit = int(request.query_params.get("limit", 100))

        qs = ResultFact.objects.all().order_by("-id")

        if exam_id:
            qs = qs.filter(target_type="exam", target_id=int(exam_id))
        if enrollment_id:
            qs = qs.filter(enrollment_id=int(enrollment_id))

        qs = qs[: min(limit, 500)]

        return Response([
            {
                "id": f.id,
                "exam_id": f.target_id,
                "enrollment_id": f.enrollment_id,
                "attempt_id": f.attempt_id,
                "question_id": f.question_id,
                "answer": f.answer,
                "is_correct": f.is_correct,
                "score": f.score,
                "max_score": f.max_score,
                "meta": f.meta,
                "created_at": f.created_at,
            }
            for f in qs
        ])


==========================================================================================
# FILE: views/admin_session_exams_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_session_exams_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.session_exams_summary import SessionExamsSummarySerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminSessionExamsSummaryView(APIView):
    """
    ‚úÖ Session Í∏∞Ï§Ä ÏãúÌóò ÏöîÏïΩ API (1 Session : N Exams)

    GET /results/admin/sessions/{session_id}/exams/summary/

    Îã®Ïùº ÏßÑÏã§ Í∑úÏπô:
    - ÏÑ∏ÏÖò Îã®ÏúÑ pass_rate: SessionProgress.exam_passed Í∏∞Î∞ò (ÏßëÍ≥Ñ Í≤∞Í≥º)
    - ÏÑ∏ÏÖò Îã®ÏúÑ clinic_rate: ClinicLink(is_auto=True) enrollment distinct Í∏∞Î∞ò
    - ÏãúÌóò Îã®ÏúÑ Ï†êÏàò ÌÜµÍ≥Ñ: Result(Îã®, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).select_related("lecture").first()
        if not session:
            return Response(
                SessionExamsSummarySerializer({
                    "session_id": int(session_id),
                    "participant_count": 0,
                    "pass_rate": 0.0,
                    "clinic_rate": 0.0,
                    "strategy": "MAX",
                    "pass_source": "EXAM",
                    "exams": [],
                }).data
            )

        # Ï†ïÏ±Ö(ÌëúÏãúÏö©)
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = str(getattr(policy, "exam_aggregate_strategy", "MAX"))
        pass_source = str(getattr(policy, "exam_pass_source", "EXAM"))

        # ‚úÖ ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú exams (Îã®Ïùº ÏßÑÏã§)
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -----------------------------
        # session-level participant/pass/clinic
        # -----------------------------
        sp_qs = SessionProgress.objects.filter(session=session)
        participant_count = sp_qs.count()

        # ÏÑ∏ÏÖò Îã®ÏúÑ ÏãúÌóò ÌÜµÍ≥ºÏú®(ÏßëÍ≥Ñ Í≤∞Í≥º)
        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # clinic_rate(Îã®Ïùº Í∑úÏπô)
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -----------------------------
        # exam-level stats (Result Í∏∞Î∞ò, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥)
        # -----------------------------
        exam_rows = []
        for ex in exams:
            rs = latest_results_per_enrollment(
                target_type="exam",
                target_id=int(ex.id),
            )

            agg = rs.aggregate(
                participant_count=Count("id"),  # Ïù¥ÎØ∏ enrollment 1Í∞úÏî©ÏúºÎ°ú Ï§ÑÏòÄÏúºÎãà count(id)=participant
                avg_score=Avg("total_score"),
                min_score=Min("total_score"),
                max_score=Max("total_score"),
            )

            pass_score = float(getattr(ex, "pass_score", 0.0) or 0.0)

            pcount = rs.filter(total_score__gte=pass_score).count()
            fcount = rs.filter(total_score__lt=pass_score).count()

            p_total = int(agg["participant_count"] or 0)
            p_rate = (pcount / p_total) if p_total else 0.0

            exam_rows.append({
                "exam_id": int(ex.id),
                "title": str(getattr(ex, "title", "") or ""),
                "pass_score": float(pass_score),

                "participant_count": p_total,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),

                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            })

        payload = {
            "session_id": int(session.id),
            "participant_count": int(participant_count),

            # ‚úÖ ÏùòÎØ∏ Í≥†Ï†ï:
            # pass_rate = SessionProgress.exam_passed Í∏∞Î∞ò (ÏßëÍ≥Ñ Í≤∞Í≥º)
            "pass_rate": round(float(pass_rate), 4),

            # ‚úÖ ÏùòÎØ∏ Í≥†Ï†ï:
            # clinic_rate = ClinicLink(is_auto=True) Í∏∞Ï§Ä
            "clinic_rate": round(float(clinic_rate), 4),

            "strategy": strategy,
            "pass_source": pass_source,
            "exams": exam_rows,

            # (Í∂åÏû•) pass_rate_source Í∞ôÏùÄ Î©îÌÉÄÎ•º serializerÏóê Ï∂îÍ∞ÄÌïòÎ©¥ ÏÇ¨Í≥† Î∞©ÏßÄÏóê ÌÅ∞ ÎèÑÏõÄ
            # "pass_rate_source": "SESSION_PROGRESS",
            # "clinic_rate_source": "CLINIC_LINK_AUTO",
        }

        return Response(SessionExamsSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_session_exams_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_session_exams_view.py
"""
Admin Session ‚Üí Exams Ï°∞Ìöå

GET /results/admin/sessions/{session_id}/exams/

‚úÖ ÌòÑÏû¨ Í≥ÑÏïΩ(Î¶¨Ìå©ÌÜ†ÎßÅ ÏôÑÎ£å):
- Session 1 : Exam N
- canonical relation: exams.Exam.sessions (ManyToManyField to lectures.Session)

ÏùëÎãµÏùÄ Î¶¨Ïä§Ìä∏ ÌòïÌÉúÎ°ú Í≥†Ï†ï:
[
  { exam_id, title, open_at, close_at, allow_retake, max_attempts },
  ...
]
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


class AdminSessionExamsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _get_exams_for_session(session: Session) -> list[Exam]:
        """
        SessionÏóê Ïó∞Í≤∞Îêú Exam Î™©Î°ù Ï°∞Ìöå

        ‚úÖ canonical:
        - session.exams (Exam.sessions related_name="exams")

        Î∞©Ïñ¥Ï†Å fallback:
        - Exam.objects.filter(sessions=session)
        """
        if hasattr(session, "exams"):
            try:
                return list(session.exams.all())
            except Exception:
                pass
        return list(Exam.objects.filter(sessions__id=int(session.id)).distinct())

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return Response([])

        exams = self._get_exams_for_session(session)
        if not exams:
            return Response([])

        return Response([
            {
                "exam_id": int(exam.id),
                "title": getattr(exam, "title", "") or "",
                "open_at": getattr(exam, "open_at", None),
                "close_at": getattr(exam, "close_at", None),
                "allow_retake": bool(getattr(exam, "allow_retake", False)),
                "max_attempts": int(getattr(exam, "max_attempts", 1) or 1),
            }
            for exam in exams
        ])


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

‚ùó ÏπòÎ™ÖÏ†Å Î≥¥Ïïà Ïù¥Ïäà ÏàòÏ†ï:
- Í∏∞Ï°¥: IsAuthenticated Îßå Í±∏Î†§ÏÑú ÌïôÏÉùÎèÑ Ï†ÑÏ≤¥ Attempt Ïó¥Îûå Í∞ÄÎä•
- Î≥ÄÍ≤Ω: Teacher/AdminÎßå Ï†ëÍ∑º Í∞ÄÎä•

ÌïÑÏöîÌïòÎ©¥ Ï∂îÌõÑ:
- ÌïôÏÉù Î≥∏Ïù∏ attemptÎßå Ï°∞ÌöåÌïòÎäî Î≥ÑÎèÑ ViewÎ•º /me/* Î°ú Îî∞Î°ú ÎßåÎì§ Í≤É
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ÏãúÌóò ÏãúÎèÑ(Attempt) Í¥ÄÎ¶¨ API (Í¥ÄÎ¶¨Ïûê/ÍµêÏÇ¨Ïö©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # ‚úÖ Î≥¥Ïïà ÏàòÏ†ï
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/question_stats_views.py
==========================================================================================
# apps/domains/results/views/question_stats_views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.question_stats_service import QuestionStatsService
from apps.domains.results.serializers.question_stats import (
    QuestionStatSerializer,
    TopWrongQuestionSerializer,
)


class AdminExamQuestionStatsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/

    ‚úÖ Îã®Ïùº ÏßÑÏã§:
    - ResultFact Í∏∞Î∞ò (append-only)
    - ÎåÄÌëú attempt ÍµêÏ≤¥/Ïû¨ÏãúÌóò Ïó¨Î∂ÄÏôÄ Î¨¥Í¥ÄÌïòÍ≤å Ìï≠ÏÉÅ ÏùºÍ¥ÄÎêú ÌÜµÍ≥Ñ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        data = QuestionStatsService.per_question_stats(
            exam_id=int(exam_id),
        )
        return Response(QuestionStatSerializer(data, many=True).data)


class ExamQuestionWrongDistributionView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, question_id: int):
        dist = QuestionStatsService.wrong_choice_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
        )
        return Response(
            {
                "question_id": int(question_id),
                "distribution": dist,
            }
        )


class ExamTopWrongQuestionsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=5
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        n = int(request.query_params.get("n", 5))
        data = QuestionStatsService.top_n_wrong_questions(
            exam_id=int(exam_id),
            n=n,
        )
        return Response(TopWrongQuestionSerializer(data, many=True).data)


==========================================================================================
# FILE: views/session_score_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_score_summary_view.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.session_score_summary_service import (
    SessionScoreSummaryService,
)
from apps.domains.results.serializers.session_score_summary import (
    SessionScoreSummarySerializer,
)


class SessionScoreSummaryView(APIView):
    """
    GET /results/admin/sessions/<session_id>/score-summary/

    ‚úÖ results ÎèÑÎ©îÏù∏ Í∏∞Ï§Ä
    - Session Îã®ÏúÑ ÏÑ±Ï†Å ÌÜµÍ≥Ñ
    - Ïö¥ÏòÅ/ÎåÄÏãúÎ≥¥Îìú/AI Ï∂îÏ≤ú ÏûÖÎ†•Ïö©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        data = SessionScoreSummaryService.build(
            session_id=int(session_id)
        )
        return Response(SessionScoreSummarySerializer(data).data)


==========================================================================================
# FILE: views/session_scores_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_scores_view.py
"""
SessionScores API (FOR FRONTEND SCORE TAB)

GET /api/v1/results/admin/sessions/<session_id>/scores/

‚úÖ Î™©Ï†Å
- ÏÑ±Ï†Å ÌÉ≠ Î©îÏù∏ ÌÖåÏù¥Î∏îÏóêÏÑú ÌïôÏÉùÎ≥Ñ ÏãúÌóò/Í≥ºÏ†ú ÏöîÏïΩ + Ìé∏Ïßë ÏÉÅÌÉú ÌëúÏãú
- results + homework_results + progress Îç∞Ïù¥ÌÑ∞Î•º "Ï°∞Ìï©"Îßå ÌïúÎã§.

üö´ Í∏àÏßÄ
- Ï†êÏàò Í≥ÑÏÇ∞/Ï†ïÏ±Ö ÏÉùÏÑ±
- homework percent / cutline Í≥ÑÏÇ∞
- progress Í≤∞Í≥º ÏßÅÏ†ë ÎÖ∏Ï∂ú

‚úÖ Îã®Ïùº ÏßÑÏã§
- exam: results(Result + Exam.pass_score)
- homework: homework_results.HomeworkScore
- clinic_required: progress.ClinicLink(is_auto=True)

üìå Ï§ëÏöî ÏÑ§Í≥Ñ Í≤∞Ï†ï
- enrollment Î™®ÏàòÎäî SessionProgress ‚ùå
- ÏãúÌóò OR Í≥ºÏ†úÏóê Ìïú Î≤àÏù¥ÎùºÎèÑ Ïó∞Í≤∞Îêú Enrollment Í∏∞Ï§Ä ‚úÖ
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Set

from django.utils import timezone
from django.shortcuts import get_object_or_404
from django.db.models import Q  # ‚úÖ Ï§ëÏöî: enrollment OR Ï°∞Í±¥Ïö©

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment
from apps.domains.results.serializers.session_scores import SessionScoreRowSerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink  # SessionProgress ‚ùå Ï†úÍ±∞

# ‚úÖ Îã®Ïùº ÏßÑÏã§
from apps.domains.homework_results.models import HomeworkScore
from apps.domains.enrollment.models import Enrollment

# 1)Î™®Ïàò
from apps.domains.exams.models import ExamEnrollment
from apps.domains.homework.models import HomeworkEnrollment


def _safe_student_name(enrollment: Optional[Enrollment]) -> str:
    """
    Enrollment ‚Üí ÌëúÏãúÏö© ÌïôÏÉùÎ™Ö ÏïàÏ†Ñ Ï∂îÏ∂ú
    (student / user / legacy ÌïÑÎìú ÎåÄÏùë)

    ‚úÖ Î∞©Ïñ¥
    - enrollment None Í∞ÄÎä•
    """
    if not enrollment:
        return "-"

    try:
        if hasattr(enrollment, "student") and enrollment.student:
            s = enrollment.student
            for key in ("name", "full_name", "username"):
                v = getattr(s, key, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        if hasattr(enrollment, "user") and enrollment.user:
            u = enrollment.user
            for key in ("name", "full_name", "username", "first_name"):
                v = getattr(u, key, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        for key in ("student_name", "name", "title"):
            v = getattr(enrollment, key, None)
            if isinstance(v, str) and v.strip():
                return v.strip()
    except Exception:
        pass

    return "-"


class SessionScoresView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = get_object_or_404(Session, id=int(session_id))

        # -------------------------------------------------
        # 0) Session ‚Üî Exam (Îã®Ïùº ÏßÑÏã§)
        # -------------------------------------------------
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -------------------------------------------------
        # 1) enrollment Î™®Ïàò
        #    - ÏãúÌóò OR Í≥ºÏ†úÏóê Ìïú Î≤àÏù¥ÎùºÎèÑ Ïó∞Í≤∞Îêú Enrollment
        # -------------------------------------------------
        hw_enrollment_ids_qs = (
            HomeworkEnrollment.objects.filter(session_id=int(session.id)).values_list(
                "enrollment_id", flat=True
            )
        )

        # ‚úÖ exam_ids ÏóÜÏúºÎ©¥ ExamEnrollment Ï°∞Í±¥ÏùÄ Ïä§ÌÇµ (Î∂àÌïÑÏöîÏøºÎ¶¨ Î∞©ÏßÄ)
        if exam_ids:
            ex_enrollment_ids_qs = (
                ExamEnrollment.objects.filter(exam_id__in=exam_ids).values_list(
                    "enrollment_id", flat=True
                )
            )
            enrollment_qs = Enrollment.objects.filter(
                Q(id__in=hw_enrollment_ids_qs) | Q(id__in=ex_enrollment_ids_qs)
            ).distinct()
        else:
            enrollment_qs = Enrollment.objects.filter(Q(id__in=hw_enrollment_ids_qs)).distinct()

        # Îã®Ïùº enrollment Ï°∞ÌöåÏö© (ÎîîÎ≤ÑÍ∑∏/ÏÇ¨Ïù¥ÎìúÌå®ÎÑê)
        enrollment_id_param = request.query_params.get("enrollment_id")
        if enrollment_id_param:
            try:
                enrollment_qs = enrollment_qs.filter(id=int(enrollment_id_param))
            except Exception:
                pass

        enrollment_ids = list(enrollment_qs.values_list("id", flat=True))

        # -------------------------------------------------
        # 2) Meta (ÌîÑÎ°†Ìä∏ ÌëúÏãúÏö©)
        # -------------------------------------------------
        meta = {
            "exams": [
                {
                    "exam_id": int(ex.id),
                    "title": str(getattr(ex, "title", "")),
                    "pass_score": float(getattr(ex, "pass_score", 0.0) or 0.0),
                }
                for ex in exams
            ],
            "homework": {"title": "Í≥ºÏ†ú", "unit": "%"},
        }

        if not enrollment_ids:
            return Response({"meta": meta, "rows": []})

        # -------------------------------------------------
        # 3) Clinic ÎåÄÏÉÅÏûê (Î≥¥Ï°∞ Ï†ïÎ≥¥)
        # -------------------------------------------------
        clinic_ids: Set[int] = set(
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values_list("enrollment_id", flat=True)
            .distinct()
        )

        # -------------------------------------------------
        # 4) Enrollment ‚Üí student_name
        # -------------------------------------------------
        enrollments = Enrollment.objects.filter(id__in=enrollment_ids)
        enrollment_map = {int(e.id): e for e in enrollments}

        student_name_map = {
            int(eid): _safe_student_name(enrollment_map.get(int(eid)))
            for eid in enrollment_ids
        }

        # -------------------------------------------------
        # 5) HomeworkScore map
        # -------------------------------------------------
        hw_qs = HomeworkScore.objects.filter(
            session=session,
            enrollment_id__in=enrollment_ids,
        )
        hw_map = {int(h.enrollment_id): h for h in hw_qs}

        # -------------------------------------------------
        # 6) Exam Result map (exam_id ‚Üí enrollment_id ‚Üí Result)
        # -------------------------------------------------
        result_map: Dict[int, Dict[int, Result]] = {}
        for exid in exam_ids:
            rs = (
                latest_results_per_enrollment(
                    target_type="exam",
                    target_id=int(exid),
                )
                .filter(enrollment_id__in=enrollment_ids)
            )
            result_map[int(exid)] = {int(r.enrollment_id): r for r in rs}

        # -------------------------------------------------
        # 7) Attempt LOCK ÏÉÅÌÉú
        # -------------------------------------------------
        attempt_ids: Set[int] = set()
        for per_exam in result_map.values():
            for r in per_exam.values():
                if getattr(r, "attempt_id", None):
                    attempt_ids.add(int(r.attempt_id))

        attempt_status_map: Dict[int, str] = {}
        if attempt_ids:
            for a in ExamAttempt.objects.filter(id__in=attempt_ids).only("id", "status"):
                attempt_status_map[int(a.id)] = str(a.status or "")

        # -------------------------------------------------
        # 8) Exam Î©îÌÉÄ map
        # -------------------------------------------------
        exam_pass_score_map = {
            int(ex.id): float(getattr(ex, "pass_score", 0.0) or 0.0)
            for ex in exams
        }
        exam_title_map = {int(ex.id): str(getattr(ex, "title", "") or "") for ex in exams}

        # -------------------------------------------------
        # 9) Row ÏÉùÏÑ± (enrollment Í∏∞Ï§Ä)
        # -------------------------------------------------
        rows: List[Dict[str, Any]] = []

        for eid in enrollment_ids:
            eid_i = int(eid)
            clinic_required = bool(eid_i in clinic_ids)

            exams_payload: List[Dict[str, Any]] = []
            exam_updated_ats: List[Any] = []

            for exid in exam_ids:
                pass_score = exam_pass_score_map.get(int(exid), 0.0)
                r: Optional[Result] = result_map.get(int(exid), {}).get(eid_i)

                if r is None:
                    # ‚ùó ÎØ∏ÏùëÏãú / ÎØ∏ÏÇ∞Ï∂ú ÏÉÅÌÉú
                    exam_score = None
                    exam_max = None
                    exam_passed = None  # ‚úÖ None Ïú†ÏßÄ
                    exam_updated_at = None
                    exam_locked = False
                    exam_lock_reason = None
                else:
                    exam_score = float(getattr(r, "total_score", None) or 0.0)
                    exam_max = float(getattr(r, "max_score", None) or 0.0)

                    # ‚úÖ Ï†ïÏ±Ö Í≥ÑÏÇ∞ Í∏àÏßÄ: passedÎäî Result Îã®Ïùº ÏßÑÏã§ÏùÑ Ïö∞ÏÑ† ÏÇ¨Ïö©
                    # - ÏóÜÏúºÎ©¥ None Ïú†ÏßÄ (ÌîÑÎ°†Ìä∏ÏóêÏÑú "ÎØ∏Ï†ï/ÎπÑÌëúÏãú" Í∞ÄÎä•)
                    exam_passed = getattr(r, "passed", None)
                    if exam_passed is not None:
                        exam_passed = bool(exam_passed)

                    exam_updated_at = getattr(r, "updated_at", None)

                    attempt_status = ""
                    if getattr(r, "attempt_id", None):
                        attempt_status = attempt_status_map.get(int(r.attempt_id), "")

                    exam_locked = bool((attempt_status or "").lower() == "grading")
                    exam_lock_reason = "GRADING" if exam_locked else None

                if exam_updated_at:
                    exam_updated_ats.append(exam_updated_at)

                exams_payload.append(
                    {
                        "exam_id": int(exid),
                        "title": exam_title_map.get(int(exid), ""),
                        "pass_score": float(pass_score),
                        "block": {
                            "score": exam_score,
                            "max_score": exam_max,
                            "passed": exam_passed,  # ‚úÖ None Í∑∏ÎåÄÎ°ú Ï†ÑÎã¨
                            "clinic_required": bool(clinic_required),
                            "is_locked": bool(exam_locked),
                            "lock_reason": exam_lock_reason,
                        },
                    }
                )

            # ---------- homework ----------
            hw: Optional[HomeworkScore] = hw_map.get(eid_i)
            if hw is None:
                hw_score = None
                hw_max = None
                hw_passed = None  # ‚ùó ÎØ∏ÏÇ∞Ï∂ú
                hw_updated_at = None
                hw_locked = False
                hw_lock_reason = None
            else:
                hw_score = hw.score
                hw_max = hw.max_score

                # ‚úÖ homework_results Îã®Ïùº ÏßÑÏã§ (ÏûàÏúºÎ©¥ Í∑∏ÎåÄÎ°ú)
                hw_passed = getattr(hw, "passed", None)
                if hw_passed is not None:
                    hw_passed = bool(hw_passed)

                hw_updated_at = getattr(hw, "updated_at", None)
                hw_locked = bool(getattr(hw, "is_locked", False))
                hw_lock_reason = str(hw.lock_reason) if getattr(hw, "lock_reason", None) else None

            updated_candidates = [
                d
                for d in (
                    (max(exam_updated_ats) if exam_updated_ats else None),
                    hw_updated_at,
                    getattr(session, "updated_at", None),
                )
                if d
            ]
            updated_at = max(updated_candidates) if updated_candidates else timezone.now()

            rows.append(
                {
                    "enrollment_id": eid_i,
                    "student_name": student_name_map.get(eid_i, "-"),
                    "exams": exams_payload,
                    "homework": {
                        "score": hw_score,
                        "max_score": hw_max,
                        "passed": hw_passed,  # ‚úÖ None Ïú†ÏßÄ
                        "clinic_required": bool(clinic_required),
                        "is_locked": bool(hw_locked),
                        "lock_reason": hw_lock_reason,
                    },
                    "updated_at": updated_at,
                }
            )

        return Response(
            {
                "meta": meta,
                "rows": SessionScoreRowSerializer(rows, many=True).data,
            }
        )


==========================================================================================
# FILE: views/student_exam_attempts_view.py
==========================================================================================
# PATH: apps/domains/results/views/student_exam_attempts_view.py
"""
Student Exam Attempt History

GET /results/me/exams/{exam_id}/attempts/

- ÌïôÏÉù Î≥∏Ïù∏ enrollment Í∏∞Ï§Ä
- Ïû¨ÏãúÌóò ÌûàÏä§ÌÜ†Î¶¨ UI Ï†ÑÏö©
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsStudent
from apps.domains.results.models import ExamAttempt
from apps.domains.enrollment.models import Enrollment


class MyExamAttemptsView(APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user

        # enrollment ÌÉêÏÉâ (Î∞©Ïñ¥)
        qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        enrollment = qs.first()
        if not enrollment:
            return Response([])

        attempts = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=int(enrollment.id),
        ).order_by("attempt_index")

        return Response([
            {
                "attempt_id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": a.is_retake,
                "is_representative": a.is_representative,
                "status": a.status,
                "created_at": a.created_at,
            }
            for a in attempts
        ])


==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import StudentExamResultSerializer
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    ‚úÖ Ìè¨Ìï®:
    - Result + items
    - Ïû¨ÏãúÌóò Ï†ïÏ±Ö(allow_retake/max_attempts/can_retake)
    - clinic_required (ClinicLink Í∏∞Ï§Ä Îã®ÏùºÌôî)
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1Ô∏è‚É£ Enrollment Ï∞æÍ∏∞ (ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ ÌïÑÎìú Ï∞®Ïù¥ Î∞©Ïñ¥)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2Ô∏è‚É£ Result Ï°∞Ìöå (Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(target_type="exam", target_id=int(exam_id), enrollment_id=enrollment_id)
            .prefetch_related("items")
            .first()
        )
        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3Ô∏è‚É£ Ïû¨ÏãúÌóò Ï†ïÏ±Ö ÌåêÎã® (attempt Í∏∞Î∞ò)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4Ô∏è‚É£ clinic_required (Îã®Ïùº ÏßÑÏã§: ClinicLink)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(int(exam_id))
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,  # ‚úÖ Ï†ïÏ±Ö ÌÜµÏùº(ÏûêÎèôÎßå)
            )

        # -------------------------------------------------
        # 5Ô∏è‚É£ ÏùëÎãµ Íµ¨ÏÑ±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = bool(clinic_required)

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_status_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_status_view.py
from __future__ import annotations

from django.core.files.storage import default_storage

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, NotFound

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models import WrongNotePDF
from apps.domains.results.serializers.wrong_note_pdf_serializers import (
    WrongNotePDFStatusSerializer,
)


class WrongNotePDFStatusView(APIView):
    """
    STEP 3-2: Ïò§ÎãµÎÖ∏Ìä∏ PDF Job ÏÉÅÌÉú Ï°∞Ìöå (polling)

    GET /results/wrong-notes/pdf/<job_id>/

    üîê Î≥¥Ïïà:
    - ÌïôÏÉù: Î≥∏Ïù∏ enrollment_idÏùò jobÎßå Ï°∞Ìöå Í∞ÄÎä•
    - ÍµêÏÇ¨/Í¥ÄÎ¶¨Ïûê: Ï†ÑÏ≤¥ Ï°∞Ìöå Í∞ÄÎä•
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this PDF job.")

    def get(self, request, job_id: int):
        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        self._assert_enrollment_access(request, int(job.enrollment_id))

        # DONEÏù¥Î©¥ Îã§Ïö¥Î°úÎìú URL Ï†úÍ≥µ (storageÏóê Îî∞Îùº url()Ïù¥ Ïã§Ìå®Ìï† Ïàò ÏûàÏúºÎãà Î∞©Ïñ¥)
        file_url = ""
        if job.file_path:
            try:
                file_url = default_storage.url(job.file_path)
            except Exception:
                file_url = ""

        data = {
            "job_id": int(job.id),
            "status": str(job.status),
            "file_path": str(job.file_path or ""),
            "file_url": str(file_url or ""),
            "error_message": str(job.error_message or ""),
            "created_at": job.created_at,
            "updated_at": job.updated_at,
        }

        return Response(WrongNotePDFStatusSerializer(data).data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_view.py
from __future__ import annotations

from django.urls import reverse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


class WrongNotePDFCreateView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± ÏöîÏ≤≠

    ‚úÖ STEP 3-2.5:
    - ÏùëÎãµÏóê status_url Ìè¨Ìï® (ÌîÑÎ°†Ìä∏ Ìè¥ÎßÅ Ìé∏Ïùò)

    ‚úÖ STEP 2 (Ï§ëÏöî):
    - View ÌååÏùº ÏÉÅÎã®ÏóêÏÑú Celery task import Í∏àÏßÄ
      (URLConf import ÏãúÏ†êÏóê worker ÏùòÏ°¥ÏÑ±ÍπåÏßÄ Î°úÎî©ÎêòÎäî ÏúÑÌóò Î∞©ÏßÄ)
    - Îî∞ÎùºÏÑú post() ÎÇ¥Î∂ÄÏóêÏÑúÎßå ÏßÄÏó∞ import ÌïúÎã§.
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id_i,
            lecture_id=int(lecture_id) if lecture_id else None,
            exam_id=int(exam_id) if exam_id else None,
            from_session_order=int(from_order or 2),
        )

        # --------------------------------------------------
        # ‚úÖ STEP 2: task ÏßÄÏó∞ import (Ï§ëÏöî)
        # - URL import ÏãúÏ†êÏóê worker Ï™Ω ÏùòÏ°¥ÏÑ±ÏùÑ ÎÅåÏñ¥Ïò§ÏßÄ ÏïäÏùå
        # --------------------------------------------------
        from apps.domains.results.tasks.wrong_note_pdf_tasks import (
            generate_wrong_note_pdf_task,
        )

        generate_wrong_note_pdf_task.delay(job.id)

        # ‚úÖ status_url Ï†úÍ≥µ (Ï†àÎåÄÍ≤ΩÎ°ú)
        status_path = reverse("wrong-note-pdf-status", kwargs={"job_id": job.id})
        status_url = request.build_absolute_uri(status_path)

        return Response({
            "job_id": job.id,
            "status": job.status,
            "status_url": status_url,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.serializers.wrong_note_serializers import (
    WrongNoteListResponseSerializer,
)
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


class WrongNoteView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå API

    ‚úÖ STEP 3-3 Í≥†Ï†ï:
    - lecture_id/from_session_order ÌïÑÌÑ∞Îäî Service Îã®Ïùº ÏßÑÏã§
    - ViewÎäî Î≥¥Ïïà + query parsing + serializerÎßå Îã¥Îãπ
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - exam_id (optional)
        - lecture_id (optional)
        - from_session_order (optional, default=2)
        - offset (optional, default=0)
        - limit (optional, default=50)
        """
        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        exam_id = request.query_params.get("exam_id")
        lecture_id = request.query_params.get("lecture_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        offset = int(request.query_params.get("offset", 0))
        limit = int(request.query_params.get("limit", 50))

        q = WrongNoteQuery(
            exam_id=int(exam_id) if exam_id else None,
            lecture_id=int(lecture_id) if lecture_id else None,
            from_session_order=from_order,
            offset=offset,
            limit=limit,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id_i,
            q=q,
        )

        next_offset = (offset + limit) if (offset + limit) < total else None
        prev_offset = (offset - limit) if (offset - limit) >= 0 else None

        payload = {
            "count": int(total),
            "next": next_offset,
            "prev": prev_offset,
            "results": items,
        }

        return Response(WrongNoteListResponseSerializer(payload).data)
