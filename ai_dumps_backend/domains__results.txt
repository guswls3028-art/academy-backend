====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: README.md
==========================================================================================
RESULTS ÎèÑÎ©îÏù∏ Îã®ÏùºÏßÑÏã§(SSOT) Î¥âÏù∏ Î¨∏ÏÑú
üìå Î¨∏ÏÑú Î™©Ï†Å (READ FIRST)

Ïù¥ Î¨∏ÏÑúÎäî results ÎèÑÎ©îÏù∏Ïùò ÏÑ§Í≥Ñ¬∑Ï±ÖÏûÑ¬∑Í≤ΩÍ≥ÑÎ•º ÏòÅÍµ¨Ï†ÅÏúºÎ°ú Í≥†Ï†ïÌïòÍ∏∞ ÏúÑÌïú Î¥âÏù∏ Î¨∏ÏÑúÎã§.

Ïù¥ Î¨∏ÏÑúÍ∞Ä Ï°¥Ïû¨ÌïòÎäî Ìïú:

‚ùå Íµ¨Ï°∞ Ïû¨ÏÑ§Í≥Ñ Í∏àÏßÄ

‚ùå Ï±ÖÏûÑ Ïù¥Îèô Í∏àÏßÄ

‚ùå ‚ÄúÌé∏ÏùòÏÉÅ‚Äù Î°úÏßÅ Ï∂îÍ∞Ä Í∏àÏßÄ

Î™®Îì† Î≥ÄÍ≤ΩÏùÄ Ïù¥ Î¨∏ÏÑúÏôÄ Ï∂©ÎèåÌïòÏßÄ ÏïäÏïÑÏïº ÌïòÎ©∞,
Ï∂©Îèå Ïãú ÏΩîÎìúÍ∞Ä ÏïÑÎãàÎùº Î¨∏ÏÑúÍ∞Ä Ï†ïÎãµÏù¥Îã§.

üéØ ÏµúÏ¢Ö Í≤∞Î°† (Ìïú Ï§Ñ ÏöîÏïΩ)

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò results ÎèÑÎ©îÏù∏ÏùÄ Ïù¥ÎØ∏ ‚ÄúÎåÄÍ∏∞ÏóÖ Ïö¥ÏòÅ Î†àÎ≤®‚ÄùÎ°ú ÏôÑÏÑ±ÎêòÏóàÏúºÎ©∞,
Î¨∏Ï†úÎäî ÏÑ§Í≥ÑÍ∞Ä ÏïÑÎãàÎùº Í≥ºÍ±∞ ÏûîÏ°¥ ÏΩîÎìúÏôÄ ÏßëÍ≥Ñ Ï±ÖÏûÑ ÌòºÏû¨ÏòÄÎã§.
Î≥∏ Î¨∏ÏÑúÎäî Í∑∏ ÌòºÏû¨Î•º ÏòÅÍµ¨Ï†ÅÏúºÎ°ú Ï∞®Îã®ÌïúÎã§.

üß≠ Ï†ÑÏ≤¥ ÎèÑÎ©îÏù∏ Îã®ÏùºÏßÑÏã§ ÏßÄÎèÑ (SSOT MAP)
1Ô∏è‚É£ Identity & Ownership (Ï†àÎåÄ Í≥†Ï†ï)
Student

Ïã§Ï°¥ Ïù∏Î¨º

Î°úÍ∑∏Ïù∏(User)Í≥º ÏÑ†ÌÉùÏ†ÅÏúºÎ°ú Ïó∞Í≤∞

‚ùå Í≤∞Í≥ºÏùò ÏßÅÏ†ë Ï£ºÏ≤¥ ÏïÑÎãò

‚ùå ÏãúÌóò/ÌÜµÍ≥Ñ FK Í∏àÏßÄ

Enrollment ‚≠ê‚≠ê‚≠ê (ÌïµÏã¨)

Î™®Îì† ÌïôÏäµ/ÏãúÌóò/Í≤∞Í≥º/ÌÜµÍ≥ÑÏùò Ïú†ÏùºÌïú Ï£ºÏ≤¥

(student, lecture) Îã®Ïùº

Results FKÎäî Î¨¥Ï°∞Í±¥ enrollment_id

StudentÎäî Ïñ∏Ï†úÎÇò Í∞ÑÏ†ë Ï∞∏Ï°∞Îßå ÌóàÏö©

üëâ ResultsÎäî StudentÎ•º Ï†àÎåÄ ÏßÅÏ†ë Ï∞∏Ï°∞ÌïòÏßÄ ÏïäÎäîÎã§.

2Ô∏è‚É£ Lecture / Session ÎèÑÎ©îÏù∏ (Ïö¥ÏòÅ Îã®ÏúÑ)
Lecture

ÍµêÏú° ÏÉÅÌíà

Ïó¨Îü¨ Session Î≥¥Ïú†

‚ùå ÏãúÌóò/Í≤∞Í≥º Í≥ÑÏÇ∞ Ï±ÖÏûÑ ÏóÜÏùå

Session

Ïö¥ÏòÅ Îã®ÏúÑ (Ï∞®Ïãú)

Lecture FK

ExamÍ≥º N:M

‚ÄúÏù¥ Ï∞®ÏãúÏóê ÏãúÌóòÏù¥ ÏûàÏóàÎäîÍ∞Ä?‚Äù
‚Üí Result / ProgressÎ°ú ÌåêÎã®

üëâ lectures ÎèÑÎ©îÏù∏ÏùÄ Í≤∞Í≥ºÎ•º Í≥ÑÏÇ∞ÌïòÏßÄ ÏïäÎäîÎã§.

3Ô∏è‚É£ Exam ÎèÑÎ©îÏù∏ (Ï∂úÏ†ú Îã®ÏúÑ)

ExamÏùÄ template / regular

ÏãúÌóò Ï†ïÏùò / ÏûêÏÇ∞ / Ï†ïÎãµÏùò SSOT

Session ‚Üî Exam = N:M

‚ùå Í≤∞Í≥º/ÌÜµÍ≥Ñ Ï±ÖÏûÑ ÏóÜÏùå

4Ô∏è‚É£ Submission ‚Üí Results (Í∞ÄÏû• Ï§ëÏöîÌïú Ï∂ï)
Submission

ÎãµÏïàÏùò SSOT

ÏÉÅÌÉú Î®∏Ïã†:

CREATED
  ‚Üí ANSWERS_READY
    ‚Üí GRADING
      ‚Üí DONE

Results ‚≠ê‚≠ê‚≠ê

Îã® ÌïòÎÇòÏùò Í≤∞Í≥º ÏßÑÏã§

Íµ¨ÏÑ± ÏöîÏÜå:

ExamAttempt (ÏãúÎèÑ)

ResultFact (append-only, ÏõêÏãú Î°úÍ∑∏)

ResultItem (Î¨∏Ìï≠ Ïä§ÎÉÖÏÉ∑)

Result (ÎåÄÌëú Í≤∞Í≥º)

Ïû¨ÏãúÌóò / Ïû¨Ï±ÑÏ†ê / ÎåÄÌëú attempt ÍµêÏ≤¥ / ÌÜµÍ≥Ñ
‚Üí Ï†ÑÎ∂Ä Ïù¥ Íµ¨Ï°∞Î°ú Ïª§Î≤Ñ

üëâ ResultsÎäî ÏÇ¨Ïã§Îßå Í∏∞Î°ùÌïúÎã§.
Í≥ÑÏÇ∞¬∑Ìï¥ÏÑù¬∑ÌåêÎã®ÏùÄ ÌïòÏßÄ ÏïäÎäîÎã§.

üß± Aggregation Layer (Ìï¥ÏÑùÏùò Ïú†ÏùºÌïú Ïû•ÏÜå)
apps/domains/results/aggregations/
‚îú‚îÄ session_results.py
‚îú‚îÄ lecture_results.py
‚îî‚îÄ global_results.py

Ïó≠Ìï†

ÏßëÍ≥Ñ / ÌÜµÍ≥Ñ / ÌåêÎã®Ïùò Ïú†ÏùºÌïú Ï±ÖÏûÑ

SQL, aggregation, business rule ÌóàÏö©

View / Model / SerializerÎäî Ï†àÎåÄ Í≥ÑÏÇ∞ Í∏àÏßÄ

ÏõêÏπô

Results = write-only facts

Aggregations = read-only interpretation

üö´ Í∏àÏßÄ ÏÇ¨Ìï≠ (ÏòÅÍµ¨ Î¥âÏù∏)

ÏïÑÎûòÎäî Ïñ¥Îñ§ Ïù¥Ïú†Î°úÎèÑ Í∏àÏßÄÎêúÎã§:

‚ùå ResultÏóê session_id FK Ï∂îÍ∞Ä

‚ùå Session.exam FK Î∂ÄÌôú

‚ùå ResultsÏóêÏÑú Student ÏßÅÏ†ë Ï∞∏Ï°∞

‚ùå View / Serializer / ModelÏóê ÏßëÍ≥Ñ Î°úÏßÅ ÏûëÏÑ±

‚ùå ‚ÄúÌé∏ÏùòÏÉÅ‚Äù Í≥ÑÏÇ∞ Î°úÏßÅ Ï∂îÍ∞Ä

‚ùå Aggregation Î°úÏßÅÏùÑ Îã§Î•∏ ÎèÑÎ©îÏù∏ÏúºÎ°ú Ïù¥Îèô

‚ö†Ô∏è Í≥ºÍ±∞ Î¨∏Ï†úÏùò Ï†ïÏ≤¥ (Ïû¨Î∞ú Î∞©ÏßÄÏö© Í∏∞Î°ù)
Î¨∏Ï†úÎäî Ïù¥Í≤ÉÎøêÏù¥ÏóàÎã§

lectures ÎèÑÎ©îÏù∏Ïóê ÎÇ®ÏïÑ ÏûàÎçò Íµ¨Î≤ÑÏ†Ñ ÏãúÌóò FK ÏÇ¨Í≥†

ResultsÏóê ÏßëÍ≥Ñ Ï±ÖÏûÑÏù¥ ÏÑûÏó¨ ÏûàÎçò ÏÉÅÌÉú

Aggregation Layer Î∂ÄÏû¨

üëâ ÏÑ§Í≥Ñ ÏûêÏ≤¥Îäî Ï≤òÏùåÎ∂ÄÌÑ∞ Ï†ïÎãµÏù¥ÏóàÎã§.

‚úÖ ÌòÑÏû¨ ÏÉÅÌÉú ÏÑ†Ïñ∏ (FINAL)

‚úÖ Results ÎèÑÎ©îÏù∏: ÏôÑÏ†Ñ Í≥†Ï†ï

‚úÖ Aggregation Layer: Îã®ÏùºÏßÑÏã§

‚úÖ Ïö¥ÏòÅ ÏÇ¨Í≥† Í∞ÄÎä•ÏÑ±: Íµ¨Ï°∞Ï†ÅÏúºÎ°ú 0

‚úÖ Î∞±ÏóîÎìú Ïû¨Î∞©Î¨∏ ÌïÑÏöîÏÑ±: ÏóÜÏùå

Ïù¥ÌõÑ Í∞úÎ∞úÏùÄ ÌîÑÎ°†Ìä∏ÏóîÎìú ÏûëÏóÖÎßå ÏßÑÌñâÌïúÎã§.
Î∞±ÏóîÎìú Î≥ÄÍ≤ΩÏù¥ ÌïÑÏöîÌïòÎã§Î©¥, Ïù¥ Î¨∏ÏÑúÎ•º Î®ºÏ†Ä ÏàòÏ†ïÌïòÍ≥†
Í∑∏ Îã§ÏùåÏóê ÏΩîÎìúÎ•º ÏàòÏ†ïÌïúÎã§.

üîí Î¥âÏù∏ ÏÑ†Ïñ∏

Ïù¥ Î¨∏ÏÑú Ïù¥ÌõÑÎ°ú:

‚Äúresults ÎèÑÎ©îÏù∏ÏùÄ Îçî Ïù¥ÏÉÅ Ïã§Ìóò ÎåÄÏÉÅÏù¥ ÏïÑÎãàÎã§.
Ïù¥ÎØ∏ Ïö¥ÏòÅ Í∏∞Ï§ÄÏùÑ ÌÜµÍ≥ºÌïú ‚ÄòÏôÑÏÑ±Ìíà‚ÄôÏù¥Îã§.‚Äù

‚Äî END ‚Äî


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ user.role / user.user_type / groups Îì± Îã§Î•º Ïàò ÏûàÏñ¥ÏÑú Î∞©Ïñ¥Ï†ÅÏúºÎ°ú.
    - ÏûàÏúºÎ©¥ Ïì∞Í≥†
    - ÏóÜÏúºÎ©¥ is_staff/is_superuserÎ°ú ÌåêÎã®
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # ÌîÑÎ°úÏ†ùÌä∏Ïóê Îî∞Îùº "TEACHER" Î¨∏ÏûêÏó¥Ïù¥ Îã§Î•º Ïàò ÏûàÏùå ‚Üí ÌïÑÏöîÏãú Ïó¨Í∏∞Îßå ÏàòÏ†ï
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # Î™ÖÏãúÏ†ÅÏúºÎ°ú teacher/admin ÏïÑÎãàÎ©¥ studentÎ°ú Ï∑®Í∏â(ÏùºÎ∞òÏ†ÅÏù∏ Ï†ïÏ±Ö)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/results/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter

from apps.domains.results.views.student_exam_result_view import MyExamResultView
from apps.domains.results.views.student_exam_attempts_view import MyExamAttemptsView

from apps.domains.results.views.admin_exam_results_view import AdminExamResultsView
from apps.domains.results.views.admin_exam_summary_view import AdminExamSummaryView
from apps.domains.results.views.admin_exam_result_detail_view import AdminExamResultDetailView
from apps.domains.results.views.admin_exam_item_score_view import AdminExamItemScoreView
from apps.domains.results.views.admin_representative_attempt_view import AdminRepresentativeAttemptView
from apps.domains.results.views.admin_exam_attempts_view import AdminExamAttemptsView

from apps.domains.results.views.admin_session_exams_view import AdminSessionExamsView
from apps.domains.results.views.admin_session_exams_summary_view import AdminSessionExamsSummaryView
from apps.domains.results.views.session_score_summary_view import SessionScoreSummaryView
from apps.domains.results.views.session_scores_view import SessionScoresView

from apps.domains.results.views.admin_result_fact_view import AdminResultFactView

from apps.domains.results.views.question_stats_views import (
    AdminExamQuestionStatsView,
    ExamQuestionWrongDistributionView,
    ExamTopWrongQuestionsView,
)

from apps.domains.results.views.wrong_note_view import WrongNoteView
from apps.domains.results.views.wrong_note_pdf_view import WrongNotePDFCreateView
from apps.domains.results.views.wrong_note_pdf_status_view import WrongNotePDFStatusView

from apps.domains.results.views.exam_attempt_view import ExamAttemptViewSet
from apps.domains.results.views.admin_clinic_targets_view import AdminClinicTargetsView

from apps.domains.clinic.views import ParticipantViewSet as AdminClinicBookingViewSet

urlpatterns = [
    path("me/exams/<int:exam_id>/", MyExamResultView.as_view(), name="my-exam-result"),
    path("me/exams/<int:exam_id>/attempts/", MyExamAttemptsView.as_view(), name="my-exam-attempts"),
    path("admin/exams/<int:exam_id>/summary/", AdminExamSummaryView.as_view(), name="admin-exam-summary"),
    path("admin/exams/<int:exam_id>/results/", AdminExamResultsView.as_view(), name="admin-exam-results"),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/",
        AdminExamResultDetailView.as_view(),
        name="admin-exam-result-detail",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/items/<int:question_id>/",
        AdminExamItemScoreView.as_view(),
        name="admin-exam-item-score",
    ),
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/attempts/",
        AdminExamAttemptsView.as_view(),
        name="admin-exam-attempts",
    ),
    path("admin/exams/<int:exam_id>/questions/", AdminExamQuestionStatsView.as_view(), name="admin-exam-question-stats"),
    path(
        "admin/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamQuestionWrongDistributionView.as_view(),
        name="admin-exam-question-wrong-distribution",
    ),
    path(
        "admin/exams/<int:exam_id>/questions/top-wrong/",
        ExamTopWrongQuestionsView.as_view(),
        name="admin-exam-top-wrong-questions",
    ),
    path(
        "admin/sessions/<int:session_id>/score-summary/",
        SessionScoreSummaryView.as_view(),
        name="session-score-summary",
    ),
    path("admin/sessions/<int:session_id>/scores/", SessionScoresView.as_view(), name="admin-session-scores"),
    path("admin/sessions/<int:session_id>/exams/", AdminSessionExamsView.as_view(), name="admin-session-exams"),
    path(
        "admin/sessions/<int:session_id>/exams/summary/",
        AdminSessionExamsSummaryView.as_view(),
        name="admin-session-exams-summary",
    ),
    path("admin/facts/", AdminResultFactView.as_view(), name="admin-result-facts"),
    path("admin/clinic-targets/", AdminClinicTargetsView.as_view(), name="admin-clinic-targets"),
    path("wrong-notes", WrongNoteView.as_view(), name="wrong-note"),
    path("wrong-notes/pdf/", WrongNotePDFCreateView.as_view(), name="wrong-note-pdf-create"),
    path("wrong-notes/pdf/<int:job_id>/", WrongNotePDFStatusView.as_view(), name="wrong-note-pdf-status"),
]

router = DefaultRouter()
router.register("exam-attempts", ExamAttemptViewSet)
router.register("admin/clinic-bookings", AdminClinicBookingViewSet, basename="admin-clinic-bookings")
urlpatterns += router.urls


==========================================================================================
# FILE: z_backend_api_final.md
==========================================================================================
# PATH: docs/contracts/backend_api_final.md
# üìò BACKEND API FINAL (EXAMS ¬∑ SUBMISSIONS ¬∑ RESULTS) ‚Äî Î¥âÏù∏Î≥∏

Í∏∞Ï§Ä
- Django REST Framework
- ÏÉÅÌÉú Î®∏Ïã†: Submission.Status
- Ï±ÑÏ†ê Îã®Ïùº ÏßÑÏã§: grade_submission()
- Í≤∞Í≥º Îã®Ïùº ÏßÑÏã§: results ÎèÑÎ©îÏù∏
- Worker: HTTP polling + callback

---

## 0Ô∏è‚É£ Í≥µÌÜµ Í∑úÏπô (Ï§ëÏöî)

### Submission ÏÉÅÌÉú ÌùêÎ¶Ñ (Í≥†Ï†ï)
SUBMITTED
 ‚Üí DISPATCHED
 ‚Üí EXTRACTING
 ‚Üí ANSWERS_READY
 ‚Üí GRADING
 ‚Üí DONE
 ‚Üí FAILED (retry Í∞ÄÎä•)

### Ï†àÎåÄ Í∑úÏπô
- ‚ùå ÌîÑÎ°†Ìä∏Îäî submissions.answers ÏßÅÏ†ë Ìï¥ÏÑù Í∏àÏßÄ
- ‚úÖ Í≤∞Í≥ºÎäî results APIÎßå Ï°∞Ìöå
- ‚úÖ Ï±ÑÏ†êÏùÄ grade_submission() Îã®Ïùº ÏßÑÏûÖÏ†ê
- ‚úÖ workerÎäî backendÏùò internal endpoint Í≥ÑÏïΩÎßå ÏÇ¨Ïö©

---

## 1Ô∏è‚É£ ÏãúÌóò (Exams)

### 1-1. ÏãúÌóò Î™©Î°ù (ÌïôÏÉù)
GET /student/exams/

### 1-2. ÏãúÌóò ÏÉÅÏÑ∏
GET /student/exams/{exam_id}/

### 1-3. ÏãúÌóòÏßÄ(OMR PDF) ÏÉùÏÑ±
POST /exams/{exam_id}/omr/generate/

Í≤∞Í≥º:
- PDF URL
- sheet_id Ìè¨Ìï®

---

## 2Ô∏è‚É£ Ï†úÏ∂ú (Submissions)

### 2-1. OMR ÏãúÌóò Ï†úÏ∂ú (ÌïµÏã¨ ÏãúÏûëÏ†ê)
POST /submissions/exams/{exam_id}/omr/

Body
{
  "enrollment_id": 123,
  "sheet_id": 45,
  "file_key": "uploads/omr/scan1.jpg"
}

Backend
- Submission ÏÉùÏÑ±
- status = SUBMITTED ‚Üí DISPATCHED
- AI job dispatch

Response
{
  "submission_id": 1001,
  "status": "dispatched"
}

### 2-2. ÏùºÎ∞ò Ï†úÏ∂ú ÏÉùÏÑ± (Î≤îÏö©)
POST /submissions/
(source = online / homework Îì±)

### 2-3. Ï†úÏ∂ú Î™©Î°ù Ï°∞Ìöå
GET /submissions/

### 2-4. Ï†úÏ∂ú ÏÉÅÏÑ∏ Ï°∞Ìöå (polling Ïö©)
GET /submissions/{submission_id}/

Ï§ëÏöî ÌïÑÎìú
- status
- meta.ai_result
- meta.omr / homework Í≤∞Í≥º

### 2-5. Ïã§Ìå® Ï†úÏ∂ú Ïû¨ÏãúÎèÑ
POST /submissions/{submission_id}/retry/

Ï°∞Í±¥
- status == FAILED

### 2-6. OMR ÏàòÎèô ÏàòÏ†ï (ÍµêÏÇ¨Ïö©)
POST /submissions/{submission_id}/manual-edit/

Body
{
  "identifier": "manual",
  "answers": [
    { "exam_question_id": 10, "answer": "B" },
    { "exam_question_id": 11, "answer": "D" }
  ],
  "note": "teacher fix"
}

Ìö®Í≥º
- SubmissionAnswer overwrite
- status ‚Üí ANSWERS_READY
- Ï¶âÏãú Ïû¨Ï±ÑÏ†ê

---

## 3Ô∏è‚É£ AI Í≤∞Í≥º ÏΩúÎ∞± (Worker ‚Üí Backend)

### 3-1. AI Í≤∞Í≥º ÏàòÏã† (ÎÇ¥Î∂Ä)
POST /internal/ai/result/

Body (ÏòàÏãú)
{
  "submission_id": 1001,
  "status": "DONE",
  "result": { ... },
  "error": null
}

Router
- apply_ai_result_for_submission()

Î∂ÑÍ∏∞
- OMR ‚Üí answers Ï†ÄÏû• ‚Üí ANSWERS_READY ‚Üí Ï±ÑÏ†ê ÎåÄÏÉÅ
- Homework video/image ‚Üí meta Ï†ÄÏû• ‚Üí DONE

---

## 4Ô∏è‚É£ Ï±ÑÏ†ê (Results ‚Äì ÎÇ¥Î∂Ä SSOT)

### 4-1. Ï±ÑÏ†ê ÏßÑÏûÖÏ†ê (ÏßÅÏ†ë Ìò∏Ï∂ú ‚ùå / ÎÇ¥Î∂Ä ÏÇ¨Ïö©)
grade_submission(submission_id)

Î≥¥Ïû•
- Idempotent
- Attempt / Result 1Í∞úÎ°ú ÏàòÎ†¥

### 4-2. ÏûêÎèô enqueue (Celery)
enqueue_grading_if_ready(submission)

Ï°∞Í±¥
- status == ANSWERS_READY

---

## 5Ô∏è‚É£ Í≤∞Í≥º Ï°∞Ìöå (Results)

### 5-1. ÌïôÏÉù ÏãúÌóò Í≤∞Í≥º Î™©Î°ù
GET /student/results/exams/

### 5-2. ÌïôÏÉù ÏãúÌóò Í≤∞Í≥º ÏÉÅÏÑ∏
GET /student/results/exams/{exam_id}/

Ìè¨Ìï®
- total_score
- objective / subjective
- breakdown
- pass/fail

### 5-3. ÏãúÌóò ÏãúÎèÑ(Attempt) Ï°∞Ìöå
GET /results/exam-attempts/

### 5-4. ÏãúÌóò Í≤∞Í≥º ÏöîÏïΩ (Í¥ÄÎ¶¨Ïûê)
GET /results/admin/exam-summary/

### 5-5. Î¨∏Ìï≠ ÌÜµÍ≥Ñ
GET /results/question-stats/

---

## 6Ô∏è‚É£ Ïò§ÎãµÎÖ∏Ìä∏ PDF

### 6-1. Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± (ÎπÑÎèôÍ∏∞)
POST /results/wrong-notes/pdf/

### 6-2. Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉÅÌÉú Ï°∞Ìöå (polling)
GET /results/wrong-notes/pdf/{job_id}/

Response
{
  "job_id": 12,
  "status": "DONE",
  "file_url": "https://..."
}

---

## 7Ô∏è‚É£ ÏàôÏ†ú (Homework ‚Äì AI ÌåêÎ≥Ñ)

### 7-1. ÏòÅÏÉÅ ÏàôÏ†ú Ï†úÏ∂ú
POST /submissions/
source: HOMEWORK_VIDEO

### 7-2. ÏòÅÏÉÅ ÏàôÏ†ú AI Í≤∞Í≥º
meta:
{
  "homework_video_result": {
    "has_content": true,
    "filled_ratio": 0.42,
    "too_short": false
  }
}

‚Äª Ï±ÑÏ†ê ‚ùå, DONE Ï≤òÎ¶¨

---

## 8Ô∏è‚É£ ÏÉÅÌÉú Ï°∞Ìöå ÏöîÏïΩ (ÌîÑÎ°†Ìä∏ Polling)

ÌîÑÎ°†Ìä∏Îäî Ïù¥ 3Í∞ÄÏßÄÎßå Î≥¥Î©¥ Îê®
- GET /submissions/{id}/  ‚Üí status ÌôïÏù∏
- status == DONE
- GET /student/results/exams/{exam_id}/

---

## üîí ÏµúÏ¢Ö Î¥âÏù∏ ÏÑ†Ïñ∏
- Ïù¥ Î¨∏ÏÑúÎäî ÌòÑÏû¨ ÏΩîÎìú Í∏∞Ï§Ä ÏµúÏ¢Ö API Í≥ÑÏïΩ(ÏöîÏïΩÎ≥∏)
- Submission / Results / Grading Îã®Ïùº ÏßÑÏã§ ÏùºÏπò
- ÌîÑÎ°†Ìä∏¬∑ÏõåÏª§¬∑Î∞±ÏóîÎìú Î∂ÑÎ¶¨ ÏôÑÏÑ±


==========================================================================================
# FILE: z_results_domain_spec_list.md
==========================================================================================
# PATH: docs/contracts/results_domain_spec_list.md
# üßæ RESULTS ÎèÑÎ©îÏù∏ Ïä§Ìéô ÎÇòÏó¥ (ÏµúÏÜå ÏÑ§Î™Ö)

ÏïÑÎûòÎäî ‚Äúresults ÎèÑÎ©îÏù∏‚ÄùÏù¥ Ï†úÍ≥µÌïòÎäî Ïä§Ìéô(Í∑úÏπô/endpoint/SSOT)ÏùÑ ÏµúÏÜå ÏÑ§Î™ÖÏúºÎ°ú ÎÇòÏó¥ÌïúÎã§.

---

## 1) Îã®Ïùº ÏßÑÏã§(SSOT)

- Í≤∞Í≥º Ïä§ÎÉÖÏÉ∑: Result (+ ResultItem)
- Î≥ÄÍ≤Ω Î°úÍ∑∏: ResultFact (append-only)
- Ïû¨ÏãúÌóò/ÎåÄÌëú: ExamAttempt (ÎåÄÌëú attempt 1Í∞ú invariant)
- clinic_required: progress.ClinicLink(is_auto=True) + resolved_at is null
- ÏãúÌóò-ÏÑ∏ÏÖò Îß§Ìïë SSOT:
  - get_exams_for_session(session)
  - get_sessions_for_exam(exam_id)
  - get_primary_session_for_exam(exam_id)
  - get_session_ids_for_exam(exam_id)

- ÌÜµÍ≥Ñ/ÏßëÍ≥Ñ Ï§ëÎ≥µ Î∞©Ïñ¥ SSOT:
  - latest_results_per_enrollment(target_type, target_id)

---

## 2) Admin/Teacher API

- ÏãúÌóò Í≤∞Í≥º ÌÖåÏù¥Î∏î:
  - GET /api/v1/results/admin/exams/{exam_id}/results/

- ÏãúÌóò ÏöîÏïΩ:
  - GET /api/v1/results/admin/exams/{exam_id}/summary/

- ÏãúÌóò Í≤∞Í≥º ÏÉÅÏÑ∏(Îã®Ïùº ÌïôÏÉù):
  - GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/

- Attempt Î™©Î°ù(Îã®Ïùº ÌïôÏÉù):
  - GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

- ÎåÄÌëú attempt ÍµêÏ≤¥:
  - POST /api/v1/results/admin/exams/{exam_id}/representative-attempt/

- Î¨∏Ìï≠ ÏàòÎèô Ï±ÑÏ†ê(Ï†êÏàò ÏàòÏ†ï):
  - PATCH /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

- Fact ÎîîÎ≤ÑÍ∑∏:
  - GET /api/v1/results/admin/facts/?exam_id=&enrollment_id=&limit=

- ÏÑ∏ÏÖò‚ÜíÏãúÌóò Î™©Î°ù:
  - GET /api/v1/results/admin/sessions/{session_id}/exams/

- ÏÑ∏ÏÖò Í∏∞Ï§Ä ÏãúÌóò ÏöîÏïΩ:
  - GET /api/v1/results/admin/sessions/{session_id}/exams/summary/

- ÏÑ∏ÏÖò Ï†êÏàò ÌÉ≠(ÏãúÌóò+Í≥ºÏ†ú):
  - GET /api/v1/results/admin/sessions/{session_id}/scores/

- ÏÑ∏ÏÖò ÏÑ±Ï†Å ÏöîÏïΩ:
  - GET /api/v1/results/admin/sessions/{session_id}/score-summary/

- ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê:
  - GET /api/v1/results/admin/clinic-targets/

- Î¨∏Ìï≠ ÌÜµÍ≥Ñ:
  - GET /api/v1/results/admin/exams/{exam_id}/questions/
  - GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=
  - GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/

---

## 3) Student API

- ÎåÄÌëú Í≤∞Í≥º:
  - GET /api/v1/results/me/exams/{exam_id}/

- attempt ÌûàÏä§ÌÜ†Î¶¨:
  - GET /api/v1/results/me/exams/{exam_id}/attempts/

- Ïò§ÎãµÎÖ∏Ìä∏:
  - GET /api/v1/results/wrong-notes/?enrollment_id=...

- Ïò§ÎãµÎÖ∏Ìä∏ PDF job ÏÉùÏÑ±/ÏÉÅÌÉú:
  - POST /api/v1/results/wrong-notes/pdf/
  - GET  /api/v1/results/wrong-notes/pdf/{job_id}/

---

## 4) Worker API (WrongNote PDF)

- GET  /api/v1/internal/wrong-note-worker/next/
- GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
- POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
- POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
- POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


==========================================================================================
# FILE: z_zfrontend_api_spec_results.md
==========================================================================================
# PATH: docs/contracts/frontend_api_spec_results.md
# üìó FRONTEND API SPEC (RESULTS Ï§ëÏã¨) ‚Äî Í≥†Ï†ï Í≥ÑÏïΩ

Ïù¥ Î¨∏ÏÑúÎäî ÌîÑÎ°†Ìä∏Í∞Ä ‚ÄúÍ≥ÑÏïΩÎßå Î≥¥Í≥†‚Äù Í∞úÎ∞úÌï† Ïàò ÏûàÎèÑÎ°ù,
results ÎèÑÎ©îÏù∏ Í∏∞Ï§Ä endpoint/ÏùòÎØ∏Îßå Í∞ÑÎã®Ìûà Í≥†Ï†ïÌïúÎã§.

ÏõêÏπô
- ÌîÑÎ°†Ìä∏Îäî ÏÉÅÌÉú + ÎåÄÌëú Í≤∞Í≥ºÎßå Ïã†Î¢∞
- Ï°∞Ìöå APIÎäî Î∂ÄÏàòÌö®Í≥º ÏóÜÏùå
- Í≤∞Í≥º/ÌÜµÍ≥ÑÎäî results SSOTÎßå ÏÇ¨Ïö©
- Clinic ÎåÄÏÉÅÏûê/ÌÜµÍ≥ºÏú®ÏùÄ progress Îã®ÏùºÏßÑÏã§(ClinicLink/SessionProgress)Î°ú Í≥ÑÏÇ∞Îêú Í≤∞Í≥ºÎßå Ï°∞Ìöå

---

## A) ÌïôÏÉù(Student)

### A-1) ÎåÄÌëú Í≤∞Í≥º(ÏãúÌóò)
GET /api/v1/results/me/exams/{exam_id}/
- Î∞òÌôò: Result Ïä§ÎÉÖÏÉ∑ + items
- Ìè¨Ìï®: allow_retake, max_attempts, can_retake
- Ìè¨Ìï®: clinic_required (ClinicLink(is_auto=True) Í∏∞Ï§Ä)

### A-2) Ïû¨ÏãúÌóò ÌûàÏä§ÌÜ†Î¶¨(ÏÑ†ÌÉù)
GET /api/v1/results/me/exams/{exam_id}/attempts/
- Î∞òÌôò: attempt_id, attempt_index, is_retake, is_representative, status, created_at

### A-3) Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå
GET /api/v1/results/wrong-notes/?enrollment_id=&exam_id=&lecture_id=&from_session_order=&offset=&limit=
- Î∞òÌôò: count, next, prev, results[]

### A-4) Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± Job
POST /api/v1/results/wrong-notes/pdf/
Body: { enrollment_id, lecture_id?, exam_id?, from_session_order? }

### A-5) Ïò§ÎãµÎÖ∏Ìä∏ PDF Job ÏÉÅÌÉú
GET /api/v1/results/wrong-notes/pdf/{job_id}/
- Î∞òÌôò: status + file_url(DONE Ïãú)

---

## B) Í¥ÄÎ¶¨Ïûê/ÍµêÏÇ¨(Admin/Teacher)

### B-1) ÏãúÌóò Í≤∞Í≥º ÌÖåÏù¥Î∏î
GET /api/v1/results/admin/exams/{exam_id}/results/

### B-2) ÏãúÌóò ÏöîÏïΩ(ÌèâÍ∑†/ÏµúÏÜå/ÏµúÎåÄ/Ìï©Î∂à/ÌÅ¥Î¶¨Îãâ)
GET /api/v1/results/admin/exams/{exam_id}/summary/

### B-3) ÏãúÌóò Î¨∏Ìï≠ ÌÜµÍ≥Ñ
GET /api/v1/results/admin/exams/{exam_id}/questions/
GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=
GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/

### B-4) Attempt Î™©Î°ù(ÌäπÏ†ï ÏãúÌóò+ÌäπÏ†ï enrollment)
GET /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

### B-5) ÎåÄÌëú Attempt ÍµêÏ≤¥(Ïä§ÎÉÖÏÉ∑ Ïû¨ÎπåÎìú + progress Ìä∏Î¶¨Í±∞)
POST /api/v1/results/admin/exams/{exam_id}/representative-attempt/
Body: { enrollment_id, attempt_id }

### B-6) Î¨∏Ìï≠ Ï†êÏàò ÏàòÎèô ÏàòÏ†ï(append-only Fact + progress Ìä∏Î¶¨Í±∞)
PATCH /api/v1/results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/
Body: { score }

### B-7) ÏÑ∏ÏÖò Í∏∞Ï§Ä ÏãúÌóò ÏöîÏïΩ(1 Session : N Exams)
GET /api/v1/results/admin/sessions/{session_id}/exams/summary/

### B-8) ÏÑ∏ÏÖò ‚Üí Exams Î™©Î°ù
GET /api/v1/results/admin/sessions/{session_id}/exams/

### B-9) ÏÑ∏ÏÖò Ï†êÏàò ÌÉ≠(ÏãúÌóò+Í≥ºÏ†ú Ï°∞Ìï©)
GET /api/v1/results/admin/sessions/{session_id}/scores/

### B-10) ÏÑ∏ÏÖò ÏÑ±Ï†Å ÏöîÏïΩ(ÎåÄÏãúÎ≥¥Îìú ÏûÖÎ†•Ïö©)
GET /api/v1/results/admin/sessions/{session_id}/score-summary/

### B-11) ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê(Í¥ÄÎ¶¨Ïûê Ìå®ÎÑê)
GET /api/v1/results/admin/clinic-targets/

---

## C) ÎÇ¥Î∂Ä Worker (WrongNote PDF)

Bearer token Ïù∏Ï¶ù ÌïÑÏöî

- GET  /api/v1/internal/wrong-note-worker/next/
- GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
- POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
- POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
- POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


==========================================================================================
# FILE: aggregations/__init__.py
==========================================================================================
# PATH: apps/domains/results/aggregations/__init__.py
from .session_results import (
    build_session_results_snapshot,
    build_session_scores_matrix_snapshot,
)
from .lecture_results import (
    build_lecture_results_snapshot,
)
from .global_results import (
    build_global_results_snapshot,
)

__all__ = [
    "build_session_results_snapshot",
    "build_session_scores_matrix_snapshot",
    "build_lecture_results_snapshot",
    "build_global_results_snapshot",
]


==========================================================================================
# FILE: aggregations/global_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/global_results.py
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, Optional

from django.db.models import Count
from django.utils import timezone

from apps.domains.lectures.models import Lecture, Session
from apps.domains.progress.models import SessionProgress, ClinicLink

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_dt(v: Any) -> Optional[datetime]:
    if v is None:
        return None
    if isinstance(v, datetime):
        return v
    try:
        # "2026-02-02T00:00:00Z" Îì± ISO ÏûÖÎ†• Î∞©Ïñ¥
        return datetime.fromisoformat(str(v).replace("Z", "+00:00"))
    except Exception:
        return None


def build_global_results_snapshot(
    *,
    lecture_id: Optional[int] = None,
    from_dt: Optional[Any] = None,
    to_dt: Optional[Any] = None,
) -> Dict[str, Any]:
    """
    ‚úÖ Ïö¥ÏòÅÏö© Í∏ÄÎ°úÎ≤å ÏöîÏïΩ (ÎåÄÏãúÎ≥¥Îìú/Í¥ÄÎ¶¨Ïûê Ìôà ÏûÖÎ†•)

    Îã®Ïùº ÏßÑÏã§:
    - participant_count: SessionProgress row count
    - clinic_count: ClinicLink(is_auto=True) enrollment distinct (ÏÑ∏ÏÖò Ìï©Í≥Ñ)
    - exam_result_count: Result (enrollment Ï§ëÎ≥µ Î∞©Ïñ¥ latest_results_per_enrollment) Ìï©Í≥Ñ
      (Ïó¨Í∏∞ÏÑúÎäî "ÏãúÌóò Ïàò * Ï∞∏Í∞ÄÏûê Ïàò" ÏÑ±Í≤©Ïù¥ÎØÄÎ°ú Îã®ÏàúÌïú 'Í±¥Ïàò'Î°úÎßå Ï†úÍ≥µ)

    Î∞òÌôò(Í≥†Ï†ï):
    {
      "scope": {"lecture_id": int|null, "from": iso|null, "to": iso|null},
      "session_count": int,
      "participant_count": int,
      "clinic_enrollment_distinct_count": int,
      "exam_latest_result_count": int,
      "generated_at": "iso"
    }
    """
    l_id = _safe_int(lecture_id) if lecture_id is not None else None
    fdt = _safe_dt(from_dt)
    tdt = _safe_dt(to_dt)

    sessions = Session.objects.all()

    if l_id:
        sessions = sessions.filter(lecture_id=int(l_id))

    # ÏãúÍ∞Ñ Î≤îÏúÑÎäî session.open_at/close_at Í∞ôÏùÄ ÌïÑÎìúÍ∞Ä ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ Îã§Î•º Ïàò ÏûàÏñ¥
    # Ïó¨Í∏∞ÏÑúÎäî "id Í∏∞Î∞ò Ï†ÑÏ≤¥"Î•º Í∏∞Î≥∏ÏúºÎ°ú ÌïòÎêò, created_at/updated_atÏù¥ ÏûàÏúºÎ©¥ Ï†úÌïúÌïúÎã§.
    if fdt or tdt:
        # best-effort: updated_at ‚Üí created_at ÏàúÏúºÎ°ú ÏãúÎèÑ
        if hasattr(Session, "updated_at"):
            if fdt:
                sessions = sessions.filter(updated_at__gte=fdt)
            if tdt:
                sessions = sessions.filter(updated_at__lt=tdt)
        elif hasattr(Session, "created_at"):
            if fdt:
                sessions = sessions.filter(created_at__gte=fdt)
            if tdt:
                sessions = sessions.filter(created_at__lt=tdt)

    session_ids = list(sessions.values_list("id", flat=True))
    session_count = len(session_ids)

    if not session_ids:
        return {
            "scope": {
                "lecture_id": l_id,
                "from": fdt.isoformat() if fdt else None,
                "to": tdt.isoformat() if tdt else None,
            },
            "session_count": 0,
            "participant_count": 0,
            "clinic_enrollment_distinct_count": 0,
            "exam_latest_result_count": 0,
            "generated_at": timezone.now().isoformat(),
        }

    participant_count = SessionProgress.objects.filter(session_id__in=session_ids).count()

    # clinic enrollment distinct (ÏÑ∏ÏÖò Ìï©Í≥Ñ Í∏∞Ï§Ä)
    clinic_enrollment_distinct_count = (
        ClinicLink.objects.filter(session_id__in=session_ids, is_auto=True)
        .values("enrollment_id")
        .distinct()
        .count()
    )

    # exam ÏµúÏã† Result count (ÏãúÌóò Í±¥Ïàò ÏÑ±Í≤©)
    exam_latest_result_count = 0
    try:
        # Session -> Exams Ïä§Ï∫î
        # (ÎßéÏùÄ ÏÑ∏ÏÖòÏóêÏÑú N+1Ïù¥ Îê† Ïàò ÏûàÏúºÎÇò Í∏ÄÎ°úÎ≤å ÏöîÏïΩÏùÄ Ïö¥ÏòÅÏóêÏÑú Ìò∏Ï∂ú ÎπàÎèÑ ÎÇÆÎã§Í≥† Í∞ÄÏ†ï)
        exam_ids = set()
        for sid in session_ids:
            s = Session.objects.filter(id=int(sid)).first()
            if not s:
                continue
            for ex in get_exams_for_session(s):
                exid = getattr(ex, "id", None)
                if exid:
                    exam_ids.add(int(exid))

        for exid in exam_ids:
            rs = latest_results_per_enrollment(target_type="exam", target_id=int(exid))
            exam_latest_result_count += rs.count()
    except Exception:
        exam_latest_result_count = 0

    return {
        "scope": {
            "lecture_id": l_id,
            "from": fdt.isoformat() if fdt else None,
            "to": tdt.isoformat() if tdt else None,
        },
        "session_count": int(session_count),
        "participant_count": int(participant_count),
        "clinic_enrollment_distinct_count": int(clinic_enrollment_distinct_count),
        "exam_latest_result_count": int(exam_latest_result_count),
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: aggregations/lecture_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/lecture_results.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

from django.db.models import Avg, Min, Max, Count
from django.utils import timezone

from apps.domains.lectures.models import Lecture, Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _safe_str(v: Any) -> str:
    try:
        return str(v or "")
    except Exception:
        return ""


def _policy_meta_for_lecture(lecture: Lecture) -> Dict[str, str]:
    try:
        policy = ProgressPolicy.objects.filter(lecture=lecture).first()
        strategy = _safe_str(getattr(policy, "exam_aggregate_strategy", "MAX") or "MAX")
        pass_source = _safe_str(getattr(policy, "exam_pass_source", "EXAM") or "EXAM")
        return {
            "strategy": strategy,
            "pass_source": pass_source,
        }
    except Exception:
        return {
            "strategy": "MAX",
            "pass_source": "EXAM",
        }


def build_lecture_results_snapshot(
    *,
    lecture_id: int,
    include_exam_level_stats: bool = False,
) -> Dict[str, Any]:
    """
    ‚úÖ Lecture Îã®ÏúÑ Ïä§ÎÉÖÏÉ∑ (ÏÑ∏ÏÖò ÏßëÍ≥Ñ Í∏∞Î∞ò)

    Îã®Ïùº ÏßÑÏã§:
    - ÏÑ∏ÏÖòÎ≥Ñ pass_rate: SessionProgress.exam_passed Í∏∞Ï§Ä
    - ÏÑ∏ÏÖòÎ≥Ñ clinic_rate: ClinicLink(is_auto=True) Í∏∞Ï§Ä
    - (ÏòµÏÖò) ÏãúÌóò Îã®ÏúÑ ÌÜµÍ≥ÑÎäî Result Í∏∞Î∞ò + latest_results_per_enrollment

    Î∞òÌôò Ïä§ÌÇ§Îßà(Í≥†Ï†ï):
    {
      "lecture_id": int,
      "strategy": str,
      "pass_source": str,
      "session_count": int,
      "sessions": [
        {
          "session_id": int,
          "order": int|None,
          "participant_count": int,
          "pass_rate": float,
          "clinic_rate": float,
          "exams": [ ... ] | []
        }
      ],
      "generated_at": "iso"
    }
    """
    lecture = Lecture.objects.filter(id=_safe_int(lecture_id)).first()
    if not lecture:
        return {
            "lecture_id": _safe_int(lecture_id),
            "strategy": "MAX",
            "pass_source": "EXAM",
            "session_count": 0,
            "sessions": [],
            "generated_at": timezone.now().isoformat(),
        }

    meta = _policy_meta_for_lecture(lecture)

    sessions_qs = Session.objects.filter(lecture=lecture).order_by("id")
    if hasattr(Session, "order"):
        try:
            sessions_qs = sessions_qs.order_by("order", "id")
        except Exception:
            sessions_qs = sessions_qs.order_by("id")

    rows: List[Dict[str, Any]] = []
    for s in sessions_qs:
        sp_qs = SessionProgress.objects.filter(session=s)
        participant_count = sp_qs.count()

        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        clinic_count = (
            ClinicLink.objects.filter(session=s, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        ex_rows: List[Dict[str, Any]] = []
        if include_exam_level_stats:
            exams = list(get_exams_for_session(s))
            for ex in exams:
                exid = _safe_int(getattr(ex, "id", 0))
                if not exid:
                    continue

                rs = latest_results_per_enrollment(target_type="exam", target_id=exid)

                agg = rs.aggregate(
                    participant_count=Count("id"),
                    avg_score=Avg("total_score"),
                    min_score=Min("total_score"),
                    max_score=Max("total_score"),
                )

                pass_score = _safe_float(getattr(ex, "pass_score", 0.0) or 0.0)
                pcount = rs.filter(total_score__gte=pass_score).count()
                fcount = rs.filter(total_score__lt=pass_score).count()

                p_total = _safe_int(agg["participant_count"] or 0)
                p_rate = (pcount / p_total) if p_total else 0.0

                ex_rows.append(
                    {
                        "exam_id": exid,
                        "title": _safe_str(getattr(ex, "title", "")),
                        "pass_score": float(pass_score),
                        "participant_count": int(p_total),
                        "avg_score": float(agg["avg_score"] or 0.0),
                        "min_score": float(agg["min_score"] or 0.0),
                        "max_score": float(agg["max_score"] or 0.0),
                        "pass_count": int(pcount),
                        "fail_count": int(fcount),
                        "pass_rate": round(float(p_rate), 4),
                    }
                )

        rows.append(
            {
                "session_id": int(s.id),
                "order": _safe_int(getattr(s, "order", None), 0) if getattr(s, "order", None) is not None else None,
                "participant_count": int(participant_count),
                "pass_rate": round(float(pass_rate), 4),
                "clinic_rate": round(float(clinic_rate), 4),
                "exams": ex_rows,
            }
        )

    return {
        "lecture_id": int(lecture.id),
        "strategy": str(meta["strategy"]),
        "pass_source": str(meta["pass_source"]),
        "session_count": int(sessions_qs.count()),
        "sessions": rows,
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: aggregations/session_results.py
==========================================================================================
# PATH: apps/domains/results/aggregations/session_results.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Avg, Min, Max, Count
from django.utils import timezone

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


@dataclass(frozen=True)
class SessionExamStatRow:
    exam_id: int
    title: str
    pass_score: float

    participant_count: int
    avg_score: float
    min_score: float
    max_score: float

    pass_count: int
    fail_count: int
    pass_rate: float


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _safe_int(v: Any, default: int = 0) -> int:
    try:
        return int(v)
    except Exception:
        return int(default)


def _safe_str(v: Any) -> str:
    try:
        return str(v or "")
    except Exception:
        return ""


def _policy_meta_for_session(session: Session) -> Dict[str, str]:
    """
    ProgressPolicyÎäî progress ÎèÑÎ©îÏù∏Ïùò Îã®Ïùº ÏßÑÏã§.
    Îã®, results ÏßëÍ≥ÑÎäî "ÌëúÏãúÏö© Î©îÌÉÄ"Îßå Í∞ÄÏ†∏Ïò®Îã§.
    """
    try:
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = _safe_str(getattr(policy, "exam_aggregate_strategy", "MAX") or "MAX")
        pass_source = _safe_str(getattr(policy, "exam_pass_source", "EXAM") or "EXAM")
        return {
            "strategy": strategy,
            "pass_source": pass_source,
        }
    except Exception:
        return {
            "strategy": "MAX",
            "pass_source": "EXAM",
        }


def build_session_results_snapshot(*, session_id: int) -> Dict[str, Any]:
    """
    ‚úÖ Session Îã®ÏúÑ ÏãúÌóò ÏöîÏïΩ Ïä§ÎÉÖÏÉ∑ (ÏßëÍ≥Ñ)

    - participant_count: SessionProgress Í∏∞Ï§Ä
    - pass_rate: SessionProgress.exam_passed Í∏∞Ï§Ä (ÏÑ∏ÏÖò ÏßëÍ≥Ñ Îã®Ïùº ÏßÑÏã§)
    - clinic_rate: ClinicLink(is_auto=True) enrollment distinct Í∏∞Ï§Ä (Îã®Ïùº ÏßÑÏã§)
    - exams[]: ÏãúÌóò Îã®ÏúÑ ÌÜµÍ≥ÑÎäî Result Í∏∞Î∞ò (Îã®, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥ latest_results_per_enrollment)

    Î∞òÌôò Ïä§ÌÇ§Îßà(Í≥†Ï†ï):
    {
      "session_id": int,
      "participant_count": int,
      "pass_rate": float,
      "clinic_rate": float,
      "strategy": str,
      "pass_source": str,
      "exams": [ ... ],
      "generated_at": "iso"
    }
    """
    session = Session.objects.filter(id=_safe_int(session_id)).select_related("lecture").first()
    if not session:
        return {
            "session_id": _safe_int(session_id),
            "participant_count": 0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "strategy": "MAX",
            "pass_source": "EXAM",
            "exams": [],
            "generated_at": timezone.now().isoformat(),
        }

    # Ï†ïÏ±Ö Î©îÌÉÄ (ÌëúÏãúÏö©)
    meta = _policy_meta_for_session(session)
    strategy = meta["strategy"]
    pass_source = meta["pass_source"]

    # ÏÑ∏ÏÖò Î™®Ïàò/ÌÜµÍ≥ºÏú®(ÏßëÍ≥Ñ Îã®Ïùº ÏßÑÏã§)
    sp_qs = SessionProgress.objects.filter(session=session)
    participant_count = sp_qs.count()

    pass_count = sp_qs.filter(exam_passed=True).count()
    pass_rate = (pass_count / participant_count) if participant_count else 0.0

    # clinic_rate(Îã®Ïùº ÏßÑÏã§)
    clinic_count = (
        ClinicLink.objects.filter(session=session, is_auto=True)
        .values("enrollment_id")
        .distinct()
        .count()
    )
    clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

    # ÏãúÌóò Îã®ÏúÑ ÌÜµÍ≥Ñ (Result Í∏∞Î∞ò, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥)
    exams = list(get_exams_for_session(session))
    exam_rows: List[Dict[str, Any]] = []

    for ex in exams:
        exid = _safe_int(getattr(ex, "id", 0))
        if not exid:
            continue

        rs = latest_results_per_enrollment(
            target_type="exam",
            target_id=exid,
        )

        agg = rs.aggregate(
            participant_count=Count("id"),  # enrollment 1Í∞úÏî©ÏúºÎ°ú Ï§ÑÏòÄÏúºÎãà count(id)=participant
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_score = _safe_float(getattr(ex, "pass_score", 0.0) or 0.0)
        pcount = rs.filter(total_score__gte=pass_score).count()
        fcount = rs.filter(total_score__lt=pass_score).count()

        p_total = _safe_int(agg["participant_count"] or 0)
        p_rate = (pcount / p_total) if p_total else 0.0

        exam_rows.append(
            {
                "exam_id": exid,
                "title": _safe_str(getattr(ex, "title", "")),
                "pass_score": float(pass_score),
                "participant_count": int(p_total),
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),
                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            }
        )

    return {
        "session_id": int(session.id),
        "participant_count": int(participant_count),
        "pass_rate": round(float(pass_rate), 4),
        "clinic_rate": round(float(clinic_rate), 4),
        "strategy": str(strategy),
        "pass_source": str(pass_source),
        "exams": exam_rows,
        "generated_at": timezone.now().isoformat(),
    }


def build_session_scores_matrix_snapshot(*, session_id: int) -> Dict[str, Any]:
    """
    ‚úÖ Session ÏÑ±Ï†Å ÌÉ≠Ïö© "ÌñâÎ†¨ Ïä§ÎÉÖÏÉ∑"

    Ï£ºÏùò:
    - Ïù¥ Ìï®ÏàòÎäî SessionScoresViewÏùò 'ÏßëÍ≥Ñ Î°úÏßÅ'ÏùÑ Ïû¨ÏÇ¨Ïö©ÌïòÍ≥† Ïã∂ÏùÑ Îïå Ïì∞Îäî Î™©Ï†Å.
    - results ÎèÑÎ©îÏù∏ÏóêÏÑú "ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞/Ï†ïÏ±Ö"ÏùÑ ÎßåÎì§ÏßÄ ÏïäÎäîÎã§.
    - Ïó¨Í∏∞ÏÑúÎäî ViewÎ•º importÌï¥ÏÑú Ìò∏Ï∂úÌïòÏßÄ ÏïäÍ≥†, ÌïÑÏöîÌïú ÏµúÏÜå Ï°∞Ìï©Îßå Ï†úÍ≥µÌïúÎã§.

    Î∞òÌôò(Í≥†Ï†ï):
    {
      "session_id": int,
      "exam_ids": [...],
      "participant_count": int,
      "generated_at": "iso"
    }

    (Ïã§Ï†ú ÌÖåÏù¥Î∏î rowsÎäî SessionScoresViewÍ∞Ä Ïù¥ÎØ∏ Ï†úÍ≥µÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Î©îÌÉÄÎßå Ï†úÍ≥µ)
    """
    session = Session.objects.filter(id=_safe_int(session_id)).select_related("lecture").first()
    if not session:
        return {
            "session_id": _safe_int(session_id),
            "exam_ids": [],
            "participant_count": 0,
            "generated_at": timezone.now().isoformat(),
        }

    exams = list(get_exams_for_session(session))
    exam_ids = [int(getattr(e, "id", 0) or 0) for e in exams if int(getattr(e, "id", 0) or 0)]

    participant_count = SessionProgress.objects.filter(session=session).count()

    return {
        "session_id": int(session.id),
        "exam_ids": exam_ids,
        "participant_count": int(participant_count),
        "generated_at": timezone.now().isoformat(),
    }


==========================================================================================
# FILE: guards/grading_contract.py
==========================================================================================
# PATH: apps/domains/results/guards/grading_contract.py
from __future__ import annotations

from typing import Dict

from django.core.exceptions import ValidationError

from apps.domains.exams.models import Exam
from apps.domains.exams.models.sheet import Sheet
from apps.domains.exams.models.answer_key import AnswerKey


class GradingContractGuard:
    """
    Boundary guard for grading.

    Î™©Ï†Å:
    - Ï±ÑÏ†ê Î°úÏßÅ Ïù¥Ï†ÑÏóê SSOT Ï†ïÌï©ÏÑ± Í≤ÄÏ¶ù
    - Îü∞ÌÉÄÏûÑ import ÏóêÎü¨ / Ï°∞Ïö©Ìïú Ïò§Îãµ ÏÉùÏÑ± Î∞©ÏßÄ
    - ÏõåÏª§/ÎèôÍ∏∞ Ìò∏Ï∂ú Í≥µÌÜµ Î≥¥Ìò∏Îßâ
    """

    @staticmethod
    def validate_exam_for_grading(exam: Exam) -> tuple[Sheet, AnswerKey]:
        # REGULAR examÎßå Ï±ÑÏ†ê Í∞ÄÎä•
        if exam.exam_type != Exam.ExamType.REGULAR:
            raise ValidationError("only REGULAR exams are gradable")

        if not exam.template_exam_id:
            raise ValidationError("regular exam must have template_exam")

        template_exam = exam.template_exam

        # Sheet Í≤ÄÏ¶ù
        sheet = getattr(template_exam, "sheet", None)
        if not isinstance(sheet, Sheet):
            raise ValidationError("template exam must have a valid sheet")

        # AnswerKey Í≤ÄÏ¶ù
        answer_key = getattr(template_exam, "answer_key", None)
        if not isinstance(answer_key, AnswerKey):
            raise ValidationError("template exam must have an answer_key")

        if not isinstance(answer_key.answers, dict):
            raise ValidationError("answer_key.answers must be a dict")

        # Question‚ÄìAnswerKey Ï†ïÌï©ÏÑ± (Ï°¥Ïû¨ Ïó¨Î∂ÄÎßå)
        question_ids = {int(q.id) for q in sheet.questions.all()}
        key_ids = {
            int(k)
            for k in answer_key.answers.keys()
            if isinstance(k, (int, str)) and str(k).isdigit()
        }

        if not key_ids.issubset(question_ids):
            raise ValidationError("answer_key contains unknown question ids")

        return sheet, answer_key


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="Ïù¥ FactÎ•º ÏÉùÏÑ±Ìïú ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="Ïù¥ attemptÎ•º Î∞úÏÉùÏãúÌÇ® submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1Î∂ÄÌÑ∞ ÏãúÏûë")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="Ïù¥ ResultÍ∞Ä Ï∞∏Ï°∞ÌïòÎäî ÎåÄÌëú ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_add_exam_attempt_meta.py
==========================================================================================
# apps/domains/results/migrations/0002_add_exam_attempt_meta.py
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("results", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="examattempt",
            name="meta",
            field=models.JSONField(
                null=True,
                blank=True,
                help_text=(
                    "Attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞. "
                    "OMR/AI ÌåêÎèÖ Ï†ïÎ≥¥, total_score, pass_score, "
                    "Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞ Îì± Ïö¥ÏòÅ/Î∂ÑÏÑùÏö© Ï†ïÎ≥¥ Ï†ÄÏû•."
                ),
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0003_examresult.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-01 15:34

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("exams", "0006_alter_sheet_unique_together_exam_template_exam_and_more"),
        ("results", "0002_add_exam_attempt_meta"),
        ("submissions", "0002_alter_submissionanswer_exam_question_id_and_more"),
    ]

    operations = [
        migrations.CreateModel(
            name="ExamResult",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("max_score", models.FloatField(default=0.0)),
                ("total_score", models.FloatField(default=0.0)),
                ("objective_score", models.FloatField(default=0.0)),
                ("subjective_score", models.FloatField(default=0.0)),
                (
                    "status",
                    models.CharField(
                        choices=[("DRAFT", "Draft"), ("FINAL", "Final")],
                        default="DRAFT",
                        max_length=10,
                    ),
                ),
                ("finalized_at", models.DateTimeField(blank=True, null=True)),
                ("breakdown", models.JSONField(blank=True, default=dict)),
                ("manual_overrides", models.JSONField(blank=True, default=dict)),
                ("is_passed", models.BooleanField(default=False)),
                (
                    "exam",
                    models.ForeignKey(
                        help_text="regular exam",
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="results",
                        to="exams.exam",
                    ),
                ),
                (
                    "submission",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="exam_result",
                        to="submissions.submission",
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_result",
                "indexes": [
                    models.Index(
                        fields=["exam", "total_score"], name="results_exam_score_idx"
                    ),
                    models.Index(
                        fields=["exam", "status", "created_at"],
                        name="results_exam_status_crted_idx",
                    ),
                ],
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF
from .exam_result import ExamResult

# ‚ùå SubmissionAnswer Ï†úÍ±∞Îê® (raw inputÏùÄ submissions ÎèÑÎ©îÏù∏ Ï±ÖÏûÑ)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
    "ExamResult",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
# apps/domains/results/models/exam_attempt.py
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    ÌïôÏÉùÏùò 'ÏãúÌóò 1Ìöå ÏùëÏãú'Î•º ÎÇòÌÉÄÎÇ¥Îäî ÏóîÌã∞Ìã∞ (append-only)

    üî• ÌïµÏã¨ Ï±ÖÏûÑ
    - Submission Îã®ÏúÑÍ∞Ä ÏïÑÎãå 'ÏãúÌóò ÏùëÏãú ÏÇ¨Ïã§'Ïùò Í≥†Ï†ï
    - Result / ResultFact / Progress ÏßëÍ≥ÑÏùò Í∏∞Ï§ÄÏ†ê
    - Ïû¨ÏãúÌóò/ÎåÄÌëú attempt ÍµêÏ≤¥Ïùò Îã®ÏúÑ

    ‚úÖ ÏÑ§Í≥Ñ Í≥†Ï†ï ÏÇ¨Ìï≠
    --------------------------------------------------
    1) ExamAttemptÎäî append-only Í∞úÎÖêÏù¥Îã§.
       - Í∏∞Ï°¥ attemptÎ•º ÏàòÏ†ïÌïòÏßÄ ÏïäÎäîÎã§.
       - ÎåÄÌëú attempt Î≥ÄÍ≤ΩÏùÄ is_representative ÌîåÎûòÍ∑∏Î°úÎßå Ï≤òÎ¶¨ÌïúÎã§.

    2) Result / ResultItemÏùÄ Ìï≠ÏÉÅ
       "ÎåÄÌëú attempt(is_representative=True)"Î•º Í∞ÄÎ¶¨ÌÇ§Îäî snapshotÏù¥Îã§.

    3) meta ÌïÑÎìúÎäî attempt Îã®ÏúÑÏùò 'Ïö¥ÏòÅ/Î∂ÑÏÑù/Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞'Î•º Ï†ÄÏû•ÌïúÎã§.
       - OMR Ïã†Î¢∞ÎèÑ
       - AI ÌåêÎèÖ Í≤∞Í≥º
       - total_score / pass_score Ïä§ÎÉÖÏÉ∑
       - Ïû¨Ï±ÑÏ†ê ÏÇ¨Ïú† Îì±
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # SubmissionÏùÄ ÏãúÎèÑÏùò ÏõêÏù∏(event)
    submission_id = models.PositiveIntegerField(
        help_text="Ïù¥ attemptÎ•º Î∞úÏÉùÏãúÌÇ® submission"
    )

    # 1Î∂ÄÌÑ∞ ÏãúÏûë (ÏãúÌóò nÎ≤àÏß∏ ÏùëÏãú)
    attempt_index = models.PositiveIntegerField(help_text="1Î∂ÄÌÑ∞ ÏãúÏûë")

    # Ïû¨ÏãúÌóò Ïó¨Î∂Ä (attempt_index > 1 Í≥º ÏùòÎØ∏Ï†ÅÏúºÎ°ú ÎèôÏùºÌïòÏßÄÎßå, Ï°∞Ìöå ÏµúÏ†ÅÌôîÏö©)
    is_retake = models.BooleanField(default=False)

    # ÏÑúÎ≤ÑÍ∞Ä ÌåêÎã®ÌïòÎäî ÎåÄÌëú attempt
    # ResultÎäî Ìï≠ÏÉÅ Ïù¥ attemptÎ•º Í∏∞Ï§ÄÏúºÎ°ú snapshotÏùÑ ÎßåÎì†Îã§.
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ÏÉùÏÑ±Îê®
            ("grading", "Grading"),     # Ï±ÑÏ†ê Ï§ë
            ("done", "Done"),           # Ï±ÑÏ†ê ÏôÑÎ£å
            ("failed", "Failed"),       # Ï±ÑÏ†ê Ïã§Ìå®
        ],
        default="pending",
    )

    # ==================================================
    # ‚úÖ NEW: attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ (ÏÑ§Í≥Ñ ÌïÑÏàò)
    # ==================================================
    meta = models.JSONField(
        null=True,
        blank=True,
        help_text=(
            "Attempt Îã®ÏúÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞. "
            "OMR/AI ÌåêÎèÖ Ï†ïÎ≥¥, total_score, pass_score, "
            "Ïû¨Ï±ÑÏ†ê Í∑ºÍ±∞ Îì± Ïö¥ÏòÅ/Î∂ÑÏÑùÏö© Ï†ïÎ≥¥ Ï†ÄÏû•."
        ),
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/exam_result.py
==========================================================================================
from __future__ import annotations

from django.db import models
from django.utils import timezone

from apps.api.common.models import BaseModel


class ExamResult(BaseModel):
    """
    results SSOT

    - submission Îã®ÏúÑ Í≤∞Í≥º 1Í∞ú (unique)
    - objectiveÎäî ÏûêÎèôÏ±ÑÏ†ê
    - subjective/descriptiveÎäî ÏàòÎèôÏ±ÑÏ†ê(override)
    - finalized ÎêòÎ©¥ Î∂àÎ≥Ä(Ïö¥ÏòÅ ÏÇ¨Í≥† Ï∞®Îã®)
    """

    class Status(models.TextChoices):
        DRAFT = "DRAFT", "Draft"
        FINAL = "FINAL", "Final"

    submission = models.OneToOneField(
        "submissions.Submission",
        on_delete=models.CASCADE,
        related_name="exam_result",
    )

    exam = models.ForeignKey(
        "exams.Exam",
        on_delete=models.CASCADE,
        related_name="results",
        help_text="regular exam",
    )

    # Ï†êÏàò
    max_score = models.FloatField(default=0.0)
    total_score = models.FloatField(default=0.0)
    objective_score = models.FloatField(default=0.0)
    subjective_score = models.FloatField(default=0.0)

    # ÏÉÅÌÉú/ÌôïÏ†ï
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.DRAFT)
    finalized_at = models.DateTimeField(null=True, blank=True)

    # ÏÉÅÏÑ∏ ÎÇ¥Ïó≠ (ÌîÑÎ°†Ìä∏/ÎîîÎ≤ÑÍπÖ/Ïò§ÎãµÎÖ∏Ìä∏Ïö©)
    # Ïòà: {"1": {"correct": true, "earned": 1, "answer": "A", "correct_answer": "A", "question_id": 123}, ...}
    breakdown = models.JSONField(default=dict, blank=True)

    # ÏàòÎèô Ï±ÑÏ†ê override (Î≤àÌò∏ Í∏∞Ï§Ä)
    # Ïòà: {"6": {"earned": 2, "comment": "Í≥ÑÏÇ∞ Ïã§Ïàò"}, "10": {"earned": 0, "comment": "ÎØ∏Ï†úÏ∂ú"}}
    manual_overrides = models.JSONField(default=dict, blank=True)

    # pass/fail (Í≥ÑÏÇ∞ Í≤∞Í≥º Ï†ÄÏû•Ìï¥ÎëêÎ©¥ UXÍ∞Ä Ïâ¨ÏõÄ)
    is_passed = models.BooleanField(default=False)

    class Meta:
        db_table = "results_exam_result"
        indexes = [
            models.Index(fields=["exam", "total_score"], name="results_exam_score_idx"),
            models.Index(
                fields=["exam", "status", "created_at"],
                name="results_exam_status_crted_idx",
            ),

        ]

    def finalize(self):
        self.status = self.Status.FINAL
        self.finalized_at = timezone.now()
        self.save(update_fields=["status", "finalized_at", "updated_at"])


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ÏãúÌóò/ÏàôÏ†ú Í≤∞Í≥º ÏµúÏã† Ïä§ÎÉÖÏÉ∑ (Ï°∞ÌöåÏö©)
    Í≥ÑÏÇ∞ ÏóÜÏùå

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ
    - attempt_id: Ïù¥ ResultÍ∞Ä Ïñ¥Îñ§ ExamAttempt(ÏãúÎèÑ)Î•º ÎåÄÌëúÌïòÎäîÏßÄ Ï∂îÏ†Å Í∞ÄÎä•
    - Ïû¨ÏãúÌóò/ÎåÄÌëú attempt ÍµêÏ≤¥ ÏãúÏóêÎèÑ "Ïñ¥Îñ§ attempt Í≤∞Í≥ºÏù∏ÏßÄ" Î™ÖÌôïÌï¥Ïßê

    ‚ö†Ô∏è Ï£ºÏùò:
    - Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ attempt_idÎäî ÏùºÎã® NULL ÌóàÏö©ÏúºÎ°ú Îì§Ïñ¥Í∞ê (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÏóêÏÑú null=True)
    - Ïö¥ÏòÅÏóêÏÑú Î∞±ÌïÑ ÌõÑ null=FalseÎ°ú tighten ÌïòÎäî 2Îã®Í≥ÑÍ∞Ä Ï†ïÏÑù
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # ‚úÖ Ïñ¥Îñ§ attemptÏùò Í≤∞Í≥ºÏù∏ÏßÄ Ï∂îÏ†Å (ÎåÄÌëú attempt Í∏∞Ï§Ä)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="Ïù¥ ResultÍ∞Ä Ï∞∏Ï°∞ÌïòÎäî ÎåÄÌëú ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    Í≤∞Í≥º Fact (append-only, Î∂àÎ≥Ä)
    - ÏßëÍ≥Ñ/ÌÜµÍ≥Ñ/Ïù¥Î≤§Ìä∏ Î°úÍ∑∏Ïóê Í∞ÄÍπåÏõÄ

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ
    - attempt_id: Ïù¥ FactÍ∞Ä Ïñ¥Îäê attemptÏóêÏÑú ÎÇòÏò® Ïù¥Î≤§Ìä∏Ïù∏ÏßÄ Ï∂îÏ†Å Í∞ÄÎä•

    ‚ö†Ô∏è Î¶¨Ìå©ÌÜ†ÎßÅ Î©îÎ™® (Ï§ëÏöî)
    ÏßÄÍ∏àÏùÄ ResultFactÍ∞Ä answer/score/meta/sourceÍπåÏßÄ Îì§Í≥† ÏûàÏùå.
    Ïû•Í∏∞Ï†ÅÏúºÎ°úÎäî:
      - ResultFact = "ÏßëÍ≥ÑÏö© Ïù¥Î≤§Ìä∏"
      - ÏÉÅÏÑ∏/Ï±ÑÏ†êÍ≤∞Í≥º = results.SubmissionAnswer Í∞Ä Îì§Í≥† Í∞ÄÎäî Í≤å Ï†ïÏÑù
    Îã§Îßå ÏßÄÍ∏à Îã®Í≥ÑÏóêÏÑúÎäî analytics Ï†úÍ±∞ + Îã®Ïàú Ïö¥ÏòÅÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # ‚úÖ Ïñ¥Îñ§ attemptÏóêÏÑú ÏÉùÏÑ±Îêú FactÏù∏ÏßÄ
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="Ïù¥ FactÎ•º ÏÉùÏÑ±Ìïú ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    Î¨∏Ìï≠Î≥Ñ ÏµúÏã† Í≤∞Í≥º ÏÉÅÌÉú (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
# PATH: apps/domains/results/serializers/__init__.py
from .exam_result import ManualGradeSerializer, ExamResultSerializer

__all__ = [
    "ManualGradeSerializer",
    "ExamResultSerializer",
]


==========================================================================================
# FILE: serializers/admin_clinic_target.py
==========================================================================================
# PATH: apps/domains/results/serializers/admin_clinic_target.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© "ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê" Î¶¨Ïä§Ìä∏ ÏùëÎãµ Í≥ÑÏïΩÏùÑ Í≥†Ï†ïÌïúÎã§.

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
- Clinic ÎåÄÏÉÅÏûê ÏÑ†Ï†ï/ÌåêÎã®ÏùÄ results ÎèÑÎ©îÏù∏Ïùò Îã®Ïùº ÏßÑÏã§Ïù¥Îã§.
- enrollment_id Í∏∞Ï§Ä(Îã®Ïùº ÏßÑÏã§)ÏúºÎ°ú ÎÇ¥Î†§Ï§ÄÎã§.
- ÌîÑÎ°†Ìä∏Ïùò ClinicTarget ÌÉÄÏûÖÍ≥º 1:1Î°ú ÎßûÏ∂òÎã§.

Î≥¥Î•òÎêú Í∏∞Îä• (Î™ÖÏãú)
- reasonÏùò ÏÑ∏Î∂Ä ÌåêÏ†ï(Ï†êÏàò/Ïã†Î¢∞ÎèÑ)ÏùÄ ÏÑúÎπÑÏä§ÏóêÏÑú Î≥¥ÏàòÏ†ÅÏúºÎ°ú ÌåêÏ†ïÌïúÎã§.
  (ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ LOW_CONFIDENCE Ïã†Ìò∏Í∞Ä Attempt.metaÏóê ÏûàÏùÑ ÏàòÎèÑ, ResultFact.metaÏóê ÏûàÏùÑ ÏàòÎèÑ ÏûàÏñ¥ Î∞©Ïñ¥ Íµ¨ÌòÑ)
"""

from rest_framework import serializers


class AdminClinicTargetSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    session_title = serializers.CharField()

    reason = serializers.ChoiceField(choices=["score", "confidence"])

    exam_score = serializers.FloatField()
    cutline_score = serializers.FloatField()

    created_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    # =====================================
    # üîß PATCH: Ï†êÏàò ÌïÑÎìú Î™ÖÏãúÏ†Å Î∂ÑÎ¶¨
    # - SessionScores / AdminExamResults Í≥µÏö© Í≥ÑÏïΩ
    # - ÌîÑÎ°†Ìä∏ ÏàòÏ†ï ÏóÜÏù¥ ÌôïÏû• Í∞ÄÎä•
    # =====================================
    exam_score = serializers.FloatField()
    exam_max_score = serializers.FloatField()

    final_score = serializers.FloatField()
    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # üî• Submission Ïó∞Îèô ÌïÑÎìú (Í∏∞Ï°¥ Ïú†ÏßÄ)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (Ïã†Í∑ú)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/exam_result.py
from __future__ import annotations

from rest_framework import serializers

from apps.domains.results.models.exam_result import ExamResult


class ManualGradeItemSerializer(serializers.Serializer):
    exam_question_id = serializers.IntegerField()
    score = serializers.FloatField(required=False)
    is_correct = serializers.BooleanField(required=False)
    note = serializers.CharField(required=False, allow_blank=True)


class ManualGradeSerializer(serializers.Serializer):
    """
    Keep stable import name for views.
    Payload shape can evolve without breaking callers.
    """
    identifier = serializers.CharField(required=False, allow_blank=True)
    answers = serializers.ListField(child=serializers.DictField(), required=False)
    grades = serializers.ListField(child=ManualGradeItemSerializer(), required=False)
    note = serializers.CharField(required=False, allow_blank=True)
    overrides = serializers.ListField(child=ManualGradeItemSerializer(), required=False)


class ExamResultSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamResult
        fields = "__all__"


==========================================================================================
# FILE: serializers/question_stats.py
==========================================================================================
# apps/domains/results/serializers/question_stats.py

from rest_framework import serializers


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct = serializers.IntegerField()
    accuracy = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    distribution = serializers.DictField(
        child=serializers.IntegerField()
    )


class TopWrongQuestionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    wrong_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/session_exams_summary.py
==========================================================================================
# apps/domains/results/serializers/session_exams_summary.py
from rest_framework import serializers


class SessionExamRowSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    participant_count = serializers.IntegerField()
    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()


class SessionExamsSummarySerializer(serializers.Serializer):
    session_id = serializers.IntegerField()

    participant_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    strategy = serializers.CharField()
    pass_source = serializers.CharField()

    exams = SessionExamRowSerializer(many=True)


==========================================================================================
# FILE: serializers/session_score_summary.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_score_summary.py

from rest_framework import serializers


class SessionScoreSummarySerializer(serializers.Serializer):
    """
    ÏÑ∏ÏÖò Îã®ÏúÑ ÏÑ±Ï†Å ÏöîÏïΩ (Ïö¥ÏòÅ/ÌÜµÍ≥ÑÏö©)

    ‚ö†Ô∏è Ï£ºÏùò
    - Result / ResultFact / Progress Í≤∞Í≥ºÎßå ÏÇ¨Ïö©
    - attempt ÍµêÏ≤¥ÏôÄ Î¨¥Í¥ÄÌïòÍ≤å Ìï≠ÏÉÅ ÏùºÍ¥ÄÎêú Í∞í
    """

    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    attempt_stats = serializers.DictField()


==========================================================================================
# FILE: serializers/session_scores.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_scores.py
"""
SessionScores Serializer (Score Tab)

‚úÖ ÏÑ§Í≥Ñ Í≥†Ï†ï(Ï§ëÏöî)
- Ïù¥ SerializerÎäî "ÌëúÏãúÏö© DTO" Ïù¥Îã§.
- ÎèÑÎ©îÏù∏ Î°úÏßÅ/ÌåêÏ†ï/Ï†ïÏ±Ö Í≥ÑÏÇ∞ÏùÑ ÌïòÏßÄ ÏïäÎäîÎã§.
- ViewÏóêÏÑú ÎßåÎì§Ïñ¥Ï§Ä dictÎ•º Í∑∏ÎåÄÎ°ú validate/serializeÎßå ÏàòÌñâÌïúÎã§.

‚úÖ ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ
- score === null ÏùÄ "ÎØ∏ÏÇ∞Ï∂ú/ÎØ∏ÏùëÏãú/Ï≤òÎ¶¨Ï§ë" ÏùòÎØ∏
- is_locked / lock_reason ÏùÄ ÏûÖÎ†• ÎπÑÌôúÏÑ±Ìôî + tooltip Ïö©ÎèÑ
"""

from __future__ import annotations

from rest_framework import serializers


class ScoreBlockSerializer(serializers.Serializer):
    score = serializers.FloatField(allow_null=True)
    max_score = serializers.FloatField(allow_null=True)

    passed = serializers.BooleanField(allow_null=True)
    clinic_required = serializers.BooleanField()

    is_locked = serializers.BooleanField()
    lock_reason = serializers.CharField(allow_null=True, allow_blank=True)


class ExamScoreBlockSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    block = ScoreBlockSerializer()


class HomeworkScoreBlockSerializer(serializers.Serializer):
    homework_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)

    block = ScoreBlockSerializer()


class SessionScoreRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField(allow_blank=True)

    exams = ExamScoreBlockSerializer(many=True)
    homeworks = HomeworkScoreBlockSerializer(many=True)

    updated_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    ‚úÖ ÌïôÏÉù ÌôîÎ©¥: Î¨∏Ìï≠Î≥Ñ Í≤∞Í≥º
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    ‚úÖ ÌïôÏÉù ÌôîÎ©¥: ÏãúÌóò Í≤∞Í≥º(Ï¥ùÏ†ê + Î¨∏Ìï≠Î≥Ñ) + Ïû¨ÏãúÌóò Î≤ÑÌäº ÌåêÎã®Í∞í

    ÏÑ§Í≥Ñ:
    - Result Î™®Îç∏ ÏûêÏ≤¥Îäî 'Ïä§ÎÉÖÏÉ∑'Ïù¥ÎØÄÎ°ú
      allow_retake/max_attempts/can_retakeÎäî Exam Ï†ïÏ±Ö + Attempt ÏÉÅÌÉúÎ°ú Í≥ÑÏÇ∞Ìï¥ÏÑú ÎÇ¥Î†§Ï§ÄÎã§.
    - Ïù¥ Í∞íÎì§ÏùÄ "ÏùëÎãµ ÌïÑÎìú"Ïù¥ÏßÄ Result DB ÌïÑÎìúÍ∞Ä ÏïÑÎãàÎã§.
      ‚Üí ViewÏóêÏÑú Í≥ÑÏÇ∞ ÌõÑ dataÏóê Ï£ºÏûÖÌïòÎäî Î∞©ÏãùÏù¥ Í∞ÄÏû• Îã®Ïàú/Î™ÖÌôï.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # ‚úÖ STEP 2: ÌîÑÎ°†Ìä∏ Ïû¨ÏãúÌóò Î≤ÑÌäº ÌåêÎã®Ïö© (ÏùëÎãµ Ï†ÑÏö© ÌïÑÎìú)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # ‚úÖ STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: serializers/wrong_note_pdf_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_pdf_serializers.py
from __future__ import annotations

from rest_framework import serializers


class WrongNotePDFStatusSerializer(serializers.Serializer):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF Job ÏÉÅÌÉú Ï°∞Ìöå ÏùëÎãµ

    ‚úÖ ÌîÑÎ°†Ìä∏ Ìè¥ÎßÅÏö© ÏµúÏÜå ÌïÑÎìú
    - status: PENDING/RUNNING/DONE/FAILED
    - file_url: DONEÏùº Îïå Îã§Ïö¥Î°úÎìú URL
    - error_message: FAILEDÏùº Îïå ÌëúÏãú
    """
    job_id = serializers.IntegerField()
    status = serializers.CharField()
    file_path = serializers.CharField(allow_blank=True)
    file_url = serializers.CharField(allow_blank=True, allow_null=True)
    error_message = serializers.CharField(allow_blank=True)
    created_at = serializers.DateTimeField()
    updated_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/wrong_note_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_serializers.py
from __future__ import annotations

from typing import Any, Dict, Optional
from rest_framework import serializers


class WrongNoteItemSerializer(serializers.Serializer):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Îã®Ïùº Î¨∏Ìï≠ ÏïÑÏù¥ÌÖú

    ‚úÖ ÏùòÎèÑ:
    - ResultFact/ResultItem Íµ¨Ï°∞Í∞Ä ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ Ï°∞Í∏à Îã¨ÎùºÎèÑ
      ViewÏóêÏÑú dictÎ°ú ÎßåÎì§Ïñ¥ serialize Í∞ÄÎä•ÌïòÍ≤å "Îã®Ïàú Serializer"Î°ú Í≥†Ï†ï
    """

    exam_id = serializers.IntegerField()
    attempt_id = serializers.IntegerField()
    attempt_created_at = serializers.DateTimeField(allow_null=True)

    question_id = serializers.IntegerField()
    question_number = serializers.IntegerField(required=False, allow_null=True)
    answer_type = serializers.CharField(required=False, allow_blank=True)

    # ÌïôÏÉù Îãµ / Ï†ïÎãµ / Ï†êÏàò
    student_answer = serializers.CharField(required=False, allow_blank=True)
    correct_answer = serializers.CharField(required=False, allow_blank=True)

    is_correct = serializers.BooleanField()
    score = serializers.FloatField()
    max_score = serializers.FloatField()

    # ÏõêÎ≥∏ Î©îÌÉÄ (OMR/AI Ìè¨Ìï®)
    meta = serializers.JSONField(required=False)

    # ÏòµÏÖò: ÌîÑÎ°†Ìä∏ UXÏö© (Î¨∏Ï†ú ÏßÄÎ¨∏/ÏÑ†ÏßÄ/Ìï¥ÏÑ§ Îì±ÏùÄ ÌôïÏû• Ìè¨Ïù∏Ìä∏)
    extra = serializers.JSONField(required=False)


class WrongNoteListResponseSerializer(serializers.Serializer):
    """
    ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ìè¨Ìï® ÏùëÎãµ
    """
    count = serializers.IntegerField()
    next = serializers.IntegerField(allow_null=True)   # Îã§Ïùå offset
    prev = serializers.IntegerField(allow_null=True)   # Ïù¥Ï†Ñ offset
    results = WrongNoteItemSerializer(many=True)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    Í≥ÑÏÇ∞Îêú Í≤∞Í≥ºÎ•º Î∞õÏïÑ resultsÏóê Î∞òÏòÅ
    ‚ùå Í≥ÑÏÇ∞ ÏóÜÏùå (Í≥ÑÏÇ∞ÏùÄ graderÍ∞Ä Ìï®)

    ‚úÖ attempt Ï§ëÏã¨ ÏÑ§Í≥Ñ Î∞òÏòÅ:
    - apply()Í∞Ä attempt_idÎ•º Î∞õÏïÑÏÑú Result / ResultFactÏóê Ï†ÄÏû•

    ‚úÖ Ïö¥ÏòÅ ÏïàÏ†ÑÏÑ± Ìå®Ïπò (Critical #4)
    - ResultFact / ResultItemÏóê Îì§Ïñ¥Í∞ÄÎäî Í∞íÏùÄ "Ìï≠ÏÉÅ ÌÉÄÏûÖÏù¥ Î≥¥Ïû•ÎêúÎã§"Îäî Ï†ÑÏ†úÍ∞Ä Ïö¥ÏòÅÏóêÏÑú Íπ®Ïßà Ïàò ÏûàÏùå
      (blank, meta-only, None, Ïà´Ïûê/Î¶¨Ïä§Ìä∏ Îì±)
    - Îî∞ÎùºÏÑú Ïó¨Í∏∞ÏÑú ÏµúÏÜå Ï∫êÏä§ÌåÖ/ÎîîÌè¥Ìä∏Î•º Í∞ïÏ†úÌï¥ DB insert ÏïàÏ†ïÏÑ±ÏùÑ Ïò¨Î¶∞Îã§.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # ‚úÖ Ï∂îÍ∞Ä
        items: list[dict],
    ) -> Result:
        """
        items format (Í∂åÏû•):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # ‚úÖ ÎåÄÌëú attempt Ï∂îÏ†Å (ÎçÆÏñ¥Ïì∞ÎäîÍ≤å Ï†ïÏÉÅ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # ‚úÖ Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1Ô∏è‚É£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2Ô∏è‚É£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ÏÉùÏÑ±/Í¥ÄÎ¶¨ Ï†ÑÎã¥

    üî• Critical Ìå®Ïπò:
    - Í∞ôÏùÄ submission_idÎ°ú AttemptÍ∞Ä Ï§ëÎ≥µ ÏÉùÏÑ±ÎêòÎäî Í≤ÉÏùÑ Ï∞®Îã®
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # üî¥ CRITICAL #2
        # -------------------------------------------------
        # Í∞ôÏùÄ submissionÏúºÎ°ú AttemptÍ∞Ä Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ï¶âÏãú Ï∞®Îã®
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1Ô∏è‚É£ Exam Ï†ïÏ±Ö Î°úÎî©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2Ô∏è‚É£ open_at / close_at Ï†ïÏ±Ö Í∞ïÏ†ú
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3Ô∏è‚É£ ÎèôÏãúÏÑ± ÏïàÏ†Ñ: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4Ô∏è‚É£ Ï†ïÏ±Ö Í∞ïÏ†ú
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5Ô∏è‚É£ ÎåÄÌëú attempt ÍµêÏ≤¥
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/clinic_target_service.py
==========================================================================================
# PATH: apps/domains/results/services/clinic_target_service.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© "ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê" Î¶¨Ïä§Ìä∏Î•º ÏÉùÏÑ±ÌïúÎã§.
- clinic_requiredÏùò Îã®Ïùº ÏßÑÏã§: progress.ClinicLink(is_auto=True)

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
1) Îã®Ïùº ÏßÑÏã§: enrollment_id (ÌïôÏÉù ÏãùÎ≥ÑÏùÄ enrollment_idÎ°úÎßå)
2) clinic_required ÌåêÎã®ÏùÄ ClinicLink (ÏûêÎèô Ìä∏Î¶¨Í±∞) Í∏∞Ï§Ä
3) Ï†êÏàò/Ïª§Ìä∏ÎùºÏù∏/ÏÇ¨Ïú†(reason)Îäî results/examsÏóêÏÑú ÌååÏÉù
4) Session ‚Üî Exam Îß§ÌïëÏùÄ results.utils.session_exam.get_exams_for_session() Îã®Ïùº ÏßÑÏã§ ÏÇ¨Ïö©

‚ö†Ô∏è ÌòÑÏã§Ï†Å Ï†úÏïΩ (Î≥¥Î•ò/Î™ÖÏãú)
- "ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ Ïó¨Îü¨ Í∞ú"Ïù∏ Íµ¨Ï°∞ÏóêÏÑú, ClinicTargetÏùò exam_score/cutline_scoreÎäî 1Í∞ú Ïà´ÏûêÎßå Îã¥ÎäîÎã§.
  Îî∞ÎùºÏÑú Î≥∏ ÏÑúÎπÑÏä§Îäî "ÎåÄÌëú exam"ÏùÑ 1Í∞ú ÏÑ†Ï†ïÌï¥ÏÑú ÌëúÍ∏∞ÌïúÎã§.
  - Í∏∞Î≥∏ Ï†ïÏ±Ö: get_exams_for_session(session) Ï§ë idÍ∞Ä Í∞ÄÏû• ÏûëÏùÄ examÏùÑ ÎåÄÌëúÎ°ú ÏÇ¨Ïö©
  - Ìñ•ÌõÑ Ï†ïÏ±Ö ÌïÑÏöî Ïãú: ProgressPolicy(strategy)ÎÇò Ïö¥ÏòÅ Í∑úÏπôÏóê Îî∞Îùº Î≥ÄÍ≤Ω Í∞ÄÎä•
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink
from apps.domains.exams.models import Exam
from apps.domains.results.models import Result, ResultFact, ExamAttempt

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exams_for_session


def _safe_str(v: Any, default: str = "-") -> str:
    try:
        s = str(v)
        return s if s.strip() else default
    except Exception:
        return default


def _safe_float(v: Any, default: float = 0.0) -> float:
    try:
        return float(v)
    except Exception:
        return float(default)


def _extract_invalid_reason_from_meta(meta: Any) -> Optional[str]:
    """
    ResultFact.meta / Attempt.meta / SubmissionAnswer.meta Îì± Îã§ÏñëÌïú ÏúÑÏπòÏóê ÏûàÏùÑ Ïàò ÏûàÎäî
    invalid_reasonÏùÑ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï∂îÏ∂úÌïúÎã§.

    Í∏∞ÎåÄ Í∞ÄÎä•Ìïú ÌòïÌÉú:
    meta = { "grading": { "invalid_reason": "LOW_CONFIDENCE" } }
    """
    if not isinstance(meta, dict):
        return None
    grading = meta.get("grading")
    if isinstance(grading, dict):
        v = grading.get("invalid_reason")
        return str(v) if v else None
    return None


def _is_low_confidence_for_attempt(*, exam_id: int, enrollment_id: int, attempt_id: Optional[int]) -> bool:
    """
    "Ïã†Î¢∞ÎèÑ ÎÇÆÏùå" ÌåêÏ†ïÏùÄ ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÌòÑÏóê Îî∞Îùº:
    - Attempt.meta.grading.invalid_reason (Í∞ÄÎä•)
    - ResultFact.meta.grading.invalid_reason (Í∞ÄÎä•, ÌòÑÏû¨ graderÎäî Î¨∏Ìï≠ metaÏóê Ïã¨Îäî ÌòïÌÉú)
    Îëò Îã§ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï≤¥ÌÅ¨ÌïúÎã§.
    """
    # 1) Attempt.meta (ÏûàÏúºÎ©¥ ÏµúÏö∞ÏÑ†)
    if attempt_id:
        a = ExamAttempt.objects.filter(id=int(attempt_id)).first()
        if a and hasattr(a, "meta"):
            reason = _extract_invalid_reason_from_meta(getattr(a, "meta", None))
            if (reason or "").upper() == "LOW_CONFIDENCE":
                return True

    # 2) ResultFact.meta (ÎåÄÌëú attempt Í∏∞Ï§Ä)
    if attempt_id:
        qs = (
            ResultFact.objects.filter(
                target_type="exam",
                target_id=int(exam_id),
                enrollment_id=int(enrollment_id),
                attempt_id=int(attempt_id),
            )
            .exclude(meta__isnull=True)
            .order_by("-id")[:200]  # Î∞©Ïñ¥: ÎÑàÎ¨¥ ÌÅ∞ scan Î∞©ÏßÄ
        )
        for f in qs:
            r = _extract_invalid_reason_from_meta(getattr(f, "meta", None))
            if (r or "").upper() == "LOW_CONFIDENCE":
                return True

    return False


def _get_student_name_by_enrollment_id(enrollment_id: int) -> str:
    """
    enrollment_id ‚Üí student_name Îß§ÌïëÏùÄ ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ ÎèÑÎ©îÏù∏Ïù¥ Îã§Î•º Ïàò ÏûàÏñ¥ Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Íµ¨ÌòÑ.

    Ïö∞ÏÑ†ÏàúÏúÑ:
    1) enrollments.SessionEnrollment (session-enrollments) Î™®Îç∏Ïù¥ ÏûàÏúºÎ©¥ student_name ÌïÑÎìú/Ï°∞Ïù∏ ÏÇ¨Ïö©
    2) enrollment.Enrollment Î™®Îç∏Ïù¥ ÏûàÏúºÎ©¥ student/user Ï°∞Ïù∏ ÏãúÎèÑ
    3) Ïã§Ìå® Ïãú "-"
    """
    enrollment_id = int(enrollment_id)

    # 1) SessionEnrollment (ÏûàÏúºÎ©¥ Í∞ÄÏû• ÌôïÏã§)
    try:
        # ÌîÑÎ°úÏ†ùÌä∏Ïóê Îî∞Îùº Ïï± Í≤ΩÎ°úÍ∞Ä Îã§Î•º Ïàò ÏûàÏùå
        # - apps.domains.enrollments.models.SessionEnrollment (Í∞ÄÏû• ÌùîÌï®)
        # - apps.domains.enrollments.models.session_enrollment.SessionEnrollment Îì±
        from apps.domains.enrollments.models import SessionEnrollment  # type: ignore

        se = (
            SessionEnrollment.objects.filter(enrollment_id=enrollment_id)
            .order_by("-id")
            .first()
        )
        if se:
            # serializer ÏùëÎãµÏóê student_nameÏù¥ ÏûàÎã§Í≥† ÌñàÎçò Ïä§ÌéôÍ≥º Ï†ïÌï©ÏÑ±
            v = getattr(se, "student_name", None)
            if v:
                return _safe_str(v, "-")

            # Ï°∞Ïù∏Ïù¥ Í∞ÄÎä•ÌïòÎ©¥ student.name
            st = getattr(se, "student", None)
            if st and hasattr(st, "name"):
                return _safe_str(getattr(st, "name", None), "-")
    except Exception:
        pass

    # 2) Enrollment (Í∏∞Ï°¥ results ÏΩîÎìúÏóêÏÑú ÏÇ¨Ïö© Ï§ë)
    try:
        from apps.domains.enrollment.models import Enrollment  # type: ignore

        e = Enrollment.objects.filter(id=enrollment_id).select_related().first()
        if not e:
            return "-"

        # student FKÍ∞Ä ÏûàÏúºÎ©¥ Ïö∞ÏÑ†
        st = getattr(e, "student", None)
        if st and hasattr(st, "name"):
            return _safe_str(getattr(st, "name", None), "-")

        # userÍ∞Ä ÌïôÏÉù ÌîÑÎ°úÌïÑÏùÑ Îì§Í≥† ÏûàÏùÑ ÏàòÎèÑ
        u = getattr(e, "user", None)
        if u:
            nm = getattr(u, "name", None) or getattr(u, "username", None)
            return _safe_str(nm, "-")
    except Exception:
        pass

    return "-"


def _get_session_title(session: Session) -> str:
    """
    ÏÑ∏ÏÖò ÌÉÄÏù¥ÌãÄÏùÄ ÌîÑÎ°úÏ†ùÌä∏ÎßàÎã§ ÌëúÌòÑÏù¥ Îã¨ÎùºÏÑú:
    - __str__ Ïö∞ÏÑ†
    - lecture/title/order Îì± ÌõÑÎ≥¥Î•º Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï°∞Ìï©
    """
    s = _safe_str(session, "-")
    if s != "-" and s.lower() != "session object":
        return s

    lecture = getattr(session, "lecture", None)
    lecture_title = _safe_str(getattr(lecture, "title", None), "")
    order = getattr(session, "order", None)

    if lecture_title and order is not None:
        return f"{lecture_title} {int(order)}ÌöåÏ∞®"
    if lecture_title:
        return lecture_title

    return f"Session#{int(getattr(session, 'id', 0) or 0)}"


@dataclass(frozen=True)
class ClinicTargetRow:
    enrollment_id: int
    student_name: str
    session_title: str
    reason: str  # "score" | "confidence"
    exam_score: float
    cutline_score: float
    created_at: Any


class ClinicTargetService:
    """
    Admin Clinic Targets

    Îã®Ïùº ÏßÑÏã§:
    - ÎåÄÏÉÅÏûê Î™®Ïàò: ClinicLink(is_auto=True)
    - enrollment_id Í∏∞Ï§Ä
    """

    @staticmethod
    def list_admin_targets() -> List[Dict[str, Any]]:
        links = (
            ClinicLink.objects.filter(is_auto=True)
            # ‚úÖ ÏàòÏ†ïÏÇ¨Ìï≠(Ï∂îÍ∞Ä): ÏòàÏïΩ ÏôÑÎ£åÎ°ú Î∂ÑÎ¶¨Îêú ÎåÄÏÉÅÏûêÎäî "ÎåÄÏÉÅÏûê"ÏóêÏÑú Ï†úÏô∏
            .filter(resolved_at__isnull=True)
            .select_related("session")
            .order_by("-created_at")  # ÏµúÏã† ÏûêÎèô ÎåÄÏÉÅ Ïö∞ÏÑ†
        )

        out: List[Dict[str, Any]] = []

        # ÏÑ∏ÏÖòÎ≥Ñ exam ÌõÑÎ≥¥ Ï∫êÏãú (ÏøºÎ¶¨ Ï†àÏïΩ)
        exams_cache: Dict[int, Optional[Exam]] = {}

        for link in links:
            session = getattr(link, "session", None)
            if not session:
                continue

            session_id = int(getattr(session, "id", 0) or 0)
            enrollment_id = int(getattr(link, "enrollment_id", 0) or 0)
            if not session_id or not enrollment_id:
                continue

            # ÎåÄÌëú exam ÏÑ†Ï†ï (ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ Ïó¨Îü¨ Í∞úÎ©¥ 1Í∞úÎßå ÌëúÍ∏∞)
            if session_id not in exams_cache:
                exams = list(get_exams_for_session(session))
                if exams:
                    # ‚úÖ Î≥¥ÏàòÏ†Å Ï†ïÏ±Ö: idÍ∞Ä Í∞ÄÏû• ÏûëÏùÄ examÏùÑ ÎåÄÌëúÎ°ú
                    ex = sorted(exams, key=lambda x: int(getattr(x, "id", 0) or 0))[0]
                    exams_cache[session_id] = ex
                else:
                    exams_cache[session_id] = None

            exam = exams_cache.get(session_id)
            if not exam:
                # ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ ÏóÜÏúºÎ©¥ score/cutlineÏùÄ 0ÏúºÎ°ú ÎÇ¥Î†§ÏÑú ÌôîÎ©¥Ïù¥ Íπ®ÏßÄÏßÄ ÏïäÍ≤å
                out.append({
                    "enrollment_id": enrollment_id,
                    "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                    "session_title": _get_session_title(session),
                    "reason": "score",
                    "exam_score": 0.0,
                    "cutline_score": 0.0,
                    "created_at": getattr(link, "created_at", None),
                })
                continue

            exam_id = int(getattr(exam, "id", 0) or 0)
            cutline = _safe_float(getattr(exam, "pass_score", 0.0), 0.0)

            # ÎåÄÌëú Ïä§ÎÉÖÏÉ∑ Result (ÏãúÌóò Îã®ÏúÑ)
            result = (
                Result.objects.filter(
                    target_type="exam",
                    target_id=exam_id,
                    enrollment_id=enrollment_id,
                )
                .order_by("-id")
                .first()
            )

            exam_score = _safe_float(getattr(result, "total_score", 0.0) if result else 0.0, 0.0)
            attempt_id = int(getattr(result, "attempt_id", 0) or 0) if result else 0

            # reason ÌåêÏ†ï
            # - LOW_CONFIDENCE ÌùîÏ†ÅÏù¥ ÏûàÏúºÎ©¥ confidence
            # - ÏïÑÎãàÎ©¥ score
            reason = "confidence" if _is_low_confidence_for_attempt(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id if attempt_id else None,
            ) else "score"

            out.append({
                "enrollment_id": enrollment_id,
                "student_name": _get_student_name_by_enrollment_id(enrollment_id),
                "session_title": _get_session_title(session),
                "reason": reason,
                "exam_score": float(exam_score),
                "cutline_score": float(cutline),
                "created_at": getattr(link, "created_at", None),
            })

        return out


==========================================================================================
# FILE: services/exam_grading_service.py
==========================================================================================
# PATH: apps/domains/results/services/exam_grading_service.py
from __future__ import annotations

from typing import Dict, Tuple

from django.core.exceptions import ValidationError
from django.db import transaction
from django.shortcuts import get_object_or_404

from apps.domains.exams.models import Exam
from apps.domains.results.models import ExamResult
from apps.domains.results.guards.grading_contract import GradingContractGuard


class ExamGradingService:
    """
    Objective exam grading service (queue-less, sync).

    Ïö¥ÏòÅ ÏõêÏπô:
    - Î™®Îç∏(SSOT)Ïù¥ Í∞ÄÏßÑ ÌïÑÎìúÎßå ÏÇ¨Ïö©
    - Í≤∞Í≥º Í≥ÑÏÇ∞ÏùÄ Í∞ÄÎä•, Î™®Îç∏ Í≥ÑÏïΩ ÏúÑÎ∞òÏùÄ Î∂àÍ∞Ä
    """

    # ------------------------------------------------------------------
    # Loaders
    # ------------------------------------------------------------------
    def _load_submission(self, submission_id: int):
        Submission = __import__(
            "apps.domains.submissions.models",
            fromlist=["Submission"],
        ).Submission

        return get_object_or_404(
            Submission.objects.select_related("user"),
            id=int(submission_id),
        )

    def _load_exam(self, submission) -> Exam:
        if str(submission.target_type) != "exam":
            raise ValidationError("submission target_type must be exam")

        return get_object_or_404(Exam, id=int(submission.target_id))

    # ------------------------------------------------------------------
    # Scoring
    # ------------------------------------------------------------------
    def _compute_score(
        self,
        *,
        sheet,
        answer_key,
        submission_answers,
    ) -> int:
        """
        Returns:
          total_score (0~100)
        """

        key_map: Dict[int, str] = {
            int(k): str(v).strip()
            for k, v in answer_key.answers.items()
            if str(k).isdigit()
        }

        answers_map: Dict[int, str] = {}
        for a in submission_answers:
            qid = int(getattr(a, "exam_question_id", 0) or 0)
            ans = str(getattr(a, "answer", "") or "").strip()
            if qid > 0:
                answers_map[qid] = ans

        questions = list(sheet.questions.all())
        total_q = len(questions)

        if total_q == 0:
            return 0

        correct = 0
        for q in questions:
            qid = int(q.id)
            if (
                qid in key_map
                and qid in answers_map
                and answers_map[qid] == key_map[qid]
            ):
                correct += 1

        return int(round((correct / total_q) * 100))

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    @transaction.atomic
    def auto_grade_objective(self, *, submission_id: int) -> ExamResult:
        SubmissionAnswer = __import__(
            "apps.domains.submissions.models",
            fromlist=["SubmissionAnswer"],
        ).SubmissionAnswer

        submission = self._load_submission(submission_id)
        exam = self._load_exam(submission)

        # ‚úÖ Í≥ÑÏïΩ Í≤ÄÏ¶ù (ÎåÄÍ∏∞ÏóÖ Ïö¥ÏòÅ ÌïµÏã¨)
        sheet, answer_key = GradingContractGuard.validate_exam_for_grading(exam)

        existing = (
            ExamResult.objects
            .select_for_update()
            .filter(submission=submission)
            .first()
        )

        submission_answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        total_score = self._compute_score(
            sheet=sheet,
            answer_key=answer_key,
            submission_answers=submission_answers,
        )

        result = existing or ExamResult.objects.create(
            submission=submission,
            exam=exam,
            total_score=0,
            status=ExamResult.Status.DRAFT,
        )

        result.total_score = total_score
        result.status = ExamResult.Status.DRAFT
        result.save(update_fields=["total_score", "status", "updated_at"])

        try:
            submission.status = "graded"
            submission.save(update_fields=["status", "updated_at"])
        except Exception:
            pass

        return result

    @transaction.atomic
    def finalize(self, *, submission_id: int) -> ExamResult:
        submission = self._load_submission(submission_id)

        result = (
            ExamResult.objects
            .select_for_update()
            .filter(submission=submission)
            .first()
        )

        if not result:
            raise ValidationError("auto-grade first; result not found")

        if result.status == ExamResult.Status.FINAL:
            return result

        result.finalize()
        return result


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# üîΩ submissions ÎèÑÎ©îÏù∏ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# üîΩ results ÎèÑÎ©îÏù∏ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# üîΩ exams ÎèÑÎ©îÏù∏ (Ï†ïÎãµ / Î¨∏Ï†ú Ï†ïÏùò)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey
# (ÏÑ†ÌÉù) pass_scoreÎ•º ExamÏóêÏÑú ÏùΩÏùÑ Ïàò ÏûàÏúºÎ©¥ Ïì∞Í≥†, ÏóÜÏúºÎ©¥ ÏïàÏ†ÑÌïòÍ≤å Ïä§ÌÇµ
try:
    from apps.domains.exams.models import Exam  # type: ignore
except Exception:  # pragma: no cover
    Exam = None  # type: ignore

# ======================================================
# üîΩ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants (STEP 1 Í≥†Ï†ï)
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    Î¨∏ÏûêÏó¥ Ï†ïÍ∑úÌôî (STEP 1 exact match Í≥†Ï†ï):
    - None Î∞©Ïñ¥
    - Í≥µÎ∞± Ï†úÍ±∞
    - ÎåÄÎ¨∏Ïûê ÌÜµÏùº
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ÏóêÏÑú
    omr dict Îßå ÏïàÏ†ÑÌïòÍ≤å Ï∂îÏ∂ú
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _ensure_dict(v: Any) -> Dict[str, Any]:
    return v if isinstance(v, dict) else {}


def _with_invalid_reason(meta: Any, reason: str) -> Dict[str, Any]:
    """
    ‚úÖ STEP 1 ÌïµÏã¨:
    low_conf / blank / multi Îì± "Î¨¥Ìö® Ï≤òÎ¶¨"Îäî 0Ï†ê Ï≤òÎ¶¨ Îøê ÏïÑÎãàÎùº
    **ÏÇ¨Ïú†Î•º append-onlyÎ°ú ÎÇ®Í≤®Ïïº Ïö¥ÏòÅ/Ïû¨Ï≤òÎ¶¨/ÌîÑÎ°†Ìä∏ ÌëúÏãúÍ∞Ä Í∞ÄÎä•**Ìï¥Ïßê.
    """
    base = _ensure_dict(meta)
    out = dict(base)
    out.setdefault("grading", {})
    if isinstance(out["grading"], dict):
        out["grading"]["invalid_reason"] = reason
    return out


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
    # ‚úÖ Í∏∞Ï°¥ metaÎ•º Î∞õÏïÑÏÑú invalid_reasonÏùÑ Ïã¨ÎäîÎã§
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    OMR Í∞ùÍ¥ÄÏãù Ï±ÑÏ†ê v1 (STEP 1 Í≥†Ï†ï)

    ‚úÖ Ï†ïÏ±Ö:
    - status != ok -> Î¨¥Ìö® (0Ï†ê)
    - marking blank/multi -> Î¨¥Ìö® (0Ï†ê)
    - confidence < threshold -> Î¨¥Ìö® (0Ï†ê) + LOW_CONFIDENCE ÏÇ¨Ïú† Ï†ÄÏû•  ‚≠ê‚≠ê‚≠ê
    - detected != 1Í∞ú -> Î¨¥Ìö® (0Ï†ê)
    """
    st = (status or "").lower()
    mk = (marking or "").lower()

    # 1) statusÍ∞Ä okÍ∞Ä ÏïÑÎãàÎ©¥ Î¨¥Ìö®
    if st != "ok":
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_STATUS_NOT_OK")

    # 2) blank/multiÎäî Î¨¥Ìö®
    if mk in ("blank", "multi"):
        reason = "OMR_BLANK" if mk == "blank" else "OMR_MULTI"
        return False, 0.0, _with_invalid_reason(original_meta, reason)

    # 3) Ïã†Î¢∞ÎèÑ Ï≤¥ÌÅ¨ (STEP 1: low confidence ÏûêÎèô 0Ï†ê + ÏÇ¨Ïú† Ï†ÄÏû•)
    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0, _with_invalid_reason(original_meta, "LOW_CONFIDENCE")

    # 4) detected 1Í∞ú Í∞ïÏ†ú
    if not detected or len(detected) != 1:
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_DETECTED_INVALID")

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    Ï£ºÍ¥ÄÏãù / fallback Ï±ÑÏ†ê (STEP 1: exact match)

    ‚úÖ Ï†ïÏ±Ö:
    - empty => 0Ï†ê
    - exact match only
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0, _with_invalid_reason(original_meta, "EMPTY_ANSWER")

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type Ï∂îÎ°†
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    ‚úÖ AnswerKey v2 Í≥†Ï†ï

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


def _get_pass_score(exam_id: int) -> Optional[float]:
    """
    (ÏÑ†ÌÉù) Exam.pass_scoreÍ∞Ä ÏûàÏúºÎ©¥ ÏùΩÏñ¥ÏÑú attempt/metaÏóê Í∏∞Î°ù.
    - ResultApplierÍ∞Ä Ïù¥ÎØ∏ is_passÎ•º Í≥ÑÏÇ∞ÌïúÎã§Î©¥ Ïù¥Í±¥ "ÏßÑÎã®/ÌëúÏãúÏö©" Ï†ïÎ≥¥Î°úÎßå ÎÇ®ÎäîÎã§.
    """
    if Exam is None:
        return None
    try:
        exam = Exam.objects.filter(id=int(exam_id)).first()
        if not exam:
            return None
        v = getattr(exam, "pass_score", None)
        return float(v) if v is not None else None
    except Exception:
        return None


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission ‚Üí ExamAttempt ‚Üí Result / ResultItem / ResultFact

    üî• v2 ÌïµÏã¨ Í≥ÑÏïΩ:
    - SubmissionAnswer.exam_question_id Îßå ÏÇ¨Ïö©
    - number / fallback ÏôÑÏ†Ñ Ï†úÍ±∞
    - AnswerKey v2 Í≥†Ï†ï
    - ‚úÖ STEP 1: LOW_CONF Î¨¥Ìö® 0Ï†ê + ÏÇ¨Ïú† Ï†ÄÏû•
    """

    # --------------------------------------------------
    # 0Ô∏è‚É£ Submission ÏÉÅÌÉú Ï†ÑÏù¥
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1Ô∏è‚É£ ExamAttempt ÏÉùÏÑ±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2Ô∏è‚É£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3Ô∏è‚É£ ExamQuestion Î°úÎî© (id Í∏∞Ï§Ä)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        total_score = 0.0
        total_max_score = 0.0

        # --------------------------------------------------
        # 4Ô∏è‚É£ Î¨∏Ìï≠Î≥Ñ Ï±ÑÏ†ê
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            # submissions meta
            original_meta = getattr(sa, "meta", None)
            omr = _get_omr_meta(original_meta)

            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            # ‚úÖ STEP 1: low_confidence statusÎäî Ï¶âÏãú Î¨¥Ìö® Ï≤òÎ¶¨ (0Ï†ê+ÏÇ¨Ïú†)
            if (status or "").lower() == "low_confidence":
                is_correct = False
                score = 0.0
                final_answer = ""
                final_meta = _with_invalid_reason(original_meta, "LOW_CONFIDENCE")
            else:
                answer_type = _infer_answer_type(q)

                if answer_type in ("choice", "omr", "multiple_choice"):
                    if omr_version.lower() in ("v1", "v2"):
                        is_correct, score, final_meta = _grade_choice_v1(
                            detected=[str(x) for x in detected],
                            marking=marking,
                            confidence=confidence,
                            status=status,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        # ÌëúÏãúÏö© answer: Í∞êÏßÄÎêú Í∞í 1Í∞úÎ©¥ Í∑∏ Í∞í, ÏïÑÎãàÎ©¥ ""
                        final_answer = (
                            "".join([_norm(x) for x in detected]) if detected else ""
                        )
                    else:
                        # OMR metaÍ∞Ä ÏóÜÍ±∞ÎÇò Î≤ÑÏ†ÑÏù¥ ÏóÜÏùÑ Îïå: ÌÖçÏä§Ìä∏ Í∏∞Î∞ò exact match
                        is_correct, score, final_meta = _grade_short_v1(
                            answer_text=answer_text,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        final_answer = answer_text
                else:
                    # subjective: exact match (STEP 1)
                    is_correct, score, final_meta = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                        original_meta=original_meta,
                    )
                    final_answer = answer_text

            # Ï†êÏàò ÎàÑÏ†Å
            total_score += float(score)
            total_max_score += float(max_score)

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                # ‚úÖ ÏµúÏ¢Ö metaÏóêÎäî invalid_reasonÏù¥ Î∞òÏòÅÎê† Ïàò ÏûàÏùå
                "meta": final_meta,
            })

        # --------------------------------------------------
        # 4-1) (ÏÑ†ÌÉù) attempt/metaÏóê total/pass Ï†ïÎ≥¥ Í∏∞Î°ù
        # - ResultApplierÍ∞Ä Ïã§Ï†ú ResultSummary.is_passÎ•º ÎßåÎì§ÎçîÎùºÎèÑ,
        #   attemptÏóêÎäî Ïö¥ÏòÅ/ÎîîÎ≤ÑÍπÖÏö©ÏúºÎ°ú ÎÇ®Í≤®ÎëêÎ©¥ Ï¢ãÏùå.
        # --------------------------------------------------
        try:
            pass_score = _get_pass_score(int(submission.target_id))
            meta = getattr(attempt, "meta", None)
            if isinstance(meta, dict):
                new_meta = dict(meta)
            else:
                new_meta = {}

            new_meta.setdefault("grading", {})
            if isinstance(new_meta["grading"], dict):
                new_meta["grading"]["total_score"] = float(total_score)
                new_meta["grading"]["total_max_score"] = float(total_max_score)
                if pass_score is not None:
                    new_meta["grading"]["pass_score"] = float(pass_score)
                    new_meta["grading"]["is_pass_inferred"] = bool(total_score >= pass_score)

            if hasattr(attempt, "meta"):
                attempt.meta = new_meta
                attempt.save(update_fields=["meta"])
        except Exception:
            # meta ÌïÑÎìúÍ∞Ä ÏóÜÍ±∞ÎÇò Ï†ÄÏû• Ïã§Ìå®Ìï¥ÎèÑ grading ÏûêÏ≤¥Îäî Í≥ÑÏÜç ÏßÑÌñâ
            pass

        # --------------------------------------------------
        # 5Ô∏è‚É£ Result Î∞òÏòÅ
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6Ô∏è‚É£ ÏÉÅÌÉú ÎßàÎ¨¥Î¶¨
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/grading_policy.py
==========================================================================================
# # PATH: apps/domains/results/services/grading_policy.py

# NOTE:
# STEP 2 Ïù¥ÌõÑ grader Î¶¨Ìå©ÌÜ†ÎßÅ Ïãú ÏÇ¨Ïö©Ìï† Ï†ïÏ±Ö Î™®Îìà
# ÌòÑÏû¨Îäî ÎØ∏ÏÇ¨Ïö©

# from __future__ import annotations

# from dataclasses import dataclass
# from typing import Any, Dict, Optional, Tuple


# # =========================================================
# # STEP 1 Ï†ïÏ±Ö ÏÉÅÏàò (Í≥†Ï†ï)
# # =========================================================

# MIN_OMR_CONFIDENCE = 0.70  # Ïù¥ ÎØ∏ÎßåÏù¥Î©¥ ÏûêÎèô Î¨¥Ìö®(0Ï†ê)


# def normalize_text(s: str) -> str:
#     """
#     Ï£ºÍ¥ÄÏãù exact match ÌëúÏ§Ä Ï†ïÍ∑úÌôî (STEP 1 Í≥†Ï†ï)
#     - strip + lower
#     - Ï∂îÌõÑ Í≥µÎ∞±/ÌäπÏàòÎ¨∏Ïûê Í∑úÏπôÏùÄ Ïó¨Í∏∞ÏÑúÎßå Î∞îÍæ∏Î©¥ Îê®
#     """
#     return (s or "").strip().lower()


# @dataclass(frozen=True)
# class OMRValidity:
#     is_valid: bool
#     invalid_reason: Optional[str] = None


# def evaluate_omr_validity(submission_answer_meta: Dict[str, Any]) -> OMRValidity:
#     """
#     SubmissionAnswer.meta["omr"] Í∏∞Î∞òÏúºÎ°ú OMR Ïú†Ìö®ÏÑ± ÌåêÎã® (STEP 1 Í≥†Ï†ï)
#     - low_confidenceÎ©¥ 0Ï†ê Ï≤òÎ¶¨
#     - ambiguous/multi/blankÏùÄ ÎÑàÏùò Ï±ÑÏ†ê Ï†ïÏ±ÖÏóê Îî∞Îùº 0Ï†ê/Î∂ÄÎ∂ÑÏ†ê Îì± ÌôïÏû• Í∞ÄÎä•ÌïòÏßÄÎßå
#       STEP 1ÏóêÏÑúÎäî ÏµúÏÜåÌïú low_confÎäî Î¨¥Ï°∞Í±¥ Î¨¥Ìö®Î°ú Í≥†Ï†ï.
#     """
#     omr = (submission_answer_meta or {}).get("omr") or {}
#     conf = omr.get("confidence")
#     status = str(omr.get("status") or "").lower()

#     try:
#         conf_f = float(conf) if conf is not None else None
#     except Exception:
#         conf_f = None

#     # ‚úÖ Î™ÖÏãúÏ†ÅÏúºÎ°ú low_confidenceÎ©¥ Î¨¥Ìö®
#     if status == "low_confidence":
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     # ‚úÖ confidence Í∞íÏù¥ ÏûàÍ≥† ÏûÑÍ≥ÑÏπò ÎØ∏ÎßåÏù¥Î©¥ Î¨¥Ìö®
#     if conf_f is not None and conf_f < MIN_OMR_CONFIDENCE:
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     return OMRValidity(is_valid=True, invalid_reason=None)


# def grade_subjective_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     Ï£ºÍ¥ÄÏãù exact match Ï±ÑÏ†ê (STEP 1 Í≥†Ï†ï)
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def grade_choice_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     Í∞ùÍ¥ÄÏãù exact match Í∏∞Î≥∏ (A/B/C/D)
#     - Îã§Ï§ëÎßàÌÇπ Ï≤òÎ¶¨/Î∂ÄÎ∂ÑÏ†êÏùÄ STEP 2 Ïù¥ÌõÑ ÌôïÏû• Ìè¨Ïù∏Ìä∏
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def evaluate_pass_fail(total_score: float, pass_score: float) -> bool:
#     """
#     ÏãúÌóò Îã®ÏúÑ pass/fail (STEP 1 Í≥†Ï†ï)
#     """
#     try:
#         return float(total_score) >= float(pass_score)
#     except Exception:
#         return False


==========================================================================================
# FILE: services/grading_service.py
==========================================================================================
from __future__ import annotations

from django.db import transaction

from apps.domains.results.models import ExamResult
from apps.domains.results.services.exam_grading_service import ExamGradingService
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


@transaction.atomic
def grade_submission(submission_id: int) -> ExamResult:
    service = ExamGradingService()
    result = service.auto_grade_objective(submission_id=int(submission_id))

    # ‚úÖ ÏãúÌóò Ï±ÑÏ†ê ÏôÑÎ£å ‚Üí progress / clinic ÏûêÎèô Í∞±Ïã†
    dispatch_progress_pipeline(submission_id=int(submission_id))

    return result


==========================================================================================
# FILE: services/question_stats_service.py
==========================================================================================
# apps/domains/results/services/question_stats_service.py
from __future__ import annotations

from typing import Dict, List, Optional
from django.db.models import Count, Avg, Max, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.models import ResultFact


class QuestionStatsService:
    """
    ÏãúÌóò Î¨∏Ìï≠ ÌÜµÍ≥Ñ Îã®Ïùº ÏßÑÏã§ (Ï†ïÏÑù)

    üî• Í∏∞Ï§Ä:
    - ResultFact (append-only)Îßå ÏÇ¨Ïö©
    - Result / ResultItem / attempt ÍµêÏ≤¥ Ïó¨Î∂ÄÏôÄ Î¨¥Í¥Ä
    - Ïö¥ÏòÅ/ÌÜµÍ≥Ñ/Î∂ÑÏÑù ÏùºÍ¥ÄÏÑ± Î≥¥Ïû•
    """

    # ======================================================
    # A) Î¨∏Ìï≠Î≥Ñ Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    # ======================================================
    @staticmethod
    def per_question_stats(
        *,
        exam_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        Î¨∏Ìï≠Î≥Ñ ÌÜµÍ≥Ñ
        - ÏùëÏãú Ïàò
        - Ï†ïÎãµ Ïàò
        - Ï†ïÎãµÎ•†
        - ÌèâÍ∑† Ï†êÏàò
        - ÏµúÎåÄ Ï†êÏàò
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct=Count("id", filter=Q(is_correct=True)),
                avg_score=Avg("score"),
                max_score=Max("score"),
            )
            .annotate(
                accuracy=ExpressionWrapper(
                    F("correct") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                )
            )
            .order_by("question_id")
        )

        return [
            {
                "question_id": row["question_id"],
                "attempts": int(row["attempts"] or 0),
                "correct": int(row["correct"] or 0),
                "accuracy": round(float(row["accuracy"] or 0.0), 4),
                "avg_score": float(row["avg_score"] or 0.0),
                "max_score": float(row["max_score"] or 0.0),
            }
            for row in rows
        ]

    # ======================================================
    # B) Î¨∏Ìï≠ Îã®Ïùº Ïò§Îãµ Î∂ÑÌè¨ (ÏÑ†ÌÉùÏßÄ Í∏∞Ï§Ä)
    # ======================================================
    @staticmethod
    def wrong_choice_distribution(
        *,
        exam_id: int,
        question_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> Dict[str, int]:
        """
        Í∞ùÍ¥ÄÏãù Ïò§Îãµ Î∂ÑÌè¨
        - answer Í∞í Í∏∞Ï§Ä
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            question_id=int(question_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = qs.values("answer").annotate(cnt=Count("id"))

        dist: Dict[str, int] = {}
        for r in rows:
            key = str(r["answer"] or "")
            dist[key] = int(r["cnt"] or 0)

        return dist

    # ======================================================
    # C) Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ Î¨∏Ìï≠ TOP N
    # ======================================================
    @staticmethod
    def top_n_wrong_questions(
        *,
        exam_id: int,
        n: int = 5,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ Î¨∏Ìï≠ TOP N
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(wrong_count=Count("id"))
            .order_by("-wrong_count")[: int(n)]
        )

        return [
            {
                "question_id": int(r["question_id"]),
                "wrong_count": int(r["wrong_count"]),
            }
            for r in rows
        ]


==========================================================================================
# FILE: services/session_score_summary_service.py
==========================================================================================
# apps/domains/results/services/session_score_summary_service.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.models import ExamAttempt
from apps.domains.progress.models import SessionProgress
from apps.domains.progress.models import ClinicLink
from apps.domains.lectures.models import Session

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exam_ids_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class SessionScoreSummaryService:
    """
    ‚úÖ Session Îã®ÏúÑ ÏÑ±Ï†Å ÌÜµÍ≥Ñ (Ïö¥ÏòÅ/ÎåÄÏãúÎ≥¥Îìú)

    Îã®Ïùº ÏßÑÏã§ Í∑úÏπô:
    - Ï†êÏàò ÌÜµÍ≥Ñ: Result(Îã®, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥ Ï†ÅÏö©)
    - ÏÑ∏ÏÖò ÌÜµÍ≥ºÏú®: SessionProgress.completed(ÌòπÏùÄ Ï†ïÏ±ÖÏóê Îî∞Îùº exam_passed) Ï§ë Î¨¥ÏóáÏù∏ÏßÄ 'Ï†ïÏùò'Í∞Ä ÌïÑÏöîÌïòÏßÄÎßå
      Í∏∞Ï°¥ ÏõêÎ≥∏ÏùÄ completedÎ•º ÏÇ¨Ïö©ÌñàÏúºÎØÄÎ°ú ÏõêÎ≥∏ ÏùòÎØ∏Î•º Ï°¥Ï§ëÌïúÎã§.
    - ÌÅ¥Î¶¨Îãâ: ClinicLink (is_auto=True, enrollment distinct)

    ‚ö†Ô∏è ÏÑ∏ÏÖò1:ÏãúÌóòN Íµ¨Ï°∞ Î∞òÏòÅ:
    - sessionÏóê Ïó∞Í≤∞Îêú exam_idÎì§ÏùÑ Î™®Îëê Í∞ÄÏ†∏ÏôÄÏÑú ÌÜµÍ≥ÑÎ•º ÎßåÎì†Îã§.
    - Îã§Îßå "ÏÑ∏ÏÖò Ï†ÑÏ≤¥ Ï†êÏàò"Î•º 1Í∞ú Ïà´ÏûêÎ°ú ÎßåÎì§ ÎïåÎäî ÏßëÍ≥Ñ Ï†ÑÎûµÏù¥ ÌïÑÏöîÌï®.
      Ïù¥ ÏÑúÎπÑÏä§Îäî "ÏÑ∏ÏÖò Ïö¥ÏòÅ ÌÜµÍ≥Ñ" ÏÑ±Í≤©Ïù¥ÎØÄÎ°ú:
        - Ï†êÏàò ÏßëÍ≥ÑÎäî Ïö∞ÏÑ† exams Ï†ÑÏ≤¥ ResultÎ•º Ìï©Ï≥ê ÌèâÍ∑†/ÏµúÏÜå/ÏµúÎåÄÎ•º Íµ¨ÌïòÎäî Î≥¥ÏàòÏ†Å Î∞©ÏãùÏúºÎ°ú Ï†úÍ≥µ.
      (Ï†ïÍµêÌïú Ï†ÑÎûµÏùÄ AdminSessionExamsSummaryViewÏóêÏÑú examÎ≥ÑÎ°ú Ï†úÍ≥µÌïòÎäî Í≤ÉÏù¥ Ï†ïÏÑù)
    """

    @staticmethod
    def build(*, session_id: int) -> dict:
        EMPTY_SUMMARY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "attempt_stats": {
                "avg_attempts": 0.0,
                "retake_ratio": 0.0,
            },
        }

        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return EMPTY_SUMMARY

        exam_ids = get_exam_ids_for_session(session)
        if not exam_ids:
            # ÏÑ∏ÏÖòÏóê ÏãúÌóòÏù¥ ÏóÜÏúºÎ©¥ Ï†êÏàò ÌÜµÍ≥ÑÎäî 0, pass/clinicÏùÄ progressÎ°úÎßå ÌåêÎã® Í∞ÄÎä•
            progresses = SessionProgress.objects.filter(session=session)
            participant_count = progresses.count()
            pass_count = progresses.filter(completed=True).count()
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id").distinct().count()
            )
            return {
                **EMPTY_SUMMARY,
                "participant_count": int(participant_count),
                "pass_rate": round((pass_count / participant_count), 4) if participant_count else 0.0,
                "clinic_rate": round((clinic_count / participant_count), 4) if participant_count else 0.0,
            }

        # -------------------------------------------------
        # participant Î™®Ïàò: SessionProgress Í∏∞Ï§Ä(ÏõêÎ≥∏ Ï°¥Ï§ë)
        # -------------------------------------------------
        progresses = SessionProgress.objects.filter(session=session)
        participant_count = progresses.count()

        # -------------------------------------------------
        # pass_rate: ÏõêÎ≥∏ÏùÄ SessionProgress.completed Í∏∞Ï§Ä
        # -------------------------------------------------
        pass_count = progresses.filter(completed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # clinic_rate: ClinicLink Í∏∞Ï§Ä Îã®ÏùºÌôî
        # -------------------------------------------------
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id")
            .distinct()
            .count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # Ï†êÏàò ÌÜµÍ≥Ñ:
        # - ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú Î™®Îì† ÏãúÌóòÏùò ResultÎ•º Î™®ÏïÑÏÑú ÌÜµÍ≥Ñ
        # - enrollment Ï§ëÎ≥µ Î∞©Ïñ¥: examÎ≥Ñ latest_results_per_enrollment Ï†ÅÏö© ÌõÑ Ìï©ÏπòÍ∏∞
        # -------------------------------------------------
        all_results = []
        for exid in exam_ids:
            rs = list(latest_results_per_enrollment(target_type="exam", target_id=int(exid)))
            all_results.extend(rs)

        if not all_results:
            score_summary = {"avg_score": 0.0, "min_score": 0.0, "max_score": 0.0}
        else:
            scores = [float(r.total_score or 0.0) for r in all_results]
            score_summary = {
                "avg_score": (sum(scores) / len(scores)) if scores else 0.0,
                "min_score": min(scores) if scores else 0.0,
                "max_score": max(scores) if scores else 0.0,
            }

        # -------------------------------------------------
        # Attempt ÌÜµÍ≥Ñ(Ïû¨ÏãúÌóò ÎπÑÏú®):
        # - ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú Î™®Îì† ÏãúÌóòÏùÑ ÎåÄÏÉÅÏúºÎ°ú attempt ÌÜµÍ≥Ñ
        # -------------------------------------------------
        attempts = ExamAttempt.objects.filter(exam_id__in=[int(x) for x in exam_ids])

        per_enrollment = (
            attempts.values("enrollment_id")
            .annotate(cnt=Count("id"))
        )

        total_attempts = sum(int(r["cnt"] or 0) for r in per_enrollment)
        retake_users = sum(1 for r in per_enrollment if int(r["cnt"] or 0) > 1)

        avg_attempts = (total_attempts / participant_count) if participant_count else 0.0
        retake_ratio = (retake_users / participant_count) if participant_count else 0.0

        return {
            "participant_count": int(participant_count),
            "avg_score": float(score_summary["avg_score"]),
            "min_score": float(score_summary["min_score"]),
            "max_score": float(score_summary["max_score"]),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_rate": round(float(clinic_rate), 4),
            "attempt_stats": {
                "avg_attempts": round(float(avg_attempts), 2),
                "retake_ratio": round(float(retake_ratio), 4),
            },
        }


==========================================================================================
# FILE: services/wrong_note_service.py
==========================================================================================
# apps/domains/results/services/wrong_note_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Q
from django.utils import timezone

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import ExamQuestion, AnswerKey, Exam


# ======================================================
# Request DTO
# ======================================================
@dataclass(frozen=True)
class WrongNoteQuery:
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå ÌååÎùºÎØ∏ÌÑ∞

    ‚úÖ STEP 3-3 ÏäπÍ≤©
    - lecture_id/from_session_order ÌïÑÌÑ∞Î•º ÏÑúÎπÑÏä§ Ï±ÖÏûÑÏúºÎ°ú ÎÅåÏñ¥Ïò¨Î¶º
      (View/Worker/PDF Î™®Îëê Í∞ôÏùÄ Í∑úÏπô ÏÇ¨Ïö©)

    - offset/limitÏùÄ Îã®Ïàú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò
    """
    exam_id: Optional[int] = None
    lecture_id: Optional[int] = None
    from_session_order: int = 2

    offset: int = 0
    limit: int = 50


# ======================================================
# Internal helpers
# ======================================================
def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _has_relation(model, name: str) -> bool:
    """
    Exam Î™®Îç∏Ïóê ÌäπÏ†ï relation(name)Ïù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ Í≤ÄÏÇ¨
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


def _get_exam_ids_by_lecture_and_order(*, lecture_id: int, from_order: int) -> List[int]:
    """
    lecture_id + from_session_orderÎ°ú exam_id Î™©Î°ù Íµ¨ÌïòÍ∏∞

    ‚ö†Ô∏è ÌîÑÎ°úÏ†ùÌä∏Î≥ÑÎ°ú Exam ‚Üî Session reverse relation Ïù¥Î¶ÑÏù¥ Îã§Î•º Ïàò ÏûàÏùå:
    - sessions / session / session_set ...
    Í∑∏ÎûòÏÑú Í∞ÄÎä•Ìïú ÌõÑÎ≥¥Îì§ÏùÑ Î™®Îëê Í≤ÄÏÇ¨Ìï¥ ÏïàÏ†ÑÌïòÍ≤å ÌïÑÌÑ∞ÎßÅ.

    ‚úÖ Í∑úÏπô:
    - Í¥ÄÍ≥ÑÎ•º Î™ª Ï∞æÏúºÎ©¥ Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò(=ÏïàÏ†ÑÌïòÍ≤å Í≤∞Í≥º ÏóÜÏùå)
    """
    exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

    # Ïö∞ÏÑ†ÏàúÏúÑ ÌõÑÎ≥¥Îì§
    # 1) sessions
    if _has_relation(Exam, "sessions"):
        exam_qs = exam_qs.filter(sessions__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 2) session (1:1 ÌòπÏùÄ FK)
    if _has_relation(Exam, "session"):
        exam_qs = exam_qs.filter(session__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 3) session_set (Django default reverse name)
    if _has_relation(Exam, "session_set"):
        exam_qs = exam_qs.filter(session_set__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # Î™ª Ï∞æÏúºÎ©¥ ÏïàÏ†ÑÌïòÍ≤å none
    return []


def _get_answer_key_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey v2 (Í≥†Ï†ï):
      answers = { "123": "B", ... }  # key = ExamQuestion.id(str)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    answers = getattr(ak, "answers", None) if ak else None
    return answers if isinstance(answers, dict) else {}


# ======================================================
# Public API
# ======================================================
def list_wrong_notes_for_enrollment(
    *,
    enrollment_id: int,
    q: WrongNoteQuery,
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    ‚úÖ ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Ïùò ResultFact Íµ¨Ï°∞Ïóê ÎßûÎäî ‚ÄúÏ†ïÏÑù‚Äù Íµ¨ÌòÑ

    ResultFact = Î¨∏Ìï≠ 1Í∞ú Ïù¥Î≤§Ìä∏(append-only)
      - question_id/answer/is_correct/score/max_score/meta/source Í∞Ä FactÏóê ÏßÅÏ†ë ÏûàÏùå

    Î∞òÌôò: (total_count, paged_items)
    """

    enrollment_id = int(enrollment_id)
    offset = max(int(q.offset or 0), 0)
    limit = max(min(int(q.limit or 50), 200), 1)

    base = ResultFact.objects.filter(
        enrollment_id=enrollment_id,
        target_type="exam",
        is_correct=False,          # Ïò§ÎãµÎßå
    )

    # 1) exam_id ÌïÑÌÑ∞
    if q.exam_id is not None:
        base = base.filter(target_id=int(q.exam_id))

    # 2) lecture_id + from_session_order ÌïÑÌÑ∞ (STEP 3-3 ÏäπÍ≤©)
    if q.lecture_id is not None:
        exam_ids = _get_exam_ids_by_lecture_and_order(
            lecture_id=int(q.lecture_id),
            from_order=int(q.from_session_order or 2),
        )
        if not exam_ids:
            return 0, []
        base = base.filter(target_id__in=exam_ids)

    # ÏµúÏã† Ïò§Îãµ Ïö∞ÏÑ†
    base = base.order_by("-id")

    total = base.count()

    facts = list(base[offset: offset + limit])

    # ÏßàÎ¨∏ Ï†ïÎ≥¥/Ï†ïÎãµÌÇ§ Î∂ôÏù¥Í∏∞ ÏúÑÌï¥ question_ids, exam_ids ÏàòÏßë
    question_ids = [int(f.question_id) for f in facts]
    exam_ids = list({int(f.target_id) for f in facts})

    questions_map = (
        ExamQuestion.objects
        .filter(id__in=question_ids)
        .select_related("sheet")
        .in_bulk(field_name="id")
    )

    answer_key_cache: Dict[int, Dict[str, Any]] = {
        exid: _get_answer_key_map(exid) for exid in exam_ids
    }

    out: List[Dict[str, Any]] = []

    for f in facts:
        exid = int(f.target_id)
        qobj = questions_map.get(int(f.question_id))

        question_number = getattr(qobj, "number", None) if qobj else None
        answer_type = (getattr(qobj, "answer_type", "") or "") if qobj else ""

        correct_answer = ""
        if qobj:
            correct_answer = str(answer_key_cache.get(exid, {}).get(str(qobj.id)) or "")

        out.append({
            "exam_id": exid,
            "attempt_id": int(getattr(f, "attempt_id", 0) or 0),
            # attempt_created_at ÌïÑÎìúÍ∞Ä Îî∞Î°ú ÏóÜÏúºÎãà created_atÏùÑ ÏÇ¨Ïö©
            "attempt_created_at": getattr(f, "created_at", None),

            "question_id": int(f.question_id),
            "question_number": _safe_int(question_number),
            "answer_type": str(answer_type),

            "student_answer": str(f.answer or ""),
            "correct_answer": str(correct_answer or ""),

            "is_correct": False,
            "score": float(f.score or 0.0),
            "max_score": float(f.max_score or 0.0),

            "meta": f.meta if f.meta is not None else {},
            "extra": {},
        })

    return total, out


==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from __future__ import annotations

import logging

logger = logging.getLogger(__name__)

try:
    from celery import shared_task  # type: ignore
except Exception:  # pragma: no cover
    # Celery ÎØ∏ÏÇ¨Ïö© ÌôòÍ≤ΩÏóêÏÑúÎèÑ import errorÎ°ú ÏÑúÎ≤ÑÍ∞Ä Ï£ΩÏúºÎ©¥ Ïïà ÎêúÎã§.
    def shared_task(*dargs, **dkwargs):  # type: ignore
        def _decorator(fn):
            return fn
        return _decorator


@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=True, retry_kwargs={"max_retries": 5})
def grade_submission_task(self, submission_id: int) -> dict:
    """
    AI callbacks ‚Üí Ï±ÑÏ†ê enqueue Ïö©.
    - Ïû¨ÏãúÎèÑÎäî Celery Î†àÎ≤®ÏóêÏÑú Ï≤òÎ¶¨(Ïö¥ÏòÅ Ï†ïÏÑù).
    """
    from apps.domains.results.services.grading_service import grade_submission

    r = grade_submission(int(submission_id))
    payload = {
        "ok": True,
        "submission_id": int(submission_id),
        "exam_result_id": int(getattr(r, "id")),
        "total_score": float(getattr(r, "total_score", 0.0) or 0.0),
        "is_passed": bool(getattr(r, "is_passed", False)),
        "status": str(getattr(r, "status", "")),
    }
    logger.info("grade_submission_task done: %s", payload)
    return payload


==========================================================================================
# FILE: utils/clinic.py
==========================================================================================
# apps/domains/results/utils/clinic.py
from __future__ import annotations

from typing import Set

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink


def get_clinic_enrollment_ids_for_session(
    *,
    session: Session,
    include_manual: bool = False,
) -> Set[int]:
    """
    ‚úÖ Clinic Îã®Ïùº Í∑úÏπô Ï†úÍ≥µ

    Í∏∞Î≥∏ Ï†ïÏ±Ö(Í∂åÏû•/ÏïàÏ†Ñ):
    - Ïö¥ÏòÅÏóêÏÑú clinic_required/clinic_rateÎäî 'ÏûêÎèô Ìä∏Î¶¨Í±∞' Í∏∞Ï§ÄÏúºÎ°ú ÌÜµÏùºÌïúÎã§.
      -> include_manual=False (default)

    ÏôúÎÉêÌïòÎ©¥:
    - ÏàòÎèô ÌÅ¥Î¶¨Îãâ(Í∞ïÏÇ¨ Ï∂îÏ≤ú/ÏöîÏ≤≠)ÏùÄ UX/Ïö¥ÏòÅ Ï†ïÏ±ÖÏóê Îî∞Îùº ÏºÄÏù¥Ïä§Í∞Ä Îã¨ÎùºÏÑú
      ÌÜµÍ≥ÑÏóê ÏÑûÏù¥Î©¥ ÌôîÎ©¥ÎßàÎã§ "Ïôú Îã§Î•¥ÎÉê" Î¨∏Ï†úÍ∞Ä Î∞òÎ≥µÎêúÎã§.

    ÌïÑÏöîÌïòÎ©¥ include_manual=TrueÎ°ú
    ÏàòÎèôÍπåÏßÄ Ìè¨Ìï®Ìïú 'Ï†ÑÏ≤¥ clinic ÎåÄÏÉÅ'ÏùÑ ÎßåÎì§ Ïàò ÏûàÎã§.
    """
    qs = ClinicLink.objects.filter(session=session)

    # ‚úÖ ÏàòÏ†ïÏÇ¨Ìï≠(Ï∂îÍ∞Ä): ÏòàÏïΩ ÏôÑÎ£åÎ°ú Î∂ÑÎ¶¨Îêú ÎåÄÏÉÅÏûêÎäî clinic_requiredÏóêÏÑú Ï†úÏô∏
    qs = qs.filter(resolved_at__isnull=True)

    if not include_manual:
        qs = qs.filter(is_auto=True)

    return set(qs.values_list("enrollment_id", flat=True).distinct())


def is_clinic_required(
    *,
    session: Session,
    enrollment_id: int,
    include_manual: bool = False,
) -> bool:
    """
    ‚úÖ enrollment Îã®ÏúÑ clinic Ïó¨Î∂Ä (Îã®Ïùº ÏßÑÏã§)
    """
    enrollment_id = int(enrollment_id)
    ids = get_clinic_enrollment_ids_for_session(
        session=session,
        include_manual=include_manual,
    )
    return enrollment_id in ids


==========================================================================================
# FILE: utils/result_queries.py
==========================================================================================
# apps/domains/results/utils/result_queries.py
from __future__ import annotations

from django.db.models import Max, QuerySet, Subquery

from apps.domains.results.models import Result


def latest_results_per_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> QuerySet[Result]:
    """
    ‚úÖ ÌÜµÍ≥Ñ/ÏßëÍ≥ÑÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî 'ÏµúÏã† Result' queryset (enrollment Í∏∞Ï§Ä 1Í∞ú)

    Ïôú ÌïÑÏöîÌïúÍ∞Ä?
    - unique_togetherÍ∞Ä ÏûàÏñ¥ÎèÑ Ïö¥ÏòÅÏóêÏÑúÎäî:
        - Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Íπ®Ïßê
        - manual insert
        - Ïû•Ïï† Î≥µÍµ¨/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ïàò
      Î°ú ÎèôÏùº enrollmentÏùò ResultÍ∞Ä Ï§ëÎ≥µÎê† Ïàò ÏûàÎã§.
    - ÌÜµÍ≥ÑÎäî Ï§ëÎ≥µÏùÑ Í≥†Î†§ÌïòÏßÄ ÏïäÏúºÎ©¥ participant/avg/min/max Ï†ÑÎ∂Ä ÏôúÍ≥°.

    Íµ¨ÌòÑ Î∞©Ïãù:
    - enrollment_idÎ≥ÑÎ°ú Í∞ÄÏû• ÌÅ∞ id(Í∞ÄÏû• ÏµúÍ∑º insert)Î•º ÏÑ†ÌÉù
    - DB vendor ÎèÖÎ¶Ω (PostgresÏùò distinct on Í∞ôÏùÄ Í∏∞Îä•Ïóê ÏùòÏ°¥ÌïòÏßÄ ÏïäÏùå)
    """
    target_id = int(target_id)

    base = Result.objects.filter(
        target_type=str(target_type),
        target_id=target_id,
    )

    # enrollmentÎ≥Ñ Í∞ÄÏû• ÏµúÏã† Result.idÎ•º ÏÑ†ÌÉù
    latest_ids = (
        base.values("enrollment_id")
        .annotate(last_id=Max("id"))
        .values("last_id")
    )

    return Result.objects.filter(id__in=Subquery(latest_ids))


def participant_count_distinct_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> int:
    """
    ‚úÖ participant_count Îã®Ïùº Í∑úÏπô: distinct enrollment Í∏∞Ï§Ä
    """
    return (
        Result.objects.filter(
            target_type=str(target_type),
            target_id=int(target_id),
        )
        .values("enrollment_id")
        .distinct()
        .count()
    )


==========================================================================================
# FILE: utils/session_exam.py
==========================================================================================
# apps/domains/results/utils/session_exam.py
from __future__ import annotations

from typing import List, Optional

from django.db.models import QuerySet

from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _has_relation(model, name: str) -> bool:
    """
    Î™®Îç∏Ïóê ÌäπÏ†ï field/relationÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ Í≤ÄÏÇ¨.
    ÌîÑÎ°úÏ†ùÌä∏ ÌûàÏä§ÌÜ†Î¶¨(ÏÑ∏ÏÖò-ÏãúÌóò Í¥ÄÍ≥ÑÍ∞Ä Î∞îÎÄåÎäî Í≥ºÏ†ï)ÏóêÏÑú
    Îü∞ÌÉÄÏûÑÏóê ÏïàÏ†ÑÌïòÍ≤å ÎèôÏûëÏãúÌÇ§Í∏∞ ÏúÑÌïú Î∞©Ïñ¥ Ïú†Ìã∏.
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


# ---------------------------------------------------------------------
# ‚úÖ Canonical API: Session -> Exams
# ---------------------------------------------------------------------
def get_exams_for_session(session: Session) -> QuerySet[Exam]:
    """
    ‚úÖ Îã®Ïùº ÏßÑÏã§: SessionÏóê Ïó∞Í≤∞Îêú Exam queryset Î∞òÌôò
    """
    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams") and hasattr(session, "exams"):
        try:
            return session.exams.all()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Exam.objects.filter(sessions__id=int(session.id)).distinct()

    # 3) Legacy fallback: Session.exam (FK)
    exam_id = getattr(session, "exam_id", None)
    if exam_id:
        return Exam.objects.filter(id=int(exam_id))

    return Exam.objects.none()


def get_exam_ids_for_session(session: Session) -> List[int]:
    """
    ‚úÖ Session -> exam_id list
    """
    return list(get_exams_for_session(session).values_list("id", flat=True))


# ---------------------------------------------------------------------
# ‚úÖ Canonical API: Exam -> Sessions
# ---------------------------------------------------------------------
def get_sessions_for_exam(exam_id: int) -> QuerySet[Session]:
    """
    ‚úÖ Îã®Ïùº ÏßÑÏã§: ÌäπÏ†ï exam_idÍ∞Ä ÏÜçÌïú Session queryset Î∞òÌôò
    """
    exam_id = int(exam_id)

    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams"):
        try:
            return Session.objects.filter(exams__id=exam_id).distinct()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Session.objects.filter(exams__id=exam_id).distinct()

    # 3) legacy: Session.exam FK
    return Session.objects.filter(exam_id=exam_id).distinct()


def get_primary_session_for_exam(exam_id: int) -> Optional[Session]:
    """
    ‚úÖ ÎåÄÌëú session Î∞òÌôò
    """
    qs = get_sessions_for_exam(int(exam_id))
    if not qs.exists():
        return None

    if hasattr(Session, "order"):
        try:
            return qs.order_by("order", "id").first()
        except Exception:
            pass

    return qs.order_by("id").first()


# ---------------------------------------------------------------------
# ‚úÖ NEW: Canonical API (ProgressPipelineÏö©)
# ---------------------------------------------------------------------
def get_session_ids_for_exam(exam_id: int) -> List[int]:
    """
    ‚úÖ Exam -> session_id list (SSOT)

    - Progress / Result / ÌÜµÍ≥Ñ / ÏïåÎ¶º Îì±ÏóêÏÑú
      "ÏãúÌóò Í≤∞Í≥º ‚Üí Ïñ¥Îñ§ Ï∞®ÏãúÎ•º Í∞±Ïã†Ìï¥Ïïº ÌïòÎäîÍ∞Ä"Î•º
      ÌåêÎã®Ìï† Îïå ÏÇ¨Ïö©ÌïòÎäî **Ïú†ÏùºÌïú Ìï®Ïàò**
    """
    return list(
        get_sessions_for_exam(int(exam_id))
        .values_list("id", flat=True)
    )


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/domains/results/views/__init__.py
# apps/domains/results/views/__init__.py

"""
results.views public exports

==========================================================================================
‚úÖ STEP 2 ‚Äî "Result vs ExamResult" Í≥µÏ°¥ Í∑úÏπô (Î¨∏ÏÑúÌôî, ÎèôÏûë Î≥ÄÍ≤Ω ÏóÜÏùå)
==========================================================================================

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Îäî Ïó≠ÏÇ¨Ï†ÅÏúºÎ°ú Îëê Í∞úÏùò Í≤∞Í≥º Î™®Îç∏Ïù¥ Í≥µÏ°¥Ìï† Ïàò ÏûàÎã§.

1) apps.domains.results.models.Result / ResultItem / ResultFact / ExamAttempt
   - Î™©Ï†Å: "ÏãúÌóò Ïö¥ÏòÅ/Ïû¨ÏãúÌóò/ÎåÄÌëú attempt/append-only" Í∏∞Î∞òÏùò SSOT
   - Admin/Teacher ÌÜµÍ≥Ñ, Ïû¨Ï±ÑÏ†ê, ÎåÄÌëú attempt ÍµêÏ≤¥, Ïò§ÎãµÎÖ∏Ìä∏(append-only Fact Í∏∞Î∞ò) Îì±Ïóê ÏÇ¨Ïö©
   - Ïù¥ Í≥ÑÏó¥ APIÎäî target_type="exam" + target_id(exam_id) + enrollment_idÍ∞Ä ÌïµÏã¨ ÌÇ§

2) apps.domains.results.models.exam_result.ExamResult
   - Î™©Ï†Å: Î†àÍ±∞Ïãú public API Ìò∏Ìôò (/api/v1/results/*) Î∞è Í≥ºÍ±∞ Í∏∞Îä• Ïú†ÏßÄ
   - ÌòÑÌñâ SSOT(Result/Fact)Î°ú ÏôÑÏ†Ñ ÌÜµÌï©ÌïòÍ∏∞ Ï†ÑÍπåÏßÄ "ÏÇ≠Ï†ú/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò" Í∏àÏßÄ
   - Ïù¥ Í≥ÑÏó¥ APIÎäî Í∏∞Ï°¥ ÌîÑÎ°†Ìä∏/Ïö¥ÏòÅÏù¥ ÏùòÏ°¥Ìï† Ïàò ÏûàÏúºÎØÄÎ°ú Í≥ÑÏïΩÏùÑ Î≥¥Ï°¥ÌïúÎã§.

ÏõêÏπô:
- Ïã†Í∑ú Í∏∞Îä•/Ï†ïÌï©ÏÑ± ÌïµÏã¨ÏùÄ 1) Result/Fact/Attempt Í∏∞Î∞òÏúºÎ°ú Íµ¨ÌòÑÌïúÎã§.
- 2) ExamResultÎäî "Ìò∏Ìôò Î†àÏù¥Ïñ¥"Î°úÎßå Ïú†ÏßÄÌïúÎã§.
- ÎëòÏùÑ ÏñµÏßÄÎ°ú Î≥ëÌï©ÌïòÍ±∞ÎÇò Î™®Îç∏ÏùÑ ÏÇ≠Ï†úÌïòÏßÄ ÏïäÎäîÎã§. (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïú†Î∞ú Í∏àÏßÄ)
==========================================================================================
"""

# ======================================================
# Student-facing
# ======================================================
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

# ======================================================
# Admin / Teacher-facing (ÎåÄÌëú ViewÎßå)
# ======================================================
from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView

__all__ = [
    "MyExamResultView",
    "WrongNoteView",
    "AdminExamResultsView",
    "AdminExamSummaryView",
]


==========================================================================================
# FILE: views/admin_clinic_targets_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_clinic_targets_view.py
"""
Ïó≠Ìï†
- Admin/TeacherÏö© ÌÅ¥Î¶¨Îãâ ÎåÄÏÉÅÏûê Ï°∞Ìöå API

Endpoint
- GET /results/admin/clinic-targets/

ÏÑ§Í≥Ñ Í≥ÑÏïΩ (Ï§ëÏöî)
- ÎåÄÏÉÅÏûê ÏÑ†Ï†ï Îã®Ïùº ÏßÑÏã§: progress.ClinicLink(is_auto=True)
- enrollment_id Í∏∞Ï§Ä
- Í≥ÑÏÇ∞/ÌåêÏ†ïÏùÄ Service(ClinicTargetService)Ïóê ÏúÑÏûÑ
- ÏùëÎãµ Ïä§ÌÇ§ÎßàÎäî AdminClinicTargetSerializerÎ°ú Í≥†Ï†ï (ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ)

Î≥¥Î•òÎêú Í∏∞Îä• (Î™ÖÏãú)
- pagination ÌïÑÏöî Ïãú Ï∂îÌõÑ DRF pagination ÎèÑÏûÖ Í∞ÄÎä•
- ÌòÑÏû¨Îäî Ïö¥ÏòÅÏóêÏÑú "Ï†ÑÏ≤¥ ÎåÄÏÉÅÏûê"Í∞Ä ÏÜåÏàòÎùºÎäî Í∞ÄÏ†ï ÌïòÏóê listÎ°ú Î∞òÌôò
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.clinic_target_service import ClinicTargetService
from apps.domains.results.serializers.admin_clinic_target import AdminClinicTargetSerializer


class AdminClinicTargetsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        rows = ClinicTargetService.list_admin_targets()
        return Response(AdminClinicTargetSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_attempts_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_attempts_view.py
# ==========================================================================================
"""
Admin Exam Attempt List View

GET /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

==========================================================================================
‚úÖ Î™©Ï†Å (Phase 1)
==========================================================================================
- Admin / TeacherÍ∞Ä ÌäπÏ†ï ÏãúÌóò(exam_id) + ÌäπÏ†ï enrollmentÏùò
  ExamAttempt Î™©Î°ùÏùÑ Ï°∞ÌöåÌïúÎã§.
- AttemptSelectorPanelÏùò Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§

==========================================================================================
‚úÖ Í≥ÑÏïΩ (ÌîÑÎ°†Ìä∏ Í≥†Ï†ï)
==========================================================================================
ÏùëÎãµ:
[
  {
    "id": 101,
    "attempt_index": 1,
    "is_retake": false,
    "is_representative": true,
    "status": "done",
    "created_at": "2025-01-01T10:00:00Z",
    "meta": {
      "grading": {
        "total_score": 85,
        "total_max_score": 100
      }
    }
  }
]

- Ï†ïÎ†¨: attempt_index ASC
- ÎåÄÌëú attempt: Ìï≠ÏÉÅ 1Í∞ú Î≥¥Ïû• (ÏÑúÎ≤Ñ invariant)
- status enum:
    pending | grading | done | failed

==========================================================================================
‚ö†Ô∏è Ï£ºÏùò
==========================================================================================
- ÏàòÏ†ï/ÎåÄÌëú Î≥ÄÍ≤Ω ‚ùå (Phase 2ÏóêÏÑú Íµ¨ÌòÑ)
- enrollment_idÎäî Enrollment PK Í∏∞Ï§Ä (results ÎèÑÎ©îÏù∏ Ï†ÑÏ≤¥ Í≥ÑÏïΩÍ≥º ÎèôÏùº)
"""

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt


class AdminExamAttemptsView(APIView):
    """
    Admin / Teacher Ï†ÑÏö© Attempt Î™©Î°ù Ï°∞Ìöå
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        # -------------------------------------------------
        # 1Ô∏è‚É£ Attempt Ï°∞Ìöå
        # -------------------------------------------------
        attempts = (
            ExamAttempt.objects
            .filter(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .order_by("attempt_index")  # ‚úÖ ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ
        )

        if not attempts.exists():
            # Îπà Î∞∞Ïó¥ÏùÑ ÎÇ¥Î†§ÎèÑ ÎêòÏßÄÎßå,
            # Admin ÌôîÎ©¥ÏóêÏÑúÎäî Î≥¥ÌÜµ "Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå"Ïù¥ ÏùòÎØ∏ ÏûàÎäî Ïò§Î•òÎùº ÌåêÎã®
            raise ValidationError("No attempts found for this exam/enrollment.")

        # -------------------------------------------------
        # 2Ô∏è‚É£ ÏùëÎãµ Íµ¨ÏÑ± (Serializer ÏóÜÏù¥ Î™ÖÏãúÏ†Å dict)
        #    - ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ ÏïàÏ†ïÏÑ±
        #    - meta Íµ¨Ï°∞Î•º Í∑∏ÎåÄÎ°ú ÎÖ∏Ï∂ú Í∞ÄÎä•
        # -------------------------------------------------
        data = []
        for a in attempts:
            row = {
                "id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": bool(a.is_retake),
                "is_representative": bool(a.is_representative),
                "status": a.status,
                "created_at": a.created_at,
            }

            # meta ÌïÑÎìúÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏ÎåÄÎ°ú ÎÖ∏Ï∂ú (grading Ï†ïÎ≥¥ Ìè¨Ìï® Í∞ÄÎä•)
            if hasattr(a, "meta") and a.meta is not None:
                row["meta"] = a.meta
            else:
                row["meta"] = {}

            data.append(row)

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_item_score_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_item_score_view.py
# (ÎèôÏûë Î≥ÄÍ≤Ω ÏóÜÏùå: Ïù¥ÎØ∏ progress Ìä∏Î¶¨Í±∞ Ìè¨Ìï®)
# ÏïÑÎûò ÌååÏùºÏùÄ "PHASE 7 Ï¢ÖÎ£å Í∏∞Ï§Ä" Î¨∏ÏÑúÎßå Î≥¥Í∞ïÌïòÍ≥† Î°úÏßÅÏùÄ Í∑∏ÎåÄÎ°ú ÎëîÎã§.

from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultItem, ResultFact, ExamAttempt

# ‚úÖ Îã®Ïùº ÏßÑÏã§: session Îß§Ìïë + progress Ìä∏Î¶¨Í±∞
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminExamItemScoreView(APIView):
    """
    PATCH /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

    ‚úÖ PHASE 7 Í∏∞Ï§Ä (Í≥†Ï†ï)
    - ÏàòÎèô Ï±ÑÏ†êÏùÄ ResultFact(append-only) + ResultItem Ïä§ÎÉÖÏÉ∑ Í∞±Ïã†ÏúºÎ°ú Í∏∞Î°ùÌïúÎã§.
    - total_score/max_scoreÎäî ResultItem Ìï©ÏúºÎ°ú Ïû¨Í≥ÑÏÇ∞ÌïúÎã§.
    - Î≥ÄÍ≤Ω Ï¶âÏãú progress pipelineÏùÑ Ìä∏Î¶¨Í±∞ÌïòÏó¨ SessionProgress/ClinicLink Îì± ÌååÏÉù Í≤∞Í≥ºÎ•º ÏµúÏã†ÌôîÌïúÎã§.

    üö´ Í∏àÏßÄ
    - Î™®Îç∏/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïú†Î∞ú Î≥ÄÍ≤Ω
    - ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ Î≥ÄÍ≤Ω
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @transaction.atomic
    def patch(
        self,
        request,
        exam_id: int,
        enrollment_id: int,
        question_id: int,
    ):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        question_id = int(question_id)

        if "score" not in request.data:
            raise ValidationError({"detail": "score is required", "code": "INVALID"})

        try:
            new_score = float(request.data.get("score"))
        except Exception:
            raise ValidationError({"detail": "score must be number", "code": "INVALID"})

        # -------------------------------------------------
        # 1Ô∏è‚É£ Result (ÎåÄÌëú Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .select_for_update()
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .first()
        )
        if not result:
            raise NotFound({"detail": "result not found", "code": "NOT_FOUND"})

        if not result.attempt_id:
            raise ValidationError(
                {"detail": "representative attempt not set", "code": "INVALID"}
            )

        # -------------------------------------------------
        # 2Ô∏è‚É£ Attempt ÏÉÅÌÉú ÌôïÏù∏ (LOCK)
        # -------------------------------------------------
        attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
        if not attempt:
            raise NotFound({"detail": "attempt not found", "code": "NOT_FOUND"})

        if attempt.status == "grading":
            return Response(
                {"detail": "attempt is grading", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 3Ô∏è‚É£ ResultItem (Î¨∏Ìï≠ Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        item = (
            ResultItem.objects
            .select_for_update()
            .filter(result=result, question_id=question_id)
            .first()
        )
        if not item:
            raise NotFound({"detail": "result item not found", "code": "NOT_FOUND"})

        # Ï†êÏàò ÏÉÅÌïú Î∞©Ïñ¥
        max_score = float(item.max_score or 0.0)
        if new_score < 0 or new_score > max_score:
            raise ValidationError(
                {
                    "detail": f"score must be between 0 and {max_score}",
                    "code": "INVALID",
                }
            )

        # -------------------------------------------------
        # 4Ô∏è‚É£ ResultFact (append-only Î°úÍ∑∏)
        # -------------------------------------------------
        ResultFact.objects.create(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=0,              # ÏàòÎèô Ï±ÑÏ†êÏù¥ÎØÄÎ°ú 0
            attempt_id=int(result.attempt_id),

            question_id=question_id,
            answer=item.answer or "",
            is_correct=bool(new_score >= max_score),
            score=float(new_score),
            max_score=max_score,
            source="manual",
            meta={
                "manual": True,
                "edited_at": timezone.now().isoformat(),
            },
        )

        # -------------------------------------------------
        # 5Ô∏è‚É£ ResultItem ÏóÖÎç∞Ïù¥Ìä∏
        # -------------------------------------------------
        item.score = float(new_score)
        item.is_correct = bool(new_score >= max_score)
        item.source = "manual"
        item.save(update_fields=["score", "is_correct", "source"])

        # -------------------------------------------------
        # 6Ô∏è‚É£ total_score Ïû¨Í≥ÑÏÇ∞
        # -------------------------------------------------
        agg = ResultItem.objects.filter(result=result)

        total_score = sum(float(x.score or 0.0) for x in agg)
        max_total = sum(float(x.max_score or 0.0) for x in agg)

        result.total_score = float(total_score)
        result.max_score = float(max_total)
        result.save(update_fields=["total_score", "max_score"])

        # -------------------------------------------------
        # 7Ô∏è‚É£ progress pipeline Ï¶âÏãú Ìä∏Î¶¨Í±∞
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "question_id": question_id,
                "score": float(new_score),
                "total_score": float(total_score),
                "max_score": float(max_total),
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_exam_result_detail_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_result_detail_view.py
# ==========================================================================================
"""
Admin Exam Result Detail View (Îã®Ïùº ÌïôÏÉù Í≤∞Í≥º ÏÉÅÏÑ∏)

GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/

==========================================================================================
‚úÖ PHASE 3 ÌôïÏ†ï Í≥ÑÏïΩ (FRONTEND LOCK)
==========================================================================================
ÏùëÎãµ Î≥¥Ïû• ÌïÑÎìú:
- passed                : Exam.pass_score Í∏∞Ï§Ä ÏãúÌóò Ìï©Î∂à
- clinic_required       : ClinicLink Îã®Ïùº ÏßÑÏã§ (ÏûêÎèô Ìä∏Î¶¨Í±∞Îßå)
- items[].is_editable   : edit_state Í∏∞Î∞ò
- edit_state            : LOCK ÌåêÎã® Î©îÌÉÄ
- allow_retake
- max_attempts
- can_retake

‚ö†Ô∏è Ï£ºÏùò
- passed ‚â† SessionProgress.exam_passed
- Ïù¥ APIÎäî "ÏãúÌóò Îã®ÏúÑ(Result) ÏßÑÏã§"
"""

from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)

from apps.domains.exams.models import Exam

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class AdminExamResultDetailView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        exam = get_object_or_404(Exam, id=exam_id)
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0)

        # -------------------------------------------------
        # 1Ô∏è‚É£ Result (ÎåÄÌëú Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )
        if not result:
            raise NotFound("result not found")

        # -------------------------------------------------
        # 2Ô∏è‚É£ passed (ÏãúÌóò Îã®ÏúÑ Í∏∞Ï§Ä)
        # -------------------------------------------------
        passed = bool(float(result.total_score or 0.0) >= pass_score)

        # -------------------------------------------------
        # 3Ô∏è‚É£ Ïû¨ÏãúÌóò Ï†ïÏ±Ö (‚ö†Ô∏è Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_qs = ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        )
        attempt_count = attempt_qs.count()
        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4Ô∏è‚É£ clinic_required (Îã®Ïùº ÏßÑÏã§)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,
            )

        # -------------------------------------------------
        # 5Ô∏è‚É£ edit_state (LOCK Í∑úÏπô)
        # -------------------------------------------------
        edit_state = {
            "can_edit": True,
            "is_locked": False,
            "lock_reason": None,
            "last_updated_by": None,
            "updated_at": None,
        }

        if result.attempt_id:
            attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
            if attempt and attempt.status == "grading":
                edit_state.update({
                    "can_edit": False,
                    "is_locked": True,
                    "lock_reason": "GRADING",
                })

        # -------------------------------------------------
        # 6Ô∏è‚É£ Serializer + items[].is_editable
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data

        for item in data.get("items", []):
            item["is_editable"] = bool(
                edit_state["can_edit"] and not edit_state["is_locked"]
            )

        # -------------------------------------------------
        # 7Ô∏è‚É£ ÏµúÏ¢Ö ÏùëÎãµ (Í∏∞Ï°¥ Í≥ÑÏïΩ + PHASE 3 ÌôïÏû•)
        # -------------------------------------------------
        data.update({
            "passed": passed,
            "allow_retake": allow_retake,
            "max_attempts": max_attempts,
            "can_retake": can_retake,
            "clinic_required": bool(clinic_required),
            "edit_state": edit_state,
        })

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_results_view.py
from __future__ import annotations

from rest_framework.generics import ListAPIView
from rest_framework.pagination import PageNumberPagination
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission
from apps.domains.exams.models import Exam

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamResultsView(ListAPIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    ‚úÖ Î™©Ìëú(ÏõêÎ≥∏ Ïú†ÏßÄ + Ï†ïÌï©ÏÑ± Í∞ïÌôî)
    - Result(Ïä§ÎÉÖÏÉ∑) Í∏∞Î∞ò Ï†êÏàò Î¶¨Ïä§Ìä∏
    - Attempt/Submission ÏÉÅÌÉú Ïó∞Í≤∞
    - Clinic Í∏∞Ï§Ä ÌÜµÏùº(ClinicLink)
    - Session‚ÜîExam Îß§Ìïë Îã®ÏùºÌôî(utils.session_exam)

    ‚ö†Ô∏è pass Í∏∞Ï§Ä Ï†ïÏùò:
    - Ïù¥ ÌôîÎ©¥ÏùÄ "ÏãúÌóò(exam) Îã®ÏúÑ Í≤∞Í≥º"Ïù¥ÎØÄÎ°ú
      pass/failÏùÄ Exam.pass_score Í∏∞Ï§ÄÏúºÎ°ú Ï†úÍ≥µÌïúÎã§.
    - ÏÑ∏ÏÖò Ï¢ÖÌï© ÌÜµÍ≥º(SessionProgress.exam_passed)Îäî
      /admin/sessions/... summary APIÏóêÏÑú Ï†úÍ≥µÌïòÎäî Í≤ÉÏù¥ Ï†ïÏÑù.

    ÏùëÎãµ: { "count", "next", "previous", "results": AdminExamResultRow[] }
    ?page=1 Î°ú ÌéòÏù¥ÏßÄ Ï†ëÍ∑º Í∞ÄÎä•.
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]
    pagination_class = PageNumberPagination
    serializer_class = AdminExamResultRowSerializer

    def get_queryset(self):
        exam_id = self.kwargs.get("exam_id")
        if exam_id is None:
            return Result.objects.none()
        return (
            latest_results_per_enrollment(
                target_type="exam",
                target_id=int(exam_id),
            )
            .order_by("enrollment_id")
        )

    def list(self, request, *args, **kwargs):
        exam_id = int(self.kwargs["exam_id"])

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        queryset = self.get_queryset()

        # -------------------------------------------------
        # ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò: Result querysetÏùÑ Î®ºÏ†Ä ÌéòÏù¥ÏßÄ Ï≤òÎ¶¨
        # -------------------------------------------------
        page = self.paginate_queryset(queryset)
        if page is None:
            return self.get_paginated_response([])

        results = page

        # -------------------------------------------------
        # Session Ï∞æÍ∏∞ (clinic ÌåêÎã®Ïö©)
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)

        # -------------------------------------------------
        # Student Ï°∞Ìöå (ÏõêÎ≥∏ Î°úÏßÅ Ïú†ÏßÄ)
        # -------------------------------------------------
        student_map = {}
        try:
            from apps.domains.progress.models import SessionProgress

            if session:
                progress_rows = SessionProgress.objects.filter(session=session)
            else:
                progress_rows = SessionProgress.objects.none()

            student_ids = set()
            for sp in progress_rows:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
                if sid:
                    student_ids.add(int(sid))

            student_map = {
                s.id: s
                for s in Student.objects.filter(id__in=list(student_ids))
            }
        except Exception:
            student_map = {}

        # -------------------------------------------------
        # enrollment_id ‚Üí ÏµúÏã† attempt/submission Îßµ (exam Ï†ÑÏ≤¥ Í∏∞Ï§Ä)
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(target_type="exam", target_id=exam_id)
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values("enrollment_id", "attempt_id", "submission_id")
        )

        latest_map = {}
        for row in fact_qs:
            eid = int(row["enrollment_id"])
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": int(row["attempt_id"]),
                    "submission_id": int(row["submission_id"]),
                }

        # Result.attempt_id fallback (ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Í≤∞Í≥ºÎßå)
        attempt_ids = [r.attempt_id for r in results if getattr(r, "attempt_id", None)]
        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = int(r.enrollment_id)
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue
            a = attempt_map.get(int(aid))
            if not a:
                continue
            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # Submission.status (ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî submissionÎßå)
        submission_ids = [
            v["submission_id"]
            for v in latest_map.values()
            if v.get("submission_id")
        ]
        submission_status_map = (
            {s.id: s.status for s in Submission.objects.filter(id__in=submission_ids)}
            if submission_ids
            else {}
        )

        # -------------------------------------------------
        # rows Íµ¨ÏÑ± (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
        # -------------------------------------------------
        rows = []
        for r in results:
            enrollment_id = int(r.enrollment_id)

            student_name = "-"
            try:
                student_name = "-"
            except Exception:
                student_name = "-"

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = (
                submission_status_map.get(submission_id) if submission_id else None
            )

            passed = bool(float(r.total_score or 0.0) >= float(pass_score))

            clinic_required = bool(
                session
                and is_clinic_required(
                    session=session,
                    enrollment_id=enrollment_id,
                    include_manual=False,
                )
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student_name,

                "exam_score": float(r.total_score or 0.0),
                "exam_max_score": float(r.max_score or 0.0),

                "final_score": float(r.total_score or 0.0),

                "passed": passed,
                "clinic_required": clinic_required,

                "submitted_at": r.submitted_at,

                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        serializer = AdminExamResultRowSerializer(rows, many=True)
        return self.get_paginated_response(serializer.data)


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.admin_exam_summary import AdminExamSummarySerializer
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ClinicLink

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamSummaryView(APIView):
    """
    LEGACY COMPAT
    GET /results/admin/exams/<exam_id>/summary/

    ‚úÖ Í≥ÑÏïΩ Ïú†ÏßÄ(ÌîÑÎ°†Ìä∏ ÏïàÏ†ïÏÑ±):
    - participant_count, avg/min/max, pass_count/fail_count/pass_rate, clinic_count

    ‚úÖ Ï†ïÌï©ÏÑ± Í∞ïÌôî:
    - Result Ï§ëÎ≥µ enrollment Î∞©Ïñ¥: ÏµúÏã† ResultÎßå ÏßëÍ≥Ñ
    - clinic_count Í∏∞Ï§Ä ÌÜµÏùº: ClinicLink(is_auto=True) enrollment distinct
    - Session‚ÜîExam Îß§Ìïë Îã®ÏùºÌôî(utils.session_exam)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        EMPTY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_count": 0,
            "fail_count": 0,
            "pass_rate": 0.0,
            "clinic_count": 0,
        }

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # ‚úÖ Ï§ëÎ≥µ Î∞©Ïñ¥: enrollmentÎãπ ÏµúÏã† ResultÎßå
        rs = latest_results_per_enrollment(target_type="exam", target_id=exam_id)

        participant_count = rs.values("enrollment_id").distinct().count()
        if participant_count == 0:
            return Response(AdminExamSummarySerializer(EMPTY).data)

        agg = rs.aggregate(
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_count = rs.filter(total_score__gte=pass_score).count()
        fail_count = rs.filter(total_score__lt=pass_score).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # ‚úÖ clinic_countÎäî session Í∏∞Î∞òÏúºÎ°úÎßå Í≥ÑÏÇ∞ Í∞ÄÎä•(ÏãúÌóòÎßåÏúºÎ°† clinicÏù¥ Ï†ïÏùòÎêòÏßÄ ÏïäÏùå)
        clinic_count = 0
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id")
                .distinct()
                .count()
            )

        payload = {
            "participant_count": int(participant_count),
            "avg_score": float(agg["avg_score"] or 0.0),
            "min_score": float(agg["min_score"] or 0.0),
            "max_score": float(agg["max_score"] or 0.0),
            "pass_count": int(pass_count),
            "fail_count": int(fail_count),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_count": int(clinic_count),
        }

        return Response(AdminExamSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_representative_attempt_view.py
# (ÎèôÏûë Î≥ÄÍ≤Ω ÏóÜÏùå: Ïù¥ÎØ∏ Ïä§ÎÉÖÏÉ∑ Ïû¨ÎπåÎìú + progress Ìä∏Î¶¨Í±∞ Ìè¨Ìï®)
# ÏïÑÎûò ÌååÏùºÏùÄ PHASE 7 Ï¢ÖÎ£å Í∏∞Ï§Ä Î¨∏ÏÑúÎßå Î≥¥Í∞ïÌïòÍ≥† Î°úÏßÅÏùÄ Í∑∏ÎåÄÎ°ú ÎëîÎã§.

from __future__ import annotations

from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result, ResultItem, ResultFact

# ‚úÖ Îã®Ïùº ÏßÑÏã§: session Îß§Ìïë + progress Ìä∏Î¶¨Í±∞
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.submissions.models import Submission
from apps.domains.progress.dispatcher import dispatch_progress_pipeline


class AdminRepresentativeAttemptView(APIView):
    """
    POST /results/admin/exams/<exam_id>/representative-attempt/

    ‚úÖ PHASE 7 Í∏∞Ï§Ä (Í≥†Ï†ï)
    - ÎåÄÌëú attempt Î≥ÄÍ≤ΩÏùÄ "is_representative"Îßå Î∞îÍæ∏Îäî ÌñâÏúÑÍ∞Ä ÏïÑÎãàÎã§.
    - Result Ïä§ÎÉÖÏÉ∑(Result/ResultItem)ÏùÄ ÏÑ†ÌÉùÎêú attemptÏùò Fact(append-only)ÏóêÏÑú Ï¶âÏãú Ïû¨Íµ¨ÏÑ±ÌïúÎã§.
    - Ïù¥ÌõÑ progress pipelineÏùÑ Ï¶âÏãú Ìä∏Î¶¨Í±∞ÌïòÏó¨ ÌååÏÉù Í≤∞Í≥ºÎ•º ÏµúÏã†ÌôîÌïúÎã§.

    üö´ Í∏àÏßÄ
    - Î™®Îç∏/ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïú†Î∞ú Î≥ÄÍ≤Ω
    - ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ Î≥ÄÍ≤Ω
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _rebuild_result_snapshot_from_attempt(
        *,
        exam_id: int,
        enrollment_id: int,
        attempt_id: int,
    ) -> Result:
        result = (
            Result.objects
            .select_for_update()
            .filter(target_type="exam", target_id=exam_id, enrollment_id=enrollment_id)
            .first()
        )
        if not result:
            raise NotFound({"detail": "result snapshot not found", "code": "NOT_FOUND"})

        latest_fact_ids = (
            ResultFact.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
                attempt_id=attempt_id,
            )
            .values("question_id")
            .annotate(last_id=Max("id"))
            .values("last_id")
        )

        facts = list(ResultFact.objects.filter(id__in=latest_fact_ids))
        if not facts:
            raise ValidationError({"detail": "no facts for this attempt; cannot rebuild snapshot", "code": "INVALID"})

        total = 0.0
        max_total = 0.0

        for f in facts:
            score = float(f.score or 0.0)
            max_score = float(f.max_score or 0.0)

            ResultItem.objects.update_or_create(
                result=result,
                question_id=int(f.question_id),
                defaults={
                    "answer": str(f.answer or ""),
                    "is_correct": bool(f.is_correct),
                    "score": score,
                    "max_score": max_score,
                    "source": str(f.source or ""),
                },
            )
            total += score
            max_total += max_score

        result.attempt_id = int(attempt_id)
        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()
        result.save(update_fields=["attempt_id", "total_score", "max_score", "submitted_at", "updated_at"])

        return result

    @transaction.atomic
    def post(self, request, exam_id: int):
        exam_id = int(exam_id)

        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if enrollment_id is None or attempt_id is None:
            raise ValidationError({"detail": "enrollment_id and attempt_id are required", "code": "INVALID"})

        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        attempts_qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        if not attempts_qs.exists():
            raise NotFound({"detail": "attempts not found for this exam/enrollment", "code": "NOT_FOUND"})

        target = attempts_qs.filter(id=attempt_id).first()
        if not target:
            raise NotFound({"detail": "attempt not found for this exam/enrollment", "code": "NOT_FOUND"})

        if (target.status or "").lower() == "grading":
            return Response(
                {"detail": "attempt is grading; cannot switch representative", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        attempts_qs.filter(is_representative=True).update(is_representative=False)
        if not target.is_representative:
            target.is_representative = True
            target.save(update_fields=["is_representative"])

        self._rebuild_result_snapshot_from_attempt(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            attempt_id=attempt_id,
        )

        session = get_primary_session_for_exam(exam_id)
        if not session:
            return Response(
                {"detail": "session not found for this exam; cannot recalculate progress", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        submission = (
            Submission.objects
            .filter(enrollment_id=enrollment_id, session_id=int(session.id))
            .order_by("-id")
            .first()
        )
        if not submission:
            return Response(
                {"detail": "no submission found; cannot recalculate progress", "code": "NO_SUBMISSION"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        dispatch_progress_pipeline(int(submission.id))

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "attempt_id": attempt_id,
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_result_fact_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_result_fact_view.py
"""
Admin ResultFact Debug View

GET /results/admin/facts/?exam_id=&enrollment_id=&limit=100

‚ö†Ô∏è Î™©Ï†Å:
- Ïö¥ÏòÅ/CS/ÎîîÎ≤ÑÍπÖ
- append-only Fact ÏßÅÏ†ë Ï°∞Ìöå
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ResultFact


class AdminResultFactView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        exam_id = request.query_params.get("exam_id")
        enrollment_id = request.query_params.get("enrollment_id")
        limit = int(request.query_params.get("limit", 100))

        qs = ResultFact.objects.all().order_by("-id")

        if exam_id:
            qs = qs.filter(target_type="exam", target_id=int(exam_id))
        if enrollment_id:
            qs = qs.filter(enrollment_id=int(enrollment_id))

        qs = qs[: min(limit, 500)]

        return Response([
            {
                "id": f.id,
                "exam_id": f.target_id,
                "enrollment_id": f.enrollment_id,
                "attempt_id": f.attempt_id,
                "question_id": f.question_id,
                "answer": f.answer,
                "is_correct": f.is_correct,
                "score": f.score,
                "max_score": f.max_score,
                "meta": f.meta,
                "created_at": f.created_at,
            }
            for f in qs
        ])


==========================================================================================
# FILE: views/admin_session_exams_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_session_exams_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.session_exams_summary import SessionExamsSummarySerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminSessionExamsSummaryView(APIView):
    """
    ‚úÖ Session Í∏∞Ï§Ä ÏãúÌóò ÏöîÏïΩ API (1 Session : N Exams)

    GET /results/admin/sessions/{session_id}/exams/summary/

    Îã®Ïùº ÏßÑÏã§ Í∑úÏπô:
    - ÏÑ∏ÏÖò Îã®ÏúÑ pass_rate: SessionProgress.exam_passed Í∏∞Î∞ò (ÏßëÍ≥Ñ Í≤∞Í≥º)
    - ÏÑ∏ÏÖò Îã®ÏúÑ clinic_rate: ClinicLink(is_auto=True) enrollment distinct Í∏∞Î∞ò
    - ÏãúÌóò Îã®ÏúÑ Ï†êÏàò ÌÜµÍ≥Ñ: Result(Îã®, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).select_related("lecture").first()
        if not session:
            return Response(
                SessionExamsSummarySerializer({
                    "session_id": int(session_id),
                    "participant_count": 0,
                    "pass_rate": 0.0,
                    "clinic_rate": 0.0,
                    "strategy": "MAX",
                    "pass_source": "EXAM",
                    "exams": [],
                }).data
            )

        # Ï†ïÏ±Ö(ÌëúÏãúÏö©)
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = str(getattr(policy, "exam_aggregate_strategy", "MAX"))
        pass_source = str(getattr(policy, "exam_pass_source", "EXAM"))

        # ‚úÖ ÏÑ∏ÏÖòÏóê Ïó∞Í≤∞Îêú exams (Îã®Ïùº ÏßÑÏã§)
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -----------------------------
        # session-level participant/pass/clinic
        # -----------------------------
        sp_qs = SessionProgress.objects.filter(session=session)
        participant_count = sp_qs.count()

        # ÏÑ∏ÏÖò Îã®ÏúÑ ÏãúÌóò ÌÜµÍ≥ºÏú®(ÏßëÍ≥Ñ Í≤∞Í≥º)
        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # clinic_rate(Îã®Ïùº Í∑úÏπô)
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -----------------------------
        # exam-level stats (Result Í∏∞Î∞ò, enrollment Ï§ëÎ≥µ Î∞©Ïñ¥)
        # -----------------------------
        exam_rows = []
        for ex in exams:
            rs = latest_results_per_enrollment(
                target_type="exam",
                target_id=int(ex.id),
            )

            agg = rs.aggregate(
                participant_count=Count("id"),  # Ïù¥ÎØ∏ enrollment 1Í∞úÏî©ÏúºÎ°ú Ï§ÑÏòÄÏúºÎãà count(id)=participant
                avg_score=Avg("total_score"),
                min_score=Min("total_score"),
                max_score=Max("total_score"),
            )

            pass_score = float(getattr(ex, "pass_score", 0.0) or 0.0)

            pcount = rs.filter(total_score__gte=pass_score).count()
            fcount = rs.filter(total_score__lt=pass_score).count()

            p_total = int(agg["participant_count"] or 0)
            p_rate = (pcount / p_total) if p_total else 0.0

            exam_rows.append({
                "exam_id": int(ex.id),
                "title": str(getattr(ex, "title", "") or ""),
                "pass_score": float(pass_score),

                "participant_count": p_total,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),

                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            })

        payload = {
            "session_id": int(session.id),
            "participant_count": int(participant_count),

            # ‚úÖ ÏùòÎØ∏ Í≥†Ï†ï:
            # pass_rate = SessionProgress.exam_passed Í∏∞Î∞ò (ÏßëÍ≥Ñ Í≤∞Í≥º)
            "pass_rate": round(float(pass_rate), 4),

            # ‚úÖ ÏùòÎØ∏ Í≥†Ï†ï:
            # clinic_rate = ClinicLink(is_auto=True) Í∏∞Ï§Ä
            "clinic_rate": round(float(clinic_rate), 4),

            "strategy": strategy,
            "pass_source": pass_source,
            "exams": exam_rows,

            # (Í∂åÏû•) pass_rate_source Í∞ôÏùÄ Î©îÌÉÄÎ•º serializerÏóê Ï∂îÍ∞ÄÌïòÎ©¥ ÏÇ¨Í≥† Î∞©ÏßÄÏóê ÌÅ∞ ÎèÑÏõÄ
            # "pass_rate_source": "SESSION_PROGRESS",
            # "clinic_rate_source": "CLINIC_LINK_AUTO",
        }

        return Response(SessionExamsSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_session_exams_view.py
==========================================================================================
"""
Admin Session ‚Üí Exams Ï°∞Ìöå

GET /results/admin/sessions/{session_id}/exams/

‚úÖ ÌòÑÏû¨ Í≥ÑÏïΩ(Î¶¨Ìå©ÌÜ†ÎßÅ ÏôÑÎ£å):
- Session 1 : Exam N
- canonical relation: exams.Exam.sessions (ManyToManyField to lectures.Session)

ÏùëÎãµÏùÄ Î¶¨Ïä§Ìä∏ ÌòïÌÉúÎ°ú Í≥†Ï†ï:
[
  {
    exam_id,
    title,
    exam_type,
    open_at,
    close_at,
    allow_retake,
    max_attempts
  },
  ...
]
"""

from django.utils.timezone import localtime
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _dt(v):
    """datetime ‚Üí ISO string | None (ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ Í≥†Ï†ï)"""
    return localtime(v).isoformat() if v else None


class AdminSessionExamsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _get_exams_for_session(session: Session) -> list[Exam]:
        """
        SessionÏóê Ïó∞Í≤∞Îêú Exam Î™©Î°ù Ï°∞Ìöå

        ‚úÖ canonical:
        - session.exams (Exam.sessions related_name="exams")

        Î∞©Ïñ¥Ï†Å fallback:
        - Exam.objects.filter(sessions=session)
        """
        if hasattr(session, "exams"):
            try:
                return list(session.exams.all())
            except Exception:
                pass

        return list(
            Exam.objects
            .filter(sessions__id=int(session.id))
            .distinct()
        )

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return Response([])

        exams = self._get_exams_for_session(session)
        if not exams:
            return Response([])

        return Response([
            {
                "exam_id": int(exam.id),
                "title": exam.title or "",
                "exam_type": exam.exam_type,          # ‚úÖ ÌîÑÎ°†Ìä∏ ÌïÑÌÑ∞/ÌëúÏãúÏö©
                "open_at": _dt(exam.open_at),         # ‚úÖ string | null
                "close_at": _dt(exam.close_at),       # ‚úÖ string | null
                "allow_retake": bool(exam.allow_retake),
                "max_attempts": int(exam.max_attempts),
            }
            for exam in exams
        ])


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

‚ùó ÏπòÎ™ÖÏ†Å Î≥¥Ïïà Ïù¥Ïäà ÏàòÏ†ï:
- Í∏∞Ï°¥: IsAuthenticated Îßå Í±∏Î†§ÏÑú ÌïôÏÉùÎèÑ Ï†ÑÏ≤¥ Attempt Ïó¥Îûå Í∞ÄÎä•
- Î≥ÄÍ≤Ω: Teacher/AdminÎßå Ï†ëÍ∑º Í∞ÄÎä•

ÌïÑÏöîÌïòÎ©¥ Ï∂îÌõÑ:
- ÌïôÏÉù Î≥∏Ïù∏ attemptÎßå Ï°∞ÌöåÌïòÎäî Î≥ÑÎèÑ ViewÎ•º /me/* Î°ú Îî∞Î°ú ÎßåÎì§ Í≤É
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ÏãúÌóò ÏãúÎèÑ(Attempt) Í¥ÄÎ¶¨ API (Í¥ÄÎ¶¨Ïûê/ÍµêÏÇ¨Ïö©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # ‚úÖ Î≥¥Ïïà ÏàòÏ†ï
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/exam_grading_view.py
==========================================================================================
# PATH: apps/domains/results/views/exam_grading_view.py
from __future__ import annotations

import logging
from typing import Any, Dict, Tuple

from django.db import transaction
from django.db.models import QuerySet

from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.views import APIView

from apps.core.permissions import IsAdminOrStaff

from apps.domains.results.models.exam_result import ExamResult
from apps.domains.results.serializers.exam_result import (
    ExamResultSerializer,
    ManualGradeSerializer,
)
from apps.domains.results.services.exam_grading_service import ExamGradingService

logger = logging.getLogger(__name__)


def _resolve_student_filter_path(user: Any) -> Tuple[str, Dict[str, Any]]:
    """
    ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ student ‚Üî submission Ïó∞Í≤∞ Í≤ΩÎ°ú Ï∞®Ïù¥Î•º Î∞©Ïñ¥Ï†ÅÏúºÎ°ú ÌÉêÏÉâ.
    """
    candidates = [
        ("submission__student__user", user),
        ("submission__student", user),
        ("submission__enrollment__student__user", user),
        ("submission__enrollment__student", user),
        ("submission__session_enrollment__enrollment__student__user", user),
        ("submission__session_enrollment__enrollment__student", user),
    ]

    for path, value in candidates:
        try:
            qs = ExamResult.objects.filter(**{path: value}).only("id")[:1]
            if qs:
                return path, {path: value}
        except Exception:
            continue

    return "id__isnull", {"id__isnull": True}


class AutoGradeSubmissionView(APIView):
    """
    ‚úÖ ÏÑúÎπÑÏä§ Î©îÏÑúÎìúÎ™Ö/Í≥ÑÏïΩÍ≥º ÏùºÏπò:
    - ExamGradingService.auto_grade_objective(submission_id=...)
    """
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def post(self, request, submission_id: int):
        service = ExamGradingService()
        out = service.auto_grade_objective(submission_id=int(submission_id))
        serializer = ExamResultSerializer(out.result)
        return Response(
            {"created": (not out.updated), "updated": bool(out.updated), "result": serializer.data},
            status=status.HTTP_201_CREATED if not out.updated else status.HTTP_200_OK,
        )


class ManualGradeSubmissionView(APIView):
    """
    ‚úÖ ÏÑúÎπÑÏä§ Î©îÏÑúÎìúÎ™Ö/Í≥ÑÏïΩÍ≥º ÏùºÏπò:
    - ExamGradingService.apply_manual_overrides(submission_id=..., overrides=...)
    """
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def put(self, request, submission_id: int):
        serializer = ManualGradeSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        overrides = serializer.validated_data.get("overrides")
        if overrides is None:
            # legacy callers might send overrides at top-level
            overrides = serializer.validated_data

        # overridesÎäî dict ÌòïÌÉú Í∏∞ÎåÄ (ÏÑúÎπÑÏä§ÏóêÏÑú dict[str, Any])
        if not isinstance(overrides, dict):
            return Response(
                {"detail": "overrides must be an object/dict"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        service = ExamGradingService()
        result = service.apply_manual_overrides(
            submission_id=int(submission_id),
            overrides=overrides,
        )

        return Response(ExamResultSerializer(result).data, status=status.HTTP_200_OK)


class FinalizeResultView(APIView):
    permission_classes = [IsAdminOrStaff]

    @transaction.atomic
    def post(self, request, submission_id: int):
        service = ExamGradingService()
        result = service.finalize(submission_id=int(submission_id))
        return Response(ExamResultSerializer(result).data, status=status.HTTP_200_OK)


class ExamResultAdminListView(ReadOnlyModelViewSet):
    permission_classes = [IsAdminOrStaff]
    serializer_class = ExamResultSerializer

    def get_queryset(self) -> QuerySet[ExamResult]:
        # ‚úÖ ExamResult Î™®Îç∏ Ïä§ÌÇ§ÎßàÏóê ÎßûÍ≤å select_related ÏµúÏÜåÌôî
        qs = ExamResult.objects.select_related("submission", "exam").all().order_by("-id")

        exam_id = self.request.query_params.get("exam_id")
        if exam_id:
            qs = qs.filter(exam_id=exam_id)

        # ExamResultÏóê student_id FKÍ∞Ä ÏóÜÏùÑ Ïàò ÏûàÏñ¥ ÏïàÏ†Ñ Ï≤òÎ¶¨:
        # (ÌïÑÎìúÍ∞Ä Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌîÑÎ°úÏ†ùÌä∏Î©¥ ÏïÑÎûò ÌïÑÌÑ∞Î•º ÌôúÏÑ±Ìôî Í∞ÄÎä•)
        student_id = self.request.query_params.get("student_id")
        if student_id and hasattr(ExamResult, "student_id"):
            qs = qs.filter(student_id=student_id)

        submission_id = self.request.query_params.get("submission_id")
        if submission_id:
            qs = qs.filter(submission_id=submission_id)

        return qs


class MyExamResultListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        qs = ExamResult.objects.select_related("exam", "submission").order_by("-id")

        exam_id = request.query_params.get("exam_id")
        if exam_id:
            qs = qs.filter(exam_id=exam_id)

        _, filter_kwargs = _resolve_student_filter_path(user)
        qs = qs.filter(**filter_kwargs)

        serializer = ExamResultSerializer(qs, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)


==========================================================================================
# FILE: views/internal_wrong_note_worker_views.py
==========================================================================================
# PATH: apps/domains/results/views/internal_wrong_note_worker_views.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional

from django.conf import settings
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status as drf_status
from rest_framework.permissions import AllowAny
from rest_framework.exceptions import PermissionDenied, NotFound, ValidationError

from apps.domains.results.models import WrongNotePDF
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)

# NOTE:
# - Celery Ï†ÑÎ©¥ ÌèêÏßÄ
# - WrongNote PDF ÏÉùÏÑ±ÏùÄ "Ïô∏Î∂Ä HTTP Worker"Í∞Ä ÏàòÌñâÌïúÎã§.
# - Worker Ïù∏Ï¶ùÏùÄ Bearer token (settings.INTERNAL_WORKER_TOKEN or settings.WORKER_TOKEN)
# - R2 ÏóÖÎ°úÎìúÎäî presigned PUT URL Í∏∞Î∞ò
#
# Contract:
#   GET  /api/v1/internal/wrong-note-worker/next/
#   GET  /api/v1/internal/wrong-note-worker/{job_id}/data/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/prepare-upload/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/complete/
#   POST /api/v1/internal/wrong-note-worker/{job_id}/fail/


def _get_worker_token() -> str:
    return (
        getattr(settings, "INTERNAL_WORKER_TOKEN", None)
        or getattr(settings, "WORKER_TOKEN", None)
        or ""
    )


def _assert_worker_auth(request) -> None:
    token = _get_worker_token()
    if not token:
        raise PermissionDenied("Internal worker token is not configured.")

    auth = request.headers.get("Authorization", "") or ""
    if not auth.lower().startswith("bearer "):
        raise PermissionDenied("Missing bearer token.")

    incoming = auth.split(" ", 1)[-1].strip()
    if incoming != token:
        raise PermissionDenied("Invalid worker token.")


def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _safe_str(v: Any) -> str:
    return str(v) if v is not None else ""


@dataclass(frozen=True)
class _NextPayload:
    job_id: int
    enrollment_id: int
    lecture_id: Optional[int]
    exam_id: Optional[int]
    from_session_order: int


class WrongNoteWorkerNextView(APIView):
    """
    Worker pulls the next queued job.

    ‚úÖ ÏÉÅÌÉúÍ∞í Îã®ÏùºÌôî(Î™®Îç∏ enum):
    - PENDING -> RUNNING -> DONE/FAILED

    Response:
    - 200 {"has_job": false}
    - 200 {"has_job": true, "job": {...}}
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def get(self, request):
        _assert_worker_auth(request)

        # 1) pick oldest queued job
        qs = (
            WrongNotePDF.objects
            .select_for_update(skip_locked=True)
            .filter(status__in=[WrongNotePDF.Status.PENDING])
            .order_by("id")
        )

        job = qs.first()
        if not job:
            return Response({"has_job": False})

        # 2) mark processing (lock)
        job.status = WrongNotePDF.Status.RUNNING
        job.error_message = ""
        job.save(update_fields=["status", "error_message", "updated_at"])

        payload = _NextPayload(
            job_id=int(job.id),
            enrollment_id=int(job.enrollment_id),
            lecture_id=_safe_int(getattr(job, "lecture_id", None), None),
            exam_id=_safe_int(getattr(job, "exam_id", None), None),
            from_session_order=int(getattr(job, "from_session_order", 2) or 2),
        )

        return Response({
            "has_job": True,
            "job": {
                "job_id": payload.job_id,
                "enrollment_id": payload.enrollment_id,
                "lecture_id": payload.lecture_id,
                "exam_id": payload.exam_id,
                "from_session_order": payload.from_session_order,
            },
        })


class WrongNoteWorkerJobDataView(APIView):
    """
    Worker fetches the data to render PDF (server-side SSOT).
    """

    permission_classes = [AllowAny]

    def get(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        # DONEÏù¥Î©¥ Îç∞Ïù¥ÌÑ∞ Ïû¨Ï†ÑÏÜ° ÎåÄÏã† ÏïàÏ†ï ÏùëÎãµ
        if str(job.status) == WrongNotePDF.Status.DONE:
            return Response({"job_id": int(job.id), "status": WrongNotePDF.Status.DONE, "count": 0, "items": []})

        # RUNNING/PENDING/FAILED ÏÉÅÌÉúÏóêÏÑú Ïû¨Ï°∞ÌöåÎäî ÌóàÏö©(ÏõåÏª§ Ïû¨ÏãúÎèÑ/Î≥µÍµ¨)
        q = WrongNoteQuery(
            exam_id=_safe_int(getattr(job, "exam_id", None), None),
            lecture_id=_safe_int(getattr(job, "lecture_id", None), None),
            from_session_order=int(getattr(job, "from_session_order", 2) or 2),
            offset=0,
            limit=200,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=int(job.enrollment_id),
            q=q,
        )

        return Response({
            "job_id": int(job.id),
            "status": str(job.status),
            "filters": {
                "enrollment_id": int(job.enrollment_id),
                "lecture_id": _safe_int(getattr(job, "lecture_id", None), None),
                "exam_id": _safe_int(getattr(job, "exam_id", None), None),
                "from_session_order": int(getattr(job, "from_session_order", 2) or 2),
            },
            "count": int(total),
            "items": items,
        })


class WrongNoteWorkerPrepareUploadView(APIView):
    """
    Worker asks server for a presigned PUT URL to upload PDF.
    """

    permission_classes = [AllowAny]

    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        if str(job.status) != WrongNotePDF.Status.RUNNING:
            raise ValidationError({"detail": "job is not running", "code": "INVALID_STATE"})

        file_key = f"results/wrong-notes/wrong-note-{int(job.id)}.pdf"

        try:
            from libs.s3_client.presign import create_presigned_put_url
        except Exception as e:
            return Response(
                {"detail": f"presign helper not available: {e}"},
                status=drf_status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

        upload_url = create_presigned_put_url(
            key=file_key,
            content_type="application/pdf",
            expires_in=60 * 10,
        )

        return Response({
            "job_id": int(job.id),
            "file_key": file_key,
            "upload_url": upload_url,
            "content_type": "application/pdf",
        })


class WrongNoteWorkerCompleteView(APIView):
    """
    Worker reports success after upload.

    POST body:
      { "file_path": "...", "meta": {...} }
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.select_for_update().filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        file_path = request.data.get("file_path") or request.data.get("file_key")
        if not file_path:
            raise ValidationError({"detail": "file_path is required", "code": "INVALID"})

        if str(job.status) != WrongNotePDF.Status.RUNNING:
            raise ValidationError({"detail": "job is not running", "code": "INVALID_STATE"})

        job.status = WrongNotePDF.Status.DONE
        job.file_path = str(file_path)
        job.error_message = ""

        meta = request.data.get("meta")
        if hasattr(job, "meta") and meta is not None:
            job.meta = meta
            job.save(update_fields=["status", "file_path", "error_message", "meta", "updated_at"])
        else:
            job.save(update_fields=["status", "file_path", "error_message", "updated_at"])

        return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.DONE, "file_path": str(job.file_path)})


class WrongNoteWorkerFailView(APIView):
    """
    Worker reports failure.

    POST body:
      { "error_message": "..." }
    """

    permission_classes = [AllowAny]

    @transaction.atomic
    def post(self, request, job_id: int):
        _assert_worker_auth(request)

        job = WrongNotePDF.objects.select_for_update().filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        msg = _safe_str(request.data.get("error_message") or request.data.get("detail") or "unknown error")[:5000]

        # DONEÏù¥Î©¥ Î©±Îì± Ï≤òÎ¶¨
        if str(job.status) == WrongNotePDF.Status.DONE:
            return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.DONE})

        job.status = WrongNotePDF.Status.FAILED
        job.error_message = msg
        job.save(update_fields=["status", "error_message", "updated_at"])

        return Response({"ok": True, "job_id": int(job.id), "status": WrongNotePDF.Status.FAILED})


==========================================================================================
# FILE: views/question_stats_views.py
==========================================================================================
# apps/domains/results/views/question_stats_views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.question_stats_service import QuestionStatsService
from apps.domains.results.serializers.question_stats import (
    QuestionStatSerializer,
    TopWrongQuestionSerializer,
)


class AdminExamQuestionStatsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/

    ‚úÖ Îã®Ïùº ÏßÑÏã§:
    - ResultFact Í∏∞Î∞ò (append-only)
    - ÎåÄÌëú attempt ÍµêÏ≤¥/Ïû¨ÏãúÌóò Ïó¨Î∂ÄÏôÄ Î¨¥Í¥ÄÌïòÍ≤å Ìï≠ÏÉÅ ÏùºÍ¥ÄÎêú ÌÜµÍ≥Ñ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        data = QuestionStatsService.per_question_stats(
            exam_id=int(exam_id),
        )
        return Response(QuestionStatSerializer(data, many=True).data)


class ExamQuestionWrongDistributionView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, question_id: int):
        dist = QuestionStatsService.wrong_choice_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
        )
        return Response(
            {
                "question_id": int(question_id),
                "distribution": dist,
            }
        )


class ExamTopWrongQuestionsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=5
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        n = int(request.query_params.get("n", 5))
        data = QuestionStatsService.top_n_wrong_questions(
            exam_id=int(exam_id),
            n=n,
        )
        return Response(TopWrongQuestionSerializer(data, many=True).data)


==========================================================================================
# FILE: views/session_score_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_score_summary_view.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.session_score_summary_service import (
    SessionScoreSummaryService,
)
from apps.domains.results.serializers.session_score_summary import (
    SessionScoreSummarySerializer,
)


class SessionScoreSummaryView(APIView):
    """
    GET /results/admin/sessions/<session_id>/score-summary/

    ‚úÖ results ÎèÑÎ©îÏù∏ Í∏∞Ï§Ä
    - Session Îã®ÏúÑ ÏÑ±Ï†Å ÌÜµÍ≥Ñ
    - Ïö¥ÏòÅ/ÎåÄÏãúÎ≥¥Îìú/AI Ï∂îÏ≤ú ÏûÖÎ†•Ïö©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        data = SessionScoreSummaryService.build(
            session_id=int(session_id)
        )
        return Response(SessionScoreSummarySerializer(data).data)


==========================================================================================
# FILE: views/session_scores_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_scores_view.py
"""
SessionScores API (FOR FRONTEND SCORE TAB)

GET /api/v1/results/admin/sessions/<session_id>/scores/

‚úÖ Î™©Ï†Å
- ÏÑ±Ï†Å ÌÉ≠ Î©îÏù∏ ÌÖåÏù¥Î∏îÏóêÏÑú ÌïôÏÉùÎ≥Ñ ÏãúÌóò/Í≥ºÏ†ú ÏöîÏïΩ + Ìé∏Ïßë ÏÉÅÌÉú ÌëúÏãú
- results + homework_results + progress Îç∞Ïù¥ÌÑ∞Î•º "Ï°∞Ìï©"Îßå ÌïúÎã§.

üö´ Í∏àÏßÄ
- Ï†êÏàò Í≥ÑÏÇ∞/Ï†ïÏ±Ö ÏÉùÏÑ±
- homework percent / cutline Í≥ÑÏÇ∞
- progress Í≤∞Í≥º ÏßÅÏ†ë ÎÖ∏Ï∂ú

‚úÖ Îã®Ïùº ÏßÑÏã§
- exam: results(Result + Exam.pass_score)
- homework: homework_results.HomeworkScore
- clinic_required: progress.ClinicLink(is_auto=True)

üìå Ï§ëÏöî ÏÑ§Í≥Ñ Í≤∞Ï†ï
- enrollment Î™®ÏàòÎäî SessionProgress ‚ùå
- ÏãúÌóò OR Í≥ºÏ†úÏóê Ìïú Î≤àÏù¥ÎùºÎèÑ Ïó∞Í≤∞Îêú Enrollment Í∏∞Ï§Ä ‚úÖ
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Set

from django.utils import timezone
from django.shortcuts import get_object_or_404
from django.db.models import Q

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment
from apps.domains.results.serializers.session_scores import SessionScoreRowSerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink

from apps.domains.homework_results.models import HomeworkScore
from apps.domains.homework_results.models import Homework
from apps.domains.homework.models import HomeworkAssignment

from apps.domains.enrollment.models import Enrollment
from apps.domains.exams.models import ExamEnrollment


def _safe_student_name(enrollment: Optional[Enrollment]) -> str:
    if not enrollment:
        return "-"

    try:
        if hasattr(enrollment, "student") and enrollment.student:
            for k in ("name", "full_name", "username"):
                v = getattr(enrollment.student, k, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        if hasattr(enrollment, "user") and enrollment.user:
            for k in ("name", "full_name", "username", "first_name"):
                v = getattr(enrollment.user, k, None)
                if isinstance(v, str) and v.strip():
                    return v.strip()

        for k in ("student_name", "name", "title"):
            v = getattr(enrollment, k, None)
            if isinstance(v, str) and v.strip():
                return v.strip()
    except Exception:
        pass

    return "-"


class SessionScoresView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = get_object_or_404(Session, id=int(session_id))

        # -------------------------------------------------
        # 0) Exams
        # -------------------------------------------------
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -------------------------------------------------
        # 1) Enrollment Î™®Ïàò (ÏãúÌóò OR Í≥ºÏ†ú)
        # -------------------------------------------------
        # ‚ùóÔ∏èFIX: HomeworkEnrollment ‚ùå
        # ‚úÖ Í≥ºÏ†ú ÎåÄÏÉÅÏûêÏùò Îã®Ïùº ÏßÑÏã§ÏùÄ HomeworkAssignment
        hw_enrollment_ids_qs = HomeworkAssignment.objects.filter(
            session=session
        ).values_list("enrollment_id", flat=True)

        if exam_ids:
            ex_enrollment_ids_qs = ExamEnrollment.objects.filter(
                exam_id__in=exam_ids
            ).values_list("enrollment_id", flat=True)

            enrollment_qs = Enrollment.objects.filter(
                Q(id__in=hw_enrollment_ids_qs)
                | Q(id__in=ex_enrollment_ids_qs)
            ).distinct()
        else:
            enrollment_qs = Enrollment.objects.filter(
                id__in=hw_enrollment_ids_qs
            ).distinct()

        enrollment_ids = list(enrollment_qs.values_list("id", flat=True))

        # -------------------------------------------------
        # 2) Meta (ÌîÑÎ°†Ìä∏ Í≥ÑÏïΩ)
        # -------------------------------------------------
        homeworks = list(
            Homework.objects.filter(session=session).order_by("id")
        )

        meta = {
            "exams": [
                {
                    "exam_id": int(ex.id),
                    "title": str(getattr(ex, "title", "")),
                    "pass_score": float(getattr(ex, "pass_score", 0.0) or 0.0),
                }
                for ex in exams
            ],
            "homeworks": [
                {
                    "homework_id": int(hw.id),
                    "title": str(hw.title),
                    "unit": None,  # ÏÑúÎ≤Ñ Îã®Ïùº ÏßÑÏã§
                }
                for hw in homeworks
            ],
        }

        if not enrollment_ids:
            return Response({"meta": meta, "rows": []})

        # -------------------------------------------------
        # 3) Clinic ÎåÄÏÉÅÏûê
        # -------------------------------------------------
        clinic_ids: Set[int] = set(
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values_list("enrollment_id", flat=True)
            .distinct()
        )

        # -------------------------------------------------
        # 4) Enrollment ‚Üí student_name
        # -------------------------------------------------
        enrollment_map = {
            int(e.id): e
            for e in Enrollment.objects.filter(id__in=enrollment_ids)
        }

        student_name_map = {
            eid: _safe_student_name(enrollment_map.get(eid))
            for eid in enrollment_ids
        }

        # -------------------------------------------------
        # 5) HomeworkScore map (enrollment ‚Üí homework ‚Üí score)
        # -------------------------------------------------
        hw_scores = HomeworkScore.objects.filter(
            session=session,
            enrollment_id__in=enrollment_ids,
        )

        hw_map: Dict[int, Dict[int, HomeworkScore]] = {}
        for hs in hw_scores:
            hw_map.setdefault(int(hs.enrollment_id), {})[int(hs.homework_id)] = hs

        # -------------------------------------------------
        # 6) Exam Result map
        # -------------------------------------------------
        result_map: Dict[int, Dict[int, Result]] = {}
        for exid in exam_ids:
            rs = (
                latest_results_per_enrollment(
                    target_type="exam",
                    target_id=int(exid),
                )
                .filter(enrollment_id__in=enrollment_ids)
            )
            result_map[int(exid)] = {int(r.enrollment_id): r for r in rs}

        # -------------------------------------------------
        # 7) Attempt LOCK ÏÉÅÌÉú
        # -------------------------------------------------
        attempt_ids = {
            int(r.attempt_id)
            for per_exam in result_map.values()
            for r in per_exam.values()
            if r.attempt_id
        }

        attempt_status_map = {
            int(a.id): str(a.status or "")
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        # -------------------------------------------------
        # 8) Exam Î©îÌÉÄ
        # -------------------------------------------------
        exam_pass_score_map = {
            int(ex.id): float(getattr(ex, "pass_score", 0.0) or 0.0)
            for ex in exams
        }
        exam_title_map = {
            int(ex.id): str(getattr(ex, "title", "") or "")
            for ex in exams
        }

        # -------------------------------------------------
        # 9) Rows
        # -------------------------------------------------
        rows: List[Dict[str, Any]] = []

        for eid in enrollment_ids:
            clinic_required = eid in clinic_ids

            exams_payload = []
            exam_updated_ats = []

            for exid in exam_ids:
                r = result_map.get(exid, {}).get(eid)

                if r is None:
                    block = {
                        "score": None,
                        "max_score": None,
                        "passed": None,
                        "clinic_required": clinic_required,
                        "is_locked": False,
                        "lock_reason": None,
                    }
                    updated_at = None
                else:
                    attempt_status = attempt_status_map.get(
                        int(r.attempt_id), ""
                    )
                    locked = attempt_status.lower() == "grading"

                    block = {
                        "score": float(r.total_score or 0.0),
                        "max_score": float(r.max_score or 0.0),
                        "passed": (
                            bool(r.passed)
                            if r.passed is not None
                            else None
                        ),
                        "clinic_required": clinic_required,
                        "is_locked": locked,
                        "lock_reason": "GRADING" if locked else None,
                    }
                    updated_at = r.updated_at

                if updated_at:
                    exam_updated_ats.append(updated_at)

                exams_payload.append(
                    {
                        "exam_id": exid,
                        "title": exam_title_map.get(exid, ""),
                        "pass_score": exam_pass_score_map.get(exid, 0.0),
                        "block": block,
                    }
                )

            homeworks_payload = []
            for hw in homeworks:
                hs = hw_map.get(eid, {}).get(int(hw.id))

                if hs is None:
                    block = {
                        "score": None,
                        "max_score": None,
                        "passed": None,
                        "clinic_required": clinic_required,
                        "is_locked": False,
                        "lock_reason": None,
                    }
                    updated_at = None
                else:
                    block = {
                        "score": hs.score,
                        "max_score": hs.max_score,
                        "passed": (
                            bool(hs.passed)
                            if hs.passed is not None
                            else None
                        ),
                        "clinic_required": clinic_required,
                        "is_locked": bool(hs.is_locked),
                        "lock_reason": hs.lock_reason,
                    }
                    updated_at = hs.updated_at

                homeworks_payload.append(
                    {
                        "homework_id": int(hw.id),
                        "title": str(hw.title),
                        "block": block,
                    }
                )

            updated_at = max(
                d
                for d in [
                    *(exam_updated_ats or []),
                    *(hs.updated_at for hs in hw_scores if hs.enrollment_id == eid),
                    getattr(session, "updated_at", None),
                ]
                if d
            )

            rows.append(
                {
                    "enrollment_id": eid,
                    "student_name": student_name_map.get(eid, "-"),
                    "exams": exams_payload,
                    "homeworks": homeworks_payload,
                    "updated_at": updated_at or timezone.now(),
                }
            )

        return Response(
            {
                "meta": meta,
                "rows": SessionScoreRowSerializer(rows, many=True).data,
            }
        )


==========================================================================================
# FILE: views/student_exam_attempts_view.py
==========================================================================================
# PATH: apps/domains/results/views/student_exam_attempts_view.py
"""
Student Exam Attempt History

GET /results/me/exams/{exam_id}/attempts/

- ÌïôÏÉù Î≥∏Ïù∏ enrollment Í∏∞Ï§Ä
- Ïû¨ÏãúÌóò ÌûàÏä§ÌÜ†Î¶¨ UI Ï†ÑÏö©
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsStudent
from apps.domains.results.models import ExamAttempt
from apps.domains.enrollment.models import Enrollment


class MyExamAttemptsView(APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user

        # enrollment ÌÉêÏÉâ (Î∞©Ïñ¥)
        qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        enrollment = qs.first()
        if not enrollment:
            return Response([])

        attempts = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=int(enrollment.id),
        ).order_by("attempt_index")

        return Response([
            {
                "attempt_id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": a.is_retake,
                "is_representative": a.is_representative,
                "status": a.status,
                "created_at": a.created_at,
            }
            for a in attempts
        ])


==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import StudentExamResultSerializer
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# ‚úÖ Îã®Ïùº ÏßÑÏã§ Ïú†Ìã∏
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    ‚úÖ Ìè¨Ìï®:
    - Result + items
    - Ïû¨ÏãúÌóò Ï†ïÏ±Ö(allow_retake/max_attempts/can_retake)
    - clinic_required (ClinicLink Í∏∞Ï§Ä Îã®ÏùºÌôî)
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1Ô∏è‚É£ Enrollment Ï∞æÍ∏∞ (ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ ÌïÑÎìú Ï∞®Ïù¥ Î∞©Ïñ¥)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2Ô∏è‚É£ Result Ï°∞Ìöå (Ïä§ÎÉÖÏÉ∑)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(target_type="exam", target_id=int(exam_id), enrollment_id=enrollment_id)
            .prefetch_related("items")
            .first()
        )
        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3Ô∏è‚É£ Ïû¨ÏãúÌóò Ï†ïÏ±Ö ÌåêÎã® (attempt Í∏∞Î∞ò)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4Ô∏è‚É£ clinic_required (Îã®Ïùº ÏßÑÏã§: ClinicLink)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(int(exam_id))
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,  # ‚úÖ Ï†ïÏ±Ö ÌÜµÏùº(ÏûêÎèôÎßå)
            )

        # -------------------------------------------------
        # 5Ô∏è‚É£ ÏùëÎãµ Íµ¨ÏÑ±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = bool(clinic_required)

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_status_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_status_view.py
from __future__ import annotations

from django.core.files.storage import default_storage

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, NotFound

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models import WrongNotePDF
from apps.domains.results.serializers.wrong_note_pdf_serializers import (
    WrongNotePDFStatusSerializer,
)


class WrongNotePDFStatusView(APIView):
    """
    STEP 3-2: Ïò§ÎãµÎÖ∏Ìä∏ PDF Job ÏÉÅÌÉú Ï°∞Ìöå (polling)

    GET /results/wrong-notes/pdf/<job_id>/

    üîê Î≥¥Ïïà:
    - ÌïôÏÉù: Î≥∏Ïù∏ enrollment_idÏùò jobÎßå Ï°∞Ìöå Í∞ÄÎä•
    - ÍµêÏÇ¨/Í¥ÄÎ¶¨Ïûê: Ï†ÑÏ≤¥ Ï°∞Ìöå Í∞ÄÎä•
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this PDF job.")

    def get(self, request, job_id: int):
        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        self._assert_enrollment_access(request, int(job.enrollment_id))

        # DONEÏù¥Î©¥ Îã§Ïö¥Î°úÎìú URL Ï†úÍ≥µ (storageÏóê Îî∞Îùº url()Ïù¥ Ïã§Ìå®Ìï† Ïàò ÏûàÏúºÎãà Î∞©Ïñ¥)
        file_url = ""
        if job.file_path:
            try:
                file_url = default_storage.url(job.file_path)
            except Exception:
                file_url = ""

        data = {
            "job_id": int(job.id),
            "status": str(job.status),
            "file_path": str(job.file_path or ""),
            "file_url": str(file_url or ""),
            "error_message": str(job.error_message or ""),
            "created_at": job.created_at,
            "updated_at": job.updated_at,
        }

        return Response(WrongNotePDFStatusSerializer(data).data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# PATH: apps/domains/results/views/wrong_note_pdf_view.py
from __future__ import annotations

from django.urls import reverse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


class WrongNotePDFCreateView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± ÏöîÏ≤≠ (Celery Ï†úÍ±∞ ‚Üí HTTP worker pull/push)

    ‚úÖ ÏÉÅÌÉúÍ∞í(Î™®Îç∏ enum) Îã®ÏùºÌôî:
    - PENDING -> RUNNING -> DONE/FAILED

    ÏùëÎãµ:
    {
      "job_id": 1,
      "status": "PENDING",
      "status_url": "https://.../results/wrong-notes/pdf/1/"
    }
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id_i,
            lecture_id=int(lecture_id) if lecture_id else None,
            exam_id=int(exam_id) if exam_id else None,
            from_session_order=int(from_order or 2),
            status=WrongNotePDF.Status.PENDING,  # ‚úÖ enqueue = PENDING
        )

        status_path = reverse("wrong-note-pdf-status", kwargs={"job_id": job.id})
        status_url = request.build_absolute_uri(status_path)

        return Response({
            "job_id": int(job.id),
            "status": str(getattr(job, "status", WrongNotePDF.Status.PENDING)),
            "status_url": status_url,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.serializers.wrong_note_serializers import (
    WrongNoteListResponseSerializer,
)
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


class WrongNoteView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå API

    ‚úÖ STEP 3-3 Í≥†Ï†ï:
    - lecture_id/from_session_order ÌïÑÌÑ∞Îäî Service Îã®Ïùº ÏßÑÏã§
    - ViewÎäî Î≥¥Ïïà + query parsing + serializerÎßå Îã¥Îãπ
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - exam_id (optional)
        - lecture_id (optional)
        - from_session_order (optional, default=2)
        - offset (optional, default=0)
        - limit (optional, default=50)
        """
        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        exam_id = request.query_params.get("exam_id")
        lecture_id = request.query_params.get("lecture_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        offset = int(request.query_params.get("offset", 0))
        limit = int(request.query_params.get("limit", 50))

        q = WrongNoteQuery(
            exam_id=int(exam_id) if exam_id else None,
            lecture_id=int(lecture_id) if lecture_id else None,
            from_session_order=from_order,
            offset=offset,
            limit=limit,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id_i,
            q=q,
        )

        next_offset = (offset + limit) if (offset + limit) < total else None
        prev_offset = (offset - limit) if (offset - limit) >= 0 else None

        payload = {
            "count": int(total),
            "next": next_offset,
            "prev": prev_offset,
            "results": items,
        }

        return Response(WrongNoteListResponseSerializer(payload).data)
