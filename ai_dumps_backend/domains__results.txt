====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    í”„ë¡œì íŠ¸ë§ˆë‹¤ user.role / user.user_type / groups ë“± ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ ë°©ì–´ì ìœ¼ë¡œ.
    - ìˆìœ¼ë©´ ì“°ê³ 
    - ì—†ìœ¼ë©´ is_staff/is_superuserë¡œ íŒë‹¨
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # í”„ë¡œì íŠ¸ì— ë”°ë¼ "TEACHER" ë¬¸ìì—´ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ â†’ í•„ìš”ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # ëª…ì‹œì ìœ¼ë¡œ teacher/admin ì•„ë‹ˆë©´ studentë¡œ ì·¨ê¸‰(ì¼ë°˜ì ì¸ ì •ì±…)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/domains/results/urls.py

from django.urls import path
from rest_framework.routers import DefaultRouter

from apps.domains.results.views.student_exam_result_view import MyExamResultView
from apps.domains.results.views.admin_exam_results_view import AdminExamResultsView
from apps.domains.results.views.admin_exam_summary_view import AdminExamSummaryView
from apps.domains.results.views.admin_exam_question_stats_view import (
    AdminExamQuestionStatsView,
)
from apps.domains.results.views.wrong_note_view import WrongNoteView
from apps.domains.results.views.wrong_note_pdf_view import WrongNotePDFCreateView
from apps.domains.results.views.exam_attempt_view import ExamAttemptViewSet

# âœ… STEP 8-B ì¶”ê°€
from apps.domains.results.views.admin_representative_attempt_view import (
    AdminRepresentativeAttemptView,
)

urlpatterns = [
    # Student
    path(
        "me/exams/<int:exam_id>/",
        MyExamResultView.as_view(),
        name="my-exam-result",
    ),

    # Admin / Teacher
    path(
        "admin/exams/<int:exam_id>/summary/",
        AdminExamSummaryView.as_view(),
        name="admin-exam-summary",
    ),
    path(
        "admin/exams/<int:exam_id>/results/",
        AdminExamResultsView.as_view(),
        name="admin-exam-results",
    ),
    path(
        "admin/exams/<int:exam_id>/questions/",
        AdminExamQuestionStatsView.as_view(),
        name="admin-exam-question-stats",
    ),

    # ==============================
    # âœ… STEP 8-B: ëŒ€í‘œ attempt ë³€ê²½
    # ==============================
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),

    # Wrong Notes
    path(
        "wrong-notes",
        WrongNoteView.as_view(),
        name="wrong-note",
    ),
    path(
        "wrong-notes/pdf/",
        WrongNotePDFCreateView.as_view(),
        name="wrong-note-pdf-create",
    ),
]

attempt_router = DefaultRouter()
attempt_router.register("exam-attempts", ExamAttemptViewSet)
urlpatterns += attempt_router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF

# âŒ SubmissionAnswer ì œê±°ë¨ (raw inputì€ submissions ë„ë©”ì¸ ì±…ì„)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    í•™ìƒì˜ 'ì‹œí—˜ 1íšŒ ì‘ì‹œ'ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—”í‹°í‹° (append-only)

    ğŸ”¥ í•µì‹¬ ì±…ì„
    - Submission ë‹¨ìœ„ê°€ ì•„ë‹Œ 'ì‹œí—˜ ì‘ì‹œ ì‚¬ì‹¤'ì˜ ê³ ì •
    - Result / Fact / Snapshotì˜ ê¸°ì¤€ì 
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # Submissionì€ ì‹œë„ì˜ ì›ì¸(event)
    submission_id = models.PositiveIntegerField(
        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
    )

    attempt_index = models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")
    is_retake = models.BooleanField(default=False)

    # ì„œë²„ê°€ íŒë‹¨í•˜ëŠ” ëŒ€í‘œ attempt (ResultëŠ” í•­ìƒ ì´ê²ƒ ê¸°ì¤€)
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ìƒì„±ë¨
            ("grading", "Grading"),     # ì±„ì  ì¤‘
            ("done", "Done"),           # ì±„ì  ì™„ë£Œ
            ("failed", "Failed"),       # ì±„ì  ì‹¤íŒ¨
        ],
        default="pending",
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ì‹œí—˜/ìˆ™ì œ ê²°ê³¼ ìµœì‹  ìŠ¤ëƒ…ìƒ· (ì¡°íšŒìš©)
    ê³„ì‚° ì—†ìŒ

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Resultê°€ ì–´ë–¤ ExamAttempt(ì‹œë„)ë¥¼ ëŒ€í‘œí•˜ëŠ”ì§€ ì¶”ì  ê°€ëŠ¥
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ ì‹œì—ë„ "ì–´ë–¤ attempt ê²°ê³¼ì¸ì§€" ëª…í™•í•´ì§

    âš ï¸ ì£¼ì˜:
    - ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ attempt_idëŠ” ì¼ë‹¨ NULL í—ˆìš©ìœ¼ë¡œ ë“¤ì–´ê° (ë§ˆì´ê·¸ë ˆì´ì…˜ì—ì„œ null=True)
    - ìš´ì˜ì—ì„œ ë°±í•„ í›„ null=Falseë¡œ tighten í•˜ëŠ” 2ë‹¨ê³„ê°€ ì •ì„
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì˜ ê²°ê³¼ì¸ì§€ ì¶”ì  (ëŒ€í‘œ attempt ê¸°ì¤€)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    ê²°ê³¼ Fact (append-only, ë¶ˆë³€)
    - ì§‘ê³„/í†µê³„/ì´ë²¤íŠ¸ ë¡œê·¸ì— ê°€ê¹Œì›€

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Factê°€ ì–´ëŠ attemptì—ì„œ ë‚˜ì˜¨ ì´ë²¤íŠ¸ì¸ì§€ ì¶”ì  ê°€ëŠ¥

    âš ï¸ ë¦¬íŒ©í† ë§ ë©”ëª¨ (ì¤‘ìš”)
    ì§€ê¸ˆì€ ResultFactê°€ answer/score/meta/sourceê¹Œì§€ ë“¤ê³  ìˆìŒ.
    ì¥ê¸°ì ìœ¼ë¡œëŠ”:
      - ResultFact = "ì§‘ê³„ìš© ì´ë²¤íŠ¸"
      - ìƒì„¸/ì±„ì ê²°ê³¼ = results.SubmissionAnswer ê°€ ë“¤ê³  ê°€ëŠ” ê²Œ ì •ì„
    ë‹¤ë§Œ ì§€ê¸ˆ ë‹¨ê³„ì—ì„œëŠ” analytics ì œê±° + ë‹¨ìˆœ ìš´ì˜ì„ ìœ„í•´ ìœ ì§€.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì—ì„œ ìƒì„±ëœ Factì¸ì§€
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    ë¬¸í•­ë³„ ìµœì‹  ê²°ê³¼ ìƒíƒœ (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    total_score = serializers.FloatField()
    max_score = serializers.FloatField()

    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # ğŸ”¥ Submission ì—°ë™ í•„ë“œ (ì‹ ê·œ)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (ì‹ ê·œ)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ë¬¸í•­ë³„ ê²°ê³¼
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ì‹œí—˜ ê²°ê³¼(ì´ì  + ë¬¸í•­ë³„) + ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ê°’

    ì„¤ê³„:
    - Result ëª¨ë¸ ìì²´ëŠ” 'ìŠ¤ëƒ…ìƒ·'ì´ë¯€ë¡œ
      allow_retake/max_attempts/can_retakeëŠ” Exam ì •ì±… + Attempt ìƒíƒœë¡œ ê³„ì‚°í•´ì„œ ë‚´ë ¤ì¤€ë‹¤.
    - ì´ ê°’ë“¤ì€ "ì‘ë‹µ í•„ë“œ"ì´ì§€ Result DB í•„ë“œê°€ ì•„ë‹ˆë‹¤.
      â†’ Viewì—ì„œ ê³„ì‚° í›„ dataì— ì£¼ì…í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ë‹¨ìˆœ/ëª…í™•.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # âœ… STEP 2: í”„ë¡ íŠ¸ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ìš© (ì‘ë‹µ ì „ìš© í•„ë“œ)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # âœ… STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    ê³„ì‚°ëœ ê²°ê³¼ë¥¼ ë°›ì•„ resultsì— ë°˜ì˜
    âŒ ê³„ì‚° ì—†ìŒ (ê³„ì‚°ì€ graderê°€ í•¨)

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜:
    - apply()ê°€ attempt_idë¥¼ ë°›ì•„ì„œ Result / ResultFactì— ì €ì¥

    âœ… ìš´ì˜ ì•ˆì „ì„± íŒ¨ì¹˜ (Critical #4)
    - ResultFact / ResultItemì— ë“¤ì–´ê°€ëŠ” ê°’ì€ "í•­ìƒ íƒ€ì…ì´ ë³´ì¥ëœë‹¤"ëŠ” ì „ì œê°€ ìš´ì˜ì—ì„œ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
      (blank, meta-only, None, ìˆ«ì/ë¦¬ìŠ¤íŠ¸ ë“±)
    - ë”°ë¼ì„œ ì—¬ê¸°ì„œ ìµœì†Œ ìºìŠ¤íŒ…/ë””í´íŠ¸ë¥¼ ê°•ì œí•´ DB insert ì•ˆì •ì„±ì„ ì˜¬ë¦°ë‹¤.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # âœ… ì¶”ê°€
        items: list[dict],
    ) -> Result:
        """
        items format (ê¶Œì¥):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # âœ… ëŒ€í‘œ attempt ì¶”ì  (ë®ì–´ì“°ëŠ”ê²Œ ì •ìƒ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # âœ… Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1ï¸âƒ£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2ï¸âƒ£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ìƒì„±/ê´€ë¦¬ ì „ë‹´

    ğŸ”¥ Critical íŒ¨ì¹˜:
    - ê°™ì€ submission_idë¡œ Attemptê°€ ì¤‘ë³µ ìƒì„±ë˜ëŠ” ê²ƒì„ ì°¨ë‹¨
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # ğŸ”´ CRITICAL #2
        # -------------------------------------------------
        # ê°™ì€ submissionìœ¼ë¡œ Attemptê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¦‰ì‹œ ì°¨ë‹¨
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1ï¸âƒ£ Exam ì •ì±… ë¡œë”©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2ï¸âƒ£ open_at / close_at ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3ï¸âƒ£ ë™ì‹œì„± ì•ˆì „: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4ï¸âƒ£ ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5ï¸âƒ£ ëŒ€í‘œ attempt êµì²´
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# ğŸ”½ submissions ë„ë©”ì¸ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# ğŸ”½ results ë„ë©”ì¸ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# ğŸ”½ exams ë„ë©”ì¸ (ì •ë‹µ / ë¬¸ì œ ì •ì˜)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey

# ======================================================
# ğŸ”½ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    ë¬¸ìì—´ ì •ê·œí™”:
    - None ë°©ì–´
    - ê³µë°± ì œê±°
    - ëŒ€ë¬¸ì í†µì¼
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ì—ì„œ
    omr dict ë§Œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
) -> Tuple[bool, float]:
    """
    OMR ê°ê´€ì‹ ì±„ì  v1
    """
    if (status or "").lower() != "ok":
        return False, 0.0

    if (marking or "").lower() in ("blank", "multi"):
        return False, 0.0

    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0

    if not detected or len(detected) != 1:
        return False, 0.0

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
) -> Tuple[bool, float]:
    """
    ì£¼ê´€ì‹ / fallback ì±„ì 
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type ì¶”ë¡ 
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    âœ… AnswerKey v2 ê³ ì •

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission â†’ ExamAttempt â†’ Result / ResultItem / ResultFact

    ğŸ”¥ v2 í•µì‹¬ ê³„ì•½:
    - SubmissionAnswer.exam_question_id ë§Œ ì‚¬ìš©
    - number / fallback ì™„ì „ ì œê±°
    - AnswerKey v2 ê³ ì •
    """

    # --------------------------------------------------
    # 0ï¸âƒ£ Submission ìƒíƒœ ì „ì´
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1ï¸âƒ£ ExamAttempt ìƒì„±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2ï¸âƒ£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3ï¸âƒ£ ExamQuestion ë¡œë”© (id ê¸°ì¤€)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        # --------------------------------------------------
        # 4ï¸âƒ£ ë¬¸í•­ë³„ ì±„ì 
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            omr = _get_omr_meta(getattr(sa, "meta", None))
            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            answer_type = _infer_answer_type(q)

            if answer_type in ("choice", "omr", "multiple_choice"):
                if omr_version.lower() in ("v1", "v2"):
                    is_correct, score = _grade_choice_v1(
                        detected=[str(x) for x in detected],
                        marking=marking,
                        confidence=confidence,
                        status=status,
                        correct_answer=correct_answer,
                        max_score=max_score,
                    )
                    final_answer = (
                        "".join([_norm(x) for x in detected])
                        if detected else ""
                    )
                else:
                    is_correct, score = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                    )
                    final_answer = answer_text
            else:
                is_correct, score = _grade_short_v1(
                    answer_text=answer_text,
                    correct_answer=correct_answer,
                    max_score=max_score,
                )
                final_answer = answer_text

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                "meta": getattr(sa, "meta", None),
            })

        # --------------------------------------------------
        # 5ï¸âƒ£ Result ë°˜ì˜
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6ï¸âƒ£ ìƒíƒœ ë§ˆë¬´ë¦¬
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/progress_pipeline.py
==========================================================================================
# apps/domains/progress/services/progress_pipeline.py
from __future__ import annotations

from typing import Optional

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.lectures.models import Session

from apps.domains.progress.services.session_calculator import SessionProgressCalculator
from apps.domains.progress.services.lecture_calculator import LectureProgressCalculator
from apps.domains.progress.services.risk_evaluator import RiskEvaluator
from apps.domains.progress.services.clinic_trigger_service import ClinicTriggerService


class ProgressPipeline:
    """
    Results ì´í›„ 'í•™ìŠµ ì§„ë„ íŒŒì´í”„ë¼ì¸'

    âš ï¸ ì£¼ì˜
    - Results ë„ë©”ì¸ì—ì„œ ì§ì ‘ import ê¸ˆì§€
    - ì‹¤íŒ¨í•´ë„ ì¬ì‹œë„ ê°€ëŠ¥í•´ì•¼ í•¨
    - ë©±ë“±ì„± ìœ ì§€
    """

    @staticmethod
    @transaction.atomic
    def run_by_submission(
        *,
        submission: Submission,
        result: Result,
    ) -> None:
        """
        ì‹œí—˜ ì±„ì  ì™„ë£Œ í›„ Progress ì¬ê³„ì‚°
        """

        if submission.target_type != Submission.TargetType.EXAM:
            return

        # 1ï¸âƒ£ Exam â†’ Session ë§¤í•‘
        session: Optional[Session] = (
            Session.objects
            .filter(exam__id=submission.target_id)
            .select_related("lecture")
            .first()
        )

        if not session:
            return

        # 2ï¸âƒ£ SessionProgress ê³„ì‚°
        sp = SessionProgressCalculator.calculate(
            enrollment_id=submission.enrollment_id,
            session=session,
            attendance_type="online",
            video_progress_rate=100,
            exam_score=result.total_score,
            homework_submitted=True,
            homework_teacher_approved=True,
        )

        # 3ï¸âƒ£ í´ë¦¬ë‹‰ ìë™ íŠ¸ë¦¬ê±°
        ClinicTriggerService.auto_create_if_failed(sp)

        # 4ï¸âƒ£ LectureProgress ì§‘ê³„
        lp = LectureProgressCalculator.calculate(
            enrollment_id=submission.enrollment_id,
            lecture=session.lecture,
        )

        # 5ï¸âƒ£ ìœ„í—˜ë„ í‰ê°€
        RiskEvaluator.evaluate(lp)


==========================================================================================
# FILE: tasks/__init__.py
==========================================================================================



==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.services.grader import grade_submission_to_results


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def grade_submission_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)
    grade_submission_to_results(submission)
    return True


==========================================================================================
# FILE: tasks/progress_pipeline_task.py
==========================================================================================
# apps/domains/progress/tasks/progress_pipeline_task.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.progress.services.progress_pipeline import ProgressPipeline


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def run_progress_pipeline_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)

    result = Result.objects.filter(
        target_type=submission.target_type,
        target_id=submission.target_id,
        enrollment_id=submission.enrollment_id,
    ).first()

    if not result:
        return False

    ProgressPipeline.run_by_submission(
        submission=submission,
        result=result,
    )

    return True


==========================================================================================
# FILE: tasks/wrong_note_pdf_tasks.py
==========================================================================================
# apps/domains/results/tasks/wrong_note_pdf_tasks.py
from celery import shared_task
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={"max_retries": 3},
)
def generate_wrong_note_pdf_task(self, job_id: int) -> bool:
    """
    ğŸ”´ UX/ìš´ì˜ íŒ¨ì¹˜
    - API ì„œë²„ëŠ” RUNNINGê¹Œì§€ë§Œ ì±…ì„
    - DONEì€ ì™¸ë¶€ workerë§Œ ì°ìŒ
    """

    job = WrongNotePDF.objects.get(id=job_id)

    job.status = WrongNotePDF.Status.RUNNING
    job.save(update_fields=["status"])

    # ------------------------------------------------
    # â— ì‹¤ì œ PDF ìƒì„±ì€ ì™¸ë¶€ Worker ì±…ì„
    # ì—¬ê¸°ì„œëŠ” enqueueë§Œ ìˆ˜í–‰
    # ------------------------------------------------
    # enqueue_wrong_note_pdf_job(job_id)
    # TODO: worker ì—°ë™

    return True


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# apps/domains/results/views/__init__.py

from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView
from .admin_exam_question_stats_view import AdminExamQuestionStatsView
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

__all__ = [
    "AdminExamResultsView",
    "AdminExamSummaryView",
    "AdminExamQuestionStatsView",
    "MyExamResultView",
    "WrongNoteView",
]


==========================================================================================
# FILE: views/admin_exam_question_stats_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_question_stats_view.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django.db.models import Count, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ResultFact


class AdminExamQuestionStatsView(APIView):
    """
    ğŸ”§ ì„±ëŠ¥ íŒ¨ì¹˜
    - N+1 ì œê±°
    - ë‹¨ì¼ aggregate ì¿¼ë¦¬
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        facts = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        rows = (
            facts.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct_count=Count("id", filter=Q(is_correct=True)),
            )
            .annotate(
                wrong_count=F("attempts") - F("correct_count"),
                correct_rate=ExpressionWrapper(
                    F("correct_count") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                ),
            )
            .order_by("question_id")
        )

        return Response(list(rows))


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_results_view.py

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission


class AdminExamResultsView(APIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    ğŸ”¥ attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜ ë²„ì „

    ë³€ê²½ í¬ì¸íŠ¸ ìš”ì•½:
    - ResultFact ê¸°ì¤€ "ìµœì‹  submission" íŒë‹¨ ì‹œ
      submission_id ë‹¨ë…ì´ ì•„ë‹ˆë¼ attempt_id ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
    - ì¬ì‹œí—˜ / ì¬ì±„ì  / ëŒ€í‘œ attempt ë³€ê²½ì—ë„ ì˜ë¯¸ì ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ìµœì‹ ê°’ ë³´ì¥

    ğŸ”§ PATCH(ì¹˜ëª… ì¼€ì´ìŠ¤):
    - items == [] (ë§¤ì¹­ ì‹¤íŒ¨)ë©´ ResultFactê°€ í•œ ê±´ë„ ì•ˆ ìƒê¸¸ ìˆ˜ ìˆìŒ.
      â†’ ê·¸ëŸ°ë° ResultëŠ” ìƒì„±ë¨ (attempt_idëŠ” ìˆìŒ).
      â†’ ê¸°ì¡´ ë¡œì§ì€ Factë§Œ ë³´ê³  ìµœì‹  submissionì„ ì¡ì•„ì™€ì„œ submission_idê°€ Noneìœ¼ë¡œ ë–¨ì–´ì§.

    âœ… í•´ê²°:
    - Result.attempt_id â†’ ExamAttempt â†’ submission_id ë¡œ fallback(ë˜ëŠ” ëŒ€ì²´)í•´ì„œ ì±„ì›€.

    âœ… ìš´ì˜ ì•ˆì •ì„± íŒ¨ì¹˜ (Critical #2)
    - SessionProgress.student_idê°€ Student.idì™€ 1:1ë¡œ ë§¤ì¹­ëœë‹¤ëŠ” ê°€ì •ì€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ê¹¨ì§ˆ ìˆ˜ ìˆë‹¤.
      (ì–´ë–¤ í”„ë¡œì íŠ¸ëŠ” user_id, ì–´ë–¤ í”„ë¡œì íŠ¸ëŠ” enrollment FK, ì–´ë–¤ í”„ë¡œì íŠ¸ëŠ” student í…Œì´ë¸” PKê°€ ë‹¤ë¦„)
    - ìµœì†Œ ë°©ì–´:
      - sp.student_idê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  í‚¤ë¡œ
      - ì—†ìœ¼ë©´ sp.user_idë¡œ fallback
      - Student ì¡°íšŒ ë° row êµ¬ì„±ì—ì„œë„ ë™ì¼ ê·œì¹™ ì ìš©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ìµœì‹  ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        results = Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        # -------------------------------------------------
        # 2ï¸âƒ£ Session â†’ Progress (enrollment ê¸°ì¤€)
        # -------------------------------------------------
        session = Session.objects.filter(exam__id=exam_id).first()
        progress_map = {
            sp.enrollment_id: sp
            for sp in SessionProgress.objects.filter(session=session)
        }

        # -------------------------------------------------
        # 3ï¸âƒ£ Student ì¡°íšŒ ìµœì í™” (Critical #2 PATCH)
        # -------------------------------------------------
        # âœ… í”„ë¡œì íŠ¸ë§ˆë‹¤ SessionProgressê°€ student_id / user_id / enrollment_id ë“±ì„ ë“¤ê³  ìˆì„ ìˆ˜ ìˆìŒ
        # ì—¬ê¸°ì„œëŠ” "ìˆìœ¼ë©´ student_id, ì—†ìœ¼ë©´ user_id"ì˜ ìµœì†Œ ë°©ì–´ ê·œì¹™ì„ ì ìš©.
        student_ids = set()

        for sp in progress_map.values():
            # ê°€ì¥ í”í•œ ì¼€ì´ìŠ¤: student_id
            if hasattr(sp, "student_id") and getattr(sp, "student_id", None):
                student_ids.add(int(sp.student_id))
            # fallback ì¼€ì´ìŠ¤: user_id
            elif hasattr(sp, "user_id") and getattr(sp, "user_id", None):
                student_ids.add(int(sp.user_id))

        student_map = {
            s.id: s
            for s in Student.objects.filter(id__in=list(student_ids))
        }

        # -------------------------------------------------
        # 4ï¸âƒ£ enrollment_id â†’ ìµœì‹  attempt/submission ë§µ (Fact ê¸°ë°˜ 1ì°¨)
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
            )
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values(
                "enrollment_id",
                "attempt_id",
                "submission_id",
            )
        )

        latest_map = {}
        for row in fact_qs:
            eid = row["enrollment_id"]
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": row["attempt_id"],
                    "submission_id": row["submission_id"],
                }

        # -------------------------------------------------
        # 4-1ï¸âƒ£ ğŸ”§ PATCH: Factê°€ ì—†ë”ë¼ë„ Result.attempt_idë¡œ submission ì¶”ì 
        # -------------------------------------------------
        attempt_ids = [r.attempt_id for r in results if getattr(r, "attempt_id", None)]
        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = r.enrollment_id
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue

            a = attempt_map.get(int(aid))
            if not a:
                continue

            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # -------------------------------------------------
        # 5ï¸âƒ£ Submission.status ì¡°íšŒ
        # -------------------------------------------------
        submission_ids = [
            v["submission_id"]
            for v in latest_map.values()
            if v.get("submission_id")
        ]

        submission_status_map = {
            s.id: s.status
            for s in Submission.objects.filter(id__in=submission_ids)
        }

        # -------------------------------------------------
        # 6ï¸âƒ£ ìµœì¢… rows êµ¬ì„± (ì‘ë‹µ ìŠ¤í™ ë³€ê²½ ì—†ìŒ)
        # -------------------------------------------------
        rows = []

        for r in results:
            enrollment_id = r.enrollment_id
            sp = progress_map.get(enrollment_id)

            # âœ… Critical #2 PATCH: student_id/user_id ì–´ë–¤ í•„ë“œê°€ ìˆì–´ë„ ìµœì†Œ ë°©ì–´ë¡œ ì»¤ë²„
            sid = None
            if sp is not None:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
            student = student_map.get(int(sid)) if sid else None

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = (
                submission_status_map.get(submission_id)
                if submission_id
                else None
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student.name if student else "-",

                "total_score": r.total_score,
                "max_score": r.max_score,

                # spê°€ ì—†ìœ¼ë©´ ë³´ìˆ˜ì ìœ¼ë¡œ False ì²˜ë¦¬
                "passed": bool(sp and not getattr(sp, "failed", False)),
                "clinic_required": bool(sp and getattr(sp, "clinic_required", False)),

                "submitted_at": r.submitted_at,

                # ğŸ”¥ Submission ì—°ë™ (ê¸°ì¡´ í”„ë¡ íŠ¸ í˜¸í™˜)
                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        return Response(
            AdminExamResultRowSerializer(rows, many=True).data
        )


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_summary_view.py
"""
Admin / Teacher Exam Summary
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result
from apps.domains.results.serializers.admin_exam_summary import (
    AdminExamSummarySerializer,
)

from apps.domains.progress.models import ProgressPolicy, SessionProgress
from apps.domains.lectures.models import Session


class AdminExamSummaryView(APIView):
    """
    GET /results/admin/exams/<exam_id>/summary/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        qs = Result.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        agg = qs.aggregate(
            participant_count=Count("id"),
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        session = Session.objects.filter(exam__id=exam_id).first()

        policy = (
            ProgressPolicy.objects
            .filter(lecture=session.lecture)
            .first()
            if session else None
        )

        pass_score = policy.exam_pass_score if policy else 0

        pass_count = qs.filter(total_score__gte=pass_score).count()
        fail_count = qs.filter(total_score__lt=pass_score).count()

        participant_count = agg["participant_count"] or 0
        pass_rate = (
            pass_count / participant_count
            if participant_count else 0.0
        )

        clinic_count = (
            SessionProgress.objects
            .filter(session=session, clinic_required=True)
            .count()
            if session else 0
        )

        return Response(
            AdminExamSummarySerializer({
                "participant_count": participant_count,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),
                "pass_count": pass_count,
                "fail_count": fail_count,
                "pass_rate": round(float(pass_rate), 4),
                "clinic_count": clinic_count,
            }).data
        )


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# apps/domains/results/views/admin_representative_attempt_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result


class AdminRepresentativeAttemptView(APIView):
    """
    POST /results/admin/exams/<exam_id>/representative-attempt/

    ìš”ì²­:
    {
      "enrollment_id": 55,
      "attempt_id": 1234
    }

    ë™ì‘:
    1) (exam_id, enrollment_id) ì˜ ëª¨ë“  attempt â†’ is_representative=False
    2) ì§€ì • attempt â†’ is_representative=True
    3) Result.attempt_idë„ í•´ë‹¹ attemptë¡œ ë™ê¸°í™”

    âœ… ìš´ì˜/CS í•„ìˆ˜ API
    - ì¬ì‹œí—˜ ì‹¤íŒ¨
    - ì±„ì  ì˜¤ë¥˜
    - ëŒ€í‘œ ì ìˆ˜ ìˆ˜ë™ êµì²´
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def post(self, request, exam_id: int):
        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if not enrollment_id or not attempt_id:
            raise ValidationError("enrollment_id and attempt_id are required")

        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        # 1ï¸âƒ£ attempt ê²€ì¦
        target = ExamAttempt.objects.filter(
            id=attempt_id,
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        ).first()

        if not target:
            raise ValidationError("attempt not found for this exam/enrollment")

        # 2ï¸âƒ£ ëŒ€í‘œ attempt ì´ˆê¸°í™”
        ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        ).update(is_representative=False)

        # 3ï¸âƒ£ ì§€ì • attempt ëŒ€í‘œë¡œ ì„¤ì •
        target.is_representative = True
        target.save(update_fields=["is_representative"])

        # 4ï¸âƒ£ Result ìŠ¤ëƒ…ìƒ·ë„ ë™ê¸°í™”
        Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
        ).update(attempt_id=attempt_id)

        return Response({
            "ok": True,
            "exam_id": exam_id,
            "enrollment_id": enrollment_id,
            "attempt_id": attempt_id,
        })


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

â— ì¹˜ëª…ì  ë³´ì•ˆ ì´ìŠˆ ìˆ˜ì •:
- ê¸°ì¡´: IsAuthenticated ë§Œ ê±¸ë ¤ì„œ í•™ìƒë„ ì „ì²´ Attempt ì—´ëŒ ê°€ëŠ¥
- ë³€ê²½: Teacher/Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥

í•„ìš”í•˜ë©´ ì¶”í›„:
- í•™ìƒ ë³¸ì¸ attemptë§Œ ì¡°íšŒí•˜ëŠ” ë³„ë„ Viewë¥¼ /me/* ë¡œ ë”°ë¡œ ë§Œë“¤ ê²ƒ
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ì‹œí—˜ ì‹œë„(Attempt) ê´€ë¦¬ API (ê´€ë¦¬ì/êµì‚¬ìš©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # âœ… ë³´ì•ˆ ìˆ˜ì •
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/exam_result_view.py
==========================================================================================
# apps/domains/results/views/exam_result_view.py
"""
âš ï¸ LEGACY APIs (DEPRECATED)

- Admin ì „ìš© APIëŠ” /admin/* ê²½ë¡œ ì‚¬ìš©
- ë³¸ íŒŒì¼ì€ ê³¼ê±° í”„ë¡ íŠ¸ í˜¸í™˜ìš©
- ì¶”í›„ ì‚­ì œ ì˜ˆì •
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django.db.models import Avg, Min, Max, StdDev, Count

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ProgressPolicy


class ExamStatsView(APIView):
    """
    âš ï¸ DEPRECATED
    ì‹œí—˜ ìš”ì•½ í†µê³„ (Legacy)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam = Exam.objects.select_related("lecture").get(id=exam_id)
        policy = ProgressPolicy.objects.get(lecture=exam.lecture)

        qs = Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        agg = qs.aggregate(
            avg=Avg("total_score"),
            std=StdDev("total_score"),
            min=Min("total_score"),
            max=Max("total_score"),
            participants=Count("id"),
        )

        participants = agg["participants"] or 0
        passed = qs.filter(
            total_score__gte=policy.exam_pass_score
        ).count()

        pass_rate = (passed / participants) if participants else 0.0

        return Response({
            "exam_id": exam_id,
            "participants": participants,
            "avg": agg["avg"],
            "std": agg["std"],
            "min": agg["min"],
            "max": agg["max"],
            "pass_rate": pass_rate,
        })


class ExamQuestionStatsView(APIView):
    """
    âš ï¸ DEPRECATED
    ì‹œí—˜ ë¬¸í•­ë³„ í†µê³„ (Legacy)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        facts = ResultFact.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        rows = []

        for qid in facts.values_list("question_id", flat=True).distinct():
            qf = facts.filter(question_id=qid)
            total = qf.count()
            correct = qf.filter(is_correct=True).count()

            rows.append({
                "question_id": qid,
                "correct_rate": (correct / total) if total else 0.0,
            })

        return Response(rows)


==========================================================================================
# FILE: views/homework_result_view.py
==========================================================================================



==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# âœ… Progress ì¡°íšŒ (clinic_required ê³„ì‚°ìš©)
from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    âœ… ë‹¨ì¼ ìµœì¢… ë²„ì „ (ì¤‘ë³µ ì œê±° ì™„ë£Œ)

    í¬í•¨ ê¸°ëŠ¥:
    - Result + ResultItem ì¡°íšŒ
    - allow_retake / max_attempts / can_retake ê³„ì‚°
    - clinic_required ì£¼ì…
    - Enrollment íƒìƒ‰ ë°©ì–´ ë¡œì§

    âš ï¸ ì¤‘ìš”:
    - ì´ View ì •ì˜ëŠ” ë°˜ë“œì‹œ 1ê°œë§Œ ì¡´ì¬í•´ì•¼ í•¨
    - ë‹¤ë¥¸ íŒŒì¼ì— ë™ì¼ í´ë˜ìŠ¤ê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚­ì œí•  ê²ƒ
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1ï¸âƒ£ Enrollment ì°¾ê¸° (í”„ë¡œì íŠ¸ë³„ í•„ë“œ ì°¨ì´ ë°©ì–´)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()

        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2ï¸âƒ£ Result ì¡°íšŒ (ìµœì‹  ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=int(exam_id),
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )

        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3ï¸âƒ£ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ (ëŒ€í‘œ attempt ì˜ì¡´ âŒ)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4ï¸âƒ£ clinic_required ê³„ì‚° (Progress íŒŒì´í”„ë¼ì¸ ê²°ê³¼)
        # -------------------------------------------------
        clinic_required = False
        session = Session.objects.filter(exam__id=exam_id).first()

        if session:
            sp = SessionProgress.objects.filter(
                session=session,
                enrollment_id=enrollment_id,
            ).first()
            clinic_required = bool(sp and getattr(sp, "clinic_required", False))

        # -------------------------------------------------
        # 5ï¸âƒ£ ì‘ë‹µ êµ¬ì„±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = clinic_required

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_view.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF

from apps.domains.results.tasks.wrong_note_pdf_tasks import (
    generate_wrong_note_pdf_task,
)


class WrongNotePDFCreateView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± ìš”ì²­

    ğŸ”´ ë³´ì•ˆ íŒ¨ì¹˜:
    - í•™ìƒì€ ë³¸ì¸ enrollmentë§Œ PDF ìƒì„± ê°€ëŠ¥
    - êµì‚¬/ê´€ë¦¬ìëŠ” ì „ì²´ í—ˆìš©
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        # ğŸ” ì ‘ê·¼ ê¶Œí•œ ê²€ì‚¬
        self._assert_enrollment_access(request, int(enrollment_id))

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=int(enrollment_id),
            lecture_id=lecture_id,
            exam_id=exam_id,
            from_session_order=int(from_order),
        )

        generate_wrong_note_pdf_task.delay(job.id)

        return Response({
            "job_id": job.id,
            "status": job.status,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import Exam


class WrongNoteView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ API (v1)

    ğŸ”´ ë³´ì•ˆ íŒ¨ì¹˜ ìš”ì•½
    - enrollment_idë¥¼ queryë¡œ ë°›ê¸° ë•Œë¬¸ì— ì ‘ê·¼ ì œì–´ í•„ìˆ˜
    - í•™ìƒ: ë³¸ì¸ enrollmentë§Œ í—ˆìš©
    - êµì‚¬/ê´€ë¦¬ì: ì „ì²´ í—ˆìš©

    âœ… ìš´ì˜ ì•ˆì •ì„± íŒ¨ì¹˜ (Critical #3)
    - Exam â†” Session reverse related_nameì´ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
      (session / sessions / session_set ë“±)
    - ê¸°ì¡´ ì½”ë“œì˜ session__order ê°€ì •ì€ ê¹¨ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ
      Exam ëª¨ë¸ì˜ ì‹¤ì œ relation ì´ë¦„ì„ ê²€ì‚¬ í›„ í•„í„° ì ìš©
    """

    permission_classes = [IsAuthenticated]

    # --------------------------------------------------
    # ğŸ” enrollment ì ‘ê·¼ ê¶Œí•œ ê²€ì‚¬ (í•µì‹¬ ë³´ì•ˆ ë¡œì§)
    # --------------------------------------------------
    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    @staticmethod
    def _has_relation(model, name: str) -> bool:
        """
        Exam ëª¨ë¸ì— session/sessions ê´€ê³„ê°€ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬ (ì •ì„).
        """
        try:
            return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
        except Exception:
            return False

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - lecture_id (optional)
        - exam_id (optional)
        - from_session_order (optional, default=2)
        """

        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        self._assert_enrollment_access(request, int(enrollment_id))

        lecture_id = request.query_params.get("lecture_id")
        exam_id = request.query_params.get("exam_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        qs = ResultFact.objects.filter(
            enrollment_id=int(enrollment_id),
            is_correct=False,
            target_type="exam",
        )

        if exam_id:
            qs = qs.filter(target_id=int(exam_id))

        if lecture_id:
            # ----------------------------------------------------------
            # âœ… Critical #3 PATCH:
            # - Exam â†” Session ê´€ê³„ëª…ì´ session/sessionsì¸ì§€ ê²€ì‚¬ í›„ ì ìš©
            # - ë‘˜ ë‹¤ ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ none()
            # ----------------------------------------------------------
            exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

            if self._has_relation(Exam, "sessions"):
                exam_qs = exam_qs.filter(sessions__order__gte=from_order)
            elif self._has_relation(Exam, "session"):
                exam_qs = exam_qs.filter(session__order__gte=from_order)
            else:
                exam_qs = exam_qs.none()

            exam_ids = exam_qs.values_list("id", flat=True)
            qs = qs.filter(target_id__in=list(exam_ids))

        qs = qs.order_by("target_id", "question_id")

        items = [{
            "exam_id": f.target_id,
            "question_id": f.question_id,
            "answer": f.answer,
            "score": f.score,
            "max_score": f.max_score,
            "source": f.source,
            "meta": f.meta,
            "created_at": f.created_at,
        } for f in qs]

        return Response({
            "enrollment_id": int(enrollment_id),
            "count": len(items),
            "items": items,
        })
