====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: urls.py
==========================================================================================
# apps/domains/results/urls.py
from django.urls import path

from apps.domains.results.views.exam_result_view import (
    ExamStatsView,
    ExamQuestionStatsView,
)
from apps.domains.results.views.wrong_note_view import WrongNoteView

urlpatterns = [
    # ÏãúÌóò ÌÜµÍ≥Ñ
    path(
        "exams/<int:exam_id>/stats",
        ExamStatsView.as_view(),
        name="exam-stats",
    ),
    path(
        "exams/<int:exam_id>/questions/stats",
        ExamQuestionStatsView.as_view(),
        name="exam-question-stats",
    ),

    # Ïò§ÎãµÎÖ∏Ìä∏
    path(
        "wrong-notes",
        WrongNoteView.as_view(),
        name="wrong-note",
    ),
]


==========================================================================================
# FILE: views.py
==========================================================================================
# exam_result_view.py / homework_result_view.py
# Ï°∞Ìöå APIÎßå Íµ¨ÌòÑ (ÏßÄÍ∏àÏùÄ ÏÉùÎûµ Í∞ÄÎä•)


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2025-12-19 00:33

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact

__all__ = ["Result", "ResultItem", "ResultFact"]


==========================================================================================
# FILE: models/result.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ÏãúÌóò/ÏàôÏ†ú Í≤∞Í≥º ÏµúÏã† Ïä§ÎÉÖÏÉ∑ (Ï°∞ÌöåÏö©)
    Í≥ÑÏÇ∞ ÏóÜÏùå
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    Í≤∞Í≥º Fact (append-only, Î∂àÎ≥Ä)
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    Î¨∏Ìï≠Î≥Ñ ÏµúÏã† Í≤∞Í≥º ÏÉÅÌÉú (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    Í≥ÑÏÇ∞Îêú Í≤∞Í≥ºÎ•º Î∞õÏïÑ resultsÏóê Î∞òÏòÅ
    ‚ùå Í≥ÑÏÇ∞ ÏóÜÏùå
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        items: list[dict],
    ) -> Result:
        """
        items format:
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        total = 0.0
        max_total = 0.0

        for item in items:
            # 1Ô∏è‚É£ Fact
            ResultFact.objects.create(
                target_type=target_type,
                target_id=target_id,
                enrollment_id=enrollment_id,
                submission_id=submission_id,
                **item,
            )

            # 2Ô∏è‚É£ Snapshot
            ResultItem.objects.update_or_create(
                result=result,
                question_id=item["question_id"],
                defaults={
                    "answer": item["answer"],
                    "is_correct": item["is_correct"],
                    "score": item["score"],
                    "max_score": item["max_score"],
                    "source": item["source"],
                },
            )

            total += item["score"]
            max_total += item["max_score"]

        result.total_score = total
        result.max_score = max_total
        result.submitted_at = timezone.now()
        result.save(update_fields=["total_score", "max_score", "submitted_at"])

        return result


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

from apps.domains.submissions.models import Submission, SubmissionAnswer
from apps.domains.results.services.applier import ResultApplier
from apps.domains.exams.models import ExamQuestion, AnswerKey

# progress Ïó∞Í≤∞
from apps.domains.progress.dispatcher import dispatch_progress_pipeline

# ============================================================
# OMR/Ï±ÑÏ†ê Ï†ïÏ±Ö v1 (Results ÎèÑÎ©îÏù∏ Ï±ÖÏûÑ)
# - WorkerÎäî "ÎãµÏïà ÏÇ¨Ïã§"Îßå Î≥¥ÎÇ¥Í≥†, Ï†êÏàò Í≥ÑÏÇ∞ÏùÄ Ïó¨Í∏∞ÏÑú ÌïúÎã§.
# - v1 Í≥†Ï†ï Ï†ïÏ±Ö:
#   - multi ÎßàÌÇπ = 0Ï†ê
#   - confidence < 0.70 = 0Ï†ê
#   - status != ok = 0Ï†ê
#   - Î∂ÄÎ∂ÑÏ†êÏàò ÏóÜÏùå
# ============================================================

OMR_CONF_THRESHOLD_V1 = 0.70


def _norm(s: Optional[str]) -> str:
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    SubmissionAnswer.metaÏóêÏÑú OMR v1 payload Ï∂îÏ∂ú.
    Í∏∞ÎåÄ ÏúÑÏπò: meta["omr"]
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
) -> Tuple[bool, float]:
    """
    Í∞ùÍ¥ÄÏãù(ÏÑ†ÌÉùÌòï) Ï±ÑÏ†ê v1
    return: (is_correct, score)
    """
    if (status or "").lower() != "ok":
        return (False, 0.0)

    m = (marking or "").lower()
    if m in ("blank", "multi"):
        return (False, 0.0)

    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return (False, 0.0)

    if not detected or len(detected) != 1:
        return (False, 0.0)

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = (ans != "") and (cor != "") and (ans == cor)
    score = float(max_score) if is_correct else 0.0
    return (is_correct, score)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
) -> Tuple[bool, float]:
    """
    Ï£ºÍ¥ÄÏãù(ÌÖçÏä§Ìä∏) Ï±ÑÏ†ê v1 (exact match only)
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return (False, 0.0)

    is_correct = (cor != "") and (ans == cor)
    score = float(max_score) if is_correct else 0.0
    return (is_correct, score)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    answer_typeÍ∞Ä Î™®Îç∏Ïóê ÏóÜÏùÑ ÏàòÎèÑ ÏûàÏúºÎãà Î∞©Ïñ¥Ï†ÅÏúºÎ°ú Ï∂îÎ°†.
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey.answers: { "1": "B", "2": "3", ... } (question number Í∏∞Î∞ò)
    """
    ak = AnswerKey.objects.filter(exam_id=exam_id).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission + SubmissionAnswer(+meta) -> Result/ResultItem/ResultFact Î∞òÏòÅ
    - Ï†ïÏ±Ö/Ï†êÏàò Í≥ÑÏÇ∞ÏùÄ Results ÎèÑÎ©îÏù∏ Ï±ÖÏûÑ
    """
    submission.status = Submission.Status.GRADING
    submission.save(update_fields=["status"])

    answers = list(SubmissionAnswer.objects.filter(submission=submission))

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    # ‚úÖ ExamQuestionÏùÄ sheet->exam Íµ¨Ï°∞
    questions = (
        ExamQuestion.objects
        .filter(sheet__exam_id=submission.target_id)
        .in_bulk(field_name="id")
    )

    # ‚úÖ Ï†ïÎãµÏùÄ AnswerKey.answersÏóêÏÑú (question.number Í∏∞Ï§Ä)
    correct_map = _get_correct_answer_map(int(submission.target_id))

    items: List[dict] = []

    for sa in answers:
        q = questions.get(sa.question_id)
        if not q:
            continue

        max_score = float(getattr(q, "score", 0) or 0.0)

        # question.number Í∏∞Î∞ò Ï†ïÎãµ
        correct_answer = str(correct_map.get(str(getattr(q, "number", ""))) or "")

        answer_text = str(sa.answer or "").strip()

        omr = _get_omr_meta(sa.meta)
        omr_version = str(omr.get("version") or "")
        detected = omr.get("detected") or []
        marking = str(omr.get("marking") or "")
        confidence = omr.get("confidence", None)
        status = str(omr.get("status") or "")

        answer_type = _infer_answer_type(q)

        if answer_type in ("choice", "omr", "multiple_choice"):
            if omr_version.lower() == "v1" and isinstance(detected, list):
                is_correct, score = _grade_choice_v1(
                    detected=[str(x) for x in detected],
                    marking=marking,
                    confidence=(float(confidence) if confidence is not None else None),
                    status=status,
                    correct_answer=correct_answer,
                    max_score=max_score,
                )
                final_answer = "".join([_norm(x) for x in detected]) if detected else ""
            else:
                is_correct, score = _grade_short_v1(
                    answer_text=answer_text,
                    correct_answer=correct_answer,
                    max_score=max_score,
                )
                final_answer = answer_text
        else:
            is_correct, score = _grade_short_v1(
                answer_text=answer_text,
                correct_answer=correct_answer,
                max_score=max_score,
            )
            final_answer = answer_text

        items.append(
            {
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                "meta": sa.meta,
            }
        )

    ResultApplier.apply(
        target_type=submission.target_type,
        target_id=int(submission.target_id),
        enrollment_id=int(submission.enrollment_id or 0),
        submission_id=int(submission.id),
        items=items,
    )

    submission.status = Submission.Status.DONE
    submission.save(update_fields=["status"])
    
    # üîî Progress ÌõÑÏÜç ÌååÏù¥ÌîÑÎùºÏù∏ (Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÌõÑ)
    transaction.on_commit(
        lambda: dispatch_progress_pipeline(submission.id)
    )


==========================================================================================
# FILE: services/progress_pipeline.py
==========================================================================================
# apps/domains/progress/services/progress_pipeline.py
from __future__ import annotations

from typing import Optional

from django.db import transaction

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.lectures.models import Session

from apps.domains.progress.services.session_calculator import SessionProgressCalculator
from apps.domains.progress.services.lecture_calculator import LectureProgressCalculator
from apps.domains.progress.services.risk_evaluator import RiskEvaluator
from apps.domains.progress.services.clinic_trigger_service import ClinicTriggerService


class ProgressPipeline:
    """
    Results Ïù¥ÌõÑ 'ÌïôÏäµ ÏßÑÎèÑ ÌååÏù¥ÌîÑÎùºÏù∏'

    ‚ö†Ô∏è Ï£ºÏùò
    - Results ÎèÑÎ©îÏù∏ÏóêÏÑú ÏßÅÏ†ë import Í∏àÏßÄ
    - Ïã§Ìå®Ìï¥ÎèÑ Ïû¨ÏãúÎèÑ Í∞ÄÎä•Ìï¥Ïïº Ìï®
    - Î©±Îì±ÏÑ± Ïú†ÏßÄ
    """

    @staticmethod
    @transaction.atomic
    def run_by_submission(
        *,
        submission: Submission,
        result: Result,
    ) -> None:
        """
        ÏãúÌóò Ï±ÑÏ†ê ÏôÑÎ£å ÌõÑ Progress Ïû¨Í≥ÑÏÇ∞
        """

        if submission.target_type != Submission.TargetType.EXAM:
            return

        # 1Ô∏è‚É£ Exam ‚Üí Session Îß§Ìïë
        session: Optional[Session] = (
            Session.objects
            .filter(exam__id=submission.target_id)
            .select_related("lecture")
            .first()
        )

        if not session:
            return

        # 2Ô∏è‚É£ SessionProgress Í≥ÑÏÇ∞
        sp = SessionProgressCalculator.calculate(
            enrollment_id=submission.enrollment_id,
            session=session,
            attendance_type="online",
            video_progress_rate=100,
            exam_score=result.total_score,
            homework_submitted=True,
            homework_teacher_approved=True,
        )

        # 3Ô∏è‚É£ ÌÅ¥Î¶¨Îãâ ÏûêÎèô Ìä∏Î¶¨Í±∞
        ClinicTriggerService.auto_create_if_failed(sp)

        # 4Ô∏è‚É£ LectureProgress ÏßëÍ≥Ñ
        lp = LectureProgressCalculator.calculate(
            enrollment_id=submission.enrollment_id,
            lecture=session.lecture,
        )

        # 5Ô∏è‚É£ ÏúÑÌóòÎèÑ ÌèâÍ∞Ä
        RiskEvaluator.evaluate(lp)


==========================================================================================
# FILE: tasks/__init__.py
==========================================================================================



==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.services.grader import grade_submission_to_results


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def grade_submission_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)
    grade_submission_to_results(submission)
    return True


==========================================================================================
# FILE: tasks/progress_pipeline_task.py
==========================================================================================
# apps/domains/progress/tasks/progress_pipeline_task.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.progress.services.progress_pipeline import ProgressPipeline


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def run_progress_pipeline_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)

    result = Result.objects.filter(
        target_type=submission.target_type,
        target_id=submission.target_id,
        enrollment_id=submission.enrollment_id,
    ).first()

    if not result:
        return False

    ProgressPipeline.run_by_submission(
        submission=submission,
        result=result,
    )

    return True


==========================================================================================
# FILE: tasks/wrong_note_pdf_tasks.py
==========================================================================================
# apps/domains/results/tasks/wrong_note_pdf_tasks.py
from celery import shared_task

from apps.domains.results.models.wrong_note_pdf import WrongNotePDF
from worker.wrong_notes.generator import generate_wrong_note_pdf


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={"max_retries": 3},
)
def generate_wrong_note_pdf_task(self, job_id: int) -> bool:
    """
    ‚ùó Í≥ÑÏïΩ Ïó≠Ìï†Îßå ÏàòÌñâ
    ‚ùó Ïã§Ï†ú Í≥ÑÏÇ∞/ÏÉùÏÑ±ÏùÄ workerÎ°ú ÏúÑÏûÑ
    """
    job = WrongNotePDF.objects.get(id=job_id)

    job.status = WrongNotePDF.Status.RUNNING
    job.save(update_fields=["status"])

    try:
        file_path = generate_wrong_note_pdf(job_id)
        job.file_path = file_path
        job.status = WrongNotePDF.Status.DONE
        job.save(update_fields=["status", "file_path"])
        return True

    except Exception as e:
        job.status = WrongNotePDF.Status.FAILED
        job.error_message = str(e)
        job.save(update_fields=["status", "error_message"])
        raise


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# apps/domains/results/views/__init__.py
from .exam_result_view import ExamStatsView, ExamQuestionStatsView
from .wrong_note_view import WrongNoteView

__all__ = [
    "ExamStatsView",
    "ExamQuestionStatsView",
    "WrongNoteView",
]


==========================================================================================
# FILE: views/exam_result_view.py
==========================================================================================
# apps/domains/results/views/exam_result_view.py
from rest_framework.views import APIView
from rest_framework.response import Response

from django.db.models import Avg, Min, Max, StdDev, Count, Q

from apps.domains.results.models import Result, ResultFact
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ProgressPolicy


class ExamStatsView(APIView):
    """
    ÏãúÌóò ÏöîÏïΩ ÌÜµÍ≥Ñ API
    - Result Í∏∞Î∞ò (snapshot)
    - Í≥ÑÏÇ∞ ÏóÜÏùå
    """

    def get(self, request, exam_id: int):
        exam = Exam.objects.select_related("lecture").get(id=exam_id)
        policy = ProgressPolicy.objects.get(lecture=exam.lecture)

        qs = Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        agg = qs.aggregate(
            avg=Avg("total_score"),
            std=StdDev("total_score"),
            min=Min("total_score"),
            max=Max("total_score"),
            participants=Count("id"),
        )

        participants = agg["participants"] or 0

        passed = qs.filter(
            total_score__gte=policy.exam_pass_score
        ).count()

        pass_rate = (passed / participants) if participants else 0.0

        return Response({
            "exam_id": exam_id,
            "participants": participants,
            "avg": agg["avg"],
            "std": agg["std"],
            "min": agg["min"],
            "max": agg["max"],
            "pass_rate": pass_rate,
        })


class ExamQuestionStatsView(APIView):
    """
    ÏãúÌóò Î¨∏Ìï≠Î≥Ñ ÌÜµÍ≥Ñ API
    - ResultFact Í∏∞Î∞ò (append-only)
    """

    def get(self, request, exam_id: int):
        facts = ResultFact.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        result = []

        question_ids = (
            facts.values_list("question_id", flat=True)
            .distinct()
        )

        for qid in question_ids:
            qf = facts.filter(question_id=qid)

            total = qf.count()
            correct = qf.filter(is_correct=True).count()

            wrong_dist = (
                qf.filter(is_correct=False)
                .values("answer")
                .annotate(cnt=Count("id"))
            )

            result.append({
                "question_id": qid,
                "correct_rate": (correct / total) if total else 0.0,
                "wrong_distribution": {
                    w["answer"]: w["cnt"] for w in wrong_dist
                },
            })

        return Response(result)


==========================================================================================
# FILE: views/homework_result_view.py
==========================================================================================



==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_view.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models.wrong_note_pdf import WrongNotePDF
from apps.domains.results.tasks.wrong_note_pdf_task import generate_wrong_note_pdf_task


class WrongNotePDFCreateView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ PDF ÏÉùÏÑ± ÏöîÏ≤≠
    """

    permission_classes = [IsAuthenticated]

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id,
            lecture_id=lecture_id,
            exam_id=exam_id,
            from_session_order=from_order,
        )

        generate_wrong_note_pdf_task.delay(job.id)

        return Response({
            "job_id": job.id,
            "status": job.status,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django.db.models import F

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import Exam
from apps.domains.lectures.models import Session


class WrongNoteView(APIView):
    """
    Ïò§ÎãµÎÖ∏Ìä∏ Ï°∞Ìöå API (v1)
    - ResultFact Í∏∞Î∞ò
    - append-only
    """

    permission_classes = [IsAuthenticated]

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - lecture_id (optional)
        - exam_id (optional)
        - from_session_order (optional, default=2)
        """

        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response(
                {"detail": "enrollment_id is required"},
                status=400,
            )

        lecture_id = request.query_params.get("lecture_id")
        exam_id = request.query_params.get("exam_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        qs = ResultFact.objects.filter(
            enrollment_id=enrollment_id,
            is_correct=False,
            target_type="exam",
        )

        # -----------------------------
        # ÏãúÌóò Í∏∞Ï§Ä ÌïÑÌÑ∞
        # -----------------------------
        if exam_id:
            qs = qs.filter(target_id=exam_id)

        # -----------------------------
        # Í∞ïÏùò / Ï£ºÏ∞® Í∏∞Ï§Ä ÌïÑÌÑ∞
        # -----------------------------
        if lecture_id:
            exam_ids = (
                Exam.objects
                .filter(
                    lecture_id=lecture_id,
                    session__order__gte=from_order,
                )
                .values_list("id", flat=True)
            )
            qs = qs.filter(target_id__in=exam_ids)

        qs = qs.select_related(None).order_by(
            "target_id",
            "question_id",
        )

        result = []

        for f in qs:
            result.append({
                "exam_id": f.target_id,
                "question_id": f.question_id,
                "answer": f.answer,
                "score": f.score,
                "max_score": f.max_score,
                "source": f.source,
                "meta": f.meta,
                "created_at": f.created_at,
            })

        return Response({
            "enrollment_id": int(enrollment_id),
            "count": len(result),
            "items": result,
        })
