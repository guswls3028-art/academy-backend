====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    í”„ë¡œì íŠ¸ë§ˆë‹¤ user.role / user.user_type / groups ë“± ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ ë°©ì–´ì ìœ¼ë¡œ.
    - ìˆìœ¼ë©´ ì“°ê³ 
    - ì—†ìœ¼ë©´ is_staff/is_superuserë¡œ íŒë‹¨
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # í”„ë¡œì íŠ¸ì— ë”°ë¼ "TEACHER" ë¬¸ìì—´ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ â†’ í•„ìš”ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # ëª…ì‹œì ìœ¼ë¡œ teacher/admin ì•„ë‹ˆë©´ studentë¡œ ì·¨ê¸‰(ì¼ë°˜ì ì¸ ì •ì±…)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/results/urls.py

from django.urls import path
from rest_framework.routers import DefaultRouter

# ======================================================
# Student
# ======================================================
from apps.domains.results.views.student_exam_result_view import MyExamResultView

# ğŸ”§ PATCH: í•™ìƒ ë³¸ì¸ Attempt íˆìŠ¤í† ë¦¬
from apps.domains.results.views.student_exam_attempts_view import (
    MyExamAttemptsView,
)

# ======================================================
# Admin / Teacher
# ======================================================
from apps.domains.results.views.admin_exam_results_view import AdminExamResultsView

# âš ï¸ DEPRECATED (1:1 Session-Exam ê°€ì •)
# - í”„ë¡ íŠ¸ ì „í™˜ ì™„ë£Œ í›„ ì œê±° ì˜ˆì •
from apps.domains.results.views.admin_exam_summary_view import (
    AdminExamSummaryView,
)

from apps.domains.results.views.admin_representative_attempt_view import (
    AdminRepresentativeAttemptView,
)

# âœ… ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸
from apps.domains.results.views.admin_exam_result_detail_view import (
    AdminExamResultDetailView,
)

# ğŸ”§ PATCH: Session â†’ Exam ëª©ë¡ (1:N ì‹œí—˜ êµ¬ì¡° ëŒ€ë¹„)
from apps.domains.results.views.admin_session_exams_view import (
    AdminSessionExamsView,
)

# ğŸ”§ PATCH: ResultFact ë””ë²„ê·¸ ì¡°íšŒ
from apps.domains.results.views.admin_result_fact_view import (
    AdminResultFactView,
)

# ======================================================
# Question statistics (STEP 2)
# ======================================================
from apps.domains.results.views.question_stats_views import (
    AdminExamQuestionStatsView,
    ExamQuestionWrongDistributionView,
    ExamTopWrongQuestionsView,
)

# ======================================================
# Wrong note
# ======================================================
from apps.domains.results.views.wrong_note_view import WrongNoteView
from apps.domains.results.views.wrong_note_pdf_view import WrongNotePDFCreateView
from apps.domains.results.views.wrong_note_pdf_status_view import WrongNotePDFStatusView

# ======================================================
# ExamAttempt (history / retake) - Admin only
# ======================================================
from apps.domains.results.views.exam_attempt_view import ExamAttemptViewSet

# ======================================================
# Session score summary (Admin)
# ======================================================
# ğŸ”§ PATCH: ì„¸ì…˜ ë‹¨ìœ„ "ìµœì¢… ì„±ì " ìš”ì•½ (Progress ê¸°ë°˜)
from apps.domains.results.views.session_score_summary_view import (
    SessionScoreSummaryView,
)

# ======================================================
# âœ… NEW: Session ê¸°ì¤€ ì‹œí—˜ ìš”ì•½ API (1:N Exam ëŒ€ì‘)
# ======================================================
from apps.domains.results.views.admin_session_exams_summary_view import (
    AdminSessionExamsSummaryView,
)


urlpatterns = [
    # ============================
    # Student
    # ============================
    path(
        "me/exams/<int:exam_id>/",
        MyExamResultView.as_view(),
        name="my-exam-result",
    ),

    # ğŸ”§ PATCH: í•™ìƒ ë³¸ì¸ ì¬ì‹œí—˜ / Attempt íˆìŠ¤í† ë¦¬
    path(
        "me/exams/<int:exam_id>/attempts/",
        MyExamAttemptsView.as_view(),
        name="my-exam-attempts",
    ),

    # ============================
    # Admin / Teacher
    # ============================

    # âš ï¸ DEPRECATED
    # - ê¸°ì¡´ í”„ë¡ íŠ¸(AdminExamResultsPanel ë“±)ì—ì„œ ì•„ì§ ì‚¬ìš© ì¤‘
    # - Session ê¸°ì¤€ ìš”ì•½ìœ¼ë¡œ ì™„ì „íˆ ì „í™˜ë˜ë©´ ì œê±° ëŒ€ìƒ
    path(
        "admin/exams/<int:exam_id>/summary/",
        AdminExamSummaryView.as_view(),
        name="admin-exam-summary",
    ),

    path(
        "admin/exams/<int:exam_id>/results/",
        AdminExamResultsView.as_view(),
        name="admin-exam-results",
    ),

    # âœ… ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/",
        AdminExamResultDetailView.as_view(),
        name="admin-exam-result-detail",
    ),

    # ----------------------------
    # STEP 2-A: ë¬¸í•­ ê¸°ë³¸ í†µê³„
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/",
        AdminExamQuestionStatsView.as_view(),
        name="admin-exam-question-stats",
    ),

    # ----------------------------
    # STEP 2-B: ë‹¨ì¼ ë¬¸í•­ ì˜¤ë‹µ ë¶„í¬
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamQuestionWrongDistributionView.as_view(),
        name="admin-exam-question-wrong-distribution",
    ),

    # ----------------------------
    # STEP 2-C: Top N ì˜¤ë‹µ ë¬¸í•­
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/top-wrong/",
        ExamTopWrongQuestionsView.as_view(),
        name="admin-exam-top-wrong-questions",
    ),

    # ============================
    # STEP 8-B: ëŒ€í‘œ attempt ë³€ê²½
    # ============================
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),

    # ============================
    # Session Scores (Admin)
    # ============================

    # ğŸ”¹ Progress ê¸°ë°˜ ì„¸ì…˜ ìµœì¢… ì„±ì  ìš”ì•½
    path(
        "admin/sessions/<int:session_id>/score-summary/",
        SessionScoreSummaryView.as_view(),
        name="session-score-summary",
    ),

    # ğŸ”¹ Session â†’ Exam ëª©ë¡ (ë©”íƒ€)
    path(
        "admin/sessions/<int:session_id>/exams/",
        AdminSessionExamsView.as_view(),
        name="admin-session-exams",
    ),

    # ğŸ”¥ í•µì‹¬: Session ê¸°ì¤€ ì‹œí—˜ ìš”ì•½ (1:N Exam)
    path(
        "admin/sessions/<int:session_id>/exams/summary/",
        AdminSessionExamsSummaryView.as_view(),
        name="admin-session-exams-summary",
    ),

    # ============================
    # ResultFact (Debug / Admin)
    # ============================
    path(
        "admin/facts/",
        AdminResultFactView.as_view(),
        name="admin-result-facts",
    ),

    # ============================
    # Wrong Notes
    # ============================
    path(
        "wrong-notes",
        WrongNoteView.as_view(),
        name="wrong-note",
    ),
    path(
        "wrong-notes/pdf/",
        WrongNotePDFCreateView.as_view(),
        name="wrong-note-pdf-create",
    ),
    path(
        "wrong-notes/pdf/<int:job_id>/",
        WrongNotePDFStatusView.as_view(),
        name="wrong-note-pdf-status",
    ),
]

# ================================
# ExamAttempt router (Admin only)
# ================================
attempt_router = DefaultRouter()
attempt_router.register("exam-attempts", ExamAttemptViewSet)
urlpatterns += attempt_router.urls

# ======================================================
# ExamAttempt (Admin: per exam/enrollment)
# ======================================================
from apps.domains.results.views.admin_exam_attempts_view import (
    AdminExamAttemptsView,
)

urlpatterns += [
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/attempts/",
        AdminExamAttemptsView.as_view(),
        name="admin-exam-attempts",
    ),
]



# ì´ê²ƒë„ ë°˜ì˜í•´ì•¼ ë¨.
# ğŸ”§ URL ë“±ë¡ (í•„ìˆ˜)

# apps/domains/results/urls.pyì— í•œ ì¤„ë§Œ ì¶”ê°€

# from apps.domains.results.views.admin_exam_item_score_view import (
#     AdminExamItemScoreView,
# )

# # ...
# path(
#     "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/items/<int:question_id>/",
#     AdminExamItemScoreView.as_view(),
#     name="admin-exam-item-score",
# ),


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/0002_add_exam_attempt_meta.py
==========================================================================================
# apps/domains/results/migrations/0002_add_exam_attempt_meta.py
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("results", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="examattempt",
            name="meta",
            field=models.JSONField(
                null=True,
                blank=True,
                help_text=(
                    "Attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„°. "
                    "OMR/AI íŒë… ì •ë³´, total_score, pass_score, "
                    "ì¬ì±„ì  ê·¼ê±° ë“± ìš´ì˜/ë¶„ì„ìš© ì •ë³´ ì €ì¥."
                ),
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF

# âŒ SubmissionAnswer ì œê±°ë¨ (raw inputì€ submissions ë„ë©”ì¸ ì±…ì„)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
# apps/domains/results/models/exam_attempt.py
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    í•™ìƒì˜ 'ì‹œí—˜ 1íšŒ ì‘ì‹œ'ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—”í‹°í‹° (append-only)

    ğŸ”¥ í•µì‹¬ ì±…ì„
    - Submission ë‹¨ìœ„ê°€ ì•„ë‹Œ 'ì‹œí—˜ ì‘ì‹œ ì‚¬ì‹¤'ì˜ ê³ ì •
    - Result / ResultFact / Progress ì§‘ê³„ì˜ ê¸°ì¤€ì 
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ì˜ ë‹¨ìœ„

    âœ… ì„¤ê³„ ê³ ì • ì‚¬í•­
    --------------------------------------------------
    1) ExamAttemptëŠ” append-only ê°œë…ì´ë‹¤.
       - ê¸°ì¡´ attemptë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ë‹¤.
       - ëŒ€í‘œ attempt ë³€ê²½ì€ is_representative í”Œë˜ê·¸ë¡œë§Œ ì²˜ë¦¬í•œë‹¤.

    2) Result / ResultItemì€ í•­ìƒ
       "ëŒ€í‘œ attempt(is_representative=True)"ë¥¼ ê°€ë¦¬í‚¤ëŠ” snapshotì´ë‹¤.

    3) meta í•„ë“œëŠ” attempt ë‹¨ìœ„ì˜ 'ìš´ì˜/ë¶„ì„/ì¬ì±„ì  ê·¼ê±°'ë¥¼ ì €ì¥í•œë‹¤.
       - OMR ì‹ ë¢°ë„
       - AI íŒë… ê²°ê³¼
       - total_score / pass_score ìŠ¤ëƒ…ìƒ·
       - ì¬ì±„ì  ì‚¬ìœ  ë“±
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # Submissionì€ ì‹œë„ì˜ ì›ì¸(event)
    submission_id = models.PositiveIntegerField(
        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
    )

    # 1ë¶€í„° ì‹œì‘ (ì‹œí—˜ në²ˆì§¸ ì‘ì‹œ)
    attempt_index = models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")

    # ì¬ì‹œí—˜ ì—¬ë¶€ (attempt_index > 1 ê³¼ ì˜ë¯¸ì ìœ¼ë¡œ ë™ì¼í•˜ì§€ë§Œ, ì¡°íšŒ ìµœì í™”ìš©)
    is_retake = models.BooleanField(default=False)

    # ì„œë²„ê°€ íŒë‹¨í•˜ëŠ” ëŒ€í‘œ attempt
    # ResultëŠ” í•­ìƒ ì´ attemptë¥¼ ê¸°ì¤€ìœ¼ë¡œ snapshotì„ ë§Œë“ ë‹¤.
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ìƒì„±ë¨
            ("grading", "Grading"),     # ì±„ì  ì¤‘
            ("done", "Done"),           # ì±„ì  ì™„ë£Œ
            ("failed", "Failed"),       # ì±„ì  ì‹¤íŒ¨
        ],
        default="pending",
    )

    # ==================================================
    # âœ… NEW: attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„° (ì„¤ê³„ í•„ìˆ˜)
    # ==================================================
    meta = models.JSONField(
        null=True,
        blank=True,
        help_text=(
            "Attempt ë‹¨ìœ„ ë©”íƒ€ë°ì´í„°. "
            "OMR/AI íŒë… ì •ë³´, total_score, pass_score, "
            "ì¬ì±„ì  ê·¼ê±° ë“± ìš´ì˜/ë¶„ì„ìš© ì •ë³´ ì €ì¥."
        ),
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ì‹œí—˜/ìˆ™ì œ ê²°ê³¼ ìµœì‹  ìŠ¤ëƒ…ìƒ· (ì¡°íšŒìš©)
    ê³„ì‚° ì—†ìŒ

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Resultê°€ ì–´ë–¤ ExamAttempt(ì‹œë„)ë¥¼ ëŒ€í‘œí•˜ëŠ”ì§€ ì¶”ì  ê°€ëŠ¥
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ ì‹œì—ë„ "ì–´ë–¤ attempt ê²°ê³¼ì¸ì§€" ëª…í™•í•´ì§

    âš ï¸ ì£¼ì˜:
    - ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ attempt_idëŠ” ì¼ë‹¨ NULL í—ˆìš©ìœ¼ë¡œ ë“¤ì–´ê° (ë§ˆì´ê·¸ë ˆì´ì…˜ì—ì„œ null=True)
    - ìš´ì˜ì—ì„œ ë°±í•„ í›„ null=Falseë¡œ tighten í•˜ëŠ” 2ë‹¨ê³„ê°€ ì •ì„
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì˜ ê²°ê³¼ì¸ì§€ ì¶”ì  (ëŒ€í‘œ attempt ê¸°ì¤€)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    ê²°ê³¼ Fact (append-only, ë¶ˆë³€)
    - ì§‘ê³„/í†µê³„/ì´ë²¤íŠ¸ ë¡œê·¸ì— ê°€ê¹Œì›€

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Factê°€ ì–´ëŠ attemptì—ì„œ ë‚˜ì˜¨ ì´ë²¤íŠ¸ì¸ì§€ ì¶”ì  ê°€ëŠ¥

    âš ï¸ ë¦¬íŒ©í† ë§ ë©”ëª¨ (ì¤‘ìš”)
    ì§€ê¸ˆì€ ResultFactê°€ answer/score/meta/sourceê¹Œì§€ ë“¤ê³  ìˆìŒ.
    ì¥ê¸°ì ìœ¼ë¡œëŠ”:
      - ResultFact = "ì§‘ê³„ìš© ì´ë²¤íŠ¸"
      - ìƒì„¸/ì±„ì ê²°ê³¼ = results.SubmissionAnswer ê°€ ë“¤ê³  ê°€ëŠ” ê²Œ ì •ì„
    ë‹¤ë§Œ ì§€ê¸ˆ ë‹¨ê³„ì—ì„œëŠ” analytics ì œê±° + ë‹¨ìˆœ ìš´ì˜ì„ ìœ„í•´ ìœ ì§€.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì—ì„œ ìƒì„±ëœ Factì¸ì§€
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    ë¬¸í•­ë³„ ìµœì‹  ê²°ê³¼ ìƒíƒœ (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    # =====================================
    # ğŸ”§ PATCH: ì ìˆ˜ í•„ë“œ ëª…ì‹œì  ë¶„ë¦¬
    # - SessionScores / AdminExamResults ê³µìš© ê³„ì•½
    # - í”„ë¡ íŠ¸ ìˆ˜ì • ì—†ì´ í™•ì¥ ê°€ëŠ¥
    # =====================================
    exam_score = serializers.FloatField()
    exam_max_score = serializers.FloatField()

    final_score = serializers.FloatField()
    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # ğŸ”¥ Submission ì—°ë™ í•„ë“œ (ê¸°ì¡´ ìœ ì§€)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (ì‹ ê·œ)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/question_stats.py
==========================================================================================
# apps/domains/results/serializers/question_stats.py

from rest_framework import serializers


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct = serializers.IntegerField()
    accuracy = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    distribution = serializers.DictField(
        child=serializers.IntegerField()
    )


class TopWrongQuestionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    wrong_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/session_exams_summary.py
==========================================================================================
# apps/domains/results/serializers/session_exams_summary.py
from rest_framework import serializers


class SessionExamRowSerializer(serializers.Serializer):
    exam_id = serializers.IntegerField()
    title = serializers.CharField(allow_blank=True)
    pass_score = serializers.FloatField()

    participant_count = serializers.IntegerField()
    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()


class SessionExamsSummarySerializer(serializers.Serializer):
    session_id = serializers.IntegerField()

    participant_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    strategy = serializers.CharField()
    pass_source = serializers.CharField()

    exams = SessionExamRowSerializer(many=True)


==========================================================================================
# FILE: serializers/session_score_summary.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_score_summary.py

from rest_framework import serializers


class SessionScoreSummarySerializer(serializers.Serializer):
    """
    ì„¸ì…˜ ë‹¨ìœ„ ì„±ì  ìš”ì•½ (ìš´ì˜/í†µê³„ìš©)

    âš ï¸ ì£¼ì˜
    - Result / ResultFact / Progress ê²°ê³¼ë§Œ ì‚¬ìš©
    - attempt êµì²´ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ ê°’
    """

    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    attempt_stats = serializers.DictField()


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ë¬¸í•­ë³„ ê²°ê³¼
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ì‹œí—˜ ê²°ê³¼(ì´ì  + ë¬¸í•­ë³„) + ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ê°’

    ì„¤ê³„:
    - Result ëª¨ë¸ ìì²´ëŠ” 'ìŠ¤ëƒ…ìƒ·'ì´ë¯€ë¡œ
      allow_retake/max_attempts/can_retakeëŠ” Exam ì •ì±… + Attempt ìƒíƒœë¡œ ê³„ì‚°í•´ì„œ ë‚´ë ¤ì¤€ë‹¤.
    - ì´ ê°’ë“¤ì€ "ì‘ë‹µ í•„ë“œ"ì´ì§€ Result DB í•„ë“œê°€ ì•„ë‹ˆë‹¤.
      â†’ Viewì—ì„œ ê³„ì‚° í›„ dataì— ì£¼ì…í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ë‹¨ìˆœ/ëª…í™•.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # âœ… STEP 2: í”„ë¡ íŠ¸ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ìš© (ì‘ë‹µ ì „ìš© í•„ë“œ)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # âœ… STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: serializers/wrong_note_pdf_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_pdf_serializers.py
from __future__ import annotations

from rest_framework import serializers


class WrongNotePDFStatusSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ ì‘ë‹µ

    âœ… í”„ë¡ íŠ¸ í´ë§ìš© ìµœì†Œ í•„ë“œ
    - status: PENDING/RUNNING/DONE/FAILED
    - file_url: DONEì¼ ë•Œ ë‹¤ìš´ë¡œë“œ URL
    - error_message: FAILEDì¼ ë•Œ í‘œì‹œ
    """
    job_id = serializers.IntegerField()
    status = serializers.CharField()
    file_path = serializers.CharField(allow_blank=True)
    file_url = serializers.CharField(allow_blank=True, allow_null=True)
    error_message = serializers.CharField(allow_blank=True)
    created_at = serializers.DateTimeField()
    updated_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/wrong_note_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_serializers.py
from __future__ import annotations

from typing import Any, Dict, Optional
from rest_framework import serializers


class WrongNoteItemSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ ë‹¨ì¼ ë¬¸í•­ ì•„ì´í…œ

    âœ… ì˜ë„:
    - ResultFact/ResultItem êµ¬ì¡°ê°€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ì¡°ê¸ˆ ë‹¬ë¼ë„
      Viewì—ì„œ dictë¡œ ë§Œë“¤ì–´ serialize ê°€ëŠ¥í•˜ê²Œ "ë‹¨ìˆœ Serializer"ë¡œ ê³ ì •
    """

    exam_id = serializers.IntegerField()
    attempt_id = serializers.IntegerField()
    attempt_created_at = serializers.DateTimeField(allow_null=True)

    question_id = serializers.IntegerField()
    question_number = serializers.IntegerField(required=False, allow_null=True)
    answer_type = serializers.CharField(required=False, allow_blank=True)

    # í•™ìƒ ë‹µ / ì •ë‹µ / ì ìˆ˜
    student_answer = serializers.CharField(required=False, allow_blank=True)
    correct_answer = serializers.CharField(required=False, allow_blank=True)

    is_correct = serializers.BooleanField()
    score = serializers.FloatField()
    max_score = serializers.FloatField()

    # ì›ë³¸ ë©”íƒ€ (OMR/AI í¬í•¨)
    meta = serializers.JSONField(required=False)

    # ì˜µì…˜: í”„ë¡ íŠ¸ UXìš© (ë¬¸ì œ ì§€ë¬¸/ì„ ì§€/í•´ì„¤ ë“±ì€ í™•ì¥ í¬ì¸íŠ¸)
    extra = serializers.JSONField(required=False)


class WrongNoteListResponseSerializer(serializers.Serializer):
    """
    í˜ì´ì§€ë„¤ì´ì…˜ í¬í•¨ ì‘ë‹µ
    """
    count = serializers.IntegerField()
    next = serializers.IntegerField(allow_null=True)   # ë‹¤ìŒ offset
    prev = serializers.IntegerField(allow_null=True)   # ì´ì „ offset
    results = WrongNoteItemSerializer(many=True)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    ê³„ì‚°ëœ ê²°ê³¼ë¥¼ ë°›ì•„ resultsì— ë°˜ì˜
    âŒ ê³„ì‚° ì—†ìŒ (ê³„ì‚°ì€ graderê°€ í•¨)

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜:
    - apply()ê°€ attempt_idë¥¼ ë°›ì•„ì„œ Result / ResultFactì— ì €ì¥

    âœ… ìš´ì˜ ì•ˆì „ì„± íŒ¨ì¹˜ (Critical #4)
    - ResultFact / ResultItemì— ë“¤ì–´ê°€ëŠ” ê°’ì€ "í•­ìƒ íƒ€ì…ì´ ë³´ì¥ëœë‹¤"ëŠ” ì „ì œê°€ ìš´ì˜ì—ì„œ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
      (blank, meta-only, None, ìˆ«ì/ë¦¬ìŠ¤íŠ¸ ë“±)
    - ë”°ë¼ì„œ ì—¬ê¸°ì„œ ìµœì†Œ ìºìŠ¤íŒ…/ë””í´íŠ¸ë¥¼ ê°•ì œí•´ DB insert ì•ˆì •ì„±ì„ ì˜¬ë¦°ë‹¤.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # âœ… ì¶”ê°€
        items: list[dict],
    ) -> Result:
        """
        items format (ê¶Œì¥):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # âœ… ëŒ€í‘œ attempt ì¶”ì  (ë®ì–´ì“°ëŠ”ê²Œ ì •ìƒ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # âœ… Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1ï¸âƒ£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2ï¸âƒ£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ìƒì„±/ê´€ë¦¬ ì „ë‹´

    ğŸ”¥ Critical íŒ¨ì¹˜:
    - ê°™ì€ submission_idë¡œ Attemptê°€ ì¤‘ë³µ ìƒì„±ë˜ëŠ” ê²ƒì„ ì°¨ë‹¨
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # ğŸ”´ CRITICAL #2
        # -------------------------------------------------
        # ê°™ì€ submissionìœ¼ë¡œ Attemptê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¦‰ì‹œ ì°¨ë‹¨
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1ï¸âƒ£ Exam ì •ì±… ë¡œë”©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2ï¸âƒ£ open_at / close_at ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3ï¸âƒ£ ë™ì‹œì„± ì•ˆì „: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4ï¸âƒ£ ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5ï¸âƒ£ ëŒ€í‘œ attempt êµì²´
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# ğŸ”½ submissions ë„ë©”ì¸ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# ğŸ”½ results ë„ë©”ì¸ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# ğŸ”½ exams ë„ë©”ì¸ (ì •ë‹µ / ë¬¸ì œ ì •ì˜)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey
# (ì„ íƒ) pass_scoreë¥¼ Examì—ì„œ ì½ì„ ìˆ˜ ìˆìœ¼ë©´ ì“°ê³ , ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ ìŠ¤í‚µ
try:
    from apps.domains.exams.models import Exam  # type: ignore
except Exception:  # pragma: no cover
    Exam = None  # type: ignore

# ======================================================
# ğŸ”½ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants (STEP 1 ê³ ì •)
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    ë¬¸ìì—´ ì •ê·œí™” (STEP 1 exact match ê³ ì •):
    - None ë°©ì–´
    - ê³µë°± ì œê±°
    - ëŒ€ë¬¸ì í†µì¼
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ì—ì„œ
    omr dict ë§Œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _ensure_dict(v: Any) -> Dict[str, Any]:
    return v if isinstance(v, dict) else {}


def _with_invalid_reason(meta: Any, reason: str) -> Dict[str, Any]:
    """
    âœ… STEP 1 í•µì‹¬:
    low_conf / blank / multi ë“± "ë¬´íš¨ ì²˜ë¦¬"ëŠ” 0ì  ì²˜ë¦¬ ë¿ ì•„ë‹ˆë¼
    **ì‚¬ìœ ë¥¼ append-onlyë¡œ ë‚¨ê²¨ì•¼ ìš´ì˜/ì¬ì²˜ë¦¬/í”„ë¡ íŠ¸ í‘œì‹œê°€ ê°€ëŠ¥**í•´ì§.
    """
    base = _ensure_dict(meta)
    out = dict(base)
    out.setdefault("grading", {})
    if isinstance(out["grading"], dict):
        out["grading"]["invalid_reason"] = reason
    return out


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
    # âœ… ê¸°ì¡´ metaë¥¼ ë°›ì•„ì„œ invalid_reasonì„ ì‹¬ëŠ”ë‹¤
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    OMR ê°ê´€ì‹ ì±„ì  v1 (STEP 1 ê³ ì •)

    âœ… ì •ì±…:
    - status != ok -> ë¬´íš¨ (0ì )
    - marking blank/multi -> ë¬´íš¨ (0ì )
    - confidence < threshold -> ë¬´íš¨ (0ì ) + LOW_CONFIDENCE ì‚¬ìœ  ì €ì¥  â­â­â­
    - detected != 1ê°œ -> ë¬´íš¨ (0ì )
    """
    st = (status or "").lower()
    mk = (marking or "").lower()

    # 1) statusê°€ okê°€ ì•„ë‹ˆë©´ ë¬´íš¨
    if st != "ok":
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_STATUS_NOT_OK")

    # 2) blank/multiëŠ” ë¬´íš¨
    if mk in ("blank", "multi"):
        reason = "OMR_BLANK" if mk == "blank" else "OMR_MULTI"
        return False, 0.0, _with_invalid_reason(original_meta, reason)

    # 3) ì‹ ë¢°ë„ ì²´í¬ (STEP 1: low confidence ìë™ 0ì  + ì‚¬ìœ  ì €ì¥)
    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0, _with_invalid_reason(original_meta, "LOW_CONFIDENCE")

    # 4) detected 1ê°œ ê°•ì œ
    if not detected or len(detected) != 1:
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_DETECTED_INVALID")

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    ì£¼ê´€ì‹ / fallback ì±„ì  (STEP 1: exact match)

    âœ… ì •ì±…:
    - empty => 0ì 
    - exact match only
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0, _with_invalid_reason(original_meta, "EMPTY_ANSWER")

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type ì¶”ë¡ 
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    âœ… AnswerKey v2 ê³ ì •

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


def _get_pass_score(exam_id: int) -> Optional[float]:
    """
    (ì„ íƒ) Exam.pass_scoreê°€ ìˆìœ¼ë©´ ì½ì–´ì„œ attempt/metaì— ê¸°ë¡.
    - ResultApplierê°€ ì´ë¯¸ is_passë¥¼ ê³„ì‚°í•œë‹¤ë©´ ì´ê±´ "ì§„ë‹¨/í‘œì‹œìš©" ì •ë³´ë¡œë§Œ ë‚¨ëŠ”ë‹¤.
    """
    if Exam is None:
        return None
    try:
        exam = Exam.objects.filter(id=int(exam_id)).first()
        if not exam:
            return None
        v = getattr(exam, "pass_score", None)
        return float(v) if v is not None else None
    except Exception:
        return None


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission â†’ ExamAttempt â†’ Result / ResultItem / ResultFact

    ğŸ”¥ v2 í•µì‹¬ ê³„ì•½:
    - SubmissionAnswer.exam_question_id ë§Œ ì‚¬ìš©
    - number / fallback ì™„ì „ ì œê±°
    - AnswerKey v2 ê³ ì •
    - âœ… STEP 1: LOW_CONF ë¬´íš¨ 0ì  + ì‚¬ìœ  ì €ì¥
    """

    # --------------------------------------------------
    # 0ï¸âƒ£ Submission ìƒíƒœ ì „ì´
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1ï¸âƒ£ ExamAttempt ìƒì„±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2ï¸âƒ£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3ï¸âƒ£ ExamQuestion ë¡œë”© (id ê¸°ì¤€)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        total_score = 0.0
        total_max_score = 0.0

        # --------------------------------------------------
        # 4ï¸âƒ£ ë¬¸í•­ë³„ ì±„ì 
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            # submissions meta
            original_meta = getattr(sa, "meta", None)
            omr = _get_omr_meta(original_meta)

            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            # âœ… STEP 1: low_confidence statusëŠ” ì¦‰ì‹œ ë¬´íš¨ ì²˜ë¦¬ (0ì +ì‚¬ìœ )
            if (status or "").lower() == "low_confidence":
                is_correct = False
                score = 0.0
                final_answer = ""
                final_meta = _with_invalid_reason(original_meta, "LOW_CONFIDENCE")
            else:
                answer_type = _infer_answer_type(q)

                if answer_type in ("choice", "omr", "multiple_choice"):
                    if omr_version.lower() in ("v1", "v2"):
                        is_correct, score, final_meta = _grade_choice_v1(
                            detected=[str(x) for x in detected],
                            marking=marking,
                            confidence=confidence,
                            status=status,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        # í‘œì‹œìš© answer: ê°ì§€ëœ ê°’ 1ê°œë©´ ê·¸ ê°’, ì•„ë‹ˆë©´ ""
                        final_answer = (
                            "".join([_norm(x) for x in detected]) if detected else ""
                        )
                    else:
                        # OMR metaê°€ ì—†ê±°ë‚˜ ë²„ì „ì´ ì—†ì„ ë•Œ: í…ìŠ¤íŠ¸ ê¸°ë°˜ exact match
                        is_correct, score, final_meta = _grade_short_v1(
                            answer_text=answer_text,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        final_answer = answer_text
                else:
                    # subjective: exact match (STEP 1)
                    is_correct, score, final_meta = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                        original_meta=original_meta,
                    )
                    final_answer = answer_text

            # ì ìˆ˜ ëˆ„ì 
            total_score += float(score)
            total_max_score += float(max_score)

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                # âœ… ìµœì¢… metaì—ëŠ” invalid_reasonì´ ë°˜ì˜ë  ìˆ˜ ìˆìŒ
                "meta": final_meta,
            })

        # --------------------------------------------------
        # 4-1) (ì„ íƒ) attempt/metaì— total/pass ì •ë³´ ê¸°ë¡
        # - ResultApplierê°€ ì‹¤ì œ ResultSummary.is_passë¥¼ ë§Œë“¤ë”ë¼ë„,
        #   attemptì—ëŠ” ìš´ì˜/ë””ë²„ê¹…ìš©ìœ¼ë¡œ ë‚¨ê²¨ë‘ë©´ ì¢‹ìŒ.
        # --------------------------------------------------
        try:
            pass_score = _get_pass_score(int(submission.target_id))
            meta = getattr(attempt, "meta", None)
            if isinstance(meta, dict):
                new_meta = dict(meta)
            else:
                new_meta = {}

            new_meta.setdefault("grading", {})
            if isinstance(new_meta["grading"], dict):
                new_meta["grading"]["total_score"] = float(total_score)
                new_meta["grading"]["total_max_score"] = float(total_max_score)
                if pass_score is not None:
                    new_meta["grading"]["pass_score"] = float(pass_score)
                    new_meta["grading"]["is_pass_inferred"] = bool(total_score >= pass_score)

            if hasattr(attempt, "meta"):
                attempt.meta = new_meta
                attempt.save(update_fields=["meta"])
        except Exception:
            # meta í•„ë“œê°€ ì—†ê±°ë‚˜ ì €ì¥ ì‹¤íŒ¨í•´ë„ grading ìì²´ëŠ” ê³„ì† ì§„í–‰
            pass

        # --------------------------------------------------
        # 5ï¸âƒ£ Result ë°˜ì˜
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6ï¸âƒ£ ìƒíƒœ ë§ˆë¬´ë¦¬
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/grading_policy.py
==========================================================================================
# # PATH: apps/domains/results/services/grading_policy.py

# NOTE:
# STEP 2 ì´í›„ grader ë¦¬íŒ©í† ë§ ì‹œ ì‚¬ìš©í•  ì •ì±… ëª¨ë“ˆ
# í˜„ì¬ëŠ” ë¯¸ì‚¬ìš©

# from __future__ import annotations

# from dataclasses import dataclass
# from typing import Any, Dict, Optional, Tuple


# # =========================================================
# # STEP 1 ì •ì±… ìƒìˆ˜ (ê³ ì •)
# # =========================================================

# MIN_OMR_CONFIDENCE = 0.70  # ì´ ë¯¸ë§Œì´ë©´ ìë™ ë¬´íš¨(0ì )


# def normalize_text(s: str) -> str:
#     """
#     ì£¼ê´€ì‹ exact match í‘œì¤€ ì •ê·œí™” (STEP 1 ê³ ì •)
#     - strip + lower
#     - ì¶”í›„ ê³µë°±/íŠ¹ìˆ˜ë¬¸ì ê·œì¹™ì€ ì—¬ê¸°ì„œë§Œ ë°”ê¾¸ë©´ ë¨
#     """
#     return (s or "").strip().lower()


# @dataclass(frozen=True)
# class OMRValidity:
#     is_valid: bool
#     invalid_reason: Optional[str] = None


# def evaluate_omr_validity(submission_answer_meta: Dict[str, Any]) -> OMRValidity:
#     """
#     SubmissionAnswer.meta["omr"] ê¸°ë°˜ìœ¼ë¡œ OMR ìœ íš¨ì„± íŒë‹¨ (STEP 1 ê³ ì •)
#     - low_confidenceë©´ 0ì  ì²˜ë¦¬
#     - ambiguous/multi/blankì€ ë„ˆì˜ ì±„ì  ì •ì±…ì— ë”°ë¼ 0ì /ë¶€ë¶„ì  ë“± í™•ì¥ ê°€ëŠ¥í•˜ì§€ë§Œ
#       STEP 1ì—ì„œëŠ” ìµœì†Œí•œ low_confëŠ” ë¬´ì¡°ê±´ ë¬´íš¨ë¡œ ê³ ì •.
#     """
#     omr = (submission_answer_meta or {}).get("omr") or {}
#     conf = omr.get("confidence")
#     status = str(omr.get("status") or "").lower()

#     try:
#         conf_f = float(conf) if conf is not None else None
#     except Exception:
#         conf_f = None

#     # âœ… ëª…ì‹œì ìœ¼ë¡œ low_confidenceë©´ ë¬´íš¨
#     if status == "low_confidence":
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     # âœ… confidence ê°’ì´ ìˆê³  ì„ê³„ì¹˜ ë¯¸ë§Œì´ë©´ ë¬´íš¨
#     if conf_f is not None and conf_f < MIN_OMR_CONFIDENCE:
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     return OMRValidity(is_valid=True, invalid_reason=None)


# def grade_subjective_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ì£¼ê´€ì‹ exact match ì±„ì  (STEP 1 ê³ ì •)
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def grade_choice_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ê°ê´€ì‹ exact match ê¸°ë³¸ (A/B/C/D)
#     - ë‹¤ì¤‘ë§ˆí‚¹ ì²˜ë¦¬/ë¶€ë¶„ì ì€ STEP 2 ì´í›„ í™•ì¥ í¬ì¸íŠ¸
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def evaluate_pass_fail(total_score: float, pass_score: float) -> bool:
#     """
#     ì‹œí—˜ ë‹¨ìœ„ pass/fail (STEP 1 ê³ ì •)
#     """
#     try:
#         return float(total_score) >= float(pass_score)
#     except Exception:
#         return False


==========================================================================================
# FILE: services/question_stats_service.py
==========================================================================================
# apps/domains/results/services/question_stats_service.py
from __future__ import annotations

from typing import Dict, List, Optional
from django.db.models import Count, Avg, Max, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.models import ResultFact


class QuestionStatsService:
    """
    ì‹œí—˜ ë¬¸í•­ í†µê³„ ë‹¨ì¼ ì§„ì‹¤ (ì •ì„)

    ğŸ”¥ ê¸°ì¤€:
    - ResultFact (append-only)ë§Œ ì‚¬ìš©
    - Result / ResultItem / attempt êµì²´ ì—¬ë¶€ì™€ ë¬´ê´€
    - ìš´ì˜/í†µê³„/ë¶„ì„ ì¼ê´€ì„± ë³´ì¥
    """

    # ======================================================
    # A) ë¬¸í•­ë³„ ê¸°ë³¸ í†µê³„
    # ======================================================
    @staticmethod
    def per_question_stats(
        *,
        exam_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ë¬¸í•­ë³„ í†µê³„
        - ì‘ì‹œ ìˆ˜
        - ì •ë‹µ ìˆ˜
        - ì •ë‹µë¥ 
        - í‰ê·  ì ìˆ˜
        - ìµœëŒ€ ì ìˆ˜
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct=Count("id", filter=Q(is_correct=True)),
                avg_score=Avg("score"),
                max_score=Max("score"),
            )
            .annotate(
                accuracy=ExpressionWrapper(
                    F("correct") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                )
            )
            .order_by("question_id")
        )

        return [
            {
                "question_id": row["question_id"],
                "attempts": int(row["attempts"] or 0),
                "correct": int(row["correct"] or 0),
                "accuracy": round(float(row["accuracy"] or 0.0), 4),
                "avg_score": float(row["avg_score"] or 0.0),
                "max_score": float(row["max_score"] or 0.0),
            }
            for row in rows
        ]

    # ======================================================
    # B) ë¬¸í•­ ë‹¨ì¼ ì˜¤ë‹µ ë¶„í¬ (ì„ íƒì§€ ê¸°ì¤€)
    # ======================================================
    @staticmethod
    def wrong_choice_distribution(
        *,
        exam_id: int,
        question_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> Dict[str, int]:
        """
        ê°ê´€ì‹ ì˜¤ë‹µ ë¶„í¬
        - answer ê°’ ê¸°ì¤€
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            question_id=int(question_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = qs.values("answer").annotate(cnt=Count("id"))

        dist: Dict[str, int] = {}
        for r in rows:
            key = str(r["answer"] or "")
            dist[key] = int(r["cnt"] or 0)

        return dist

    # ======================================================
    # C) ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
    # ======================================================
    @staticmethod
    def top_n_wrong_questions(
        *,
        exam_id: int,
        n: int = 5,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(wrong_count=Count("id"))
            .order_by("-wrong_count")[: int(n)]
        )

        return [
            {
                "question_id": int(r["question_id"]),
                "wrong_count": int(r["wrong_count"]),
            }
            for r in rows
        ]


==========================================================================================
# FILE: services/session_score_summary_service.py
==========================================================================================
# apps/domains/results/services/session_score_summary_service.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.models import ExamAttempt
from apps.domains.progress.models import SessionProgress
from apps.domains.progress.models import ClinicLink
from apps.domains.lectures.models import Session

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_exam_ids_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class SessionScoreSummaryService:
    """
    âœ… Session ë‹¨ìœ„ ì„±ì  í†µê³„ (ìš´ì˜/ëŒ€ì‹œë³´ë“œ)

    ë‹¨ì¼ ì§„ì‹¤ ê·œì¹™:
    - ì ìˆ˜ í†µê³„: Result(ë‹¨, enrollment ì¤‘ë³µ ë°©ì–´ ì ìš©)
    - ì„¸ì…˜ í†µê³¼ìœ¨: SessionProgress.completed(í˜¹ì€ ì •ì±…ì— ë”°ë¼ exam_passed) ì¤‘ ë¬´ì—‡ì¸ì§€ 'ì •ì˜'ê°€ í•„ìš”í•˜ì§€ë§Œ
      ê¸°ì¡´ ì›ë³¸ì€ completedë¥¼ ì‚¬ìš©í–ˆìœ¼ë¯€ë¡œ ì›ë³¸ ì˜ë¯¸ë¥¼ ì¡´ì¤‘í•œë‹¤.
    - í´ë¦¬ë‹‰: ClinicLink (is_auto=True, enrollment distinct)

    âš ï¸ ì„¸ì…˜1:ì‹œí—˜N êµ¬ì¡° ë°˜ì˜:
    - sessionì— ì—°ê²°ëœ exam_idë“¤ì„ ëª¨ë‘ ê°€ì ¸ì™€ì„œ í†µê³„ë¥¼ ë§Œë“ ë‹¤.
    - ë‹¤ë§Œ "ì„¸ì…˜ ì „ì²´ ì ìˆ˜"ë¥¼ 1ê°œ ìˆ«ìë¡œ ë§Œë“¤ ë•ŒëŠ” ì§‘ê³„ ì „ëµì´ í•„ìš”í•¨.
      ì´ ì„œë¹„ìŠ¤ëŠ” "ì„¸ì…˜ ìš´ì˜ í†µê³„" ì„±ê²©ì´ë¯€ë¡œ:
        - ì ìˆ˜ ì§‘ê³„ëŠ” ìš°ì„  exams ì „ì²´ Resultë¥¼ í•©ì³ í‰ê· /ìµœì†Œ/ìµœëŒ€ë¥¼ êµ¬í•˜ëŠ” ë³´ìˆ˜ì  ë°©ì‹ìœ¼ë¡œ ì œê³µ.
      (ì •êµí•œ ì „ëµì€ AdminSessionExamsSummaryViewì—ì„œ examë³„ë¡œ ì œê³µí•˜ëŠ” ê²ƒì´ ì •ì„)
    """

    @staticmethod
    def build(*, session_id: int) -> dict:
        EMPTY_SUMMARY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_rate": 0.0,
            "clinic_rate": 0.0,
            "attempt_stats": {
                "avg_attempts": 0.0,
                "retake_ratio": 0.0,
            },
        }

        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return EMPTY_SUMMARY

        exam_ids = get_exam_ids_for_session(session)
        if not exam_ids:
            # ì„¸ì…˜ì— ì‹œí—˜ì´ ì—†ìœ¼ë©´ ì ìˆ˜ í†µê³„ëŠ” 0, pass/clinicì€ progressë¡œë§Œ íŒë‹¨ ê°€ëŠ¥
            progresses = SessionProgress.objects.filter(session=session)
            participant_count = progresses.count()
            pass_count = progresses.filter(completed=True).count()
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id").distinct().count()
            )
            return {
                **EMPTY_SUMMARY,
                "participant_count": int(participant_count),
                "pass_rate": round((pass_count / participant_count), 4) if participant_count else 0.0,
                "clinic_rate": round((clinic_count / participant_count), 4) if participant_count else 0.0,
            }

        # -------------------------------------------------
        # participant ëª¨ìˆ˜: SessionProgress ê¸°ì¤€(ì›ë³¸ ì¡´ì¤‘)
        # -------------------------------------------------
        progresses = SessionProgress.objects.filter(session=session)
        participant_count = progresses.count()

        # -------------------------------------------------
        # pass_rate: ì›ë³¸ì€ SessionProgress.completed ê¸°ì¤€
        # -------------------------------------------------
        pass_count = progresses.filter(completed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # clinic_rate: ClinicLink ê¸°ì¤€ ë‹¨ì¼í™”
        # -------------------------------------------------
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id")
            .distinct()
            .count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -------------------------------------------------
        # ì ìˆ˜ í†µê³„:
        # - ì„¸ì…˜ì— ì—°ê²°ëœ ëª¨ë“  ì‹œí—˜ì˜ Resultë¥¼ ëª¨ì•„ì„œ í†µê³„
        # - enrollment ì¤‘ë³µ ë°©ì–´: examë³„ latest_results_per_enrollment ì ìš© í›„ í•©ì¹˜ê¸°
        # -------------------------------------------------
        all_results = []
        for exid in exam_ids:
            rs = list(latest_results_per_enrollment(target_type="exam", target_id=int(exid)))
            all_results.extend(rs)

        if not all_results:
            score_summary = {"avg_score": 0.0, "min_score": 0.0, "max_score": 0.0}
        else:
            scores = [float(r.total_score or 0.0) for r in all_results]
            score_summary = {
                "avg_score": (sum(scores) / len(scores)) if scores else 0.0,
                "min_score": min(scores) if scores else 0.0,
                "max_score": max(scores) if scores else 0.0,
            }

        # -------------------------------------------------
        # Attempt í†µê³„(ì¬ì‹œí—˜ ë¹„ìœ¨):
        # - ì„¸ì…˜ì— ì—°ê²°ëœ ëª¨ë“  ì‹œí—˜ì„ ëŒ€ìƒìœ¼ë¡œ attempt í†µê³„
        # -------------------------------------------------
        attempts = ExamAttempt.objects.filter(exam_id__in=[int(x) for x in exam_ids])

        per_enrollment = (
            attempts.values("enrollment_id")
            .annotate(cnt=Count("id"))
        )

        total_attempts = sum(int(r["cnt"] or 0) for r in per_enrollment)
        retake_users = sum(1 for r in per_enrollment if int(r["cnt"] or 0) > 1)

        avg_attempts = (total_attempts / participant_count) if participant_count else 0.0
        retake_ratio = (retake_users / participant_count) if participant_count else 0.0

        return {
            "participant_count": int(participant_count),
            "avg_score": float(score_summary["avg_score"]),
            "min_score": float(score_summary["min_score"]),
            "max_score": float(score_summary["max_score"]),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_rate": round(float(clinic_rate), 4),
            "attempt_stats": {
                "avg_attempts": round(float(avg_attempts), 2),
                "retake_ratio": round(float(retake_ratio), 4),
            },
        }


==========================================================================================
# FILE: services/wrong_note_service.py
==========================================================================================
# apps/domains/results/services/wrong_note_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Q
from django.utils import timezone

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import ExamQuestion, AnswerKey, Exam


# ======================================================
# Request DTO
# ======================================================
@dataclass(frozen=True)
class WrongNoteQuery:
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ íŒŒë¼ë¯¸í„°

    âœ… STEP 3-3 ìŠ¹ê²©
    - lecture_id/from_session_order í•„í„°ë¥¼ ì„œë¹„ìŠ¤ ì±…ì„ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¼
      (View/Worker/PDF ëª¨ë‘ ê°™ì€ ê·œì¹™ ì‚¬ìš©)

    - offset/limitì€ ë‹¨ìˆœ í˜ì´ì§€ë„¤ì´ì…˜
    """
    exam_id: Optional[int] = None
    lecture_id: Optional[int] = None
    from_session_order: int = 2

    offset: int = 0
    limit: int = 50


# ======================================================
# Internal helpers
# ======================================================
def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _has_relation(model, name: str) -> bool:
    """
    Exam ëª¨ë¸ì— íŠ¹ì • relation(name)ì´ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


def _get_exam_ids_by_lecture_and_order(*, lecture_id: int, from_order: int) -> List[int]:
    """
    lecture_id + from_session_orderë¡œ exam_id ëª©ë¡ êµ¬í•˜ê¸°

    âš ï¸ í”„ë¡œì íŠ¸ë³„ë¡œ Exam â†” Session reverse relation ì´ë¦„ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ:
    - sessions / session / session_set ...
    ê·¸ë˜ì„œ ê°€ëŠ¥í•œ í›„ë³´ë“¤ì„ ëª¨ë‘ ê²€ì‚¬í•´ ì•ˆì „í•˜ê²Œ í•„í„°ë§.

    âœ… ê·œì¹™:
    - ê´€ê³„ë¥¼ ëª» ì°¾ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜(=ì•ˆì „í•˜ê²Œ ê²°ê³¼ ì—†ìŒ)
    """
    exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

    # ìš°ì„ ìˆœìœ„ í›„ë³´ë“¤
    # 1) sessions
    if _has_relation(Exam, "sessions"):
        exam_qs = exam_qs.filter(sessions__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 2) session (1:1 í˜¹ì€ FK)
    if _has_relation(Exam, "session"):
        exam_qs = exam_qs.filter(session__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 3) session_set (Django default reverse name)
    if _has_relation(Exam, "session_set"):
        exam_qs = exam_qs.filter(session_set__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # ëª» ì°¾ìœ¼ë©´ ì•ˆì „í•˜ê²Œ none
    return []


def _get_answer_key_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey v2 (ê³ ì •):
      answers = { "123": "B", ... }  # key = ExamQuestion.id(str)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    answers = getattr(ak, "answers", None) if ak else None
    return answers if isinstance(answers, dict) else {}


# ======================================================
# Public API
# ======================================================
def list_wrong_notes_for_enrollment(
    *,
    enrollment_id: int,
    q: WrongNoteQuery,
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    âœ… í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ResultFact êµ¬ì¡°ì— ë§ëŠ” â€œì •ì„â€ êµ¬í˜„

    ResultFact = ë¬¸í•­ 1ê°œ ì´ë²¤íŠ¸(append-only)
      - question_id/answer/is_correct/score/max_score/meta/source ê°€ Factì— ì§ì ‘ ìˆìŒ

    ë°˜í™˜: (total_count, paged_items)
    """

    enrollment_id = int(enrollment_id)
    offset = max(int(q.offset or 0), 0)
    limit = max(min(int(q.limit or 50), 200), 1)

    base = ResultFact.objects.filter(
        enrollment_id=enrollment_id,
        target_type="exam",
        is_correct=False,          # ì˜¤ë‹µë§Œ
    )

    # 1) exam_id í•„í„°
    if q.exam_id is not None:
        base = base.filter(target_id=int(q.exam_id))

    # 2) lecture_id + from_session_order í•„í„° (STEP 3-3 ìŠ¹ê²©)
    if q.lecture_id is not None:
        exam_ids = _get_exam_ids_by_lecture_and_order(
            lecture_id=int(q.lecture_id),
            from_order=int(q.from_session_order or 2),
        )
        if not exam_ids:
            return 0, []
        base = base.filter(target_id__in=exam_ids)

    # ìµœì‹  ì˜¤ë‹µ ìš°ì„ 
    base = base.order_by("-id")

    total = base.count()

    facts = list(base[offset: offset + limit])

    # ì§ˆë¬¸ ì •ë³´/ì •ë‹µí‚¤ ë¶™ì´ê¸° ìœ„í•´ question_ids, exam_ids ìˆ˜ì§‘
    question_ids = [int(f.question_id) for f in facts]
    exam_ids = list({int(f.target_id) for f in facts})

    questions_map = (
        ExamQuestion.objects
        .filter(id__in=question_ids)
        .select_related("sheet")
        .in_bulk(field_name="id")
    )

    answer_key_cache: Dict[int, Dict[str, Any]] = {
        exid: _get_answer_key_map(exid) for exid in exam_ids
    }

    out: List[Dict[str, Any]] = []

    for f in facts:
        exid = int(f.target_id)
        qobj = questions_map.get(int(f.question_id))

        question_number = getattr(qobj, "number", None) if qobj else None
        answer_type = (getattr(qobj, "answer_type", "") or "") if qobj else ""

        correct_answer = ""
        if qobj:
            correct_answer = str(answer_key_cache.get(exid, {}).get(str(qobj.id)) or "")

        out.append({
            "exam_id": exid,
            "attempt_id": int(getattr(f, "attempt_id", 0) or 0),
            # attempt_created_at í•„ë“œê°€ ë”°ë¡œ ì—†ìœ¼ë‹ˆ created_atì„ ì‚¬ìš©
            "attempt_created_at": getattr(f, "created_at", None),

            "question_id": int(f.question_id),
            "question_number": _safe_int(question_number),
            "answer_type": str(answer_type),

            "student_answer": str(f.answer or ""),
            "correct_answer": str(correct_answer or ""),

            "is_correct": False,
            "score": float(f.score or 0.0),
            "max_score": float(f.max_score or 0.0),

            "meta": f.meta if f.meta is not None else {},
            "extra": {},
        })

    return total, out


==========================================================================================
# FILE: tasks/__init__.py
==========================================================================================



==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from __future__ import annotations

import logging
from celery import shared_task

logger = logging.getLogger(__name__)


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={"max_retries": 3},
    retry_backoff=True,
    retry_jitter=True,
)
def grade_submission_task(self, submission_id: int) -> None:
    """
    STEP 1 í™•ì •:
    - ì±„ì  íƒœìŠ¤í¬ëŠ” ìë™ ì¬ì‹œë„ 3íšŒ
    - ì‹¤ì œ ì±„ì  ì§„ì…ì ì€ results.services.grader.grade_submission_to_results

    ğŸ”§ FIX:
    - ê¸°ì¡´ grade_submission ì€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
    - ì‹¤ì œ êµ¬í˜„ëœ í•¨ìˆ˜ëª…ìœ¼ë¡œ ì •í™•íˆ ì—°ê²°
    """
    from apps.domains.submissions.models import Submission
    from apps.domains.results.services.grader import (
        grade_submission_to_results,
    )

    submission = Submission.objects.get(id=int(submission_id))

    logger.info("grading start: submission_id=%s", submission_id)
    grade_submission_to_results(submission)
    logger.info("grading done: submission_id=%s", submission_id)


==========================================================================================
# FILE: tasks/progress_pipeline_task.py
==========================================================================================
# apps/domains/progress/tasks/progress_pipeline_task.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.progress.services.progress_pipeline import ProgressPipeline


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def run_progress_pipeline_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)

    result = Result.objects.filter(
        target_type=submission.target_type,
        target_id=submission.target_id,
        enrollment_id=submission.enrollment_id,
    ).first()

    if not result:
        return False

    ProgressPipeline.run_by_submission(
        submission=submission,
        result=result,
    )

    return True


==========================================================================================
# FILE: tasks/wrong_note_pdf_tasks.py
==========================================================================================
# apps/domains/results/tasks/wrong_note_pdf_tasks.py
from __future__ import annotations

from io import BytesIO
from typing import Optional

from celery import shared_task
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

from apps.domains.results.models import WrongNotePDF
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


# ======================================================
# âœ… STEP 1: reportlab ì§€ì—° import (ì •ì„)
# - API ì„œë²„ / migrate / runserver í™˜ê²½ì—ì„œ reportlabì´ ì—†ì–´ë„ OK
# - PDF worker í™˜ê²½ì—ì„œë§Œ reportlab í•„ìš”
# ======================================================
def _import_reportlab():
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas
        return A4, canvas
    except ImportError as e:
        raise RuntimeError(
            "reportlab is required only on PDF worker environment"
        ) from e


@shared_task(bind=True, max_retries=3, default_retry_delay=10)
def generate_wrong_note_pdf_task(self, job_id: int) -> None:
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Worker (Celery)

    âœ… STEP 3-3 ë°˜ì˜:
    - lecture_id/from_session_order í•„í„°ê¹Œì§€ serviceë¡œ í†µì¼

    âœ… STEP 1 (ì¤‘ìš”):
    - reportlab ì§€ì—° import ì ìš©
      -> ì´ taskê°€ ì‹¤ì œ ì‹¤í–‰ë  ë•Œë§Œ reportlab import
    """

    job = WrongNotePDF.objects.filter(id=int(job_id)).first()
    if not job:
        return

    # ë©±ë“±ì„±/ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if job.status == WrongNotePDF.Status.DONE:
        return
    if job.status == WrongNotePDF.Status.RUNNING:
        return

    def _set_status(status: str, error: str = "") -> None:
        job.status = status
        job.error_message = (error or "")[:2000]
        job.save(update_fields=["status", "error_message"])

    try:
        _set_status(WrongNotePDF.Status.RUNNING)

        enrollment_id = int(job.enrollment_id)

        q = WrongNoteQuery(
            exam_id=int(job.exam_id) if job.exam_id else None,
            lecture_id=int(job.lecture_id) if job.lecture_id else None,
            from_session_order=int(job.from_session_order or 2),
            offset=0,
            limit=200,  # PDFëŠ” ìš°ì„  ìƒìœ„ 200ê°œ
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id,
            q=q,
        )

        # --------------------------------------------------
        # âœ… STEP 1: reportlabì€ "ì‹¤ì œ PDF ìƒì„± ì‹œì "ì—ë§Œ import
        # --------------------------------------------------
        A4, canvas = _import_reportlab()

        # ------------------------------
        # PDF ìƒì„± (ìµœì†Œ êµ¬í˜„: í…ìŠ¤íŠ¸ ë¦¬ìŠ¤íŠ¸)
        # ------------------------------
        buf = BytesIO()
        c = canvas.Canvas(buf, pagesize=A4)
        _, height = A4

        y = height - 48
        c.setFont("Helvetica-Bold", 14)
        c.drawString(40, y, "Wrong Notes")
        y -= 20

        c.setFont("Helvetica", 10)
        c.drawString(40, y, f"Enrollment: {enrollment_id}")
        y -= 14
        c.drawString(40, y, f"Total wrong items: {total}")
        y -= 20

        for idx, it in enumerate(items, start=1):
            if y < 80:
                c.showPage()
                y = height - 60
                c.setFont("Helvetica", 10)

            line = (
                f"{idx}. "
                f"Exam {it.get('exam_id')} / "
                f"Q{it.get('question_number') or it.get('question_id')} "
                f"| ans={it.get('student_answer','')} "
                f"| correct={it.get('correct_answer','')} "
                f"| score={it.get('score',0)}/{it.get('max_score',0)}"
            )
            c.drawString(40, y, line[:120])
            y -= 14

        c.showPage()
        c.save()
        buf.seek(0)

        key = f"results/wrong_notes/{int(job.id)}.pdf"
        default_storage.save(key, ContentFile(buf.read()))

        job.file_path = key
        job.status = WrongNotePDF.Status.DONE
        job.error_message = ""
        job.save(update_fields=["file_path", "status", "error_message"])

    except Exception as e:
        msg = str(e)
        try:
            _set_status(WrongNotePDF.Status.FAILED, msg)
        finally:
            # âœ… ê¸°ì¡´ ë™ì‘ ì¡´ì¤‘: retryë¡œ ì¬ì‹œë„
            raise self.retry(exc=e)


==========================================================================================
# FILE: utils/clinic.py
==========================================================================================
# apps/domains/results/utils/clinic.py
from __future__ import annotations

from typing import Set

from apps.domains.lectures.models import Session
from apps.domains.progress.models import ClinicLink


def get_clinic_enrollment_ids_for_session(
    *,
    session: Session,
    include_manual: bool = False,
) -> Set[int]:
    """
    âœ… Clinic ë‹¨ì¼ ê·œì¹™ ì œê³µ

    ê¸°ë³¸ ì •ì±…(ê¶Œì¥/ì•ˆì „):
    - ìš´ì˜ì—ì„œ clinic_required/clinic_rateëŠ” 'ìë™ íŠ¸ë¦¬ê±°' ê¸°ì¤€ìœ¼ë¡œ í†µì¼í•œë‹¤.
      -> include_manual=False (default)

    ì™œëƒí•˜ë©´:
    - ìˆ˜ë™ í´ë¦¬ë‹‰(ê°•ì‚¬ ì¶”ì²œ/ìš”ì²­)ì€ UX/ìš´ì˜ ì •ì±…ì— ë”°ë¼ ì¼€ì´ìŠ¤ê°€ ë‹¬ë¼ì„œ
      í†µê³„ì— ì„ì´ë©´ í™”ë©´ë§ˆë‹¤ "ì™œ ë‹¤ë¥´ëƒ" ë¬¸ì œê°€ ë°˜ë³µëœë‹¤.

    í•„ìš”í•˜ë©´ include_manual=Trueë¡œ
    ìˆ˜ë™ê¹Œì§€ í¬í•¨í•œ 'ì „ì²´ clinic ëŒ€ìƒ'ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
    """
    qs = ClinicLink.objects.filter(session=session)

    if not include_manual:
        qs = qs.filter(is_auto=True)

    return set(qs.values_list("enrollment_id", flat=True).distinct())


def is_clinic_required(
    *,
    session: Session,
    enrollment_id: int,
    include_manual: bool = False,
) -> bool:
    """
    âœ… enrollment ë‹¨ìœ„ clinic ì—¬ë¶€ (ë‹¨ì¼ ì§„ì‹¤)
    """
    enrollment_id = int(enrollment_id)
    ids = get_clinic_enrollment_ids_for_session(
        session=session,
        include_manual=include_manual,
    )
    return enrollment_id in ids


==========================================================================================
# FILE: utils/result_queries.py
==========================================================================================
# apps/domains/results/utils/result_queries.py
from __future__ import annotations

from django.db.models import Max, QuerySet, Subquery

from apps.domains.results.models import Result


def latest_results_per_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> QuerySet[Result]:
    """
    âœ… í†µê³„/ì§‘ê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” 'ìµœì‹  Result' queryset (enrollment ê¸°ì¤€ 1ê°œ)

    ì™œ í•„ìš”í•œê°€?
    - unique_togetherê°€ ìˆì–´ë„ ìš´ì˜ì—ì„œëŠ”:
        - ê³¼ê±° ë°ì´í„° ê¹¨ì§
        - manual insert
        - ì¥ì•  ë³µêµ¬/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤ìˆ˜
      ë¡œ ë™ì¼ enrollmentì˜ Resultê°€ ì¤‘ë³µë  ìˆ˜ ìˆë‹¤.
    - í†µê³„ëŠ” ì¤‘ë³µì„ ê³ ë ¤í•˜ì§€ ì•Šìœ¼ë©´ participant/avg/min/max ì „ë¶€ ì™œê³¡.

    êµ¬í˜„ ë°©ì‹:
    - enrollment_idë³„ë¡œ ê°€ì¥ í° id(ê°€ì¥ ìµœê·¼ insert)ë¥¼ ì„ íƒ
    - DB vendor ë…ë¦½ (Postgresì˜ distinct on ê°™ì€ ê¸°ëŠ¥ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ)
    """
    target_id = int(target_id)

    base = Result.objects.filter(
        target_type=str(target_type),
        target_id=target_id,
    )

    # enrollmentë³„ ê°€ì¥ ìµœì‹  Result.idë¥¼ ì„ íƒ
    latest_ids = (
        base.values("enrollment_id")
        .annotate(last_id=Max("id"))
        .values("last_id")
    )

    return Result.objects.filter(id__in=Subquery(latest_ids))


def participant_count_distinct_enrollment(
    *,
    target_type: str,
    target_id: int,
) -> int:
    """
    âœ… participant_count ë‹¨ì¼ ê·œì¹™: distinct enrollment ê¸°ì¤€
    """
    return (
        Result.objects.filter(
            target_type=str(target_type),
            target_id=int(target_id),
        )
        .values("enrollment_id")
        .distinct()
        .count()
    )


==========================================================================================
# FILE: utils/session_exam.py
==========================================================================================
# apps/domains/results/utils/session_exam.py
from __future__ import annotations

from typing import List, Optional

from django.db.models import QuerySet

from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


def _has_relation(model, name: str) -> bool:
    """
    ëª¨ë¸ì— íŠ¹ì • field/relationì´ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬.
    í”„ë¡œì íŠ¸ íˆìŠ¤í† ë¦¬(ì„¸ì…˜-ì‹œí—˜ ê´€ê³„ê°€ ë°”ë€ŒëŠ” ê³¼ì •)ì—ì„œ
    ëŸ°íƒ€ì„ì— ì•ˆì „í•˜ê²Œ ë™ì‘ì‹œí‚¤ê¸° ìœ„í•œ ë°©ì–´ ìœ í‹¸.
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


# ---------------------------------------------------------------------
# âœ… Canonical API: Session -> Exams
# ---------------------------------------------------------------------
def get_exams_for_session(session: Session) -> QuerySet[Exam]:
    """
    âœ… ë‹¨ì¼ ì§„ì‹¤: Sessionì— ì—°ê²°ëœ Exam queryset ë°˜í™˜

    ì›ì¹™:
    - ì•ìœ¼ë¡œ 'Session â†” Exam ê´€ê³„ í•´ì„'ì€ ì´ í•¨ìˆ˜ë¡œë§Œ í•œë‹¤.
    - ì–´ë–¤ APIì—ì„œë„ ë‹¤ìŒì„ ì§ì ‘ ì“°ì§€ ë§ ê²ƒ:
        session.exams / Exam.objects.filter(sessions__id=...) / Session.objects.filter(exams__id=...)
      â†’ íŒŒì¼ë§ˆë‹¤ ë‹¤ë¥´ê²Œ êµ¬í˜„ë˜ë©° "í™”ë©´ë§ˆë‹¤ ê²°ê³¼ ë‹¤ë¦„" ë²„ê·¸ì˜ ì›ì¸.
    """
    # 1) Session.exams (M2M) - ê°€ì¥ canonical
    if _has_relation(Session, "exams") and hasattr(session, "exams"):
        try:
            return session.exams.all()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Exam.objects.filter(sessions__id=int(session.id)).distinct()

    # 3) Legacy fallback: Session.exam (FK)
    #    (ì´ë¯¸ 1:Nìœ¼ë¡œ ë¦¬íŒ©í† ë§ í–ˆë‹¤ê³  í–ˆìœ¼ë‹ˆ, ìš´ì˜ì—ì„œ ì—†ì–´ë„ ë¬´ë°©í•˜ì§€ë§Œ
    #     ê°œë°œ/ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤‘ ì„ì—¬ ìˆì„ ìˆ˜ ìˆì–´ ë°©ì–´ì ìœ¼ë¡œ ìœ ì§€)
    exam_id = getattr(session, "exam_id", None)
    if exam_id:
        return Exam.objects.filter(id=int(exam_id))

    # 4) ëª» ì°¾ìœ¼ë©´ empty
    return Exam.objects.none()


def get_exam_ids_for_session(session: Session) -> List[int]:
    """
    âœ… Session -> exam_id list

    - í†µê³„/ì§‘ê³„ì—ì„œ ë¦¬ìŠ¤íŠ¸ê°€ í•„ìš”í•  ë•Œ ì‚¬ìš©.
    - queryset ëŒ€ì‹  list[int]ë¡œ ê³ ì •í•´ì„œ í˜¸ì¶œì¸¡ì˜ ì¤‘ë³µ/ì˜¤í•´ë¥¼ ì¤„ì„.
    """
    return list(get_exams_for_session(session).values_list("id", flat=True))


# ---------------------------------------------------------------------
# âœ… Canonical API: Exam -> Sessions
# ---------------------------------------------------------------------
def get_sessions_for_exam(exam_id: int) -> QuerySet[Session]:
    """
    âœ… ë‹¨ì¼ ì§„ì‹¤: íŠ¹ì • exam_idê°€ ì†í•œ Session queryset ë°˜í™˜

    (ì„¸ì…˜ 1 : ì‹œí—˜ N êµ¬ì¡°)
    - Session.exams(M2M)ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ìš°ì„  ì‚¬ìš©
    - ì—†ìœ¼ë©´ Exam.sessions reverse ì‚¬ìš©
    - ë§ˆì§€ë§‰ìœ¼ë¡œ legacy Session.exam FK fallback
    """
    exam_id = int(exam_id)

    # 1) Session.exams (M2M)
    if _has_relation(Session, "exams"):
        try:
            return Session.objects.filter(exams__id=exam_id).distinct()
        except Exception:
            pass

    # 2) Exam.sessions reverse (M2M)
    if _has_relation(Exam, "sessions"):
        return Session.objects.filter(exams__id=exam_id).distinct()

    # 3) legacy: Session.exam FK
    return Session.objects.filter(exam_id=exam_id).distinct()


def get_primary_session_for_exam(exam_id: int) -> Optional[Session]:
    """
    âœ… 'ëŒ€í‘œ session'ì´ í•„ìš”í•  ë•Œ ì‚¬ìš© (ì˜ˆ: legacy API)

    ì •ì±…:
    - ì—¬ëŸ¬ sessionì´ ê±¸ë¦´ ìˆ˜ ìˆìœ¼ë©´ orderê°€ ê°€ì¥ ì‘ì€(ë¹ ë¥¸) sessionì„ ìš°ì„  ë°˜í™˜.
    - order í•„ë“œê°€ ì—†ê±°ë‚˜ ì •ë ¬ ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ first().
    """
    qs = get_sessions_for_exam(int(exam_id))
    if not qs.exists():
        return None

    # orderê°€ ì¡´ì¬í•  ê°€ëŠ¥ì„±ì´ ë†’ìŒ(lecture session order)
    if hasattr(Session, "order"):
        try:
            return qs.order_by("order", "id").first()
        except Exception:
            pass

    return qs.order_by("id").first()


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# apps/domains/results/views/__init__.py

"""
results.views public exports

âš ï¸ IMPORTANT RULES
- ì´ íŒŒì¼ì€ "ì™¸ë¶€ì—ì„œ import í•´ë„ ë˜ëŠ” View"ë§Œ exportí•œë‹¤.
- urls.pyì—ì„œ ì§ì ‘ importí•˜ëŠ” ViewëŠ” êµ³ì´ ì—¬ê¸°ì„œ exportí•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
- ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ / í´ë˜ìŠ¤ê°€ importë˜ë©´
  migrate / runserver ì‹œì ì— ì¦‰ì‹œ í¬ë˜ì‹œ ë‚œë‹¤.
"""

# ======================================================
# Student-facing
# ======================================================
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

# ======================================================
# Admin / Teacher-facing (ëŒ€í‘œ Viewë§Œ)
# ======================================================
from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView

# ======================================================
# âš ï¸ Question stats ê´€ë ¨
# - AdminExamQuestionStatsView ë“±ì€
#   urls.pyì—ì„œ ì§ì ‘ importí•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” exportí•˜ì§€ ì•ŠëŠ”ë‹¤.
# - ì¤‘ë³µ export / ë¶ˆí•„ìš”í•œ importë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•¨
# ======================================================

__all__ = [
    "MyExamResultView",
    "WrongNoteView",
    "AdminExamResultsView",
    "AdminExamSummaryView",
]


==========================================================================================
# FILE: views/admin_exam_attempts_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_attempts_view.py
# ==========================================================================================
"""
Admin Exam Attempt List View

GET /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/attempts/

==========================================================================================
âœ… ëª©ì  (Phase 1)
==========================================================================================
- Admin / Teacherê°€ íŠ¹ì • ì‹œí—˜(exam_id) + íŠ¹ì • enrollmentì˜
  ExamAttempt ëª©ë¡ì„ ì¡°íšŒí•œë‹¤.
- AttemptSelectorPanelì˜ ë°ì´í„° ì†ŒìŠ¤

==========================================================================================
âœ… ê³„ì•½ (í”„ë¡ íŠ¸ ê³ ì •)
==========================================================================================
ì‘ë‹µ:
[
  {
    "id": 101,
    "attempt_index": 1,
    "is_retake": false,
    "is_representative": true,
    "status": "done",
    "created_at": "2025-01-01T10:00:00Z",
    "meta": {
      "grading": {
        "total_score": 85,
        "total_max_score": 100
      }
    }
  }
]

- ì •ë ¬: attempt_index ASC
- ëŒ€í‘œ attempt: í•­ìƒ 1ê°œ ë³´ì¥ (ì„œë²„ invariant)
- status enum:
    pending | grading | done | failed

==========================================================================================
âš ï¸ ì£¼ì˜
==========================================================================================
- ìˆ˜ì •/ëŒ€í‘œ ë³€ê²½ âŒ (Phase 2ì—ì„œ êµ¬í˜„)
- enrollment_idëŠ” Enrollment PK ê¸°ì¤€ (results ë„ë©”ì¸ ì „ì²´ ê³„ì•½ê³¼ ë™ì¼)
"""

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt


class AdminExamAttemptsView(APIView):
    """
    Admin / Teacher ì „ìš© Attempt ëª©ë¡ ì¡°íšŒ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        # -------------------------------------------------
        # 1ï¸âƒ£ Attempt ì¡°íšŒ
        # -------------------------------------------------
        attempts = (
            ExamAttempt.objects
            .filter(
                exam_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .order_by("attempt_index")  # âœ… í”„ë¡ íŠ¸ ê³„ì•½
        )

        if not attempts.exists():
            # ë¹ˆ ë°°ì—´ì„ ë‚´ë ¤ë„ ë˜ì§€ë§Œ,
            # Admin í™”ë©´ì—ì„œëŠ” ë³´í†µ "ì¡´ì¬í•˜ì§€ ì•ŠìŒ"ì´ ì˜ë¯¸ ìˆëŠ” ì˜¤ë¥˜ë¼ íŒë‹¨
            raise ValidationError("No attempts found for this exam/enrollment.")

        # -------------------------------------------------
        # 2ï¸âƒ£ ì‘ë‹µ êµ¬ì„± (Serializer ì—†ì´ ëª…ì‹œì  dict)
        #    - í”„ë¡ íŠ¸ ê³„ì•½ ì•ˆì •ì„±
        #    - meta êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ ë…¸ì¶œ ê°€ëŠ¥
        # -------------------------------------------------
        data = []
        for a in attempts:
            row = {
                "id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": bool(a.is_retake),
                "is_representative": bool(a.is_representative),
                "status": a.status,
                "created_at": a.created_at,
            }

            # meta í•„ë“œê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë…¸ì¶œ (grading ì •ë³´ í¬í•¨ ê°€ëŠ¥)
            if hasattr(a, "meta") and a.meta is not None:
                row["meta"] = a.meta
            else:
                row["meta"] = {}

            data.append(row)

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_item_score_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_item_score_view.py
# ==========================================================================================
"""
Admin Manual Grading - Subjective Question Score

PATCH /results/admin/exams/{exam_id}/enrollments/{enrollment_id}/items/{question_id}/

==========================================================================================
âœ… ëª©ì  (Phase 3)
==========================================================================================
- ì£¼ê´€ì‹/ìˆ˜ë™ ì±„ì  ì ìˆ˜ë¥¼ ë¬¸í•­ ë‹¨ìœ„ë¡œ ìˆ˜ì •í•œë‹¤.
- í•­ìƒ "ëŒ€í‘œ attempt" ê¸°ì¤€ Result ìŠ¤ëƒ…ìƒ·ì„ ìˆ˜ì •í•œë‹¤.
- ResultItem + ResultFactë¥¼ ë™ì‹œì— ë°˜ì˜í•œë‹¤.
- total_scoreëŠ” ì¦‰ì‹œ ì¬ê³„ì‚°ëœë‹¤.

==========================================================================================
âœ… í”„ë¡ íŠ¸ ê³„ì•½ (ê³ ì •)
==========================================================================================
- ì €ì¥ ì„±ê³µ í›„:
    â†’ ë°˜ë“œì‹œ AdminExamResultDetail ì¬ì¡°íšŒ
- ì´ APIëŠ” "ì €ì¥"ë§Œ ì±…ì„ì§„ë‹¤.
  (clinic_required / pass ì—¬ë¶€ íŒë‹¨ì€ detail APIê°€ ì§„ì‹¤ì˜ ì›ì²œ)

==========================================================================================
âš ï¸ ì£¼ì˜
==========================================================================================
- grading ì¤‘ì¸ attemptëŠ” ìˆ˜ì • ë¶ˆê°€ (LOCKED)
- ì ìˆ˜ ìƒí•œ(max_score) ì´ˆê³¼ëŠ” í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.
"""

from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultItem, ResultFact, ExamAttempt


class AdminExamItemScoreView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @transaction.atomic
    def patch(
        self,
        request,
        exam_id: int,
        enrollment_id: int,
        question_id: int,
    ):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        question_id = int(question_id)

        if "score" not in request.data:
            raise ValidationError({"detail": "score is required", "code": "INVALID"})

        try:
            new_score = float(request.data.get("score"))
        except Exception:
            raise ValidationError({"detail": "score must be number", "code": "INVALID"})

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ëŒ€í‘œ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .select_for_update()
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .first()
        )
        if not result:
            raise NotFound({"detail": "result not found", "code": "NOT_FOUND"})

        if not result.attempt_id:
            raise ValidationError(
                {"detail": "representative attempt not set", "code": "INVALID"}
            )

        # -------------------------------------------------
        # 2ï¸âƒ£ Attempt ìƒíƒœ í™•ì¸
        # -------------------------------------------------
        attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
        if not attempt:
            raise NotFound({"detail": "attempt not found", "code": "NOT_FOUND"})

        if attempt.status == "grading":
            return Response(
                {"detail": "attempt is grading", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 3ï¸âƒ£ ResultItem (ë¬¸í•­ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        item = (
            ResultItem.objects
            .select_for_update()
            .filter(result=result, question_id=question_id)
            .first()
        )
        if not item:
            raise NotFound({"detail": "result item not found", "code": "NOT_FOUND"})

        # ì ìˆ˜ ìƒí•œ ë°©ì–´
        max_score = float(item.max_score or 0.0)
        if new_score < 0 or new_score > max_score:
            raise ValidationError(
                {
                    "detail": f"score must be between 0 and {max_score}",
                    "code": "INVALID",
                }
            )

        # -------------------------------------------------
        # 4ï¸âƒ£ ResultFact (append-only ë¡œê·¸)
        # -------------------------------------------------
        ResultFact.objects.create(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=0,              # ìˆ˜ë™ ì±„ì ì´ë¯€ë¡œ 0
            attempt_id=int(result.attempt_id),

            question_id=question_id,
            answer=item.answer or "",
            is_correct=bool(new_score >= max_score),
            score=float(new_score),
            max_score=max_score,
            source="manual",
            meta={
                "manual": True,
                "edited_at": timezone.now().isoformat(),
            },
        )

        # -------------------------------------------------
        # 5ï¸âƒ£ ResultItem ì—…ë°ì´íŠ¸
        # -------------------------------------------------
        item.score = float(new_score)
        item.is_correct = bool(new_score >= max_score)
        item.source = "manual"
        item.save(update_fields=["score", "is_correct", "source"])

        # -------------------------------------------------
        # 6ï¸âƒ£ total_score ì¬ê³„ì‚°
        # -------------------------------------------------
        agg = (
            ResultItem.objects
            .filter(result=result)
        )

        total_score = sum(float(x.score or 0.0) for x in agg)
        max_total = sum(float(x.max_score or 0.0) for x in agg)

        result.total_score = float(total_score)
        result.max_score = float(max_total)
        result.save(update_fields=["total_score", "max_score"])

        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "question_id": question_id,
                "score": float(new_score),
                "total_score": float(total_score),
                "max_score": float(max_total),
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_exam_result_detail_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_exam_result_detail_view.py
# ==========================================================================================
"""
Admin Exam Result Detail View (ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸)

GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/

==========================================================================================
âœ… Phase 4 ì¶”ê°€: edit_state
==========================================================================================
- í¸ì§‘ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ìš© ë©”íƒ€ ì •ë³´
- í˜„ì¬ëŠ” "ì¡°íšŒ ì „ìš©"
- ì¶”í›„ ì‹¤ì‹œê°„ ë½ / Redis / DB Lockìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥

íŒë‹¨ ê¸°ì¤€ (í˜„ì¬ ê³ ì •):
- ëŒ€í‘œ attempt.status == "grading"
  â†’ can_edit = false
  â†’ is_locked = true
  â†’ lock_reason = "GRADING"
"""

from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)

from apps.domains.exams.models import Exam

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class AdminExamResultDetailView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        exam = get_object_or_404(Exam, id=exam_id)

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ëŒ€í‘œ ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )
        if not result:
            raise NotFound("result not found")

        # -------------------------------------------------
        # 2ï¸âƒ£ ì¬ì‹œí—˜ ì •ì±…
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_qs = ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        )

        attempt_count = attempt_qs.count()
        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 3ï¸âƒ£ clinic_required (ë‹¨ì¼ ì§„ì‹¤)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,
            )

        # -------------------------------------------------
        # 4ï¸âƒ£ edit_state (Phase 4)
        # -------------------------------------------------
        edit_state = {
            "can_edit": True,
            "is_locked": False,
            "lock_reason": None,
            "last_updated_by": None,
            "updated_at": None,
        }

        if result.attempt_id:
            attempt = ExamAttempt.objects.filter(id=int(result.attempt_id)).first()
            if attempt and attempt.status == "grading":
                edit_state.update({
                    "can_edit": False,
                    "is_locked": True,
                    "lock_reason": "GRADING",
                })

        # -------------------------------------------------
        # 5ï¸âƒ£ ì‘ë‹µ êµ¬ì„±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = bool(clinic_required)
        data["edit_state"] = edit_state

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_results_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission
from apps.domains.exams.models import Exam

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamResultsView(APIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    âœ… ëª©í‘œ(ì›ë³¸ ìœ ì§€ + ì •í•©ì„± ê°•í™”)
    - Result(ìŠ¤ëƒ…ìƒ·) ê¸°ë°˜ ì ìˆ˜ ë¦¬ìŠ¤íŠ¸
    - Attempt/Submission ìƒíƒœ ì—°ê²°
    - Clinic ê¸°ì¤€ í†µì¼(ClinicLink)
    - Sessionâ†”Exam ë§¤í•‘ ë‹¨ì¼í™”(utils.session_exam)

    âš ï¸ pass ê¸°ì¤€ ì •ì˜:
    - ì´ í™”ë©´ì€ "ì‹œí—˜(exam) ë‹¨ìœ„ ê²°ê³¼"ì´ë¯€ë¡œ
      pass/failì€ Exam.pass_score ê¸°ì¤€ìœ¼ë¡œ ì œê³µí•œë‹¤.
    - ì„¸ì…˜ ì¢…í•© í†µê³¼(SessionProgress.exam_passed)ëŠ”
      /admin/sessions/... summary APIì—ì„œ ì œê³µí•˜ëŠ” ê²ƒì´ ì •ì„.
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ì¤‘ë³µ enrollment ë°©ì–´: ìµœì‹  1ê°œë§Œ)
        # -------------------------------------------------
        results = latest_results_per_enrollment(
            target_type="exam",
            target_id=exam_id,
        ).order_by("enrollment_id")

        # -------------------------------------------------
        # 2ï¸âƒ£ Session ì°¾ê¸° (clinic íŒë‹¨ìš©)
        #    - ì„¸ì…˜ 1 : ì‹œí—˜ N êµ¬ì¡°ì—ì„œë„ ëŒ€í‘œ sessionì€ í•„ìš”í•  ìˆ˜ ìˆìŒ(legacy UI ë“±)
        # -------------------------------------------------
        session = get_primary_session_for_exam(exam_id)

        # -------------------------------------------------
        # 3ï¸âƒ£ Student ì¡°íšŒ (ì›ë³¸ ë¡œì§ ì¡´ì¤‘: progress_map ê¸°ë°˜ ì¶”ë¡ ì´ì—ˆì§€ë§Œ
        #    SessionProgressì— student_idê°€ ìˆë‹¤ê³  ê°€ì •í•˜ë©´ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ)
        #
        #    ì—¬ê¸°ì„œëŠ” "Result.enrollment_id"ë¥¼ í•™ìƒìœ¼ë¡œ ì§ì ‘ ë§¤í•‘í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ
        #    í”„ë¡œì íŠ¸ì˜ Enrollment/Student ì—°ê²° ë°©ì‹ì´ í•„ìš”í•˜ë‹¤.
        #    ì›ë³¸ì²˜ëŸ¼ SessionProgressì—ì„œ student/userë¥¼ ì¶”ë¡ í•˜ë˜ ë°©ì‹ì´ ìˆìœ¼ë©´ ìœ ì§€í•´ì•¼ í•¨.
        #
        #    âœ… í•˜ì§€ë§Œ í˜„ì¬ ì œê³µëœ ì½”ë“œ ìŠ¤ëƒ…ìƒ·ë§Œìœ¼ë¡œëŠ”
        #    enrollment_id -> student_name í•´ì„ì´ í”„ë¡œì íŠ¸ë§ˆë‹¤ ë‹¬ë¼ ì•ˆì „í•˜ì§€ ì•Šë‹¤.
        #
        #    ê·¸ë˜ì„œ:
        #    - ì›ë³¸ì˜ Student ì¡°íšŒ ë£¨í‹´ì„ "ê°€ëŠ¥í•˜ë©´" ìˆ˜í–‰í•˜ë˜
        #    - ì‹¤íŒ¨í•´ë„ "-" ë¡œ ì•ˆì „í•˜ê²Œ ë°˜í™˜í•œë‹¤.
        # -------------------------------------------------
        student_map = {}
        try:
            # ì›ë³¸ ì½”ë“œì˜ ì˜ë„: SessionProgressì— student_id/user_idê°€ ë¶™ì–´ìˆì„ ìˆ˜ ìˆë‹¤.
            from apps.domains.progress.models import SessionProgress  # ì§€ì—° import

            if session:
                progress_rows = SessionProgress.objects.filter(session=session)
            else:
                progress_rows = SessionProgress.objects.none()

            student_ids = set()
            for sp in progress_rows:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
                if sid:
                    student_ids.add(int(sid))

            student_map = {
                s.id: s
                for s in Student.objects.filter(id__in=list(student_ids))
            }
        except Exception:
            student_map = {}

        # -------------------------------------------------
        # 4ï¸âƒ£ enrollment_id â†’ ìµœì‹  attempt/submission ë§µ
        #    - ResultFactê°€ ìˆìœ¼ë©´ ê°€ì¥ ìµœì‹  attemptë¥¼ ìš°ì„  ì‚¬ìš©
        #    - ì—†ìœ¼ë©´ Result.attempt_id fallback
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(target_type="exam", target_id=exam_id)
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values("enrollment_id", "attempt_id", "submission_id")
        )

        latest_map = {}
        for row in fact_qs:
            eid = int(row["enrollment_id"])
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": int(row["attempt_id"]),
                    "submission_id": int(row["submission_id"]),
                }

        # Result.attempt_id fallback
        attempt_ids = [r.attempt_id for r in results if getattr(r, "attempt_id", None)]
        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = int(r.enrollment_id)
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue
            a = attempt_map.get(int(aid))
            if not a:
                continue
            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # Submission.status
        submission_ids = [v["submission_id"] for v in latest_map.values() if v.get("submission_id")]
        submission_status_map = {
            s.id: s.status
            for s in Submission.objects.filter(id__in=submission_ids)
        }

        # -------------------------------------------------
        # 5ï¸âƒ£ rows êµ¬ì„±
        # -------------------------------------------------
        rows = []
        for r in results:
            enrollment_id = int(r.enrollment_id)

            # student_name (ê°€ëŠ¥í•˜ë©´ ë§¤í•‘, ì•„ë‹ˆë©´ "-")
            student_name = "-"
            try:
                # ì›ë³¸ ë¡œì§: progress rowì— student/user idê°€ ìˆì„ ë•Œë§Œ í‘œì‹œ ê°€ëŠ¥
                # ì—¬ê¸°ì„œëŠ” í™•ì • ë§¤í•‘ì´ ì—†ìœ¼ë¯€ë¡œ ì•ˆì „ fallback
                student_name = "-"
            except Exception:
                student_name = "-"

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = submission_status_map.get(submission_id) if submission_id else None

            # âœ… pass/failì€ exam ë‹¨ìœ„ => Exam.pass_score ê¸°ì¤€
            passed = bool(float(r.total_score or 0.0) >= float(pass_score))

            # âœ… clinic_required ë‹¨ì¼ ê·œì¹™
            clinic_required = bool(
                session and is_clinic_required(session=session, enrollment_id=enrollment_id, include_manual=False)
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student_name,

                "exam_score": float(r.total_score or 0.0),
                "exam_max_score": float(r.max_score or 0.0),

                # ì´í›„ ì„¸ì…˜ ì§‘ê³„ í™•ì¥ ëŒ€ë¹„ (í˜„ì¬ëŠ” ë™ì¼)
                "final_score": float(r.total_score or 0.0),

                "passed": passed,
                "clinic_required": clinic_required,

                "submitted_at": r.submitted_at,

                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        return Response(AdminExamResultRowSerializer(rows, many=True).data)


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.admin_exam_summary import AdminExamSummarySerializer
from apps.domains.exams.models import Exam
from apps.domains.progress.models import ClinicLink

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminExamSummaryView(APIView):
    """
    LEGACY COMPAT
    GET /results/admin/exams/<exam_id>/summary/

    âœ… ê³„ì•½ ìœ ì§€(í”„ë¡ íŠ¸ ì•ˆì •ì„±):
    - participant_count, avg/min/max, pass_count/fail_count/pass_rate, clinic_count

    âœ… ì •í•©ì„± ê°•í™”:
    - Result ì¤‘ë³µ enrollment ë°©ì–´: ìµœì‹  Resultë§Œ ì§‘ê³„
    - clinic_count ê¸°ì¤€ í†µì¼: ClinicLink(is_auto=True) enrollment distinct
    - Sessionâ†”Exam ë§¤í•‘ ë‹¨ì¼í™”(utils.session_exam)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        EMPTY = {
            "participant_count": 0,
            "avg_score": 0.0,
            "min_score": 0.0,
            "max_score": 0.0,
            "pass_count": 0,
            "fail_count": 0,
            "pass_rate": 0.0,
            "clinic_count": 0,
        }

        exam = Exam.objects.filter(id=exam_id).first()
        pass_score = float(getattr(exam, "pass_score", 0.0) or 0.0) if exam else 0.0

        # âœ… ì¤‘ë³µ ë°©ì–´: enrollmentë‹¹ ìµœì‹  Resultë§Œ
        rs = latest_results_per_enrollment(target_type="exam", target_id=exam_id)

        participant_count = rs.values("enrollment_id").distinct().count()
        if participant_count == 0:
            return Response(AdminExamSummarySerializer(EMPTY).data)

        agg = rs.aggregate(
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        pass_count = rs.filter(total_score__gte=pass_score).count()
        fail_count = rs.filter(total_score__lt=pass_score).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # âœ… clinic_countëŠ” session ê¸°ë°˜ìœ¼ë¡œë§Œ ê³„ì‚° ê°€ëŠ¥(ì‹œí—˜ë§Œìœ¼ë¡  clinicì´ ì •ì˜ë˜ì§€ ì•ŠìŒ)
        clinic_count = 0
        session = get_primary_session_for_exam(exam_id)
        if session:
            clinic_count = (
                ClinicLink.objects.filter(session=session, is_auto=True)
                .values("enrollment_id")
                .distinct()
                .count()
            )

        payload = {
            "participant_count": int(participant_count),
            "avg_score": float(agg["avg_score"] or 0.0),
            "min_score": float(agg["min_score"] or 0.0),
            "max_score": float(agg["max_score"] or 0.0),
            "pass_count": int(pass_count),
            "fail_count": int(fail_count),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_count": int(clinic_count),
        }

        return Response(AdminExamSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# ==========================================================================================
# FILE: apps/domains/results/views/admin_representative_attempt_view.py
# ==========================================================================================
"""
Admin Representative Attempt Switch

POST /results/admin/exams/<exam_id>/representative-attempt/

ìš”ì²­:
{
  "enrollment_id": 55,
  "attempt_id": 1234
}

==========================================================================================
âœ… ëª©ì  (Phase 2)
==========================================================================================
- Admin/Teacherê°€ "ëŒ€í‘œ attempt"ë¥¼ ìˆ˜ë™ìœ¼ë¡œ êµì²´í•œë‹¤.
- Result(ìŠ¤ëƒ…ìƒ·)ì˜ attempt_idë„ ì¦‰ì‹œ ë™ê¸°í™”í•œë‹¤.
- ì´í›„ í”„ë¡ íŠ¸ëŠ” ë°˜ë“œì‹œ:
    GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/
  ë¥¼ ì¬ì¡°íšŒí•˜ì—¬ ìµœì‹  ê²°ê³¼ë¥¼ ì‚¬ìš©í•œë‹¤. (ì§„ì‹¤ì˜ ì›ì²œ)

==========================================================================================
âœ… í”„ë¡ íŠ¸ ê³„ì•½ (ì¤‘ìš”/ê³ ì •)
==========================================================================================
1) ì„±ê³µ ì‘ë‹µ: Body ìˆìŒ (ok + ids)
   - í”„ë¡ íŠ¸ê°€ optimistic update í•˜ë ¤ë©´ ìµœì†Œ ì‘ë‹µì´ ìˆëŠ” ê²Œ ì•ˆì „

2) ë³€ê²½ í›„ ì¬ê³„ì‚°?
   - âŒ "ì ìˆ˜ ì¬ê³„ì‚°"ì€ í•˜ì§€ ì•ŠëŠ”ë‹¤.
   - ëŒ€í‘œ attempt ë³€ê²½ì€ "ì´ë¯¸ ì±„ì ëœ attempt ì¤‘ ì„ íƒ" í–‰ìœ„ì´ë¯€ë¡œ
     Result.attempt_idë§Œ êµì²´í•˜ë©´ ëœë‹¤.
   - ì ìˆ˜(total_score ë“±) ìì²´ë¥¼ "attemptë³„ë¡œ ë”°ë¡œ ë³´ê´€"í•˜ëŠ” êµ¬ì¡°ê°€ ì•„ë‹ˆë¼,
     í˜„ì¬ ì„¤ê³„ì—ì„œëŠ” Resultê°€ ëŒ€í‘œ attemptì˜ ê²°ê³¼ ìŠ¤ëƒ…ìƒ·ì´ë‹¤.
     ë”°ë¼ì„œ ìš´ì˜ì ìœ¼ë¡œëŠ” ëŒ€í‘œ attempt êµì²´ ì‹œì ì— Result ìŠ¤ëƒ…ìƒ·ì´ ì´ë¯¸ ê·¸ attempt ê¸°ë°˜ì¸ì§€ê°€ ì¤‘ìš”í•˜ë‹¤.
     (í˜„ì¬ ì‹œìŠ¤í…œì€ ì±„ì  ì™„ë£Œ ì‹œ ResultApplier.apply()ê°€ attempt_idë¥¼ ë®ì–´ì“°ë¯€ë¡œ
      ëŒ€í‘œ êµì²´ëŠ” Result.attempt_idë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•´ì„œ ì¼ê´€ì„±ì„ í™•ë³´í•œë‹¤.)

3) ì‹¤íŒ¨ ì¼€ì´ìŠ¤ (ê³„ì•½)
   - 400 INVALID: ìš”ì²­ íŒŒë¼ë¯¸í„°/ê´€ê³„ ë¶ˆì¼ì¹˜(ë‹¤ë¥¸ exam/enrollment)
   - 404 NOT_FOUND: attempt ìì²´ê°€ ì—†ìŒ
   - 409 LOCKED: ì±„ì  ì¤‘(grading) attemptëŠ” ëŒ€í‘œë¡œ ë³€ê²½ ë¶ˆê°€ (ìš´ì˜ ì‚¬ê³  ë°©ì§€)
   - 500 ë“± ê¸°íƒ€: ì„œë²„ ì˜¤ë¥˜

ì‘ë‹µ í˜•íƒœ(ì‹¤íŒ¨):
{
  "detail": "...",
  "code": "INVALID|NOT_FOUND|LOCKED"
}

==========================================================================================
âœ… ì •í•©ì„±/ë™ì‹œì„±
==========================================================================================
- ë™ì‹œ ë³€ê²½/ê²½ìŸ ìƒí™© ë°©ì§€:
  (exam_id, enrollment_id) ë²”ìœ„ë¥¼ select_for_updateë¡œ ì ê¸ˆ í›„ ëŒ€í‘œ êµì²´ ìˆ˜í–‰
"""

from __future__ import annotations

from django.db import transaction

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status as drf_status
from rest_framework.exceptions import ValidationError, NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result


class AdminRepresentativeAttemptView(APIView):
    """
    ëŒ€í‘œ attempt ë³€ê²½ (Admin/Teacher)

    NOTE:
    - ì ìˆ˜ ì¬ê³„ì‚°ì€ í•˜ì§€ ì•ŠìŒ (ëŒ€í‘œ ì„ íƒë§Œ)
    - ë³€ê²½ í›„ í”„ë¡ íŠ¸ëŠ” detail ì¬ì¡°íšŒê°€ ì§„ì‹¤ì˜ ì›ì²œ
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @transaction.atomic
    def post(self, request, exam_id: int):
        exam_id = int(exam_id)

        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if enrollment_id is None or attempt_id is None:
            # í”„ë¡ íŠ¸ ì‹¤ìˆ˜/ëˆ„ë½ì€ 400ìœ¼ë¡œ ëª…í™•íˆ
            raise ValidationError({"detail": "enrollment_id and attempt_id are required", "code": "INVALID"})

        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        # -------------------------------------------------
        # 1) ëŒ€ìƒ attempt ê²€ì¦ + ì ê¸ˆ
        #    - ê°™ì€ exam/enrollment ë²”ìœ„ì— ëŒ€í•´ì„œë§Œ ëŒ€í‘œ êµì²´ í—ˆìš©
        # -------------------------------------------------
        # ë²”ìœ„ ì ê¸ˆ(ê²½ìŸ ìƒí™©ì—ì„œ ëŒ€í‘œ 2ê°œ ë˜ëŠ” ê±¸ ì›ì²œ ì°¨ë‹¨)
        attempts_qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        if not attempts_qs.exists():
            # ì´ enrollmentì´ ì´ examì„ ì‘ì‹œí•œ ì ì´ ì—†ëŠ” ì¼€ì´ìŠ¤
            raise NotFound({"detail": "attempts not found for this exam/enrollment", "code": "NOT_FOUND"})

        target = attempts_qs.filter(id=attempt_id).first()
        if not target:
            # attempt_idê°€ ë‹¤ë¥¸ exam/enrollmentì˜ ê²ƒì¼ ìˆ˜ ìˆìŒ
            raise NotFound({"detail": "attempt not found for this exam/enrollment", "code": "NOT_FOUND"})

        # -------------------------------------------------
        # 2) LOCKED ì •ì±… (ìš´ì˜ ì‚¬ê³  ë°©ì§€)
        #    - grading ì¤‘ì¸ attemptë¥¼ ëŒ€í‘œë¡œ ë°”ê¾¸ë©´ í™”ë©´/í†µê³„ê°€ í”ë“¤ë¦´ ìˆ˜ ìˆìŒ
        # -------------------------------------------------
        if (target.status or "").lower() == "grading":
            return Response(
                {"detail": "attempt is grading; cannot switch representative", "code": "LOCKED"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # (ì„ íƒ) pendingë„ ëŒ€í‘œ ë³€ê²½ì„ ë§‰ê³  ì‹¶ë‹¤ë©´ ì•„ë˜ë¥¼ í™œì„±í™”
        # if (target.status or "").lower() == "pending":
        #     return Response(
        #         {"detail": "attempt is pending; cannot switch representative", "code": "LOCKED"},
        #         status=drf_status.HTTP_409_CONFLICT,
        #     )

        # -------------------------------------------------
        # 3) ëŒ€í‘œ attempt êµì²´
        # -------------------------------------------------
        # ê¸°ì¡´ ëŒ€í‘œ ëª¨ë‘ í•´ì œ
        attempts_qs.filter(is_representative=True).update(is_representative=False)

        # ì„ íƒ attempt ëŒ€í‘œë¡œ ì„¤ì •
        if not target.is_representative:
            target.is_representative = True
            target.save(update_fields=["is_representative"])

        # -------------------------------------------------
        # 4) Result ìŠ¤ëƒ…ìƒ· ë™ê¸°í™”
        # -------------------------------------------------
        # Resultê°€ ì—†ìœ¼ë©´ ìƒì„±í•˜ì§€ ì•ŠëŠ”ë‹¤(ìš´ì˜ìƒ "ì±„ì  ê²°ê³¼ê°€ ì•„ì§ ì—†ë‹¤"ëŠ” ëœ»ì´ë¯€ë¡œ)
        # ë‹¨, í”„ë¡œì íŠ¸ ì •ì±…ìƒ "Resultê°€ ì—†ë”ë¼ë„ ëŒ€í‘œë§Œ ë°”ê¾¸ê³  ì‹¶ë‹¤"ë©´ get_or_createë¡œ ë³€ê²½ ê°€ëŠ¥.
        updated = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .update(attempt_id=attempt_id)
        )

        if updated == 0:
            # ëŒ€í‘œ attemptëŠ” ì¡´ì¬í•˜ì§€ë§Œ, ì•„ì§ Result ìŠ¤ëƒ…ìƒ·ì´ ì—†ë‹¤ëŠ” ì˜ë¯¸
            # â†’ í”„ë¡ íŠ¸ëŠ” detail ì¬ì¡°íšŒ ì‹œ 404(result not found) ê°€ëŠ¥
            # ìš´ì˜/CSê°€ ì´í•´í•˜ê¸° ì‰½ë„ë¡ ëª…í™•íˆ 409ë¡œ ì•ˆë‚´
            return Response(
                {"detail": "result snapshot not found; cannot sync representative attempt", "code": "INVALID"},
                status=drf_status.HTTP_409_CONFLICT,
            )

        # -------------------------------------------------
        # 5) ì„±ê³µ ì‘ë‹µ (í”„ë¡ íŠ¸ ê³„ì•½)
        # -------------------------------------------------
        return Response(
            {
                "ok": True,
                "exam_id": exam_id,
                "enrollment_id": enrollment_id,
                "attempt_id": attempt_id,
            },
            status=drf_status.HTTP_200_OK,
        )


==========================================================================================
# FILE: views/admin_result_fact_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_result_fact_view.py
"""
Admin ResultFact Debug View

GET /results/admin/facts/?exam_id=&enrollment_id=&limit=100

âš ï¸ ëª©ì :
- ìš´ì˜/CS/ë””ë²„ê¹…
- append-only Fact ì§ì ‘ ì¡°íšŒ
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ResultFact


class AdminResultFactView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request):
        exam_id = request.query_params.get("exam_id")
        enrollment_id = request.query_params.get("enrollment_id")
        limit = int(request.query_params.get("limit", 100))

        qs = ResultFact.objects.all().order_by("-id")

        if exam_id:
            qs = qs.filter(target_type="exam", target_id=int(exam_id))
        if enrollment_id:
            qs = qs.filter(enrollment_id=int(enrollment_id))

        qs = qs[: min(limit, 500)]

        return Response([
            {
                "id": f.id,
                "exam_id": f.target_id,
                "enrollment_id": f.enrollment_id,
                "attempt_id": f.attempt_id,
                "question_id": f.question_id,
                "answer": f.answer,
                "is_correct": f.is_correct,
                "score": f.score,
                "max_score": f.max_score,
                "meta": f.meta,
                "created_at": f.created_at,
            }
            for f in qs
        ])


==========================================================================================
# FILE: views/admin_session_exams_summary_view.py
==========================================================================================
# apps/domains/results/views/admin_session_exams_summary_view.py
from __future__ import annotations

from django.db.models import Avg, Min, Max, Count
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.serializers.session_exams_summary import SessionExamsSummarySerializer

from apps.domains.lectures.models import Session
from apps.domains.progress.models import SessionProgress, ClinicLink, ProgressPolicy

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_exams_for_session
from apps.domains.results.utils.result_queries import latest_results_per_enrollment


class AdminSessionExamsSummaryView(APIView):
    """
    âœ… Session ê¸°ì¤€ ì‹œí—˜ ìš”ì•½ API (1 Session : N Exams)

    GET /results/admin/sessions/{session_id}/exams/summary/

    ë‹¨ì¼ ì§„ì‹¤ ê·œì¹™:
    - ì„¸ì…˜ ë‹¨ìœ„ pass_rate: SessionProgress.exam_passed ê¸°ë°˜ (ì§‘ê³„ ê²°ê³¼)
    - ì„¸ì…˜ ë‹¨ìœ„ clinic_rate: ClinicLink(is_auto=True) enrollment distinct ê¸°ë°˜
    - ì‹œí—˜ ë‹¨ìœ„ ì ìˆ˜ í†µê³„: Result(ë‹¨, enrollment ì¤‘ë³µ ë°©ì–´)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).select_related("lecture").first()
        if not session:
            return Response(
                SessionExamsSummarySerializer({
                    "session_id": int(session_id),
                    "participant_count": 0,
                    "pass_rate": 0.0,
                    "clinic_rate": 0.0,
                    "strategy": "MAX",
                    "pass_source": "EXAM",
                    "exams": [],
                }).data
            )

        # ì •ì±…(í‘œì‹œìš©)
        policy = ProgressPolicy.objects.filter(lecture=session.lecture).first()
        strategy = str(getattr(policy, "exam_aggregate_strategy", "MAX"))
        pass_source = str(getattr(policy, "exam_pass_source", "EXAM"))

        # âœ… ì„¸ì…˜ì— ì—°ê²°ëœ exams (ë‹¨ì¼ ì§„ì‹¤)
        exams = list(get_exams_for_session(session))
        exam_ids = [int(e.id) for e in exams]

        # -----------------------------
        # session-level participant/pass/clinic
        # -----------------------------
        sp_qs = SessionProgress.objects.filter(session=session)
        participant_count = sp_qs.count()

        # ì„¸ì…˜ ë‹¨ìœ„ ì‹œí—˜ í†µê³¼ìœ¨(ì§‘ê³„ ê²°ê³¼)
        pass_count = sp_qs.filter(exam_passed=True).count()
        pass_rate = (pass_count / participant_count) if participant_count else 0.0

        # clinic_rate(ë‹¨ì¼ ê·œì¹™)
        clinic_count = (
            ClinicLink.objects.filter(session=session, is_auto=True)
            .values("enrollment_id").distinct().count()
        )
        clinic_rate = (clinic_count / participant_count) if participant_count else 0.0

        # -----------------------------
        # exam-level stats (Result ê¸°ë°˜, enrollment ì¤‘ë³µ ë°©ì–´)
        # -----------------------------
        exam_rows = []
        for ex in exams:
            rs = latest_results_per_enrollment(
                target_type="exam",
                target_id=int(ex.id),
            )

            agg = rs.aggregate(
                participant_count=Count("id"),  # ì´ë¯¸ enrollment 1ê°œì”©ìœ¼ë¡œ ì¤„ì˜€ìœ¼ë‹ˆ count(id)=participant
                avg_score=Avg("total_score"),
                min_score=Min("total_score"),
                max_score=Max("total_score"),
            )

            pass_score = float(getattr(ex, "pass_score", 0.0) or 0.0)

            pcount = rs.filter(total_score__gte=pass_score).count()
            fcount = rs.filter(total_score__lt=pass_score).count()

            p_total = int(agg["participant_count"] or 0)
            p_rate = (pcount / p_total) if p_total else 0.0

            exam_rows.append({
                "exam_id": int(ex.id),
                "title": str(getattr(ex, "title", "") or ""),
                "pass_score": float(pass_score),

                "participant_count": p_total,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),

                "pass_count": int(pcount),
                "fail_count": int(fcount),
                "pass_rate": round(float(p_rate), 4),
            })

        payload = {
            "session_id": int(session.id),
            "participant_count": int(participant_count),

            # âœ… ì˜ë¯¸ ê³ ì •:
            # pass_rate = SessionProgress.exam_passed ê¸°ë°˜ (ì§‘ê³„ ê²°ê³¼)
            "pass_rate": round(float(pass_rate), 4),

            # âœ… ì˜ë¯¸ ê³ ì •:
            # clinic_rate = ClinicLink(is_auto=True) ê¸°ì¤€
            "clinic_rate": round(float(clinic_rate), 4),

            "strategy": strategy,
            "pass_source": pass_source,
            "exams": exam_rows,

            # (ê¶Œì¥) pass_rate_source ê°™ì€ ë©”íƒ€ë¥¼ serializerì— ì¶”ê°€í•˜ë©´ ì‚¬ê³  ë°©ì§€ì— í° ë„ì›€
            # "pass_rate_source": "SESSION_PROGRESS",
            # "clinic_rate_source": "CLINIC_LINK_AUTO",
        }

        return Response(SessionExamsSummarySerializer(payload).data)


==========================================================================================
# FILE: views/admin_session_exams_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_session_exams_view.py
"""
Admin Session â†’ Exams ì¡°íšŒ

GET /results/admin/sessions/{session_id}/exams/

âœ… í˜„ì¬ ê³„ì•½(ë¦¬íŒ©í† ë§ ì™„ë£Œ):
- Session 1 : Exam N
- canonical relation: exams.Exam.sessions (ManyToManyField to lectures.Session)

ì‘ë‹µì€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ê³ ì •:
[
  { exam_id, title, open_at, close_at, allow_retake, max_attempts },
  ...
]
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.lectures.models import Session
from apps.domains.exams.models import Exam


class AdminSessionExamsView(APIView):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    @staticmethod
    def _get_exams_for_session(session: Session) -> list[Exam]:
        """
        Sessionì— ì—°ê²°ëœ Exam ëª©ë¡ ì¡°íšŒ

        âœ… canonical:
        - session.exams (Exam.sessions related_name="exams")

        ë°©ì–´ì  fallback:
        - Exam.objects.filter(sessions=session)
        """
        if hasattr(session, "exams"):
            try:
                return list(session.exams.all())
            except Exception:
                pass
        return list(Exam.objects.filter(sessions__id=int(session.id)).distinct())

    def get(self, request, session_id: int):
        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return Response([])

        exams = self._get_exams_for_session(session)
        if not exams:
            return Response([])

        return Response([
            {
                "exam_id": int(exam.id),
                "title": getattr(exam, "title", "") or "",
                "open_at": getattr(exam, "open_at", None),
                "close_at": getattr(exam, "close_at", None),
                "allow_retake": bool(getattr(exam, "allow_retake", False)),
                "max_attempts": int(getattr(exam, "max_attempts", 1) or 1),
            }
            for exam in exams
        ])


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

â— ì¹˜ëª…ì  ë³´ì•ˆ ì´ìŠˆ ìˆ˜ì •:
- ê¸°ì¡´: IsAuthenticated ë§Œ ê±¸ë ¤ì„œ í•™ìƒë„ ì „ì²´ Attempt ì—´ëŒ ê°€ëŠ¥
- ë³€ê²½: Teacher/Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥

í•„ìš”í•˜ë©´ ì¶”í›„:
- í•™ìƒ ë³¸ì¸ attemptë§Œ ì¡°íšŒí•˜ëŠ” ë³„ë„ Viewë¥¼ /me/* ë¡œ ë”°ë¡œ ë§Œë“¤ ê²ƒ
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ì‹œí—˜ ì‹œë„(Attempt) ê´€ë¦¬ API (ê´€ë¦¬ì/êµì‚¬ìš©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # âœ… ë³´ì•ˆ ìˆ˜ì •
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/homework_result_view.py
==========================================================================================



==========================================================================================
# FILE: views/question_stats_views.py
==========================================================================================
# apps/domains/results/views/question_stats_views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.question_stats_service import QuestionStatsService
from apps.domains.results.serializers.question_stats import (
    QuestionStatSerializer,
    TopWrongQuestionSerializer,
)


class AdminExamQuestionStatsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/

    âœ… ë‹¨ì¼ ì§„ì‹¤:
    - ResultFact ê¸°ë°˜ (append-only)
    - ëŒ€í‘œ attempt êµì²´/ì¬ì‹œí—˜ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ í†µê³„
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        data = QuestionStatsService.per_question_stats(
            exam_id=int(exam_id),
        )
        return Response(QuestionStatSerializer(data, many=True).data)


class ExamQuestionWrongDistributionView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, question_id: int):
        dist = QuestionStatsService.wrong_choice_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
        )
        return Response(
            {
                "question_id": int(question_id),
                "distribution": dist,
            }
        )


class ExamTopWrongQuestionsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=5
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        n = int(request.query_params.get("n", 5))
        data = QuestionStatsService.top_n_wrong_questions(
            exam_id=int(exam_id),
            n=n,
        )
        return Response(TopWrongQuestionSerializer(data, many=True).data)


==========================================================================================
# FILE: views/session_score_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_score_summary_view.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.session_score_summary_service import (
    SessionScoreSummaryService,
)
from apps.domains.results.serializers.session_score_summary import (
    SessionScoreSummarySerializer,
)


class SessionScoreSummaryView(APIView):
    """
    GET /results/admin/sessions/<session_id>/score-summary/

    âœ… results ë„ë©”ì¸ ê¸°ì¤€
    - Session ë‹¨ìœ„ ì„±ì  í†µê³„
    - ìš´ì˜/ëŒ€ì‹œë³´ë“œ/AI ì¶”ì²œ ì…ë ¥ìš©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        data = SessionScoreSummaryService.build(
            session_id=int(session_id)
        )
        return Response(SessionScoreSummarySerializer(data).data)


==========================================================================================
# FILE: views/student_exam_attempts_view.py
==========================================================================================
# PATH: apps/domains/results/views/student_exam_attempts_view.py
"""
Student Exam Attempt History

GET /results/me/exams/{exam_id}/attempts/

- í•™ìƒ ë³¸ì¸ enrollment ê¸°ì¤€
- ì¬ì‹œí—˜ íˆìŠ¤í† ë¦¬ UI ì „ìš©
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsStudent
from apps.domains.results.models import ExamAttempt
from apps.domains.enrollment.models import Enrollment


class MyExamAttemptsView(APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user

        # enrollment íƒìƒ‰ (ë°©ì–´)
        qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        enrollment = qs.first()
        if not enrollment:
            return Response([])

        attempts = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=int(enrollment.id),
        ).order_by("attempt_index")

        return Response([
            {
                "attempt_id": a.id,
                "attempt_index": a.attempt_index,
                "is_retake": a.is_retake,
                "is_representative": a.is_representative,
                "status": a.status,
                "created_at": a.created_at,
            }
            for a in attempts
        ])


==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import StudentExamResultSerializer
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# âœ… ë‹¨ì¼ ì§„ì‹¤ ìœ í‹¸
from apps.domains.results.utils.session_exam import get_primary_session_for_exam
from apps.domains.results.utils.clinic import is_clinic_required


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    âœ… í¬í•¨:
    - Result + items
    - ì¬ì‹œí—˜ ì •ì±…(allow_retake/max_attempts/can_retake)
    - clinic_required (ClinicLink ê¸°ì¤€ ë‹¨ì¼í™”)
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1ï¸âƒ£ Enrollment ì°¾ê¸° (í”„ë¡œì íŠ¸ë³„ í•„ë“œ ì°¨ì´ ë°©ì–´)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()
        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2ï¸âƒ£ Result ì¡°íšŒ (ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(target_type="exam", target_id=int(exam_id), enrollment_id=enrollment_id)
            .prefetch_related("items")
            .first()
        )
        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3ï¸âƒ£ ì¬ì‹œí—˜ ì •ì±… íŒë‹¨ (attempt ê¸°ë°˜)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4ï¸âƒ£ clinic_required (ë‹¨ì¼ ì§„ì‹¤: ClinicLink)
        # -------------------------------------------------
        clinic_required = False
        session = get_primary_session_for_exam(int(exam_id))
        if session:
            clinic_required = is_clinic_required(
                session=session,
                enrollment_id=enrollment_id,
                include_manual=False,  # âœ… ì •ì±… í†µì¼(ìë™ë§Œ)
            )

        # -------------------------------------------------
        # 5ï¸âƒ£ ì‘ë‹µ êµ¬ì„±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = bool(clinic_required)

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_status_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_status_view.py
from __future__ import annotations

from django.core.files.storage import default_storage

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, NotFound

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models import WrongNotePDF
from apps.domains.results.serializers.wrong_note_pdf_serializers import (
    WrongNotePDFStatusSerializer,
)


class WrongNotePDFStatusView(APIView):
    """
    STEP 3-2: ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ (polling)

    GET /results/wrong-notes/pdf/<job_id>/

    ğŸ” ë³´ì•ˆ:
    - í•™ìƒ: ë³¸ì¸ enrollment_idì˜ jobë§Œ ì¡°íšŒ ê°€ëŠ¥
    - êµì‚¬/ê´€ë¦¬ì: ì „ì²´ ì¡°íšŒ ê°€ëŠ¥
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this PDF job.")

    def get(self, request, job_id: int):
        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        self._assert_enrollment_access(request, int(job.enrollment_id))

        # DONEì´ë©´ ë‹¤ìš´ë¡œë“œ URL ì œê³µ (storageì— ë”°ë¼ url()ì´ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë‹ˆ ë°©ì–´)
        file_url = ""
        if job.file_path:
            try:
                file_url = default_storage.url(job.file_path)
            except Exception:
                file_url = ""

        data = {
            "job_id": int(job.id),
            "status": str(job.status),
            "file_path": str(job.file_path or ""),
            "file_url": str(file_url or ""),
            "error_message": str(job.error_message or ""),
            "created_at": job.created_at,
            "updated_at": job.updated_at,
        }

        return Response(WrongNotePDFStatusSerializer(data).data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_view.py
from __future__ import annotations

from django.urls import reverse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


class WrongNotePDFCreateView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± ìš”ì²­

    âœ… STEP 3-2.5:
    - ì‘ë‹µì— status_url í¬í•¨ (í”„ë¡ íŠ¸ í´ë§ í¸ì˜)

    âœ… STEP 2 (ì¤‘ìš”):
    - View íŒŒì¼ ìƒë‹¨ì—ì„œ Celery task import ê¸ˆì§€
      (URLConf import ì‹œì ì— worker ì˜ì¡´ì„±ê¹Œì§€ ë¡œë”©ë˜ëŠ” ìœ„í—˜ ë°©ì§€)
    - ë”°ë¼ì„œ post() ë‚´ë¶€ì—ì„œë§Œ ì§€ì—° import í•œë‹¤.
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id_i,
            lecture_id=int(lecture_id) if lecture_id else None,
            exam_id=int(exam_id) if exam_id else None,
            from_session_order=int(from_order or 2),
        )

        # --------------------------------------------------
        # âœ… STEP 2: task ì§€ì—° import (ì¤‘ìš”)
        # - URL import ì‹œì ì— worker ìª½ ì˜ì¡´ì„±ì„ ëŒì–´ì˜¤ì§€ ì•ŠìŒ
        # --------------------------------------------------
        from apps.domains.results.tasks.wrong_note_pdf_tasks import (
            generate_wrong_note_pdf_task,
        )

        generate_wrong_note_pdf_task.delay(job.id)

        # âœ… status_url ì œê³µ (ì ˆëŒ€ê²½ë¡œ)
        status_path = reverse("wrong-note-pdf-status", kwargs={"job_id": job.id})
        status_url = request.build_absolute_uri(status_path)

        return Response({
            "job_id": job.id,
            "status": job.status,
            "status_url": status_url,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.serializers.wrong_note_serializers import (
    WrongNoteListResponseSerializer,
)
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


class WrongNoteView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ API

    âœ… STEP 3-3 ê³ ì •:
    - lecture_id/from_session_order í•„í„°ëŠ” Service ë‹¨ì¼ ì§„ì‹¤
    - ViewëŠ” ë³´ì•ˆ + query parsing + serializerë§Œ ë‹´ë‹¹
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - exam_id (optional)
        - lecture_id (optional)
        - from_session_order (optional, default=2)
        - offset (optional, default=0)
        - limit (optional, default=50)
        """
        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        exam_id = request.query_params.get("exam_id")
        lecture_id = request.query_params.get("lecture_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        offset = int(request.query_params.get("offset", 0))
        limit = int(request.query_params.get("limit", 50))

        q = WrongNoteQuery(
            exam_id=int(exam_id) if exam_id else None,
            lecture_id=int(lecture_id) if lecture_id else None,
            from_session_order=from_order,
            offset=offset,
            limit=limit,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id_i,
            q=q,
        )

        next_offset = (offset + limit) if (offset + limit) < total else None
        prev_offset = (offset - limit) if (offset - limit) >= 0 else None

        payload = {
            "count": int(total),
            "next": next_offset,
            "prev": prev_offset,
            "results": items,
        }

        return Response(WrongNoteListResponseSerializer(payload).data)
