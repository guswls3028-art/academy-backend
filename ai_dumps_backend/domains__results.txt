====================================================================================================
# BACKEND APP: domains__results
# ROOT PATH: C:\academy\apps\domains\results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class ResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.results"
    label = "results"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/results/permissions.py
from __future__ import annotations

from rest_framework.permissions import BasePermission


def _role(u) -> str:
    """
    í”„ë¡œì íŠ¸ë§ˆë‹¤ user.role / user.user_type / groups ë“± ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ ë°©ì–´ì ìœ¼ë¡œ.
    - ìˆìœ¼ë©´ ì“°ê³ 
    - ì—†ìœ¼ë©´ is_staff/is_superuserë¡œ íŒë‹¨
    """
    v = getattr(u, "role", None) or getattr(u, "user_type", None) or ""
    return str(v).upper()


def is_admin_user(u) -> bool:
    return bool(getattr(u, "is_superuser", False) or getattr(u, "is_staff", False) or _role(u) in ("ADMIN", "STAFF"))


def is_teacher_user(u) -> bool:
    # í”„ë¡œì íŠ¸ì— ë”°ë¼ "TEACHER" ë¬¸ìì—´ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ â†’ í•„ìš”ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •
    return bool(is_admin_user(u) or _role(u) in ("TEACHER",))


def is_student_user(u) -> bool:
    # ëª…ì‹œì ìœ¼ë¡œ teacher/admin ì•„ë‹ˆë©´ studentë¡œ ì·¨ê¸‰(ì¼ë°˜ì ì¸ ì •ì±…)
    return bool(not is_teacher_user(u))


class IsStudent(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_student_user(u))


class IsTeacherOrAdmin(BasePermission):
    def has_permission(self, request, view):
        u = getattr(request, "user", None)
        return bool(u and u.is_authenticated and is_teacher_user(u))


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/results/urls.py

from django.urls import path
from rest_framework.routers import DefaultRouter

# ======================================================
# Student
# ======================================================
from apps.domains.results.views.student_exam_result_view import MyExamResultView

# ======================================================
# Admin / Teacher
# ======================================================
from apps.domains.results.views.admin_exam_results_view import AdminExamResultsView
from apps.domains.results.views.admin_exam_summary_view import AdminExamSummaryView
from apps.domains.results.views.admin_representative_attempt_view import (
    AdminRepresentativeAttemptView,
)

# âœ… ì¶”ê°€: ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸
from apps.domains.results.views.admin_exam_result_detail_view import (
    AdminExamResultDetailView,
)

# ======================================================
# Question statistics (STEP 2)
# ======================================================
from apps.domains.results.views.question_stats_views import (
    AdminExamQuestionStatsView,
    ExamQuestionWrongDistributionView,
    ExamTopWrongQuestionsView,
)

# ======================================================
# Wrong note
# ======================================================
from apps.domains.results.views.wrong_note_view import WrongNoteView
from apps.domains.results.views.wrong_note_pdf_view import WrongNotePDFCreateView
from apps.domains.results.views.wrong_note_pdf_status_view import WrongNotePDFStatusView

# ======================================================
# ExamAttempt (history / retake)
# ======================================================
from apps.domains.results.views.exam_attempt_view import ExamAttemptViewSet

# ======================================================
# Session score summary (Admin)
# ======================================================
# ğŸ”§ PATCH: ì„¸ì…˜ ë‹¨ìœ„ ì„±ì  ìš”ì•½ API
from apps.domains.results.views.session_score_summary_view import (
    SessionScoreSummaryView,
)


urlpatterns = [
    # ============================
    # Student
    # ============================
    path(
        "me/exams/<int:exam_id>/",
        MyExamResultView.as_view(),
        name="my-exam-result",
    ),

    # ============================
    # Admin / Teacher
    # ============================
    path(
        "admin/exams/<int:exam_id>/summary/",
        AdminExamSummaryView.as_view(),
        name="admin-exam-summary",
    ),
    path(
        "admin/exams/<int:exam_id>/results/",
        AdminExamResultsView.as_view(),
        name="admin-exam-results",
    ),

    # âœ… ë‹¨ì¼ í•™ìƒ ê²°ê³¼ ìƒì„¸ (ë¦¬ìŠ¤íŠ¸ APIì™€ ë¶„ë¦¬)
    path(
        "admin/exams/<int:exam_id>/enrollments/<int:enrollment_id>/",
        AdminExamResultDetailView.as_view(),
        name="admin-exam-result-detail",
    ),

    # ----------------------------
    # STEP 2-A: ë¬¸í•­ ê¸°ë³¸ í†µê³„
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/",
        AdminExamQuestionStatsView.as_view(),
        name="admin-exam-question-stats",
    ),

    # ----------------------------
    # STEP 2-B: ë‹¨ì¼ ë¬¸í•­ ì˜¤ë‹µ ë¶„í¬
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/<int:question_id>/wrong-distribution/",
        ExamQuestionWrongDistributionView.as_view(),
        name="admin-exam-question-wrong-distribution",
    ),

    # ----------------------------
    # STEP 2-C: Top N ì˜¤ë‹µ ë¬¸í•­
    # ----------------------------
    path(
        "admin/exams/<int:exam_id>/questions/top-wrong/",
        ExamTopWrongQuestionsView.as_view(),
        name="admin-exam-top-wrong-questions",
    ),

    # ============================
    # STEP 8-B: ëŒ€í‘œ attempt ë³€ê²½
    # ============================
    path(
        "admin/exams/<int:exam_id>/representative-attempt/",
        AdminRepresentativeAttemptView.as_view(),
        name="admin-representative-attempt",
    ),

    # ============================
    # Session Scores (Admin)
    # ============================
    # ğŸ”§ PATCH: ì„¸ì…˜ ë‹¨ìœ„ ìµœì¢… ì„±ì  ìš”ì•½
    path(
        "admin/sessions/<int:session_id>/score-summary/",
        SessionScoreSummaryView.as_view(),
        name="session-score-summary",
    ),

    # ============================
    # Wrong Notes
    # ============================
    path(
        "wrong-notes",
        WrongNoteView.as_view(),
        name="wrong-note",
    ),
    path(
        "wrong-notes/pdf/",
        WrongNotePDFCreateView.as_view(),
        name="wrong-note-pdf-create",
    ),
    path(
        "wrong-notes/pdf/<int:job_id>/",
        WrongNotePDFStatusView.as_view(),
        name="wrong-note-pdf-status",
    ),
]

# ================================
# ExamAttempt router
# ================================
attempt_router = DefaultRouter()
attempt_router.register("exam-attempts", ExamAttemptViewSet)
urlpatterns += attempt_router.urls


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-06 12:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ResultFact",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                ("submission_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                ("meta", models.JSONField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_fact",
                "ordering": ["-id"],
            },
        ),
        migrations.CreateModel(
            name="WrongNotePDF",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField()),
                ("lecture_id", models.PositiveIntegerField(blank=True, null=True)),
                ("exam_id", models.PositiveIntegerField(blank=True, null=True)),
                ("from_session_order", models.PositiveIntegerField(default=2)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "Pending"),
                            ("RUNNING", "Running"),
                            ("DONE", "Done"),
                            ("FAILED", "Failed"),
                        ],
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("file_path", models.CharField(blank=True, max_length=255)),
                ("error_message", models.TextField(blank=True)),
            ],
            options={
                "db_table": "results_wrong_note_pdf",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ExamAttempt",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("exam_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "submission_id",
                    models.PositiveIntegerField(
                        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
                    ),
                ),
                ("attempt_index", models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")),
                ("is_retake", models.BooleanField(default=False)),
                ("is_representative", models.BooleanField(default=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("grading", "Grading"),
                            ("done", "Done"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
            ],
            options={
                "db_table": "results_exam_attempt",
                "ordering": ["-created_at"],
                "unique_together": {("exam_id", "enrollment_id", "attempt_index")},
            },
        ),
        migrations.CreateModel(
            name="Result",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("target_type", models.CharField(max_length=20)),
                ("target_id", models.PositiveIntegerField()),
                ("enrollment_id", models.PositiveIntegerField()),
                (
                    "attempt_id",
                    models.PositiveIntegerField(
                        blank=True,
                        db_index=True,
                        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
                        null=True,
                    ),
                ),
                ("total_score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("submitted_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "db_table": "results_result",
                "unique_together": {("target_type", "target_id", "enrollment_id")},
            },
        ),
        migrations.CreateModel(
            name="ResultItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("question_id", models.PositiveIntegerField()),
                ("answer", models.TextField(blank=True)),
                ("is_correct", models.BooleanField(default=False)),
                ("score", models.FloatField(default=0.0)),
                ("max_score", models.FloatField(default=0.0)),
                ("source", models.CharField(max_length=20)),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="items",
                        to="results.result",
                    ),
                ),
            ],
            options={
                "db_table": "results_result_item",
                "unique_together": {("result", "question_id")},
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# apps/domains/results/models/__init__.py

from .result import Result
from .result_item import ResultItem
from .result_fact import ResultFact
from .exam_attempt import ExamAttempt
from .wrong_note_pdf import WrongNotePDF

# âŒ SubmissionAnswer ì œê±°ë¨ (raw inputì€ submissions ë„ë©”ì¸ ì±…ì„)

__all__ = [
    "Result",
    "ResultItem",
    "ResultFact",
    "ExamAttempt",
    "WrongNotePDF",
]


==========================================================================================
# FILE: models/exam_attempt.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ExamAttempt(BaseModel):
    """
    í•™ìƒì˜ 'ì‹œí—˜ 1íšŒ ì‘ì‹œ'ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—”í‹°í‹° (append-only)

    ğŸ”¥ í•µì‹¬ ì±…ì„
    - Submission ë‹¨ìœ„ê°€ ì•„ë‹Œ 'ì‹œí—˜ ì‘ì‹œ ì‚¬ì‹¤'ì˜ ê³ ì •
    - Result / Fact / Snapshotì˜ ê¸°ì¤€ì 
    """

    exam_id = models.PositiveIntegerField()
    enrollment_id = models.PositiveIntegerField()

    # Submissionì€ ì‹œë„ì˜ ì›ì¸(event)
    submission_id = models.PositiveIntegerField(
        help_text="ì´ attemptë¥¼ ë°œìƒì‹œí‚¨ submission"
    )

    attempt_index = models.PositiveIntegerField(help_text="1ë¶€í„° ì‹œì‘")
    is_retake = models.BooleanField(default=False)

    # ì„œë²„ê°€ íŒë‹¨í•˜ëŠ” ëŒ€í‘œ attempt (ResultëŠ” í•­ìƒ ì´ê²ƒ ê¸°ì¤€)
    is_representative = models.BooleanField(default=True)

    status = models.CharField(
        max_length=20,
        choices=[
            ("pending", "Pending"),     # ìƒì„±ë¨
            ("grading", "Grading"),     # ì±„ì  ì¤‘
            ("done", "Done"),           # ì±„ì  ì™„ë£Œ
            ("failed", "Failed"),       # ì±„ì  ì‹¤íŒ¨
        ],
        default="pending",
    )

    class Meta:
        db_table = "results_exam_attempt"
        unique_together = ("exam_id", "enrollment_id", "attempt_index")
        ordering = ["-created_at"]

    def __str__(self):
        return (
            f"ExamAttempt exam={self.exam_id} "
            f"enrollment={self.enrollment_id} "
            f"#{self.attempt_index}"
        )


==========================================================================================
# FILE: models/result.py
==========================================================================================
# apps/domains/results/models/result.py
from django.db import models
from apps.api.common.models import BaseModel


class Result(BaseModel):
    """
    ì‹œí—˜/ìˆ™ì œ ê²°ê³¼ ìµœì‹  ìŠ¤ëƒ…ìƒ· (ì¡°íšŒìš©)
    ê³„ì‚° ì—†ìŒ

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Resultê°€ ì–´ë–¤ ExamAttempt(ì‹œë„)ë¥¼ ëŒ€í‘œí•˜ëŠ”ì§€ ì¶”ì  ê°€ëŠ¥
    - ì¬ì‹œí—˜/ëŒ€í‘œ attempt êµì²´ ì‹œì—ë„ "ì–´ë–¤ attempt ê²°ê³¼ì¸ì§€" ëª…í™•í•´ì§

    âš ï¸ ì£¼ì˜:
    - ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ attempt_idëŠ” ì¼ë‹¨ NULL í—ˆìš©ìœ¼ë¡œ ë“¤ì–´ê° (ë§ˆì´ê·¸ë ˆì´ì…˜ì—ì„œ null=True)
    - ìš´ì˜ì—ì„œ ë°±í•„ í›„ null=Falseë¡œ tighten í•˜ëŠ” 2ë‹¨ê³„ê°€ ì •ì„
    """

    target_type = models.CharField(max_length=20)  # exam / homework
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì˜ ê²°ê³¼ì¸ì§€ ì¶”ì  (ëŒ€í‘œ attempt ê¸°ì¤€)
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Resultê°€ ì°¸ì¡°í•˜ëŠ” ëŒ€í‘œ ExamAttempt.id",
    )

    total_score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    submitted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "results_result"
        unique_together = ("target_type", "target_id", "enrollment_id")


==========================================================================================
# FILE: models/result_fact.py
==========================================================================================
# apps/domains/results/models/result_fact.py
from django.db import models
from apps.api.common.models import BaseModel


class ResultFact(BaseModel):
    """
    ê²°ê³¼ Fact (append-only, ë¶ˆë³€)
    - ì§‘ê³„/í†µê³„/ì´ë²¤íŠ¸ ë¡œê·¸ì— ê°€ê¹Œì›€

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜
    - attempt_id: ì´ Factê°€ ì–´ëŠ attemptì—ì„œ ë‚˜ì˜¨ ì´ë²¤íŠ¸ì¸ì§€ ì¶”ì  ê°€ëŠ¥

    âš ï¸ ë¦¬íŒ©í† ë§ ë©”ëª¨ (ì¤‘ìš”)
    ì§€ê¸ˆì€ ResultFactê°€ answer/score/meta/sourceê¹Œì§€ ë“¤ê³  ìˆìŒ.
    ì¥ê¸°ì ìœ¼ë¡œëŠ”:
      - ResultFact = "ì§‘ê³„ìš© ì´ë²¤íŠ¸"
      - ìƒì„¸/ì±„ì ê²°ê³¼ = results.SubmissionAnswer ê°€ ë“¤ê³  ê°€ëŠ” ê²Œ ì •ì„
    ë‹¤ë§Œ ì§€ê¸ˆ ë‹¨ê³„ì—ì„œëŠ” analytics ì œê±° + ë‹¨ìˆœ ìš´ì˜ì„ ìœ„í•´ ìœ ì§€.
    """

    target_type = models.CharField(max_length=20)
    target_id = models.PositiveIntegerField()

    enrollment_id = models.PositiveIntegerField()
    submission_id = models.PositiveIntegerField()

    # âœ… ì–´ë–¤ attemptì—ì„œ ìƒì„±ëœ Factì¸ì§€
    attempt_id = models.PositiveIntegerField(
        null=True,
        blank=True,
        db_index=True,
        help_text="ì´ Factë¥¼ ìƒì„±í•œ ExamAttempt.id",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "results_fact"
        ordering = ["-id"]


==========================================================================================
# FILE: models/result_item.py
==========================================================================================
from django.db import models
from apps.api.common.models import BaseModel


class ResultItem(BaseModel):
    """
    ë¬¸í•­ë³„ ìµœì‹  ê²°ê³¼ ìƒíƒœ (snapshot)
    """

    result = models.ForeignKey(
        "results.Result",
        on_delete=models.CASCADE,
        related_name="items",
    )

    question_id = models.PositiveIntegerField()

    answer = models.TextField(blank=True)
    is_correct = models.BooleanField(default=False)

    score = models.FloatField(default=0.0)
    max_score = models.FloatField(default=0.0)

    source = models.CharField(max_length=20)

    class Meta:
        db_table = "results_result_item"
        unique_together = ("result", "question_id")


==========================================================================================
# FILE: models/wrong_note_pdf.py
==========================================================================================
# apps/domains/results/models/wrong_note_pdf.py
from django.db import models
from apps.api.common.models import BaseModel


class WrongNotePDF(BaseModel):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Job
    """

    class Status(models.TextChoices):
        PENDING = "PENDING"
        RUNNING = "RUNNING"
        DONE = "DONE"
        FAILED = "FAILED"

    enrollment_id = models.PositiveIntegerField()
    lecture_id = models.PositiveIntegerField(null=True, blank=True)
    exam_id = models.PositiveIntegerField(null=True, blank=True)

    from_session_order = models.PositiveIntegerField(default=2)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
    )

    file_path = models.CharField(max_length=255, blank=True)
    error_message = models.TextField(blank=True)

    class Meta:
        db_table = "results_wrong_note_pdf"
        ordering = ["-created_at"]


==========================================================================================
# FILE: serializers/admin_exam_result_row.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_result_row.py
from rest_framework import serializers


class AdminExamResultRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()

    # =====================================
    # ğŸ”§ PATCH: ì ìˆ˜ í•„ë“œ ëª…ì‹œì  ë¶„ë¦¬
    # - SessionScores / AdminExamResults ê³µìš© ê³„ì•½
    # - í”„ë¡ íŠ¸ ìˆ˜ì • ì—†ì´ í™•ì¥ ê°€ëŠ¥
    # =====================================
    exam_score = serializers.FloatField()
    exam_max_score = serializers.FloatField()

    final_score = serializers.FloatField()
    passed = serializers.BooleanField()
    clinic_required = serializers.BooleanField()

    submitted_at = serializers.DateTimeField(allow_null=True)

    # ===============================
    # ğŸ”¥ Submission ì—°ë™ í•„ë“œ (ê¸°ì¡´ ìœ ì§€)
    # ===============================
    submission_id = serializers.IntegerField(allow_null=True)
    submission_status = serializers.CharField(allow_null=True)


==========================================================================================
# FILE: serializers/admin_exam_summary.py
==========================================================================================
# apps/domains/results/serializers/admin_exam_summary.py
from rest_framework import serializers


class AdminExamSummarySerializer(serializers.Serializer):
    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_count = serializers.IntegerField()
    fail_count = serializers.IntegerField()
    pass_rate = serializers.FloatField()

    clinic_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/exam_attempt.py
==========================================================================================
# apps/domains/results/serializers/exam_attempt.py (ì‹ ê·œ)

from rest_framework import serializers
from apps.domains.results.models import ExamAttempt


class ExamAttemptSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExamAttempt
        fields = "__all__"


==========================================================================================
# FILE: serializers/question_stats.py
==========================================================================================
# apps/domains/results/serializers/question_stats.py

from rest_framework import serializers


class QuestionStatSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    attempts = serializers.IntegerField()
    correct = serializers.IntegerField()
    accuracy = serializers.FloatField()
    avg_score = serializers.FloatField()
    max_score = serializers.FloatField()


class WrongDistributionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    distribution = serializers.DictField(
        child=serializers.IntegerField()
    )


class TopWrongQuestionSerializer(serializers.Serializer):
    question_id = serializers.IntegerField()
    wrong_count = serializers.IntegerField()


==========================================================================================
# FILE: serializers/session_score_summary.py
==========================================================================================
# PATH: apps/domains/results/serializers/session_score_summary.py

from rest_framework import serializers


class SessionScoreSummarySerializer(serializers.Serializer):
    """
    ì„¸ì…˜ ë‹¨ìœ„ ì„±ì  ìš”ì•½ (ìš´ì˜/í†µê³„ìš©)

    âš ï¸ ì£¼ì˜
    - Result / ResultFact / Progress ê²°ê³¼ë§Œ ì‚¬ìš©
    - attempt êµì²´ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ ê°’
    """

    participant_count = serializers.IntegerField()

    avg_score = serializers.FloatField()
    min_score = serializers.FloatField()
    max_score = serializers.FloatField()

    pass_rate = serializers.FloatField()
    clinic_rate = serializers.FloatField()

    attempt_stats = serializers.DictField()


==========================================================================================
# FILE: serializers/student_exam_result.py
==========================================================================================
# PATH: apps/domains/results/serializers/student_exam_result.py
from __future__ import annotations

from rest_framework import serializers
from apps.domains.results.models import Result, ResultItem


class ResultItemSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ë¬¸í•­ë³„ ê²°ê³¼
    """
    class Meta:
        model = ResultItem
        fields = [
            "question_id",
            "answer",
            "is_correct",
            "score",
            "max_score",
            "source",
        ]


class StudentExamResultSerializer(serializers.ModelSerializer):
    """
    âœ… í•™ìƒ í™”ë©´: ì‹œí—˜ ê²°ê³¼(ì´ì  + ë¬¸í•­ë³„) + ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ê°’

    ì„¤ê³„:
    - Result ëª¨ë¸ ìì²´ëŠ” 'ìŠ¤ëƒ…ìƒ·'ì´ë¯€ë¡œ
      allow_retake/max_attempts/can_retakeëŠ” Exam ì •ì±… + Attempt ìƒíƒœë¡œ ê³„ì‚°í•´ì„œ ë‚´ë ¤ì¤€ë‹¤.
    - ì´ ê°’ë“¤ì€ "ì‘ë‹µ í•„ë“œ"ì´ì§€ Result DB í•„ë“œê°€ ì•„ë‹ˆë‹¤.
      â†’ Viewì—ì„œ ê³„ì‚° í›„ dataì— ì£¼ì…í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ë‹¨ìˆœ/ëª…í™•.
    """

    items = ResultItemSerializer(many=True, read_only=True)

    # âœ… STEP 2: í”„ë¡ íŠ¸ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ìš© (ì‘ë‹µ ì „ìš© í•„ë“œ)
    attempt_id = serializers.IntegerField(allow_null=True, required=False, read_only=True)
    can_retake = serializers.BooleanField(required=False, read_only=True)
    max_attempts = serializers.IntegerField(required=False, read_only=True)
    allow_retake = serializers.BooleanField(required=False, read_only=True)

    class Meta:
        model = Result
        fields = [
            "target_type",
            "target_id",
            "enrollment_id",

            # âœ… STEP 2
            "attempt_id",
            "total_score",
            "max_score",
            "submitted_at",
            "items",
            "allow_retake",
            "max_attempts",
            "can_retake",
        ]


==========================================================================================
# FILE: serializers/wrong_note_pdf_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_pdf_serializers.py
from __future__ import annotations

from rest_framework import serializers


class WrongNotePDFStatusSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ ì‘ë‹µ

    âœ… í”„ë¡ íŠ¸ í´ë§ìš© ìµœì†Œ í•„ë“œ
    - status: PENDING/RUNNING/DONE/FAILED
    - file_url: DONEì¼ ë•Œ ë‹¤ìš´ë¡œë“œ URL
    - error_message: FAILEDì¼ ë•Œ í‘œì‹œ
    """
    job_id = serializers.IntegerField()
    status = serializers.CharField()
    file_path = serializers.CharField(allow_blank=True)
    file_url = serializers.CharField(allow_blank=True, allow_null=True)
    error_message = serializers.CharField(allow_blank=True)
    created_at = serializers.DateTimeField()
    updated_at = serializers.DateTimeField()


==========================================================================================
# FILE: serializers/wrong_note_serializers.py
==========================================================================================
# apps/domains/results/serializers/wrong_note_serializers.py
from __future__ import annotations

from typing import Any, Dict, Optional
from rest_framework import serializers


class WrongNoteItemSerializer(serializers.Serializer):
    """
    ì˜¤ë‹µë…¸íŠ¸ ë‹¨ì¼ ë¬¸í•­ ì•„ì´í…œ

    âœ… ì˜ë„:
    - ResultFact/ResultItem êµ¬ì¡°ê°€ í”„ë¡œì íŠ¸ë§ˆë‹¤ ì¡°ê¸ˆ ë‹¬ë¼ë„
      Viewì—ì„œ dictë¡œ ë§Œë“¤ì–´ serialize ê°€ëŠ¥í•˜ê²Œ "ë‹¨ìˆœ Serializer"ë¡œ ê³ ì •
    """

    exam_id = serializers.IntegerField()
    attempt_id = serializers.IntegerField()
    attempt_created_at = serializers.DateTimeField(allow_null=True)

    question_id = serializers.IntegerField()
    question_number = serializers.IntegerField(required=False, allow_null=True)
    answer_type = serializers.CharField(required=False, allow_blank=True)

    # í•™ìƒ ë‹µ / ì •ë‹µ / ì ìˆ˜
    student_answer = serializers.CharField(required=False, allow_blank=True)
    correct_answer = serializers.CharField(required=False, allow_blank=True)

    is_correct = serializers.BooleanField()
    score = serializers.FloatField()
    max_score = serializers.FloatField()

    # ì›ë³¸ ë©”íƒ€ (OMR/AI í¬í•¨)
    meta = serializers.JSONField(required=False)

    # ì˜µì…˜: í”„ë¡ íŠ¸ UXìš© (ë¬¸ì œ ì§€ë¬¸/ì„ ì§€/í•´ì„¤ ë“±ì€ í™•ì¥ í¬ì¸íŠ¸)
    extra = serializers.JSONField(required=False)


class WrongNoteListResponseSerializer(serializers.Serializer):
    """
    í˜ì´ì§€ë„¤ì´ì…˜ í¬í•¨ ì‘ë‹µ
    """
    count = serializers.IntegerField()
    next = serializers.IntegerField(allow_null=True)   # ë‹¤ìŒ offset
    prev = serializers.IntegerField(allow_null=True)   # ì´ì „ offset
    results = WrongNoteItemSerializer(many=True)


==========================================================================================
# FILE: services/__init__.py
==========================================================================================
from .applier import ResultApplier

__all__ = ["ResultApplier"]


==========================================================================================
# FILE: services/applier.py
==========================================================================================
# apps/domains/results/services/applier.py
from __future__ import annotations

from django.db import transaction
from django.utils import timezone

from apps.domains.results.models import Result, ResultItem, ResultFact


class ResultApplier:
    """
    ê³„ì‚°ëœ ê²°ê³¼ë¥¼ ë°›ì•„ resultsì— ë°˜ì˜
    âŒ ê³„ì‚° ì—†ìŒ (ê³„ì‚°ì€ graderê°€ í•¨)

    âœ… attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜:
    - apply()ê°€ attempt_idë¥¼ ë°›ì•„ì„œ Result / ResultFactì— ì €ì¥

    âœ… ìš´ì˜ ì•ˆì „ì„± íŒ¨ì¹˜ (Critical #4)
    - ResultFact / ResultItemì— ë“¤ì–´ê°€ëŠ” ê°’ì€ "í•­ìƒ íƒ€ì…ì´ ë³´ì¥ëœë‹¤"ëŠ” ì „ì œê°€ ìš´ì˜ì—ì„œ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
      (blank, meta-only, None, ìˆ«ì/ë¦¬ìŠ¤íŠ¸ ë“±)
    - ë”°ë¼ì„œ ì—¬ê¸°ì„œ ìµœì†Œ ìºìŠ¤íŒ…/ë””í´íŠ¸ë¥¼ ê°•ì œí•´ DB insert ì•ˆì •ì„±ì„ ì˜¬ë¦°ë‹¤.
    """

    @staticmethod
    @transaction.atomic
    def apply(
        *,
        target_type: str,
        target_id: int,
        enrollment_id: int,
        submission_id: int,
        attempt_id: int,            # âœ… ì¶”ê°€
        items: list[dict],
    ) -> Result:
        """
        items format (ê¶Œì¥):
        {
            question_id,
            answer,
            is_correct,
            score,
            max_score,
            source,
            meta
        }
        """

        result, _ = Result.objects.get_or_create(
            target_type=target_type,
            target_id=target_id,
            enrollment_id=enrollment_id,
        )

        # âœ… ëŒ€í‘œ attempt ì¶”ì  (ë®ì–´ì“°ëŠ”ê²Œ ì •ìƒ)
        result.attempt_id = int(attempt_id)

        total = 0.0
        max_total = 0.0

        for item in (items or []):
            # -----------------------------
            # âœ… Critical #4 PATCH
            # -----------------------------
            qid = int(item.get("question_id"))
            ans = str(item.get("answer") or "")
            is_correct = bool(item.get("is_correct"))
            score = float(item.get("score") or 0.0)
            max_score = float(item.get("max_score") or 0.0)
            source = str(item.get("source") or "")
            meta = item.get("meta", None)

            # 1ï¸âƒ£ Fact (append-only)
            ResultFact.objects.create(
                target_type=target_type,
                target_id=int(target_id),
                enrollment_id=int(enrollment_id),
                submission_id=int(submission_id),
                attempt_id=int(attempt_id),

                question_id=qid,
                answer=ans,
                is_correct=is_correct,
                score=score,
                max_score=max_score,
                source=source,
                meta=meta,
            )

            # 2ï¸âƒ£ Snapshot (ResultItem)
            ResultItem.objects.update_or_create(
                result=result,
                question_id=qid,
                defaults={
                    "answer": ans,
                    "is_correct": is_correct,
                    "score": score,
                    "max_score": max_score,
                    "source": source,
                },
            )

            total += score
            max_total += max_score

        result.total_score = float(total)
        result.max_score = float(max_total)
        result.submitted_at = timezone.now()

        result.save(
            update_fields=["attempt_id", "total_score", "max_score", "submitted_at"]
        )

        return result


==========================================================================================
# FILE: services/attempt_service.py
==========================================================================================
# apps/domains/results/services/attempt_service.py
from __future__ import annotations

from django.core.exceptions import ValidationError
from django.db import transaction
from django.db.models import Max
from django.utils import timezone

from apps.domains.results.models import ExamAttempt
from apps.domains.exams.models import Exam


class ExamAttemptService:
    """
    ExamAttempt ìƒì„±/ê´€ë¦¬ ì „ë‹´

    ğŸ”¥ Critical íŒ¨ì¹˜:
    - ê°™ì€ submission_idë¡œ Attemptê°€ ì¤‘ë³µ ìƒì„±ë˜ëŠ” ê²ƒì„ ì°¨ë‹¨
    """

    @staticmethod
    @transaction.atomic
    def create_for_submission(
        *,
        exam_id: int,
        enrollment_id: int,
        submission_id: int,
    ) -> ExamAttempt:

        # -------------------------------------------------
        # ğŸ”´ CRITICAL #2
        # -------------------------------------------------
        # ê°™ì€ submissionìœ¼ë¡œ Attemptê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¦‰ì‹œ ì°¨ë‹¨
        if ExamAttempt.objects.filter(submission_id=int(submission_id)).exists():
            raise ValidationError(
                "Attempt already exists for this submission."
            )

        # -------------------------------------------------
        # 1ï¸âƒ£ Exam ì •ì±… ë¡œë”©
        # -------------------------------------------------
        exam = Exam.objects.filter(id=int(exam_id)).first()
        allow_retake = bool(getattr(exam, "allow_retake", False)) if exam else False
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1) if exam else 1

        # -------------------------------------------------
        # 2ï¸âƒ£ open_at / close_at ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if exam:
            now = timezone.now()
            open_at = getattr(exam, "open_at", None)
            close_at = getattr(exam, "close_at", None)

            if open_at and now < open_at:
                raise ValidationError("Exam not open yet.")
            if close_at and now > close_at:
                raise ValidationError("Exam is closed.")

        # -------------------------------------------------
        # 3ï¸âƒ£ ë™ì‹œì„± ì•ˆì „: (exam, enrollment) lock
        # -------------------------------------------------
        qs = (
            ExamAttempt.objects
            .select_for_update()
            .filter(exam_id=exam_id, enrollment_id=enrollment_id)
        )

        last = qs.aggregate(Max("attempt_index")).get("attempt_index__max") or 0
        next_index = int(last) + 1

        # -------------------------------------------------
        # 4ï¸âƒ£ ì •ì±… ê°•ì œ
        # -------------------------------------------------
        if not allow_retake and next_index > 1:
            raise ValidationError("Retake is not allowed for this exam.")

        if allow_retake and next_index > max_attempts:
            raise ValidationError("Max attempts exceeded.")

        # -------------------------------------------------
        # 5ï¸âƒ£ ëŒ€í‘œ attempt êµì²´
        # -------------------------------------------------
        qs.filter(is_representative=True).update(is_representative=False)

        attempt = ExamAttempt.objects.create(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
            submission_id=submission_id,
            attempt_index=next_index,
            is_retake=(last > 0),
            is_representative=True,
            status="pending",
        )

        return attempt


==========================================================================================
# FILE: services/grader.py
==========================================================================================
# apps/domains/results/services/grader.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from django.db import transaction

# ======================================================
# ğŸ”½ submissions ë„ë©”ì¸ (raw input)
# ======================================================
from apps.domains.submissions.models import Submission, SubmissionAnswer

# ======================================================
# ğŸ”½ results ë„ë©”ì¸ (apply / attempt)
# ======================================================
from apps.domains.results.services.applier import ResultApplier
from apps.domains.results.services.attempt_service import ExamAttemptService

# ======================================================
# ğŸ”½ exams ë„ë©”ì¸ (ì •ë‹µ / ë¬¸ì œ ì •ì˜)
# ======================================================
from apps.domains.exams.models import ExamQuestion, AnswerKey
# (ì„ íƒ) pass_scoreë¥¼ Examì—ì„œ ì½ì„ ìˆ˜ ìˆìœ¼ë©´ ì“°ê³ , ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ ìŠ¤í‚µ
try:
    from apps.domains.exams.models import Exam  # type: ignore
except Exception:  # pragma: no cover
    Exam = None  # type: ignore

# ======================================================
# ğŸ”½ progress pipeline (side-effect)
# ======================================================
from apps.domains.progress.tasks.progress_pipeline_task import (
    run_progress_pipeline_task,
)

# ======================================================
# Constants (STEP 1 ê³ ì •)
# ======================================================
OMR_CONF_THRESHOLD_V1 = 0.70


# ======================================================
# Utils
# ======================================================
def _norm(s: Optional[str]) -> str:
    """
    ë¬¸ìì—´ ì •ê·œí™” (STEP 1 exact match ê³ ì •):
    - None ë°©ì–´
    - ê³µë°± ì œê±°
    - ëŒ€ë¬¸ì í†µì¼
    """
    return (s or "").strip().upper()


def _get_omr_meta(meta: Any) -> Dict[str, Any]:
    """
    submissions.SubmissionAnswer.meta ì—ì„œ
    omr dict ë§Œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
    """
    if not isinstance(meta, dict):
        return {}
    omr = meta.get("omr")
    return omr if isinstance(omr, dict) else {}


def _ensure_dict(v: Any) -> Dict[str, Any]:
    return v if isinstance(v, dict) else {}


def _with_invalid_reason(meta: Any, reason: str) -> Dict[str, Any]:
    """
    âœ… STEP 1 í•µì‹¬:
    low_conf / blank / multi ë“± "ë¬´íš¨ ì²˜ë¦¬"ëŠ” 0ì  ì²˜ë¦¬ ë¿ ì•„ë‹ˆë¼
    **ì‚¬ìœ ë¥¼ append-onlyë¡œ ë‚¨ê²¨ì•¼ ìš´ì˜/ì¬ì²˜ë¦¬/í”„ë¡ íŠ¸ í‘œì‹œê°€ ê°€ëŠ¥**í•´ì§.
    """
    base = _ensure_dict(meta)
    out = dict(base)
    out.setdefault("grading", {})
    if isinstance(out["grading"], dict):
        out["grading"]["invalid_reason"] = reason
    return out


# ======================================================
# Grading helpers
# ======================================================
def _grade_choice_v1(
    *,
    detected: List[str],
    marking: str,
    confidence: Optional[float],
    status: str,
    correct_answer: str,
    max_score: float,
    # âœ… ê¸°ì¡´ metaë¥¼ ë°›ì•„ì„œ invalid_reasonì„ ì‹¬ëŠ”ë‹¤
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    OMR ê°ê´€ì‹ ì±„ì  v1 (STEP 1 ê³ ì •)

    âœ… ì •ì±…:
    - status != ok -> ë¬´íš¨ (0ì )
    - marking blank/multi -> ë¬´íš¨ (0ì )
    - confidence < threshold -> ë¬´íš¨ (0ì ) + LOW_CONFIDENCE ì‚¬ìœ  ì €ì¥  â­â­â­
    - detected != 1ê°œ -> ë¬´íš¨ (0ì )
    """
    st = (status or "").lower()
    mk = (marking or "").lower()

    # 1) statusê°€ okê°€ ì•„ë‹ˆë©´ ë¬´íš¨
    if st != "ok":
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_STATUS_NOT_OK")

    # 2) blank/multiëŠ” ë¬´íš¨
    if mk in ("blank", "multi"):
        reason = "OMR_BLANK" if mk == "blank" else "OMR_MULTI"
        return False, 0.0, _with_invalid_reason(original_meta, reason)

    # 3) ì‹ ë¢°ë„ ì²´í¬ (STEP 1: low confidence ìë™ 0ì  + ì‚¬ìœ  ì €ì¥)
    conf = float(confidence) if confidence is not None else 0.0
    if conf < OMR_CONF_THRESHOLD_V1:
        return False, 0.0, _with_invalid_reason(original_meta, "LOW_CONFIDENCE")

    # 4) detected 1ê°œ ê°•ì œ
    if not detected or len(detected) != 1:
        return False, 0.0, _with_invalid_reason(original_meta, "OMR_DETECTED_INVALID")

    ans = _norm(detected[0])
    cor = _norm(correct_answer)

    is_correct = ans != "" and cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _grade_short_v1(
    *,
    answer_text: str,
    correct_answer: str,
    max_score: float,
    original_meta: Any,
) -> Tuple[bool, float, Dict[str, Any]]:
    """
    ì£¼ê´€ì‹ / fallback ì±„ì  (STEP 1: exact match)

    âœ… ì •ì±…:
    - empty => 0ì 
    - exact match only
    """
    ans = _norm(answer_text)
    cor = _norm(correct_answer)

    if ans == "":
        return False, 0.0, _with_invalid_reason(original_meta, "EMPTY_ANSWER")

    is_correct = cor != "" and ans == cor
    return is_correct, (float(max_score) if is_correct else 0.0), _ensure_dict(original_meta)


def _infer_answer_type(q: ExamQuestion) -> str:
    """
    ExamQuestion.answer_type ì¶”ë¡ 
    """
    v = getattr(q, "answer_type", None)
    if isinstance(v, str) and v.strip():
        return v.strip().lower()
    return "choice"


def _get_correct_answer_map_v2(exam_id: int) -> Dict[str, Any]:
    """
    âœ… AnswerKey v2 ê³ ì •

    answers = {
        "123": "B",
        "124": "D"
    }

    key == ExamQuestion.id (string)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    if not ak or not isinstance(ak.answers, dict):
        return {}
    return ak.answers


def _get_pass_score(exam_id: int) -> Optional[float]:
    """
    (ì„ íƒ) Exam.pass_scoreê°€ ìˆìœ¼ë©´ ì½ì–´ì„œ attempt/metaì— ê¸°ë¡.
    - ResultApplierê°€ ì´ë¯¸ is_passë¥¼ ê³„ì‚°í•œë‹¤ë©´ ì´ê±´ "ì§„ë‹¨/í‘œì‹œìš©" ì •ë³´ë¡œë§Œ ë‚¨ëŠ”ë‹¤.
    """
    if Exam is None:
        return None
    try:
        exam = Exam.objects.filter(id=int(exam_id)).first()
        if not exam:
            return None
        v = getattr(exam, "pass_score", None)
        return float(v) if v is not None else None
    except Exception:
        return None


# ======================================================
# Main grading pipeline
# ======================================================
@transaction.atomic
def grade_submission_to_results(submission: Submission) -> None:
    """
    Submission â†’ ExamAttempt â†’ Result / ResultItem / ResultFact

    ğŸ”¥ v2 í•µì‹¬ ê³„ì•½:
    - SubmissionAnswer.exam_question_id ë§Œ ì‚¬ìš©
    - number / fallback ì™„ì „ ì œê±°
    - AnswerKey v2 ê³ ì •
    - âœ… STEP 1: LOW_CONF ë¬´íš¨ 0ì  + ì‚¬ìœ  ì €ì¥
    """

    # --------------------------------------------------
    # 0ï¸âƒ£ Submission ìƒíƒœ ì „ì´
    # --------------------------------------------------
    submission.status = Submission.Status.GRADING
    if hasattr(submission, "error_message"):
        submission.error_message = ""
        submission.save(update_fields=["status", "error_message"])
    else:
        submission.save(update_fields=["status"])

    if submission.target_type != Submission.TargetType.EXAM:
        raise ValueError("Only exam grading is supported")

    attempt = None

    try:
        # --------------------------------------------------
        # 1ï¸âƒ£ ExamAttempt ìƒì„±
        # --------------------------------------------------
        attempt = ExamAttemptService.create_for_submission(
            exam_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
        )
        attempt.status = "grading"
        attempt.save(update_fields=["status"])

        # --------------------------------------------------
        # 2ï¸âƒ£ Raw answers
        # --------------------------------------------------
        answers = list(
            SubmissionAnswer.objects.filter(submission=submission)
        )

        # --------------------------------------------------
        # 3ï¸âƒ£ ExamQuestion ë¡œë”© (id ê¸°ì¤€)
        # --------------------------------------------------
        questions_by_id = (
            ExamQuestion.objects
            .filter(sheet__exam_id=submission.target_id)
            .in_bulk(field_name="id")
        )

        correct_map = _get_correct_answer_map_v2(int(submission.target_id))

        items: List[dict] = []

        total_score = 0.0
        total_max_score = 0.0

        # --------------------------------------------------
        # 4ï¸âƒ£ ë¬¸í•­ë³„ ì±„ì 
        # --------------------------------------------------
        for sa in answers:
            eqid = getattr(sa, "exam_question_id", None)
            if not eqid:
                continue

            try:
                q = questions_by_id.get(int(eqid))
            except (TypeError, ValueError):
                continue

            if not q:
                continue

            max_score = float(getattr(q, "score", 0) or 0.0)
            correct_answer = str(correct_map.get(str(q.id)) or "")

            answer_text = str(getattr(sa, "answer", "") or "").strip()

            # submissions meta
            original_meta = getattr(sa, "meta", None)
            omr = _get_omr_meta(original_meta)

            detected = omr.get("detected") or []
            marking = str(omr.get("marking") or "")
            confidence = omr.get("confidence", None)
            status = str(omr.get("status") or "")
            omr_version = str(omr.get("version") or "")

            # âœ… STEP 1: low_confidence statusëŠ” ì¦‰ì‹œ ë¬´íš¨ ì²˜ë¦¬ (0ì +ì‚¬ìœ )
            if (status or "").lower() == "low_confidence":
                is_correct = False
                score = 0.0
                final_answer = ""
                final_meta = _with_invalid_reason(original_meta, "LOW_CONFIDENCE")
            else:
                answer_type = _infer_answer_type(q)

                if answer_type in ("choice", "omr", "multiple_choice"):
                    if omr_version.lower() in ("v1", "v2"):
                        is_correct, score, final_meta = _grade_choice_v1(
                            detected=[str(x) for x in detected],
                            marking=marking,
                            confidence=confidence,
                            status=status,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        # í‘œì‹œìš© answer: ê°ì§€ëœ ê°’ 1ê°œë©´ ê·¸ ê°’, ì•„ë‹ˆë©´ ""
                        final_answer = (
                            "".join([_norm(x) for x in detected]) if detected else ""
                        )
                    else:
                        # OMR metaê°€ ì—†ê±°ë‚˜ ë²„ì „ì´ ì—†ì„ ë•Œ: í…ìŠ¤íŠ¸ ê¸°ë°˜ exact match
                        is_correct, score, final_meta = _grade_short_v1(
                            answer_text=answer_text,
                            correct_answer=correct_answer,
                            max_score=max_score,
                            original_meta=original_meta,
                        )
                        final_answer = answer_text
                else:
                    # subjective: exact match (STEP 1)
                    is_correct, score, final_meta = _grade_short_v1(
                        answer_text=answer_text,
                        correct_answer=correct_answer,
                        max_score=max_score,
                        original_meta=original_meta,
                    )
                    final_answer = answer_text

            # ì ìˆ˜ ëˆ„ì 
            total_score += float(score)
            total_max_score += float(max_score)

            items.append({
                "question_id": q.id,
                "answer": final_answer,
                "is_correct": bool(is_correct),
                "score": float(score),
                "max_score": float(max_score),
                "source": submission.source,
                # âœ… ìµœì¢… metaì—ëŠ” invalid_reasonì´ ë°˜ì˜ë  ìˆ˜ ìˆìŒ
                "meta": final_meta,
            })

        # --------------------------------------------------
        # 4-1) (ì„ íƒ) attempt/metaì— total/pass ì •ë³´ ê¸°ë¡
        # - ResultApplierê°€ ì‹¤ì œ ResultSummary.is_passë¥¼ ë§Œë“¤ë”ë¼ë„,
        #   attemptì—ëŠ” ìš´ì˜/ë””ë²„ê¹…ìš©ìœ¼ë¡œ ë‚¨ê²¨ë‘ë©´ ì¢‹ìŒ.
        # --------------------------------------------------
        try:
            pass_score = _get_pass_score(int(submission.target_id))
            meta = getattr(attempt, "meta", None)
            if isinstance(meta, dict):
                new_meta = dict(meta)
            else:
                new_meta = {}

            new_meta.setdefault("grading", {})
            if isinstance(new_meta["grading"], dict):
                new_meta["grading"]["total_score"] = float(total_score)
                new_meta["grading"]["total_max_score"] = float(total_max_score)
                if pass_score is not None:
                    new_meta["grading"]["pass_score"] = float(pass_score)
                    new_meta["grading"]["is_pass_inferred"] = bool(total_score >= pass_score)

            if hasattr(attempt, "meta"):
                attempt.meta = new_meta
                attempt.save(update_fields=["meta"])
        except Exception:
            # meta í•„ë“œê°€ ì—†ê±°ë‚˜ ì €ì¥ ì‹¤íŒ¨í•´ë„ grading ìì²´ëŠ” ê³„ì† ì§„í–‰
            pass

        # --------------------------------------------------
        # 5ï¸âƒ£ Result ë°˜ì˜
        # --------------------------------------------------
        ResultApplier.apply(
            target_type=submission.target_type,
            target_id=int(submission.target_id),
            enrollment_id=int(submission.enrollment_id),
            submission_id=int(submission.id),
            attempt_id=int(attempt.id),
            items=items,
        )

        # --------------------------------------------------
        # 6ï¸âƒ£ ìƒíƒœ ë§ˆë¬´ë¦¬
        # --------------------------------------------------
        attempt.status = "done"
        attempt.save(update_fields=["status"])

        submission.status = Submission.Status.DONE
        submission.save(update_fields=["status"])

        transaction.on_commit(
            lambda: run_progress_pipeline_task.delay(submission.id)
        )

    except Exception as e:
        if attempt:
            attempt.status = "failed"
            attempt.save(update_fields=["status"])

        submission.status = Submission.Status.FAILED
        if hasattr(submission, "error_message"):
            submission.error_message = str(e)[:2000]
            submission.save(update_fields=["status", "error_message"])
        else:
            submission.save(update_fields=["status"])
        raise


==========================================================================================
# FILE: services/grading_policy.py
==========================================================================================
# # PATH: apps/domains/results/services/grading_policy.py

# NOTE:
# STEP 2 ì´í›„ grader ë¦¬íŒ©í† ë§ ì‹œ ì‚¬ìš©í•  ì •ì±… ëª¨ë“ˆ
# í˜„ì¬ëŠ” ë¯¸ì‚¬ìš©

# from __future__ import annotations

# from dataclasses import dataclass
# from typing import Any, Dict, Optional, Tuple


# # =========================================================
# # STEP 1 ì •ì±… ìƒìˆ˜ (ê³ ì •)
# # =========================================================

# MIN_OMR_CONFIDENCE = 0.70  # ì´ ë¯¸ë§Œì´ë©´ ìë™ ë¬´íš¨(0ì )


# def normalize_text(s: str) -> str:
#     """
#     ì£¼ê´€ì‹ exact match í‘œì¤€ ì •ê·œí™” (STEP 1 ê³ ì •)
#     - strip + lower
#     - ì¶”í›„ ê³µë°±/íŠ¹ìˆ˜ë¬¸ì ê·œì¹™ì€ ì—¬ê¸°ì„œë§Œ ë°”ê¾¸ë©´ ë¨
#     """
#     return (s or "").strip().lower()


# @dataclass(frozen=True)
# class OMRValidity:
#     is_valid: bool
#     invalid_reason: Optional[str] = None


# def evaluate_omr_validity(submission_answer_meta: Dict[str, Any]) -> OMRValidity:
#     """
#     SubmissionAnswer.meta["omr"] ê¸°ë°˜ìœ¼ë¡œ OMR ìœ íš¨ì„± íŒë‹¨ (STEP 1 ê³ ì •)
#     - low_confidenceë©´ 0ì  ì²˜ë¦¬
#     - ambiguous/multi/blankì€ ë„ˆì˜ ì±„ì  ì •ì±…ì— ë”°ë¼ 0ì /ë¶€ë¶„ì  ë“± í™•ì¥ ê°€ëŠ¥í•˜ì§€ë§Œ
#       STEP 1ì—ì„œëŠ” ìµœì†Œí•œ low_confëŠ” ë¬´ì¡°ê±´ ë¬´íš¨ë¡œ ê³ ì •.
#     """
#     omr = (submission_answer_meta or {}).get("omr") or {}
#     conf = omr.get("confidence")
#     status = str(omr.get("status") or "").lower()

#     try:
#         conf_f = float(conf) if conf is not None else None
#     except Exception:
#         conf_f = None

#     # âœ… ëª…ì‹œì ìœ¼ë¡œ low_confidenceë©´ ë¬´íš¨
#     if status == "low_confidence":
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     # âœ… confidence ê°’ì´ ìˆê³  ì„ê³„ì¹˜ ë¯¸ë§Œì´ë©´ ë¬´íš¨
#     if conf_f is not None and conf_f < MIN_OMR_CONFIDENCE:
#         return OMRValidity(is_valid=False, invalid_reason="LOW_CONFIDENCE")

#     return OMRValidity(is_valid=True, invalid_reason=None)


# def grade_subjective_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ì£¼ê´€ì‹ exact match ì±„ì  (STEP 1 ê³ ì •)
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def grade_choice_exact(answer: str, correct: str, full_score: float) -> float:
#     """
#     ê°ê´€ì‹ exact match ê¸°ë³¸ (A/B/C/D)
#     - ë‹¤ì¤‘ë§ˆí‚¹ ì²˜ë¦¬/ë¶€ë¶„ì ì€ STEP 2 ì´í›„ í™•ì¥ í¬ì¸íŠ¸
#     """
#     return float(full_score) if normalize_text(answer) == normalize_text(correct) else 0.0


# def evaluate_pass_fail(total_score: float, pass_score: float) -> bool:
#     """
#     ì‹œí—˜ ë‹¨ìœ„ pass/fail (STEP 1 ê³ ì •)
#     """
#     try:
#         return float(total_score) >= float(pass_score)
#     except Exception:
#         return False


==========================================================================================
# FILE: services/question_stats_service.py
==========================================================================================
# apps/domains/results/services/question_stats_service.py
from __future__ import annotations

from typing import Dict, List, Optional
from django.db.models import Count, Avg, Max, Q, F, FloatField, ExpressionWrapper

from apps.domains.results.models import ResultFact


class QuestionStatsService:
    """
    ì‹œí—˜ ë¬¸í•­ í†µê³„ ë‹¨ì¼ ì§„ì‹¤ (ì •ì„)

    ğŸ”¥ ê¸°ì¤€:
    - ResultFact (append-only)ë§Œ ì‚¬ìš©
    - Result / ResultItem / attempt êµì²´ ì—¬ë¶€ì™€ ë¬´ê´€
    - ìš´ì˜/í†µê³„/ë¶„ì„ ì¼ê´€ì„± ë³´ì¥
    """

    # ======================================================
    # A) ë¬¸í•­ë³„ ê¸°ë³¸ í†µê³„
    # ======================================================
    @staticmethod
    def per_question_stats(
        *,
        exam_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ë¬¸í•­ë³„ í†µê³„
        - ì‘ì‹œ ìˆ˜
        - ì •ë‹µ ìˆ˜
        - ì •ë‹µë¥ 
        - í‰ê·  ì ìˆ˜
        - ìµœëŒ€ ì ìˆ˜
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(
                attempts=Count("id"),
                correct=Count("id", filter=Q(is_correct=True)),
                avg_score=Avg("score"),
                max_score=Max("score"),
            )
            .annotate(
                accuracy=ExpressionWrapper(
                    F("correct") * 1.0 / F("attempts"),
                    output_field=FloatField(),
                )
            )
            .order_by("question_id")
        )

        return [
            {
                "question_id": row["question_id"],
                "attempts": int(row["attempts"] or 0),
                "correct": int(row["correct"] or 0),
                "accuracy": round(float(row["accuracy"] or 0.0), 4),
                "avg_score": float(row["avg_score"] or 0.0),
                "max_score": float(row["max_score"] or 0.0),
            }
            for row in rows
        ]

    # ======================================================
    # B) ë¬¸í•­ ë‹¨ì¼ ì˜¤ë‹µ ë¶„í¬ (ì„ íƒì§€ ê¸°ì¤€)
    # ======================================================
    @staticmethod
    def wrong_choice_distribution(
        *,
        exam_id: int,
        question_id: int,
        attempt_ids: Optional[List[int]] = None,
    ) -> Dict[str, int]:
        """
        ê°ê´€ì‹ ì˜¤ë‹µ ë¶„í¬
        - answer ê°’ ê¸°ì¤€
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            question_id=int(question_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = qs.values("answer").annotate(cnt=Count("id"))

        dist: Dict[str, int] = {}
        for r in rows:
            key = str(r["answer"] or "")
            dist[key] = int(r["cnt"] or 0)

        return dist

    # ======================================================
    # C) ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
    # ======================================================
    @staticmethod
    def top_n_wrong_questions(
        *,
        exam_id: int,
        n: int = 5,
        attempt_ids: Optional[List[int]] = None,
    ) -> List[Dict]:
        """
        ê°€ì¥ ë§ì´ í‹€ë¦° ë¬¸í•­ TOP N
        """

        qs = ResultFact.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
            is_correct=False,
        )

        if attempt_ids:
            qs = qs.filter(attempt_id__in=attempt_ids)

        rows = (
            qs.values("question_id")
            .annotate(wrong_count=Count("id"))
            .order_by("-wrong_count")[: int(n)]
        )

        return [
            {
                "question_id": int(r["question_id"]),
                "wrong_count": int(r["wrong_count"]),
            }
            for r in rows
        ]


==========================================================================================
# FILE: services/session_score_summary_service.py
==========================================================================================
# PATH: apps/domains/results/services/session_score_summary_service.py

from __future__ import annotations

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session


class SessionScoreSummaryService:
    """
    âœ… Session ë‹¨ìœ„ ì„±ì  í†µê³„ (results ê¸°ì¤€ ë‹¨ì¼ ì§„ì‹¤)

    ì‚¬ìš© ê·¼ê±°:
    - ì ìˆ˜: Result (ëŒ€í‘œ attempt ìŠ¤ëƒ…ìƒ·)
    - í†µê³¼/í´ë¦¬ë‹‰: SessionProgress
    - ì¬ì‹œí—˜: ExamAttempt
    """

    @staticmethod
    def build(*, session_id: int) -> dict:
        session = Session.objects.filter(id=int(session_id)).first()
        if not session:
            return {
                "participant_count": 0,
                "avg_score": 0.0,
                "min_score": 0.0,
                "max_score": 0.0,
                "pass_rate": 0.0,
                "clinic_rate": 0.0,
                "attempt_stats": {
                    "avg_attempts": 0.0,
                    "retake_ratio": 0.0,
                },
            }

        # ---------------------------------------------
        # 1ï¸âƒ£ Session â†” Exam (ë‹¤ëŒ€ì¼)
        # ---------------------------------------------
        exam_ids = list(
            session.exam_set.values_list("id", flat=True)
            if hasattr(session, "exam_set")
            else Session.objects.filter(id=session.id).values_list("exam__id", flat=True)
        )

        if not exam_ids:
            return {
                "participant_count": 0,
                "avg_score": 0.0,
                "min_score": 0.0,
                "max_score": 0.0,
                "pass_rate": 0.0,
                "clinic_rate": 0.0,
                "attempt_stats": {
                    "avg_attempts": 0.0,
                    "retake_ratio": 0.0,
                },
            }

        # ---------------------------------------------
        # 2ï¸âƒ£ Result ê¸°ë°˜ ì ìˆ˜ í†µê³„ (ëŒ€í‘œ attempt)
        # ---------------------------------------------
        results = Result.objects.filter(
            target_type="exam",
            target_id__in=exam_ids,
        )

        agg = results.aggregate(
            participant_count=Count("id"),
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        participant_count = agg["participant_count"] or 0

        # ---------------------------------------------
        # 3ï¸âƒ£ Progress ê¸°ë°˜ pass / clinic
        # ---------------------------------------------
        progresses = SessionProgress.objects.filter(session=session)

        pass_count = progresses.filter(failed=False).count()
        clinic_count = progresses.filter(clinic_required=True).count()

        pass_rate = (
            pass_count / participant_count
            if participant_count else 0.0
        )
        clinic_rate = (
            clinic_count / participant_count
            if participant_count else 0.0
        )

        # ---------------------------------------------
        # 4ï¸âƒ£ Attempt í†µê³„ (ì¬ì‹œí—˜ ë¹„ìœ¨)
        # ---------------------------------------------
        attempts = ExamAttempt.objects.filter(
            exam_id__in=exam_ids
        )

        per_enrollment = (
            attempts
            .values("enrollment_id")
            .annotate(cnt=Count("id"))
        )

        total_attempts = sum(r["cnt"] for r in per_enrollment)
        retake_users = sum(1 for r in per_enrollment if r["cnt"] > 1)

        avg_attempts = (
            total_attempts / participant_count
            if participant_count else 0.0
        )
        retake_ratio = (
            retake_users / participant_count
            if participant_count else 0.0
        )

        return {
            "participant_count": participant_count,
            "avg_score": float(agg["avg_score"] or 0.0),
            "min_score": float(agg["min_score"] or 0.0),
            "max_score": float(agg["max_score"] or 0.0),
            "pass_rate": round(float(pass_rate), 4),
            "clinic_rate": round(float(clinic_rate), 4),
            "attempt_stats": {
                "avg_attempts": round(float(avg_attempts), 2),
                "retake_ratio": round(float(retake_ratio), 4),
            },
        }


==========================================================================================
# FILE: services/wrong_note_service.py
==========================================================================================
# apps/domains/results/services/wrong_note_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from django.db.models import Q
from django.utils import timezone

from apps.domains.results.models import ResultFact
from apps.domains.exams.models import ExamQuestion, AnswerKey, Exam


# ======================================================
# Request DTO
# ======================================================
@dataclass(frozen=True)
class WrongNoteQuery:
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ íŒŒë¼ë¯¸í„°

    âœ… STEP 3-3 ìŠ¹ê²©
    - lecture_id/from_session_order í•„í„°ë¥¼ ì„œë¹„ìŠ¤ ì±…ì„ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¼
      (View/Worker/PDF ëª¨ë‘ ê°™ì€ ê·œì¹™ ì‚¬ìš©)

    - offset/limitì€ ë‹¨ìˆœ í˜ì´ì§€ë„¤ì´ì…˜
    """
    exam_id: Optional[int] = None
    lecture_id: Optional[int] = None
    from_session_order: int = 2

    offset: int = 0
    limit: int = 50


# ======================================================
# Internal helpers
# ======================================================
def _safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def _has_relation(model, name: str) -> bool:
    """
    Exam ëª¨ë¸ì— íŠ¹ì • relation(name)ì´ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬
    """
    try:
        return any(getattr(f, "name", None) == name for f in model._meta.get_fields())
    except Exception:
        return False


def _get_exam_ids_by_lecture_and_order(*, lecture_id: int, from_order: int) -> List[int]:
    """
    lecture_id + from_session_orderë¡œ exam_id ëª©ë¡ êµ¬í•˜ê¸°

    âš ï¸ í”„ë¡œì íŠ¸ë³„ë¡œ Exam â†” Session reverse relation ì´ë¦„ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ:
    - sessions / session / session_set ...
    ê·¸ë˜ì„œ ê°€ëŠ¥í•œ í›„ë³´ë“¤ì„ ëª¨ë‘ ê²€ì‚¬í•´ ì•ˆì „í•˜ê²Œ í•„í„°ë§.

    âœ… ê·œì¹™:
    - ê´€ê³„ë¥¼ ëª» ì°¾ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜(=ì•ˆì „í•˜ê²Œ ê²°ê³¼ ì—†ìŒ)
    """
    exam_qs = Exam.objects.filter(lecture_id=int(lecture_id))

    # ìš°ì„ ìˆœìœ„ í›„ë³´ë“¤
    # 1) sessions
    if _has_relation(Exam, "sessions"):
        exam_qs = exam_qs.filter(sessions__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 2) session (1:1 í˜¹ì€ FK)
    if _has_relation(Exam, "session"):
        exam_qs = exam_qs.filter(session__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # 3) session_set (Django default reverse name)
    if _has_relation(Exam, "session_set"):
        exam_qs = exam_qs.filter(session_set__order__gte=int(from_order))
        return list(exam_qs.values_list("id", flat=True))

    # ëª» ì°¾ìœ¼ë©´ ì•ˆì „í•˜ê²Œ none
    return []


def _get_answer_key_map(exam_id: int) -> Dict[str, Any]:
    """
    AnswerKey v2 (ê³ ì •):
      answers = { "123": "B", ... }  # key = ExamQuestion.id(str)
    """
    ak = AnswerKey.objects.filter(exam_id=int(exam_id)).first()
    answers = getattr(ak, "answers", None) if ak else None
    return answers if isinstance(answers, dict) else {}


# ======================================================
# Public API
# ======================================================
def list_wrong_notes_for_enrollment(
    *,
    enrollment_id: int,
    q: WrongNoteQuery,
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    âœ… í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ResultFact êµ¬ì¡°ì— ë§ëŠ” â€œì •ì„â€ êµ¬í˜„

    ResultFact = ë¬¸í•­ 1ê°œ ì´ë²¤íŠ¸(append-only)
      - question_id/answer/is_correct/score/max_score/meta/source ê°€ Factì— ì§ì ‘ ìˆìŒ

    ë°˜í™˜: (total_count, paged_items)
    """

    enrollment_id = int(enrollment_id)
    offset = max(int(q.offset or 0), 0)
    limit = max(min(int(q.limit or 50), 200), 1)

    base = ResultFact.objects.filter(
        enrollment_id=enrollment_id,
        target_type="exam",
        is_correct=False,          # ì˜¤ë‹µë§Œ
    )

    # 1) exam_id í•„í„°
    if q.exam_id is not None:
        base = base.filter(target_id=int(q.exam_id))

    # 2) lecture_id + from_session_order í•„í„° (STEP 3-3 ìŠ¹ê²©)
    if q.lecture_id is not None:
        exam_ids = _get_exam_ids_by_lecture_and_order(
            lecture_id=int(q.lecture_id),
            from_order=int(q.from_session_order or 2),
        )
        if not exam_ids:
            return 0, []
        base = base.filter(target_id__in=exam_ids)

    # ìµœì‹  ì˜¤ë‹µ ìš°ì„ 
    base = base.order_by("-id")

    total = base.count()

    facts = list(base[offset: offset + limit])

    # ì§ˆë¬¸ ì •ë³´/ì •ë‹µí‚¤ ë¶™ì´ê¸° ìœ„í•´ question_ids, exam_ids ìˆ˜ì§‘
    question_ids = [int(f.question_id) for f in facts]
    exam_ids = list({int(f.target_id) for f in facts})

    questions_map = (
        ExamQuestion.objects
        .filter(id__in=question_ids)
        .select_related("sheet")
        .in_bulk(field_name="id")
    )

    answer_key_cache: Dict[int, Dict[str, Any]] = {
        exid: _get_answer_key_map(exid) for exid in exam_ids
    }

    out: List[Dict[str, Any]] = []

    for f in facts:
        exid = int(f.target_id)
        qobj = questions_map.get(int(f.question_id))

        question_number = getattr(qobj, "number", None) if qobj else None
        answer_type = (getattr(qobj, "answer_type", "") or "") if qobj else ""

        correct_answer = ""
        if qobj:
            correct_answer = str(answer_key_cache.get(exid, {}).get(str(qobj.id)) or "")

        out.append({
            "exam_id": exid,
            "attempt_id": int(getattr(f, "attempt_id", 0) or 0),
            # attempt_created_at í•„ë“œê°€ ë”°ë¡œ ì—†ìœ¼ë‹ˆ created_atì„ ì‚¬ìš©
            "attempt_created_at": getattr(f, "created_at", None),

            "question_id": int(f.question_id),
            "question_number": _safe_int(question_number),
            "answer_type": str(answer_type),

            "student_answer": str(f.answer or ""),
            "correct_answer": str(correct_answer or ""),

            "is_correct": False,
            "score": float(f.score or 0.0),
            "max_score": float(f.max_score or 0.0),

            "meta": f.meta if f.meta is not None else {},
            "extra": {},
        })

    return total, out


==========================================================================================
# FILE: tasks/__init__.py
==========================================================================================



==========================================================================================
# FILE: tasks/grading_tasks.py
==========================================================================================
# apps/domains/results/tasks/grading_tasks.py
from __future__ import annotations

import logging
from celery import shared_task

logger = logging.getLogger(__name__)


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={"max_retries": 3},
    retry_backoff=True,
    retry_jitter=True,
)
def grade_submission_task(self, submission_id: int) -> None:
    """
    STEP 1 í™•ì •:
    - ì±„ì  íƒœìŠ¤í¬ëŠ” ìë™ ì¬ì‹œë„ 3íšŒ
    - ì‹¤ì œ ì±„ì  ì§„ì…ì ì€ results.services.grader.grade_submission_to_results

    ğŸ”§ FIX:
    - ê¸°ì¡´ grade_submission ì€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
    - ì‹¤ì œ êµ¬í˜„ëœ í•¨ìˆ˜ëª…ìœ¼ë¡œ ì •í™•íˆ ì—°ê²°
    """
    from apps.domains.submissions.models import Submission
    from apps.domains.results.services.grader import (
        grade_submission_to_results,
    )

    submission = Submission.objects.get(id=int(submission_id))

    logger.info("grading start: submission_id=%s", submission_id)
    grade_submission_to_results(submission)
    logger.info("grading done: submission_id=%s", submission_id)


==========================================================================================
# FILE: tasks/progress_pipeline_task.py
==========================================================================================
# apps/domains/progress/tasks/progress_pipeline_task.py
from celery import shared_task

from apps.domains.submissions.models import Submission
from apps.domains.results.models import Result
from apps.domains.progress.services.progress_pipeline import ProgressPipeline


@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={"max_retries": 3})
def run_progress_pipeline_task(self, submission_id: int) -> bool:
    submission = Submission.objects.get(id=submission_id)

    result = Result.objects.filter(
        target_type=submission.target_type,
        target_id=submission.target_id,
        enrollment_id=submission.enrollment_id,
    ).first()

    if not result:
        return False

    ProgressPipeline.run_by_submission(
        submission=submission,
        result=result,
    )

    return True


==========================================================================================
# FILE: tasks/wrong_note_pdf_tasks.py
==========================================================================================
# apps/domains/results/tasks/wrong_note_pdf_tasks.py
from __future__ import annotations

from io import BytesIO
from typing import Optional

from celery import shared_task
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

from apps.domains.results.models import WrongNotePDF
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


# ======================================================
# âœ… STEP 1: reportlab ì§€ì—° import (ì •ì„)
# - API ì„œë²„ / migrate / runserver í™˜ê²½ì—ì„œ reportlabì´ ì—†ì–´ë„ OK
# - PDF worker í™˜ê²½ì—ì„œë§Œ reportlab í•„ìš”
# ======================================================
def _import_reportlab():
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas
        return A4, canvas
    except ImportError as e:
        raise RuntimeError(
            "reportlab is required only on PDF worker environment"
        ) from e


@shared_task(bind=True, max_retries=3, default_retry_delay=10)
def generate_wrong_note_pdf_task(self, job_id: int) -> None:
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± Worker (Celery)

    âœ… STEP 3-3 ë°˜ì˜:
    - lecture_id/from_session_order í•„í„°ê¹Œì§€ serviceë¡œ í†µì¼

    âœ… STEP 1 (ì¤‘ìš”):
    - reportlab ì§€ì—° import ì ìš©
      -> ì´ taskê°€ ì‹¤ì œ ì‹¤í–‰ë  ë•Œë§Œ reportlab import
    """

    job = WrongNotePDF.objects.filter(id=int(job_id)).first()
    if not job:
        return

    # ë©±ë“±ì„±/ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if job.status == WrongNotePDF.Status.DONE:
        return
    if job.status == WrongNotePDF.Status.RUNNING:
        return

    def _set_status(status: str, error: str = "") -> None:
        job.status = status
        job.error_message = (error or "")[:2000]
        job.save(update_fields=["status", "error_message"])

    try:
        _set_status(WrongNotePDF.Status.RUNNING)

        enrollment_id = int(job.enrollment_id)

        q = WrongNoteQuery(
            exam_id=int(job.exam_id) if job.exam_id else None,
            lecture_id=int(job.lecture_id) if job.lecture_id else None,
            from_session_order=int(job.from_session_order or 2),
            offset=0,
            limit=200,  # PDFëŠ” ìš°ì„  ìƒìœ„ 200ê°œ
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id,
            q=q,
        )

        # --------------------------------------------------
        # âœ… STEP 1: reportlabì€ "ì‹¤ì œ PDF ìƒì„± ì‹œì "ì—ë§Œ import
        # --------------------------------------------------
        A4, canvas = _import_reportlab()

        # ------------------------------
        # PDF ìƒì„± (ìµœì†Œ êµ¬í˜„: í…ìŠ¤íŠ¸ ë¦¬ìŠ¤íŠ¸)
        # ------------------------------
        buf = BytesIO()
        c = canvas.Canvas(buf, pagesize=A4)
        _, height = A4

        y = height - 48
        c.setFont("Helvetica-Bold", 14)
        c.drawString(40, y, "Wrong Notes")
        y -= 20

        c.setFont("Helvetica", 10)
        c.drawString(40, y, f"Enrollment: {enrollment_id}")
        y -= 14
        c.drawString(40, y, f"Total wrong items: {total}")
        y -= 20

        for idx, it in enumerate(items, start=1):
            if y < 80:
                c.showPage()
                y = height - 60
                c.setFont("Helvetica", 10)

            line = (
                f"{idx}. "
                f"Exam {it.get('exam_id')} / "
                f"Q{it.get('question_number') or it.get('question_id')} "
                f"| ans={it.get('student_answer','')} "
                f"| correct={it.get('correct_answer','')} "
                f"| score={it.get('score',0)}/{it.get('max_score',0)}"
            )
            c.drawString(40, y, line[:120])
            y -= 14

        c.showPage()
        c.save()
        buf.seek(0)

        key = f"results/wrong_notes/{int(job.id)}.pdf"
        default_storage.save(key, ContentFile(buf.read()))

        job.file_path = key
        job.status = WrongNotePDF.Status.DONE
        job.error_message = ""
        job.save(update_fields=["file_path", "status", "error_message"])

    except Exception as e:
        msg = str(e)
        try:
            _set_status(WrongNotePDF.Status.FAILED, msg)
        finally:
            # âœ… ê¸°ì¡´ ë™ì‘ ì¡´ì¤‘: retryë¡œ ì¬ì‹œë„
            raise self.retry(exc=e)


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# apps/domains/results/views/__init__.py

"""
results.views public exports

âš ï¸ IMPORTANT RULES
- ì´ íŒŒì¼ì€ "ì™¸ë¶€ì—ì„œ import í•´ë„ ë˜ëŠ” View"ë§Œ exportí•œë‹¤.
- urls.pyì—ì„œ ì§ì ‘ importí•˜ëŠ” ViewëŠ” êµ³ì´ ì—¬ê¸°ì„œ exportí•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
- ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ / í´ë˜ìŠ¤ê°€ importë˜ë©´
  migrate / runserver ì‹œì ì— ì¦‰ì‹œ í¬ë˜ì‹œ ë‚œë‹¤.
"""

# ======================================================
# Student-facing
# ======================================================
from .student_exam_result_view import MyExamResultView
from .wrong_note_view import WrongNoteView

# ======================================================
# Admin / Teacher-facing (ëŒ€í‘œ Viewë§Œ)
# ======================================================
from .admin_exam_results_view import AdminExamResultsView
from .admin_exam_summary_view import AdminExamSummaryView

# ======================================================
# âš ï¸ Question stats ê´€ë ¨
# - AdminExamQuestionStatsView ë“±ì€
#   urls.pyì—ì„œ ì§ì ‘ importí•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” exportí•˜ì§€ ì•ŠëŠ”ë‹¤.
# - ì¤‘ë³µ export / ë¶ˆí•„ìš”í•œ importë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•¨
# ======================================================

__all__ = [
    "MyExamResultView",
    "WrongNoteView",
    "AdminExamResultsView",
    "AdminExamSummaryView",
]


==========================================================================================
# FILE: views/admin_exam_result_detail_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_result_detail_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)

from apps.domains.exams.models import Exam
from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session


class AdminExamResultDetailView(APIView):
    """
    GET /results/admin/exams/<exam_id>/enrollments/<enrollment_id>/

    âœ… ëª©ì :
    - ê¸°ì¡´ /admin/exams/<exam_id>/results/ ëŠ” "ì „ì²´ ë¦¬ìŠ¤íŠ¸" ìš©ë„ ìœ ì§€
    - ë‹¨ì¼ í•™ìƒ ìƒì„¸(Result + ResultItem)ëŠ” ë³„ë„ endpointë¡œ ë¶„ë¦¬í•´ì„œ ê³„ì•½ ì¶©ëŒ ì œê±°

    âœ… ì‘ë‹µ:
    - StudentExamResultSerializer(Result) ê¸°ë°˜
    - allow_retake/max_attempts/can_retake/clinic_required ë¥¼ ê´€ë¦¬ì í™”ë©´ì—ì„œë„ ê°™ì´ ì œê³µ (optional UX)
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, enrollment_id: int):
        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)

        exam = get_object_or_404(Exam, id=exam_id)

        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )

        if not result:
          # âœ… ëª…ì‹œì ìœ¼ë¡œ 404 (ê´€ë¦¬ì UIì—ì„œ ë¶„ê¸° ì²˜ë¦¬ ì‰¬ì›€)
            raise NotFound("result not found")

        # -------------------------------------------------
        # âœ… ì¬ì‹œí—˜ ì •ì±… ê³„ì‚° (MyExamResultView ë¡œì§ ì¡´ì¤‘)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # âœ… clinic_required (progress pipeline ê²°ê³¼)
        # -------------------------------------------------
        clinic_required = False
        session = Session.objects.filter(exam__id=exam_id).first()
        if session:
            sp = SessionProgress.objects.filter(
                session=session,
                enrollment_id=enrollment_id,
            ).first()
            clinic_required = bool(sp and getattr(sp, "clinic_required", False))

        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = clinic_required

        return Response(data)


==========================================================================================
# FILE: views/admin_exam_results_view.py
==========================================================================================
# apps/domains/results/views/admin_exam_results_view.py

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result, ResultFact, ExamAttempt
from apps.domains.results.serializers.admin_exam_result_row import (
    AdminExamResultRowSerializer,
)

from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session
from apps.domains.students.models import Student
from apps.domains.submissions.models import Submission


class AdminExamResultsView(APIView):
    """
    GET /results/admin/exams/<exam_id>/results/

    ğŸ”¥ attempt ì¤‘ì‹¬ ì„¤ê³„ ë°˜ì˜ ë²„ì „
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        exam_id = int(exam_id)

        # -------------------------------------------------
        # 1ï¸âƒ£ Result (ìµœì‹  ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        results = Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
        )

        # -------------------------------------------------
        # 2ï¸âƒ£ Session â†’ Progress (enrollment ê¸°ì¤€)
        # -------------------------------------------------
        session = Session.objects.filter(exam__id=exam_id).first()

        if not session:
            progress_map = {}
        else:
            progress_map = {
                sp.enrollment_id: sp
                for sp in SessionProgress.objects.filter(session=session)
            }

        # -------------------------------------------------
        # 3ï¸âƒ£ Student ì¡°íšŒ ìµœì í™”
        # -------------------------------------------------
        student_ids = set()

        for sp in progress_map.values():
            if hasattr(sp, "student_id") and getattr(sp, "student_id", None):
                student_ids.add(int(sp.student_id))
            elif hasattr(sp, "user_id") and getattr(sp, "user_id", None):
                student_ids.add(int(sp.user_id))

        student_map = {
            s.id: s
            for s in Student.objects.filter(id__in=list(student_ids))
        }

        # -------------------------------------------------
        # 4ï¸âƒ£ enrollment_id â†’ ìµœì‹  attempt/submission ë§µ
        # -------------------------------------------------
        fact_qs = (
            ResultFact.objects
            .filter(
                target_type="exam",
                target_id=exam_id,
            )
            .exclude(attempt_id__isnull=True)
            .order_by("-attempt_id", "-id")
            .values(
                "enrollment_id",
                "attempt_id",
                "submission_id",
            )
        )

        latest_map = {}
        for row in fact_qs:
            eid = row["enrollment_id"]
            if eid not in latest_map:
                latest_map[eid] = {
                    "attempt_id": row["attempt_id"],
                    "submission_id": row["submission_id"],
                }

        # -------------------------------------------------
        # 4-1ï¸âƒ£ Fact ì—†ëŠ” ê²½ìš° Result.attempt_id fallback
        # -------------------------------------------------
        attempt_ids = [
            r.attempt_id
            for r in results
            if getattr(r, "attempt_id", None)
        ]

        attempt_map = {
            a.id: a
            for a in ExamAttempt.objects.filter(id__in=attempt_ids)
        }

        for r in results:
            eid = r.enrollment_id
            aid = getattr(r, "attempt_id", None)
            if not aid:
                continue

            a = attempt_map.get(int(aid))
            if not a:
                continue

            if (eid not in latest_map) or (not latest_map[eid].get("submission_id")):
                latest_map[eid] = {
                    "attempt_id": int(a.id),
                    "submission_id": int(a.submission_id),
                }

        # -------------------------------------------------
        # 5ï¸âƒ£ Submission.status ì¡°íšŒ
        # -------------------------------------------------
        submission_ids = [
            v["submission_id"]
            for v in latest_map.values()
            if v.get("submission_id")
        ]

        submission_status_map = {
            s.id: s.status
            for s in Submission.objects.filter(id__in=submission_ids)
        }

        # -------------------------------------------------
        # 6ï¸âƒ£ ìµœì¢… rows êµ¬ì„±
        # -------------------------------------------------
        rows = []

        for r in results:
            enrollment_id = r.enrollment_id
            sp = progress_map.get(enrollment_id)

            sid = None
            if sp is not None:
                sid = getattr(sp, "student_id", None) or getattr(sp, "user_id", None)
            student = student_map.get(int(sid)) if sid else None

            latest = latest_map.get(enrollment_id, {})
            submission_id = latest.get("submission_id")
            submission_status = (
                submission_status_map.get(submission_id)
                if submission_id
                else None
            )

            rows.append({
                "enrollment_id": enrollment_id,
                "student_name": student.name if student else "-",

                # =====================================
                # ğŸ”§ PATCH: ì ìˆ˜ ì˜ë¯¸ ë¶„ë¦¬
                # =====================================
                "exam_score": r.total_score,
                "exam_max_score": r.max_score,

                # ğŸ”¥ í˜„ì¬ëŠ” ë™ì¼í•˜ì§€ë§Œ
                # ì´í›„ session aggregation / ê°€ì¤‘ì¹˜ ê°€ëŠ¥
                "final_score": r.total_score,

                "passed": bool(sp and not getattr(sp, "failed", False)),
                "clinic_required": bool(sp and getattr(sp, "clinic_required", False)),

                "submitted_at": r.submitted_at,

                "submission_id": submission_id,
                "submission_status": submission_status,
            })

        return Response(
            AdminExamResultRowSerializer(rows, many=True).data
        )


==========================================================================================
# FILE: views/admin_exam_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/admin_exam_summary_view.py
"""
Admin / Teacher Exam Summary
"""

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django.db.models import Avg, Min, Max, Count

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import Result
from apps.domains.results.serializers.admin_exam_summary import (
    AdminExamSummarySerializer,
)

from apps.domains.progress.models import ProgressPolicy, SessionProgress
from apps.domains.lectures.models import Session


class AdminExamSummaryView(APIView):
    """
    GET /results/admin/exams/<exam_id>/summary/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        qs = Result.objects.filter(
            target_type="exam",
            target_id=int(exam_id),
        )

        agg = qs.aggregate(
            participant_count=Count("id"),
            avg_score=Avg("total_score"),
            min_score=Min("total_score"),
            max_score=Max("total_score"),
        )

        session = Session.objects.filter(exam__id=exam_id).first()

        policy = (
            ProgressPolicy.objects
            .filter(lecture=session.lecture)
            .first()
            if session else None
        )

        pass_score = policy.exam_pass_score if policy else 0

        pass_count = qs.filter(total_score__gte=pass_score).count()
        fail_count = qs.filter(total_score__lt=pass_score).count()

        participant_count = agg["participant_count"] or 0
        pass_rate = (
            pass_count / participant_count
            if participant_count else 0.0
        )

        clinic_count = (
            SessionProgress.objects
            .filter(session=session, clinic_required=True)
            .count()
            if session else 0
        )

        return Response(
            AdminExamSummarySerializer({
                "participant_count": participant_count,
                "avg_score": float(agg["avg_score"] or 0.0),
                "min_score": float(agg["min_score"] or 0.0),
                "max_score": float(agg["max_score"] or 0.0),
                "pass_count": pass_count,
                "fail_count": fail_count,
                "pass_rate": round(float(pass_rate), 4),
                "clinic_count": clinic_count,
            }).data
        )


==========================================================================================
# FILE: views/admin_representative_attempt_view.py
==========================================================================================
# apps/domains/results/views/admin_representative_attempt_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.models import ExamAttempt, Result


class AdminRepresentativeAttemptView(APIView):
    """
    POST /results/admin/exams/<exam_id>/representative-attempt/

    ìš”ì²­:
    {
      "enrollment_id": 55,
      "attempt_id": 1234
    }

    ë™ì‘:
    1) (exam_id, enrollment_id) ì˜ ëª¨ë“  attempt â†’ is_representative=False
    2) ì§€ì • attempt â†’ is_representative=True
    3) Result.attempt_idë„ í•´ë‹¹ attemptë¡œ ë™ê¸°í™”

    âœ… ìš´ì˜/CS í•„ìˆ˜ API
    - ì¬ì‹œí—˜ ì‹¤íŒ¨
    - ì±„ì  ì˜¤ë¥˜
    - ëŒ€í‘œ ì ìˆ˜ ìˆ˜ë™ êµì²´
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def post(self, request, exam_id: int):
        enrollment_id = request.data.get("enrollment_id")
        attempt_id = request.data.get("attempt_id")

        if not enrollment_id or not attempt_id:
            raise ValidationError("enrollment_id and attempt_id are required")

        exam_id = int(exam_id)
        enrollment_id = int(enrollment_id)
        attempt_id = int(attempt_id)

        # 1ï¸âƒ£ attempt ê²€ì¦
        target = ExamAttempt.objects.filter(
            id=attempt_id,
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        ).first()

        if not target:
            raise ValidationError("attempt not found for this exam/enrollment")

        # 2ï¸âƒ£ ëŒ€í‘œ attempt ì´ˆê¸°í™”
        ExamAttempt.objects.filter(
            exam_id=exam_id,
            enrollment_id=enrollment_id,
        ).update(is_representative=False)

        # 3ï¸âƒ£ ì§€ì • attempt ëŒ€í‘œë¡œ ì„¤ì •
        target.is_representative = True
        target.save(update_fields=["is_representative"])

        # 4ï¸âƒ£ Result ìŠ¤ëƒ…ìƒ·ë„ ë™ê¸°í™”
        Result.objects.filter(
            target_type="exam",
            target_id=exam_id,
            enrollment_id=enrollment_id,
        ).update(attempt_id=attempt_id)

        return Response({
            "ok": True,
            "exam_id": exam_id,
            "enrollment_id": enrollment_id,
            "attempt_id": attempt_id,
        })


==========================================================================================
# FILE: views/exam_attempt_view.py
==========================================================================================
# apps/domains/results/views/exam_attempt_view.py
"""
ExamAttemptViewSet

â— ì¹˜ëª…ì  ë³´ì•ˆ ì´ìŠˆ ìˆ˜ì •:
- ê¸°ì¡´: IsAuthenticated ë§Œ ê±¸ë ¤ì„œ í•™ìƒë„ ì „ì²´ Attempt ì—´ëŒ ê°€ëŠ¥
- ë³€ê²½: Teacher/Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥

í•„ìš”í•˜ë©´ ì¶”í›„:
- í•™ìƒ ë³¸ì¸ attemptë§Œ ì¡°íšŒí•˜ëŠ” ë³„ë„ Viewë¥¼ /me/* ë¡œ ë”°ë¡œ ë§Œë“¤ ê²ƒ
"""

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import ExamAttempt
from apps.domains.results.serializers.exam_attempt import ExamAttemptSerializer
from apps.domains.results.permissions import IsTeacherOrAdmin


class ExamAttemptViewSet(ModelViewSet):
    """
    ì‹œí—˜ ì‹œë„(Attempt) ê´€ë¦¬ API (ê´€ë¦¬ì/êµì‚¬ìš©)
    """

    queryset = ExamAttempt.objects.all().order_by("-created_at")
    serializer_class = ExamAttemptSerializer

    # âœ… ë³´ì•ˆ ìˆ˜ì •
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]


==========================================================================================
# FILE: views/homework_result_view.py
==========================================================================================



==========================================================================================
# FILE: views/question_stats_views.py
==========================================================================================
# apps/domains/results/views/question_stats_views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.question_stats_service import QuestionStatsService
from apps.domains.results.serializers.question_stats import (
    QuestionStatSerializer,
    TopWrongQuestionSerializer,
)


class AdminExamQuestionStatsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/

    âœ… ë‹¨ì¼ ì§„ì‹¤:
    - ResultFact ê¸°ë°˜ (append-only)
    - ëŒ€í‘œ attempt êµì²´/ì¬ì‹œí—˜ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ê´€ëœ í†µê³„
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        data = QuestionStatsService.per_question_stats(
            exam_id=int(exam_id),
        )
        return Response(QuestionStatSerializer(data, many=True).data)


class ExamQuestionWrongDistributionView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/{question_id}/wrong-distribution/
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int, question_id: int):
        dist = QuestionStatsService.wrong_choice_distribution(
            exam_id=int(exam_id),
            question_id=int(question_id),
        )
        return Response(
            {
                "question_id": int(question_id),
                "distribution": dist,
            }
        )


class ExamTopWrongQuestionsView(APIView):
    """
    GET /api/v1/results/admin/exams/{exam_id}/questions/top-wrong/?n=5
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, exam_id: int):
        n = int(request.query_params.get("n", 5))
        data = QuestionStatsService.top_n_wrong_questions(
            exam_id=int(exam_id),
            n=n,
        )
        return Response(TopWrongQuestionSerializer(data, many=True).data)


==========================================================================================
# FILE: views/session_score_summary_view.py
==========================================================================================
# PATH: apps/domains/results/views/session_score_summary_view.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.permissions import IsTeacherOrAdmin
from apps.domains.results.services.session_score_summary_service import (
    SessionScoreSummaryService,
)
from apps.domains.results.serializers.session_score_summary import (
    SessionScoreSummarySerializer,
)


class SessionScoreSummaryView(APIView):
    """
    GET /results/admin/sessions/<session_id>/score-summary/

    âœ… results ë„ë©”ì¸ ê¸°ì¤€
    - Session ë‹¨ìœ„ ì„±ì  í†µê³„
    - ìš´ì˜/ëŒ€ì‹œë³´ë“œ/AI ì¶”ì²œ ì…ë ¥ìš©
    """

    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    def get(self, request, session_id: int):
        data = SessionScoreSummaryService.build(
            session_id=int(session_id)
        )
        return Response(SessionScoreSummarySerializer(data).data)


==========================================================================================
# FILE: views/student_exam_result_view.py
==========================================================================================
# apps/domains/results/views/student_exam_result_view.py
from __future__ import annotations

from django.shortcuts import get_object_or_404

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from apps.domains.results.models import Result, ExamAttempt
from apps.domains.results.serializers.student_exam_result import (
    StudentExamResultSerializer,
)
from apps.domains.results.permissions import IsStudent

from apps.domains.exams.models import Exam
from apps.domains.enrollment.models import Enrollment

# âœ… Progress ì¡°íšŒ (clinic_required ê³„ì‚°ìš©)
from apps.domains.progress.models import SessionProgress
from apps.domains.lectures.models import Session


class MyExamResultView(APIView):
    """
    GET /results/me/exams/<exam_id>/

    âœ… ë‹¨ì¼ ìµœì¢… ë²„ì „ (ì¤‘ë³µ ì œê±° ì™„ë£Œ)

    í¬í•¨ ê¸°ëŠ¥:
    - Result + ResultItem ì¡°íšŒ
    - allow_retake / max_attempts / can_retake ê³„ì‚°
    - clinic_required ì£¼ì…
    - Enrollment íƒìƒ‰ ë°©ì–´ ë¡œì§

    âš ï¸ ì¤‘ìš”:
    - ì´ View ì •ì˜ëŠ” ë°˜ë“œì‹œ 1ê°œë§Œ ì¡´ì¬í•´ì•¼ í•¨
    - ë‹¤ë¥¸ íŒŒì¼ì— ë™ì¼ í´ë˜ìŠ¤ê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚­ì œí•  ê²ƒ
    """

    permission_classes = [IsAuthenticated, IsStudent]

    def get(self, request, exam_id: int):
        user = request.user
        exam = get_object_or_404(Exam, id=int(exam_id))

        # -------------------------------------------------
        # 1ï¸âƒ£ Enrollment ì°¾ê¸° (í”„ë¡œì íŠ¸ë³„ í•„ë“œ ì°¨ì´ ë°©ì–´)
        # -------------------------------------------------
        enrollment_qs = Enrollment.objects.all()

        if hasattr(Enrollment, "user_id"):
            enrollment_qs = enrollment_qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            enrollment_qs = enrollment_qs.filter(student_id=user.id)
        else:
            enrollment_qs = enrollment_qs.filter(user=user)

        enrollment = enrollment_qs.first()
        if not enrollment:
            return Response({"detail": "enrollment not found"}, status=404)

        enrollment_id = int(enrollment.id)

        # -------------------------------------------------
        # 2ï¸âƒ£ Result ì¡°íšŒ (ìµœì‹  ìŠ¤ëƒ…ìƒ·)
        # -------------------------------------------------
        result = (
            Result.objects
            .filter(
                target_type="exam",
                target_id=int(exam_id),
                enrollment_id=enrollment_id,
            )
            .prefetch_related("items")
            .first()
        )

        if not result:
            return Response({"detail": "result not found"}, status=404)

        # -------------------------------------------------
        # 3ï¸âƒ£ ì¬ì‹œí—˜ ë²„íŠ¼ íŒë‹¨ (ëŒ€í‘œ attempt ì˜ì¡´ âŒ)
        # -------------------------------------------------
        allow_retake = bool(getattr(exam, "allow_retake", False))
        max_attempts = int(getattr(exam, "max_attempts", 1) or 1)

        attempt_count = ExamAttempt.objects.filter(
            exam_id=int(exam_id),
            enrollment_id=enrollment_id,
        ).count()

        can_retake = bool(allow_retake and attempt_count < max_attempts)

        # -------------------------------------------------
        # 4ï¸âƒ£ clinic_required ê³„ì‚° (Progress íŒŒì´í”„ë¼ì¸ ê²°ê³¼)
        # -------------------------------------------------
        clinic_required = False
        session = Session.objects.filter(exam__id=exam_id).first()

        if session:
            sp = SessionProgress.objects.filter(
                session=session,
                enrollment_id=enrollment_id,
            ).first()
            clinic_required = bool(sp and getattr(sp, "clinic_required", False))

        # -------------------------------------------------
        # 5ï¸âƒ£ ì‘ë‹µ êµ¬ì„±
        # -------------------------------------------------
        data = StudentExamResultSerializer(result).data
        data["allow_retake"] = allow_retake
        data["max_attempts"] = max_attempts
        data["can_retake"] = can_retake
        data["clinic_required"] = clinic_required

        return Response(data)


==========================================================================================
# FILE: views/wrong_note_pdf_status_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_status_view.py
from __future__ import annotations

from django.core.files.storage import default_storage

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied, NotFound

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models import WrongNotePDF
from apps.domains.results.serializers.wrong_note_pdf_serializers import (
    WrongNotePDFStatusSerializer,
)


class WrongNotePDFStatusView(APIView):
    """
    STEP 3-2: ì˜¤ë‹µë…¸íŠ¸ PDF Job ìƒíƒœ ì¡°íšŒ (polling)

    GET /results/wrong-notes/pdf/<job_id>/

    ğŸ” ë³´ì•ˆ:
    - í•™ìƒ: ë³¸ì¸ enrollment_idì˜ jobë§Œ ì¡°íšŒ ê°€ëŠ¥
    - êµì‚¬/ê´€ë¦¬ì: ì „ì²´ ì¡°íšŒ ê°€ëŠ¥
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this PDF job.")

    def get(self, request, job_id: int):
        job = WrongNotePDF.objects.filter(id=int(job_id)).first()
        if not job:
            raise NotFound("job not found")

        self._assert_enrollment_access(request, int(job.enrollment_id))

        # DONEì´ë©´ ë‹¤ìš´ë¡œë“œ URL ì œê³µ (storageì— ë”°ë¼ url()ì´ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë‹ˆ ë°©ì–´)
        file_url = ""
        if job.file_path:
            try:
                file_url = default_storage.url(job.file_path)
            except Exception:
                file_url = ""

        data = {
            "job_id": int(job.id),
            "status": str(job.status),
            "file_path": str(job.file_path or ""),
            "file_url": str(file_url or ""),
            "error_message": str(job.error_message or ""),
            "created_at": job.created_at,
            "updated_at": job.updated_at,
        }

        return Response(WrongNotePDFStatusSerializer(data).data)


==========================================================================================
# FILE: views/wrong_note_pdf_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_pdf_view.py
from __future__ import annotations

from django.urls import reverse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment
from apps.domains.results.models.wrong_note_pdf import WrongNotePDF


class WrongNotePDFCreateView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ PDF ìƒì„± ìš”ì²­

    âœ… STEP 3-2.5:
    - ì‘ë‹µì— status_url í¬í•¨ (í”„ë¡ íŠ¸ í´ë§ í¸ì˜)

    âœ… STEP 2 (ì¤‘ìš”):
    - View íŒŒì¼ ìƒë‹¨ì—ì„œ Celery task import ê¸ˆì§€
      (URLConf import ì‹œì ì— worker ì˜ì¡´ì„±ê¹Œì§€ ë¡œë”©ë˜ëŠ” ìœ„í—˜ ë°©ì§€)
    - ë”°ë¼ì„œ post() ë‚´ë¶€ì—ì„œë§Œ ì§€ì—° import í•œë‹¤.
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))
        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot create PDF for this enrollment_id.")

    def post(self, request):
        enrollment_id = request.data.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        lecture_id = request.data.get("lecture_id")
        exam_id = request.data.get("exam_id")
        from_order = request.data.get("from_session_order", 2)

        job = WrongNotePDF.objects.create(
            enrollment_id=enrollment_id_i,
            lecture_id=int(lecture_id) if lecture_id else None,
            exam_id=int(exam_id) if exam_id else None,
            from_session_order=int(from_order or 2),
        )

        # --------------------------------------------------
        # âœ… STEP 2: task ì§€ì—° import (ì¤‘ìš”)
        # - URL import ì‹œì ì— worker ìª½ ì˜ì¡´ì„±ì„ ëŒì–´ì˜¤ì§€ ì•ŠìŒ
        # --------------------------------------------------
        from apps.domains.results.tasks.wrong_note_pdf_tasks import (
            generate_wrong_note_pdf_task,
        )

        generate_wrong_note_pdf_task.delay(job.id)

        # âœ… status_url ì œê³µ (ì ˆëŒ€ê²½ë¡œ)
        status_path = reverse("wrong-note-pdf-status", kwargs={"job_id": job.id})
        status_url = request.build_absolute_uri(status_path)

        return Response({
            "job_id": job.id,
            "status": job.status,
            "status_url": status_url,
        })


==========================================================================================
# FILE: views/wrong_note_view.py
==========================================================================================
# apps/domains/results/views/wrong_note_view.py
from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied

from apps.domains.results.permissions import is_teacher_user
from apps.domains.enrollment.models import Enrollment

from apps.domains.results.serializers.wrong_note_serializers import (
    WrongNoteListResponseSerializer,
)
from apps.domains.results.services.wrong_note_service import (
    WrongNoteQuery,
    list_wrong_notes_for_enrollment,
)


class WrongNoteView(APIView):
    """
    ì˜¤ë‹µë…¸íŠ¸ ì¡°íšŒ API

    âœ… STEP 3-3 ê³ ì •:
    - lecture_id/from_session_order í•„í„°ëŠ” Service ë‹¨ì¼ ì§„ì‹¤
    - ViewëŠ” ë³´ì•ˆ + query parsing + serializerë§Œ ë‹´ë‹¹
    """

    permission_classes = [IsAuthenticated]

    def _assert_enrollment_access(self, request, enrollment_id: int) -> None:
        user = request.user

        if is_teacher_user(user):
            return

        qs = Enrollment.objects.filter(id=int(enrollment_id))

        if hasattr(Enrollment, "user_id"):
            qs = qs.filter(user_id=user.id)
        elif hasattr(Enrollment, "student_id"):
            qs = qs.filter(student_id=user.id)

        if not qs.exists():
            raise PermissionDenied("You cannot access this enrollment_id.")

    def get(self, request):
        """
        Query Params
        - enrollment_id (required)
        - exam_id (optional)
        - lecture_id (optional)
        - from_session_order (optional, default=2)
        - offset (optional, default=0)
        - limit (optional, default=50)
        """
        enrollment_id = request.query_params.get("enrollment_id")
        if not enrollment_id:
            return Response({"detail": "enrollment_id is required"}, status=400)

        enrollment_id_i = int(enrollment_id)
        self._assert_enrollment_access(request, enrollment_id_i)

        exam_id = request.query_params.get("exam_id")
        lecture_id = request.query_params.get("lecture_id")
        from_order = int(request.query_params.get("from_session_order", 2))

        offset = int(request.query_params.get("offset", 0))
        limit = int(request.query_params.get("limit", 50))

        q = WrongNoteQuery(
            exam_id=int(exam_id) if exam_id else None,
            lecture_id=int(lecture_id) if lecture_id else None,
            from_session_order=from_order,
            offset=offset,
            limit=limit,
        )

        total, items = list_wrong_notes_for_enrollment(
            enrollment_id=enrollment_id_i,
            q=q,
        )

        next_offset = (offset + limit) if (offset + limit) < total else None
        prev_offset = (offset - limit) if (offset - limit) >= 0 else None

        payload = {
            "count": int(total),
            "next": next_offset,
            "prev": prev_offset,
            "results": items,
        }

        return Response(WrongNoteListResponseSerializer(payload).data)
