====================================================================================================
# BACKEND APP: domains__inventory
# ROOT PATH: C:\academy\apps\domains\inventory
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# apps/domains/inventory — 멀티테넌트 인벤토리(파일 관리)


==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class InventoryConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.inventory"
    verbose_name = "인벤토리"


==========================================================================================
# FILE: models.py
==========================================================================================
# PATH: apps/domains/inventory/models.py
# 멀티테넌트 인벤토리 — 폴더/파일 메타데이터 (실체는 R2)

from django.db import models
from apps.api.common.models import TimestampModel
from apps.core.models import Tenant
from apps.core.db import TenantQuerySet


class InventoryFolder(TimestampModel):
    """인벤토리 폴더 (재귀 구조)."""
    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="inventory_folders",
        db_index=True,
    )
    # admin = 선생님 개인, student = 학생별 (student_ps 사용)
    scope = models.CharField(max_length=20, choices=[("admin", "선생님"), ("student", "학생")], db_index=True)
    student_ps = models.CharField(max_length=20, blank=True, default="", db_index=True)
    parent = models.ForeignKey(
        "self",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="children",
    )
    name = models.CharField(max_length=255)

    class Meta:
        app_label = "inventory"
        ordering = ["name"]


class InventoryFile(TimestampModel):
    """인벤토리 파일 메타데이터 (실체는 R2)."""
    objects = TenantQuerySet.as_manager()

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="inventory_files",
        db_index=True,
    )
    scope = models.CharField(max_length=20, choices=[("admin", "선생님"), ("student", "학생")], db_index=True)
    student_ps = models.CharField(max_length=20, blank=True, default="", db_index=True)
    folder = models.ForeignKey(
        InventoryFolder,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="files",
    )
    display_name = models.CharField(max_length=255)
    description = models.TextField(blank=True, default="")
    icon = models.CharField(max_length=64, blank=True, default="file-text")
    # R2 객체 키 (저장 경로)
    r2_key = models.CharField(max_length=512, unique=True, db_index=True)
    original_name = models.CharField(max_length=255)
    size_bytes = models.BigIntegerField(default=0)
    content_type = models.CharField(max_length=128, default="application/octet-stream")

    class Meta:
        app_label = "inventory"
        ordering = ["-created_at"]


==========================================================================================
# FILE: r2_path.py
==========================================================================================
# PATH: apps/domains/inventory/r2_path.py
# R2 저장 경로 SSOT
# 학생: tenants/{tenant_id}/students/{student_ps}/inventory/{folder_path}/{file_name}
# 선생님: tenants/{tenant_id}/admin/inventory/{folder_path}/{file_name}

import re
import secrets
from datetime import datetime


def safe_filename(original: str) -> str:
    """충돌 방지: 원본명_YYMMDD_해시.확장자"""
    base, ext = "", ""
    if "." in original:
        idx = original.rfind(".")
        base, ext = original[:idx], original[idx:]
    else:
        base = original
    stamp = datetime.now().strftime("%y%m%d")
    hash_s = secrets.token_hex(2)
    return f"{base}_{stamp}_{hash_s}{ext}"


def folder_path_string(folder_names: list[str]) -> str:
    """폴더 이름 리스트 → R2 경로 세그먼트."""
    safe = [re.sub(r"[^\w\s\-.]", "_", n).strip() or "folder" for n in folder_names]
    return "/".join(safe)


def build_r2_key(
    *,
    tenant_id: int,
    scope: str,
    student_ps: str = "",
    folder_path: str = "",
    file_name: str,
) -> str:
    if scope == "student":
        prefix = f"tenants/{tenant_id}/students/{student_ps}/inventory"
    else:
        prefix = f"tenants/{tenant_id}/admin/inventory"
    if folder_path:
        return f"{prefix}/{folder_path}/{file_name}"
    return f"{prefix}/{file_name}"


==========================================================================================
# FILE: services.py
==========================================================================================
# PATH: apps/domains/inventory/services.py
# 이동 로직: R2 Copy → DB 업데이트 → R2 Delete (실패 시 원본 삭제 안 함)

from __future__ import annotations

import json
from django.db import transaction

from .models import InventoryFolder, InventoryFile
from .r2_path import build_r2_key, folder_path_string, safe_filename
from apps.core.models import Tenant
from academy.adapters.db.django import repositories_inventory as inv_repo

try:
    from apps.infrastructure.storage.r2 import (
        copy_object_r2_storage,
        delete_object_r2_storage,
    )
except ImportError:
    copy_object_r2_storage = None
    delete_object_r2_storage = None


def _folder_path_parts(folder: InventoryFolder | None, tenant: Tenant, scope: str, student_ps: str) -> list[str]:
    """폴더부터 루트까지 이름 리스트 (루트가 마지막)."""
    parts = []
    f = folder
    while f:
        parts.append(f.name)
        f = f.parent
    return list(reversed(parts))


def _get_folder_path_str(folder: InventoryFolder | None, tenant: Tenant, scope: str, student_ps: str) -> str:
    return folder_path_string(_folder_path_parts(folder, tenant, scope, student_ps))


def _filename_from_r2_key(r2_key: str) -> str:
    """R2 key에서 마지막 파일명만 추출."""
    return r2_key.split("/")[-1] if r2_key else ""


def _check_duplicate_file(target_folder_id: int | None, tenant: Tenant, scope: str, student_ps: str, display_name: str):
    qs = inv_repo.inventory_file_filter_folder(tenant, scope, target_folder_id)
    if scope == "student":
        qs = qs.filter(student_ps=student_ps)
    return qs.filter(display_name=display_name).first()


def move_file(
    *,
    tenant: Tenant,
    scope: str,
    student_ps: str,
    source_file_id: int,
    target_folder_id: int | None,
    on_duplicate: str | None = None,
) -> dict:
    """
    파일 이동: R2 Copy → DB 업데이트 → R2 Delete.
    실패 시 원본 R2 객체는 삭제하지 않음.
    """
    if not copy_object_r2_storage or not delete_object_r2_storage:
        return {"ok": False, "detail": "R2 storage not configured"}

    source = inv_repo.inventory_file_get_by_id(tenant, source_file_id)
    if not source or source.scope != scope or (scope == "student" and source.student_ps != student_ps):
        return {"ok": False, "detail": "Source file not found", "status": 404}

    target_folder = None
    if target_folder_id:
        target_folder = inv_repo.inventory_folder_get_by_id(tenant, target_folder_id)
        if not target_folder or target_folder.scope != scope or (scope == "student" and target_folder.student_ps != student_ps):
            return {"ok": False, "detail": "Target folder not found", "status": 404}

    if source.folder_id == target_folder_id:
        return {"ok": True, "detail": "Already in target"}

    target_path = _get_folder_path_str(target_folder, tenant, scope, student_ps)
    current_filename = _filename_from_r2_key(source.r2_key)
    display_name = source.display_name

    existing = _check_duplicate_file(target_folder_id, tenant, scope, student_ps, display_name)
    if existing and existing.id != source_file_id:
        if on_duplicate == "overwrite":
            existing_key = existing.r2_key
            existing.delete()
            try:
                delete_object_r2_storage(key=existing_key)
            except Exception:
                pass
        elif on_duplicate == "rename":
            base, ext = "", ""
            if "." in display_name:
                idx = display_name.rfind(".")
                base, ext = display_name[:idx], display_name[idx:]
            else:
                base = display_name
            display_name = f"{base}_복사본{ext}" if ext else f"{base}_복사본"
            current_filename = safe_filename(display_name)
        else:
            return {"ok": False, "status": 409, "code": "duplicate", "existing_name": display_name, "detail": "File with same name exists"}

    new_key = build_r2_key(
        tenant_id=tenant.id,
        scope=scope,
        student_ps=student_ps,
        folder_path=target_path,
        file_name=current_filename,
    )

    old_key = source.r2_key
    try:
        copy_object_r2_storage(source_key=old_key, dest_key=new_key)
    except Exception as e:
        return {"ok": False, "detail": f"R2 copy failed: {e}", "status": 502}

    try:
        with transaction.atomic():
            source.folder_id = target_folder_id
            source.r2_key = new_key
            source.display_name = display_name
            source.save(update_fields=["folder_id", "r2_key", "display_name", "updated_at"])
    except Exception as e:
        return {"ok": False, "detail": f"DB update failed: {e}", "status": 500}

    try:
        delete_object_r2_storage(key=old_key)
    except Exception as e:
        return {"ok": False, "detail": f"R2 delete failed (data updated): {e}", "status": 500}

    return {"ok": True}


def _collect_folder_tree(folder: InventoryFolder, tenant: Tenant, scope: str, student_ps: str):
    """폴더와 그 하위 모든 폴더·파일 수집."""
    folders = [folder]
    files = list(inv_repo.inventory_file_filter_scope_folder(tenant, scope, folder))
    if scope == "student":
        files = [f for f in files if f.student_ps == student_ps]
    for child in inv_repo.inventory_folder_filter_parent(tenant, folder):
        if scope == "student" and child.student_ps != student_ps:
            continue
        sub_f, sub_files = _collect_folder_tree(child, tenant, scope, student_ps)
        folders.extend(sub_f)
        files.extend(sub_files)
    return folders, files


def _file_folder_path(inv_file: InventoryFile, tenant: Tenant, scope: str, student_ps: str) -> str:
    """파일이 속한 폴더의 경로 문자열 (prefix 제외)."""
    return _get_folder_path_str(inv_file.folder, tenant, scope, student_ps)


def _delete_folder_tree_r2_and_db(folder: InventoryFolder, tenant: Tenant, scope: str, student_ps: str) -> None:
    """폴더와 하위 모든 파일·폴더를 R2 및 DB에서 삭제 (이동 시 덮어쓰기용)."""
    for child in inv_repo.inventory_folder_filter_parent(tenant, folder):
        if scope == "student" and child.student_ps != student_ps:
            continue
        _delete_folder_tree_r2_and_db(child, tenant, scope, student_ps)
    files = list(inv_repo.inventory_file_filter_scope_folder(tenant, scope, folder))
    if scope == "student":
        files = [f for f in files if f.student_ps == student_ps]
    for inv_file in files:
        try:
            delete_object_r2_storage(key=inv_file.r2_key)
        except Exception:
            pass
        inv_file.delete()
    folder.delete()


def move_folder(
    *,
    tenant: Tenant,
    scope: str,
    student_ps: str,
    source_folder_id: int,
    target_folder_id: int | None,
    on_duplicate: str | None = None,
) -> dict:
    """
    폴더 이동: 하위 모든 파일에 대해 R2 Copy → DB 업데이트 → R2 Delete.
    폴더 자체의 parent_id 업데이트 포함. 실패 시 원본 삭제 안 함.
    """
    if not copy_object_r2_storage or not delete_object_r2_storage:
        return {"ok": False, "detail": "R2 storage not configured"}

    source_folder = inv_repo.inventory_folder_get_by_id(tenant, source_folder_id)
    if not source_folder or source_folder.scope != scope or (scope == "student" and source_folder.student_ps != student_ps):
        return {"ok": False, "detail": "Source folder not found", "status": 404}

    target_folder = None
    if target_folder_id:
        target_folder = inv_repo.inventory_folder_get_by_id(tenant, target_folder_id)
        if not target_folder or target_folder.scope != scope or (scope == "student" and target_folder.student_ps != student_ps):
            return {"ok": False, "detail": "Target folder not found", "status": 404}
        f = target_folder
        while f:
            if f.id == source_folder_id:
                return {"ok": False, "detail": "Cannot move folder into itself or descendant", "status": 400}
            f = f.parent

    if source_folder.parent_id == target_folder_id:
        return {"ok": True, "detail": "Already in target"}

    q = inv_repo.inventory_folder_filter_parent_id_name(tenant, target_folder_id, source_folder.name)
    if scope == "student":
        q = q.filter(student_ps=student_ps)
    existing_sibling = q.first()
    if existing_sibling and existing_sibling.id != source_folder_id:
        if on_duplicate == "overwrite":
            _delete_folder_tree_r2_and_db(existing_sibling, tenant, scope, student_ps)
        elif on_duplicate == "rename":
            source_folder.name = f"{source_folder.name}_복사본"
            source_folder.save(update_fields=["name", "updated_at"])
        else:
            return {"ok": False, "status": 409, "code": "duplicate", "existing_name": source_folder.name, "detail": "Folder with same name exists"}

    folders, files = _collect_folder_tree(source_folder, tenant, scope, student_ps)
    source_folder_path = _get_folder_path_str(source_folder, tenant, scope, student_ps)
    target_path_str = _get_folder_path_str(target_folder, tenant, scope, student_ps)

    copy_plans = []
    for inv_file in files:
        old_key = inv_file.r2_key
        file_name = _filename_from_r2_key(old_key)
        current_folder_path = _file_folder_path(inv_file, tenant, scope, student_ps)
        if current_folder_path.startswith(source_folder_path):
            rel = current_folder_path[len(source_folder_path):].lstrip("/")
        else:
            rel = ""
        if rel:
            new_folder_path = f"{target_path_str}/{source_folder.name}/{rel}" if target_path_str else f"{source_folder.name}/{rel}"
        else:
            new_folder_path = f"{target_path_str}/{source_folder.name}" if target_path_str else source_folder.name
        new_key = build_r2_key(
            tenant_id=tenant.id,
            scope=scope,
            student_ps=student_ps,
            folder_path=new_folder_path,
            file_name=file_name,
        )
        copy_plans.append((inv_file, old_key, new_key))

    for inv_file, old_key, new_key in copy_plans:
        try:
            copy_object_r2_storage(source_key=old_key, dest_key=new_key)
        except Exception as e:
            return {"ok": False, "detail": f"R2 copy failed: {e}", "status": 502}

    try:
        with transaction.atomic():
            for inv_file, old_key, new_key in copy_plans:
                inv_file.r2_key = new_key
                inv_file.save(update_fields=["r2_key", "updated_at"])
            source_folder.parent = target_folder
            source_folder.save(update_fields=["parent_id", "updated_at"])
    except Exception as e:
        return {"ok": False, "detail": f"DB update failed: {e}", "status": 500}

    for inv_file, old_key, new_key in copy_plans:
        try:
            delete_object_r2_storage(key=old_key)
        except Exception:
            pass

    return {"ok": True}


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/inventory/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path("quota/", views.QuotaView.as_view()),
    path("inventory/", views.InventoryListView.as_view()),
    path("inventory/folders/", views.FolderCreateView.as_view()),
    path("inventory/upload/", views.FileUploadView.as_view()),
    path("inventory/folders/<int:folder_id>/", views.FolderDeleteView.as_view()),
    path("inventory/files/<int:file_id>/", views.FileDeleteView.as_view()),
    path("inventory/presign/", views.PresignView.as_view()),
    path("inventory/move/", views.MoveView.as_view()),
]


==========================================================================================
# FILE: views.py
==========================================================================================
# PATH: apps/domains/inventory/views.py
# 저장소 API — R2 업로드 후 DB 메타데이터, 비어있지 않은 폴더 삭제 방지

from django.http import JsonResponse
from django.views import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.conf import settings

from rest_framework_simplejwt.authentication import JWTAuthentication

from apps.core.models import Program
from .models import InventoryFolder, InventoryFile
from .r2_path import build_r2_key, safe_filename, folder_path_string
from academy.adapters.db.django import repositories_inventory as inv_repo
from .services import move_file as do_move_file, move_folder as do_move_folder

# R2 Storage 버킷 (인벤토리 전용)
try:
    from apps.infrastructure.storage.r2 import (
        upload_fileobj_to_r2_storage,
        generate_presigned_get_url_storage,
        copy_object_r2_storage,
        delete_object_r2_storage,
    )
except ImportError:
    upload_fileobj_to_r2_storage = None
    generate_presigned_get_url_storage = None
    copy_object_r2_storage = None
    delete_object_r2_storage = None

QUOTA_BYTES = {"lite": 0, "basic": 10 * 1024**3, "premium": 200 * 1024**3}


def _tenant_required(view_func):
    def wrapped(request, *args, **kwargs):
        if not getattr(request, "tenant", None):
            return JsonResponse({"detail": "Tenant required"}, status=400)
        return view_func(request, *args, **kwargs)
    return wrapped


def _jwt_required(view_func):
    """JWT 인증 필수. 미인증 시 401 (저장소 API는 로그인 사용자만 허용)."""
    def wrapped(request, *args, **kwargs):
        auth = JWTAuthentication()
        result = auth.authenticate(request)
        if result is None:
            return JsonResponse(
                {"detail": "Authentication required", "code": "auth_required"},
                status=401,
            )
        request.user, request.auth = result[0], result[1]
        return view_func(request, *args, **kwargs)
    return wrapped


class QuotaView(View):
    """GET /storage/quota/ — 테넌트 사용량 및 플랜 한도."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def get(self, request):
        tenant = request.tenant
        try:
            program = Program.ensure_for_tenant(tenant=tenant)
            plan = (program.plan or "basic").lower()
        except Exception:
            plan = "basic"
        try:
            limit = QUOTA_BYTES.get(plan, QUOTA_BYTES["basic"])
            used = inv_repo.inventory_file_aggregate_size(tenant)
            return JsonResponse({
                "usedBytes": used,
                "limitBytes": limit,
                "plan": plan,
            })
        except Exception as e:
            return JsonResponse(
                {"detail": str(e) if settings.DEBUG else "Internal Server Error"},
                status=500,
            )


class InventoryListView(View):
    """GET /storage/inventory/?scope=admin|student&student_ps=... — 폴더/파일 목록 (전체, 클라이언트에서 필터)."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def get(self, request):
        scope = (request.GET.get("scope") or "admin").lower()
        if scope not in ("admin", "student"):
            return JsonResponse({"detail": "Invalid scope"}, status=400)
        student_ps = (request.GET.get("student_ps") or "").strip()
        if scope == "student" and not student_ps:
            return JsonResponse({"detail": "student_ps required for student scope"}, status=400)

        try:
            tenant = request.tenant
            student_ps_arg = student_ps if scope == "student" else None
            qs_folders = inv_repo.inventory_folder_filter(tenant, scope, student_ps_arg)
            qs_files = inv_repo.inventory_file_filter(tenant, scope, student_ps_arg)

            folders = [
                {"id": str(f.id), "name": f.name, "parentId": str(f.parent_id) if f.parent_id else None}
                for f in qs_folders
            ]
            files = [
                {
                    "id": str(f.id),
                    "name": f.original_name,
                    "displayName": f.display_name,
                    "description": f.description or "",
                    "icon": f.icon or "file-text",
                    "folderId": str(f.folder_id) if f.folder_id else None,
                    "sizeBytes": f.size_bytes,
                    "r2Key": f.r2_key,
                    "contentType": f.content_type or "",
                    "createdAt": f.created_at.isoformat() if f.created_at else "",
                }
                for f in qs_files
            ]
            return JsonResponse({"folders": folders, "files": files})
        except Exception as e:
            return JsonResponse(
                {"detail": str(e) if settings.DEBUG else "Internal Server Error"},
                status=500,
            )


class FolderCreateView(View):
    """
    POST /storage/inventory/folders/ — 폴더 생성.

    필수: tenant(요청 host로 해석), name
    선택: scope(기본 admin), student_ps(scope=student일 때 필수), parent_id(숫자 또는 null/빈값=루트)

    404 가능 원인:
    - 미들웨어: 요청 host가 TenantDomain에 없음 (새 테넌트면 해당 host 등록 필요)
    - parent_id에 해당하는 폴더가 해당 테넌트에 없음
    500: create 실패 시 DEBUG면 상세 메시지 반환
    """

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def post(self, request):
        import json
        try:
            body = json.loads(request.body)
        except Exception:
            return JsonResponse({"detail": "Invalid JSON"}, status=400)
        scope = (body.get("scope") or "admin").lower()
        student_ps = (body.get("student_ps") or "").strip()
        parent_id = body.get("parent_id")
        name = (body.get("name") or "").strip()
        if not name:
            return JsonResponse({"detail": "name required"}, status=400)
        if scope == "student" and not student_ps:
            return JsonResponse({"detail": "student_ps required for student scope"}, status=400)

        tenant = request.tenant
        parent = None
        pid = None
        if parent_id is not None and parent_id != "":
            try:
                pid = int(parent_id)
            except (TypeError, ValueError):
                return JsonResponse({"detail": "parent_id must be a number"}, status=400)
            parent = inv_repo.inventory_folder_get(tenant, pid)
            if not parent:
                return JsonResponse({"detail": "Parent folder not found"}, status=404)

        try:
            folder = inv_repo.inventory_folder_create(
                tenant, pid if parent_id not in (None, "") else None, name, scope, student_ps or "",
            )
        except Exception as e:
            return JsonResponse(
                {"detail": str(e) if settings.DEBUG else "Failed to create folder"},
                status=500,
            )
        return JsonResponse({
            "id": str(folder.id),
            "name": folder.name,
            "parentId": str(folder.parent_id) if folder.parent_id else None,
        })


class FileUploadView(View):
    """POST /storage/inventory/upload/ — R2 업로드 후 DB 저장. 플랜 한도 체크."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def post(self, request):
        scope = (request.POST.get("scope") or "admin").lower()
        student_ps = (request.POST.get("student_ps") or "").strip()
        folder_id = request.POST.get("folder_id")
        display_name = (request.POST.get("display_name") or "").strip()
        description = (request.POST.get("description") or "").strip()
        icon = (request.POST.get("icon") or "file-text").strip()
        file_obj = request.FILES.get("file")
        if not file_obj:
            return JsonResponse({"detail": "file required"}, status=400)
        if scope == "student" and not student_ps:
            return JsonResponse({"detail": "student_ps required for student scope"}, status=400)

        tenant = request.tenant
        # Quota
        try:
            program = Program.ensure_for_tenant(tenant=tenant)
            plan = (program.plan or "basic").lower()
        except Exception:
            plan = "basic"
        limit = QUOTA_BYTES.get(plan, QUOTA_BYTES["basic"])
        if plan == "lite":
            return JsonResponse({"detail": "인벤토리 기능을 사용할 수 없는 플랜입니다.", "code": "plan_lite"}, status=403)
        used = inv_repo.inventory_file_aggregate_size(tenant)
        if used + file_obj.size > limit:
            return JsonResponse({"detail": "용량 한도를 초과했습니다. 플랜 업그레이드가 필요합니다.", "code": "quota_exceeded"}, status=403)

        folder = None
        folder_path = ""
        if folder_id:
            folder = inv_repo.inventory_folder_get(tenant, int(folder_id))
            if folder:
                path_parts = []
                p = folder
                while p:
                    path_parts.append(p.name)
                    p = p.parent
                folder_path = folder_path_string(reversed(path_parts))

        safe_name = safe_filename(file_obj.name)
        r2_key = build_r2_key(
            tenant_id=tenant.id,
            scope=scope,
            student_ps=student_ps,
            folder_path=folder_path,
            file_name=safe_name,
        )

        if upload_fileobj_to_r2_storage:
            try:
                upload_fileobj_to_r2_storage(
                    fileobj=file_obj,
                    key=r2_key,
                    content_type=file_obj.content_type or "application/octet-stream",
                )
            except Exception as e:
                return JsonResponse({"detail": f"R2 upload failed: {e}"}, status=502)

        inv_file = inv_repo.inventory_file_create(
            tenant=tenant,
            scope=scope,
            student_ps=student_ps,
            folder=folder,
            display_name=display_name or file_obj.name,
            description=description,
            icon=icon,
            r2_key=r2_key,
            original_name=file_obj.name,
            size_bytes=file_obj.size,
            content_type=file_obj.content_type or "application/octet-stream",
        )
        return JsonResponse({
            "id": str(inv_file.id),
            "name": inv_file.original_name,
            "displayName": inv_file.display_name,
            "description": inv_file.description,
            "icon": inv_file.icon,
            "folderId": str(inv_file.folder_id) if inv_file.folder_id else None,
            "sizeBytes": inv_file.size_bytes,
            "r2Key": inv_file.r2_key,
            "contentType": inv_file.content_type,
            "createdAt": inv_file.created_at.isoformat() if inv_file.created_at else "",
        })


class FolderDeleteView(View):
    """DELETE /storage/inventory/folders/:id/ — 비어있을 때만 삭제."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def delete(self, request, folder_id):
        tenant = request.tenant
        scope = (request.GET.get("scope") or "admin").lower()
        student_ps = (request.GET.get("student_ps") or "").strip()

        folder = inv_repo.inventory_folder_get(tenant, folder_id)
        if not folder:
            return JsonResponse({"detail": "Not found"}, status=404)
        if folder.scope != scope or (scope == "student" and folder.student_ps != student_ps):
            return JsonResponse({"detail": "Forbidden"}, status=403)

        if inv_repo.inventory_folder_has_children(tenant, folder):
            return JsonResponse({"detail": "비어있지 않은 폴더는 지울 수 없습니다. 먼저 하위 파일·폴더를 비우거나 삭제하세요.", "code": "folder_not_empty"}, status=400)
        if inv_repo.inventory_folder_has_files(tenant, folder):
            return JsonResponse({"detail": "비어있지 않은 폴더는 지울 수 없습니다. 먼저 하위 파일·폴더를 비우거나 삭제하세요.", "code": "folder_not_empty"}, status=400)

        folder.delete()
        return JsonResponse({}, status=204)


class FileDeleteView(View):
    """DELETE /storage/inventory/files/:id/ — DB 삭제 후 R2 객체 삭제."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def delete(self, request, file_id):
        tenant = request.tenant
        scope = (request.GET.get("scope") or "admin").lower()
        student_ps = (request.GET.get("student_ps") or "").strip()

        inv_file = inv_repo.inventory_file_get(tenant, file_id)
        if not inv_file:
            return JsonResponse({"detail": "Not found"}, status=404)
        if inv_file.scope != scope or (scope == "student" and inv_file.student_ps != student_ps):
            return JsonResponse({"detail": "Forbidden"}, status=403)

        r2_key = inv_file.r2_key
        inv_file.delete()
        # R2 객체 삭제 (선택: 구현 시 s3.delete_object 호출)
        # if delete_r2_object:
        #     delete_r2_object(r2_key)
        return JsonResponse({}, status=204)


class PresignView(View):
    """POST /storage/inventory/presign/ — R2 presigned GET URL."""

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def post(self, request):
        import json
        try:
            body = json.loads(request.body)
        except Exception:
            return JsonResponse({"detail": "Invalid JSON"}, status=400)
        r2_key = body.get("r2_key")
        expires_in = int(body.get("expires_in") or 3600)
        if not r2_key:
            return JsonResponse({"detail": "r2_key required"}, status=400)
        if not generate_presigned_get_url_storage:
            return JsonResponse({"url": ""}, status=200)
        url = generate_presigned_get_url_storage(key=r2_key, expires_in=expires_in)
        return JsonResponse({"url": url})


class MoveView(View):
    """
    POST /storage/inventory/move/
    Body: { type: "file"|"folder", source_id: str, target_folder_id: str|null, on_duplicate?: "overwrite"|"rename" }
    Copy & Delete 방식: R2 복사 성공 → DB 업데이트 → R2 원본 삭제. 실패 시 원본 삭제 안 함.
    """

    @method_decorator(csrf_exempt)
    @method_decorator(_tenant_required)
    @method_decorator(_jwt_required)
    def post(self, request):
        import json
        try:
            body = json.loads(request.body)
        except Exception:
            return JsonResponse({"detail": "Invalid JSON"}, status=400)
        move_type = (body.get("type") or "file").lower()
        source_id = body.get("source_id")
        target_folder_id = body.get("target_folder_id")
        on_duplicate_raw = body.get("on_duplicate")
        on_duplicate = (on_duplicate_raw.strip().lower() if on_duplicate_raw and str(on_duplicate_raw).strip() else None)
        if move_type not in ("file", "folder") or not source_id:
            return JsonResponse({"detail": "type and source_id required"}, status=400)
        scope = (body.get("scope") or request.GET.get("scope") or "admin").lower()
        student_ps = (body.get("student_ps") or request.GET.get("student_ps") or "").strip()
        if scope == "student" and not student_ps:
            return JsonResponse({"detail": "student_ps required for student scope"}, status=400)

        tenant = request.tenant
        try:
            sid = int(source_id)
        except (TypeError, ValueError):
            return JsonResponse({"detail": "Invalid source_id"}, status=400)
        tid = None
        if target_folder_id is not None and target_folder_id != "":
            try:
                tid = int(target_folder_id)
            except (TypeError, ValueError):
                return JsonResponse({"detail": "Invalid target_folder_id"}, status=400)

        if move_type == "file":
            result = do_move_file(
                tenant=tenant,
                scope=scope,
                student_ps=student_ps,
                source_file_id=sid,
                target_folder_id=tid,
                on_duplicate=on_duplicate,
            )
        else:
            result = do_move_folder(
                tenant=tenant,
                scope=scope,
                student_ps=student_ps,
                source_folder_id=sid,
                target_folder_id=tid,
                on_duplicate=on_duplicate,
            )

        if not result.get("ok"):
            status = result.get("status", 400)
            payload = {"detail": result.get("detail", "Move failed")}
            if result.get("code"):
                payload["code"] = result["code"]
            if result.get("existing_name") is not None:
                payload["existing_name"] = result["existing_name"]
            return JsonResponse(payload, status=status)
        return JsonResponse({"ok": True})


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-15 06:03

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="InventoryFolder",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "scope",
                    models.CharField(
                        choices=[("admin", "선생님"), ("student", "학생")],
                        db_index=True,
                        max_length=20,
                    ),
                ),
                (
                    "student_ps",
                    models.CharField(
                        blank=True, db_index=True, default="", max_length=20
                    ),
                ),
                ("name", models.CharField(max_length=255)),
                (
                    "parent",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="children",
                        to="inventory.inventoryfolder",
                    ),
                ),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="inventory_folders",
                        to="core.tenant",
                    ),
                ),
            ],
            options={
                "ordering": ["name"],
            },
        ),
        migrations.CreateModel(
            name="InventoryFile",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "scope",
                    models.CharField(
                        choices=[("admin", "선생님"), ("student", "학생")],
                        db_index=True,
                        max_length=20,
                    ),
                ),
                (
                    "student_ps",
                    models.CharField(
                        blank=True, db_index=True, default="", max_length=20
                    ),
                ),
                ("display_name", models.CharField(max_length=255)),
                ("description", models.TextField(blank=True, default="")),
                (
                    "icon",
                    models.CharField(blank=True, default="file-text", max_length=64),
                ),
                (
                    "r2_key",
                    models.CharField(db_index=True, max_length=512, unique=True),
                ),
                ("original_name", models.CharField(max_length=255)),
                ("size_bytes", models.BigIntegerField(default=0)),
                (
                    "content_type",
                    models.CharField(
                        default="application/octet-stream", max_length=128
                    ),
                ),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="inventory_files",
                        to="core.tenant",
                    ),
                ),
                (
                    "folder",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="files",
                        to="inventory.inventoryfolder",
                    ),
                ),
            ],
            options={
                "ordering": ["-created_at"],
            },
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================

