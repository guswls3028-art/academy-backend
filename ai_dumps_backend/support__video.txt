====================================================================================================
# BACKEND APP: support__video
# ROOT PATH: C:\academy\apps\support\video
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# services package
#


==========================================================================================
# FILE: admin.py
==========================================================================================
from django.contrib import admin
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


@admin.register(Video)
class VideoAdmin(admin.ModelAdmin):
    list_display = ("id", "title", "session", "order", "duration", "status")
    list_display_links = ("id", "title")
    list_filter = ("status", "session__lecture", "session")
    search_fields = ("title",)
    ordering = ("session", "order")


@admin.register(VideoPermission)
class VideoPermissionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "rule",
        "allow_skip_override",
        "max_speed_override",
        "show_watermark_override",
        "block_seek",
        "block_speed_control",
        "is_override",
    )
    list_display_links = ("id", "video")
    list_filter = ("rule", "video__session__lecture", "block_seek", "block_speed_control")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


@admin.register(VideoProgress)
class VideoProgressAdmin(admin.ModelAdmin):
    list_display = ("id", "video", "enrollment", "progress", "completed", "updated_at")
    list_display_links = ("id", "video")
    list_filter = ("video__session__lecture", "completed")
    search_fields = ("enrollment__student__name",)
    ordering = ("-updated_at",)


@admin.register(VideoPlaybackSession)
class VideoPlaybackSessionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "device_id",
        "status",
        "started_at",
        "ended_at",
    )
    list_filter = ("status", "video__session__lecture", "video")
    search_fields = ("session_id", "device_id", "enrollment__student__name")
    ordering = ("-started_at",)


@admin.register(VideoPlaybackEvent)
class VideoPlaybackEventAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "user_id",
        "event_type",
        "violated",
        "violation_reason",
        "occurred_at",
        "received_at",
    )
    list_filter = ("event_type", "violated", "video__session__lecture")
    search_fields = ("session_id", "enrollment__student__name", "user_id")
    ordering = ("-received_at",)


==========================================================================================
# FILE: drm.py
==========================================================================================
import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


==========================================================================================
# FILE: models.py
==========================================================================================
from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (ÏòÅÏÉÅ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞)
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "ÏóÖÎ°úÎìú ÎåÄÍ∏∞"
        UPLOADED = "UPLOADED", "ÏóÖÎ°úÎìú ÏôÑÎ£å"
        PROCESSING = "PROCESSING", "Ï≤òÎ¶¨Ï§ë"
        READY = "READY", "ÏÇ¨Ïö© Í∞ÄÎä•"
        FAILED = "FAILED", "Ïã§Ìå®"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # Ïç∏ÎÑ§ÏùºÏùÄ WorkerÍ∞Ä ÏÉùÏÑ±
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # Í∏∞Î≥∏ Ïû¨ÏÉù Ï†ïÏ±Ö (ÎπÑÎîîÏò§ Îã®ÏúÑ default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Ï†ïÏ±Ö Î≥ÄÍ≤Ω Ï¶âÏãú Î∞òÏòÅÏùÑ ÏúÑÌïú Î≤ÑÏ†Ñ (token versioning)
    # - Í∏∞Ï°¥ API Í≥ÑÏïΩ Íπ®ÏßÄÏßÄ ÏïäÍ≤å default=1
    # - Ï†ïÏ±Ö/Í∂åÌïú Î≥ÄÍ≤Ω Ïãú Ï¶ùÍ∞ÄÏãúÌÇ§Î©¥, Í∏∞Ï°¥ ÌÜ†ÌÅ∞ Ï¶âÏãú Î¨¥Ìö®Ìôî Í∞ÄÎä•
    # --------------------------------------------------
    policy_version = models.PositiveIntegerField(
        default=1,
        db_index=True,
        help_text="Increment on policy/permission changes to invalidate existing tokens",
    )

    # --------------------------------------------------
    # Worker Ïã§Ìå® ÏÇ¨Ïú† Í∏∞Î°ù
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    # ===============================
    # HLS Output (Worker Í≤∞Í≥º)
    # ===============================
    hls_path = models.CharField(
        max_length=500,
        blank=True,
        help_text="HLS master playlist path (relative to CDN root)",
    )

    # --------------------------------------------------
    # Worker Lease (Îã§Ï§ë ÎÖ∏Îìú Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄÏö©)
    # - Í∏∞Ï°¥ reclaim(updated_at Í∏∞Î∞ò) Íµ¨Ï°∞Î•º Ïú†ÏßÄÌïòÎ©¥ÏÑú,
    #   Ï§ëÏïô ÌÜµÏ†úÏö© lease Ï†ïÎ≥¥Î•º "Ï∂îÍ∞Ä"Î°ú Í∏∞Î°ùÌïúÎã§.
    # - ÏÑúÎ≤Ñ/ÏõåÏª§Í∞Ä ÏÑúÎ°ú ÎÇ¥Î∂Ä Íµ¨ÌòÑ Î™∞ÎùºÎèÑ ÎèôÏûë(Ìó§ÎçîÎßå ÏÇ¨Ïö©).
    # --------------------------------------------------
    processing_started_at = models.DateTimeField(null=True, blank=True)
    leased_until = models.DateTimeField(null=True, blank=True)
    leased_by = models.CharField(max_length=64, blank=True, default="")

    class Meta:
        ordering = ["order", "id"]
        indexes = [
            models.Index(fields=["status", "updated_at"]),
            models.Index(fields=["leased_until", "status"]),
        ]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        return "unknown"


# ========================================================
# Video Permission (ÏàòÍ∞ïÏÉùÎ≥Ñ override + Ï†ëÍ∑º Í∑úÏπô)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "Î¨¥Ï†úÌïú"),
            ("once", "1Ìöå Ï†úÌïú"),
            ("blocked", "Ï†úÌïú"),
        ],
        default="once",
    )

    # ÌïôÏÉùÎ≥Ñ Ï†ïÏ±Ö override (nullÏù¥Î©¥ Video Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # ÏµúÏö∞ÏÑ† Ï∞®Îã® ÌîåÎûòÍ∑∏
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (ÏÑ∏ÏÖò / Í∞êÏÇ¨)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "ÌôúÏÑ±"
        ENDED = "ENDED", "Ï¢ÖÎ£å"
        REVOKED = "REVOKED", "Ï∞®Îã®"
        EXPIRED = "EXPIRED", "ÎßåÎ£å"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]
        indexes = [
            models.Index(fields=["status", "started_at"]),
            models.Index(fields=["video", "enrollment", "status"]),
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "ÌÉ≠ Ïà®ÍπÄ"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "ÌÉ≠ ÎÖ∏Ï∂ú"
        FOCUS_LOST = "FOCUS_LOST", "Ìè¨Ïª§Ïä§ Ïù¥ÌÉà"
        FOCUS_GAINED = "FOCUS_GAINED", "Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "ÌÉêÏÉâ ÏãúÎèÑ"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "Î∞∞ÏÜç Î≥ÄÍ≤Ω ÏãúÎèÑ"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "Ï†ÑÏ≤¥ÌôîÎ©¥ ÏßÑÏûÖ"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "Ï†ÑÏ≤¥ÌôîÎ©¥ Ï¢ÖÎ£å"
        PLAYER_ERROR = "PLAYER_ERROR", "ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•ò"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


==========================================================================================
# FILE: policy.py
==========================================================================================
from __future__ import annotations

from typing import Dict, Tuple, Optional


def evaluate_event_violation(
    *,
    event_type: str,
    policy: Dict,
    payload: Dict,
) -> Tuple[bool, Optional[str]]:
    """
    ÏÑúÎ≤Ñ Í∏∞Ï§Ä Ï†ïÏ±Ö ÏúÑÎ∞ò ÌåêÏ†ï (ÌîÑÎ°†Ìä∏ ÌòëÏ°∞ ÏóÜÏù¥)
    """
    if not policy:
        return False, None

    if event_type == "seek":
        if not policy.get("allow_skip", False):
            return True, "seek_not_allowed"

    if event_type == "speed":
        max_speed = policy.get("max_speed", 1.0)
        speed = float(payload.get("speed", 1.0))
        if speed > max_speed:
            return True, f"speed_exceeded:{speed}>{max_speed}"

    return False, None


def violation_should_revoke(*, violated_count: int, total: int) -> bool:
    """
    ÏúÑÎ∞ò ÎàÑÏ†Å Í∏∞Ï§Ä (Î≥¥ÏàòÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï)
    """
    if violated_count >= 3:
        return True
    if total > 0 and (violated_count / total) >= 0.5:
        return True
    return False


==========================================================================================
# FILE: serializers.py
==========================================================================================
# PATH: apps/support/video/serializers.py

from django.conf import settings
from rest_framework import serializers

from apps.domains.lectures.models import Session
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)

# ========================================================
# Video
# ========================================================

class VideoSerializer(serializers.ModelSerializer):
    """
    ‚úÖ FINAL SEALED VERSION (SaaS production)

    - DB Ï†ÄÏû• ÌïÑÎìúÏôÄ API ÎÖ∏Ï∂ú ÌïÑÎìú Î∂ÑÎ¶¨
    - CDN Í∏∞Î∞ò URL ÎèôÏ†Å ÏÉùÏÑ±
    - Cache-busting ÏßÄÏõê
    - Legacy Í≤ΩÎ°ú normalize
    """

    # write
    session = serializers.PrimaryKeyRelatedField(
        queryset=Session.objects.all(),
        write_only=True,
    )

    # read
    session_id = serializers.IntegerField(
        source="session.id",
        read_only=True,
    )

    source_type = serializers.SerializerMethodField()

    # CDN derived
    thumbnail_url = serializers.SerializerMethodField()
    hls_url = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session",
            "session_id",
            "title",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "thumbnail",
            "thumbnail_url",
            "hls_path",
            "hls_url",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = [
            "id",
            "session_id",
            "created_at",
            "updated_at",
            "thumbnail",
            "hls_path",
            "thumbnail_url",
            "hls_url",
        ]
        ref_name = "SealedVideo"

    # ---------------------------
    # helpers
    # ---------------------------

    def get_source_type(self, obj):
        return "s3" if obj.file_key else "unknown"

    def _cdn_base(self) -> str | None:
        base = getattr(settings, "CDN_HLS_BASE_URL", None)
        return base.rstrip("/") if base else None

    def _normalize_media_path(self, path: str) -> str:
        path = path.lstrip("/")

        if path.startswith("media/"):
            return path

        if path.startswith("storage/media/"):
            return path[len("storage/"):]

        return path

    def _cache_version(self, obj) -> int:
        try:
            return int(obj.updated_at.timestamp())
        except Exception:
            return 0

    # ---------------------------
    # CDN fields
    # ---------------------------

    def get_thumbnail_url(self, obj):
        cdn = self._cdn_base()
        if not cdn:
            return None

        # 1Ô∏è‚É£ explicit thumbnail
        if obj.thumbnail:
            path = self._normalize_media_path(obj.thumbnail.name)
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        # 2Ô∏è‚É£ READY fallback
        if obj.status == obj.Status.READY:
            path = self._normalize_media_path(
                f"media/hls/videos/{obj.id}/thumbnail.jpg"
            )
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        return None

    def get_hls_url(self, obj):
        if not obj.hls_path:
            return None

        cdn = self._cdn_base()
        if not cdn:
            return None

        path = self._normalize_media_path(str(obj.hls_path))
        return f"{cdn}/{path}?v={self._cache_version(obj)}"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "SealedVideoDetail"


# ========================================================
# Permission / Progress
# ========================================================

class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "SealedVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    # ‚úÖ ÏßÑÌñâÎ•† % (ÌîÑÎ°†Ìä∏ ÌëúÏãúÏö©)
    progress_percent = serializers.SerializerMethodField()

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "SealedVideoProgress"

    def get_progress_percent(self, obj):
        try:
            return round(float(obj.progress or 0) * 100, 1)
        except Exception:
            return 0.0


# ========================================================
# Playback API
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


# ========================================================
# Events
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(
        choices=VideoPlaybackEvent.EventType.choices
    )
    occurred_at = serializers.IntegerField(required=False)
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


# ========================================================
# Event List (Admin Analytics)
# ========================================================

class VideoPlaybackEventListSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )
    enrollment_id = serializers.IntegerField(
        source="enrollment.id",
        read_only=True,
    )

    severity = serializers.SerializerMethodField()
    score = serializers.SerializerMethodField()

    class Meta:
        model = VideoPlaybackEvent
        fields = [
            "id",
            "video",
            "enrollment_id",
            "student_name",
            "session_id",
            "user_id",
            "event_type",
            "violated",
            "violation_reason",
            "event_payload",
            "policy_snapshot",
            "occurred_at",
            "received_at",
            "severity",
            "score",
        ]
        ref_name = "SealedVideoPlaybackEventList"

    # ---------------------------
    # Risk classification
    # ---------------------------

    def get_severity(self, obj):
        base = {
            "SEEK_ATTEMPT": "warn",
            "SPEED_CHANGE_ATTEMPT": "warn",
            "FOCUS_LOST": "warn",
            "VISIBILITY_HIDDEN": "info",
            "PLAYER_ERROR": "info",
        }.get(obj.event_type, "info")

        return "danger" if obj.violated else base

    def get_score(self, obj):
        weights = {
            "VISIBILITY_HIDDEN": 1,
            "FOCUS_LOST": 2,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "PLAYER_ERROR": 1,
        }

        w = int(weights.get(obj.event_type, 1))

        if obj.violated:
            w *= 2
        if obj.violation_reason:
            w += 1

        return w


# ========================================================
# Aggregated Risk Row
# ========================================================

class VideoRiskRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    score = serializers.IntegerField()
    danger = serializers.IntegerField()
    warn = serializers.IntegerField()
    info = serializers.IntegerField()
    last_occurred_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/support/video/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
    VideoPlaybackEventViewSet,
    VideoProcessingCompleteView,
    VideoPolicyImpactAPIView,
)

from .views.achievement_views import VideoAchievementView
from .views.playback_views import (
    PlaybackStartView,
    PlaybackRefreshView,
    PlaybackHeartbeatView,
    PlaybackEndView,
    PlaybackEventBatchView,
)

# ========================================================
# Router
# ========================================================

router = DefaultRouter()
router.register(r"videos", VideoViewSet, basename="videos")
router.register(r"video-permissions", VideoPermissionViewSet, basename="video-permissions")
router.register(r"video-progress", VideoProgressViewSet, basename="video-progress")
router.register(r"video-playback-events", VideoPlaybackEventViewSet, basename="video-playback-events")

# ========================================================
# urlpatterns (ÏÑ†Ïñ∏ Î®ºÏ†Ä!)
# ========================================================

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / Extra APIs
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="video-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="video-video-stats-nested",
    ),
    path(
        "videos/<int:video_id>/achievement/",
        VideoAchievementView.as_view(),
        name="video-video-achievement",
    ),
]

# ========================================================
# Playback APIs (Student)
# ========================================================

urlpatterns += [
    path("playback/start/", PlaybackStartView.as_view()),
    path("playback/refresh/", PlaybackRefreshView.as_view()),
    path("playback/heartbeat/", PlaybackHeartbeatView.as_view()),
    path("playback/end/", PlaybackEndView.as_view()),
    path("playback/events/", PlaybackEventBatchView.as_view()),
]

# ========================================================
# Internal (Legacy ACK - kept)
# ========================================================

urlpatterns += [
    path(
        "internal/videos/<int:video_id>/processing-complete/",
        VideoProcessingCompleteView.as_view(),
        name="video-video-processing-complete",
    ),
]

# ========================================================
# Policy Impact (Admin preview)
# ========================================================

urlpatterns += [
    path(
        "videos/<int:video_id>/policy-impact/",
        VideoPolicyImpactAPIView.as_view(),
        name="video-video-policy-impact",
    ),
]


==========================================================================================
# FILE: urls_internal.py
==========================================================================================
# PATH: apps/support/video/urls_internal.py

from __future__ import annotations

from django.urls import path

from apps.support.video.views.internal_video_worker import (
    VideoWorkerClaimNextView,
    VideoWorkerCompleteView,
    VideoWorkerFailView,
)

from apps.support.video.views.internal_video_worker_heartbeat import (
    InternalVideoWorkerHeartbeatView,
)

urlpatterns = [
    # --------------------------------------------------
    # Worker job control
    # --------------------------------------------------
    path(
        "video-worker/next/",
        VideoWorkerClaimNextView.as_view(),
        name="video_worker_next",
    ),
    path(
        "video-worker/<int:video_id>/complete/",
        VideoWorkerCompleteView.as_view(),
        name="video_worker_complete",
    ),
    path(
        "video-worker/<int:video_id>/fail/",
        VideoWorkerFailView.as_view(),
        name="video_worker_fail",
    ),

    # --------------------------------------------------
    # Worker heartbeat (long-running protection)
    # --------------------------------------------------
    path(
        "video-worker/<int:video_id>/heartbeat/",
        InternalVideoWorkerHeartbeatView.as_view(),
        name="internal-video-worker-heartbeat",
    ),
]


==========================================================================================
# FILE: utils.py
==========================================================================================
# PATH: apps/support/video/utils.py

def extract_duration_seconds_from_url(url: str) -> int | None:
    """
    ffprobeÎ•º URLÏóê ÏßÅÏ†ë Ï†ÅÏö© (Range Request Í∏∞Î∞ò)

    ‚ö†Ô∏è API ÏÑúÎ≤Ñ ÏïàÏ†ÑÌôî:
    - ffmpeg Î™®Îìà ÏóÜÏúºÎ©¥ None Î∞òÌôò
    - API ÌÅ¨ÎûòÏãú Ï†àÎåÄ Î∞úÏÉù ‚ùå
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        probe = ffmpeg.probe(url)
        fmt = probe.get("format") or {}
        dur = fmt.get("duration")
        if dur is None:
            return None
        return int(float(dur))
    except Exception:
        return None


def generate_thumbnail_from_url(
    url: str,
    ss_seconds: int = 1,
) -> bytes | None:
    """
    URL Ïä§Ìä∏Î¶¨Î∞ç Í∏∞Î∞ò Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±

    üö´ API ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏÇ¨Ïö© Í∏àÏßÄ
    ‚úîÔ∏è Worker Ï†ÑÏö©

    - Ïã§Ìå® Ïãú None Î∞òÌôò
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        out, _ = (
            ffmpeg
            .input(url, ss=ss_seconds)
            .output(
                "pipe:",
                vframes=1,
                format="image2",
                vcodec="mjpeg",
            )
            .run(capture_stdout=True, capture_stderr=True)
        )
        return out
    except Exception:
        return None


==========================================================================================
# FILE: cdn/__init__.py
==========================================================================================
# CDN helpers package


==========================================================================================
# FILE: cdn/cloudflare_signing.py
==========================================================================================
# PATH: apps/support/video/cdn/cloudflare_signing.py

from __future__ import annotations

import base64
import hmac
import hashlib
from dataclasses import dataclass
from typing import Dict, Optional
from urllib.parse import urlencode


def _b64url(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).decode("ascii").rstrip("=")


@dataclass(frozen=True)
class CloudflareSignedURL:
    """
    CDN Edge(Cloudflare Worker Îì±)ÏóêÏÑú Í≤ÄÏ¶ù Í∞ÄÎä•Ìïú ÏøºÎ¶¨ ÏÑúÎ™Ö ÏÉùÏÑ±.
    - sig = HMAC-SHA256(secret, f"{path}|{exp}|{kid}|{uid}")
    - ÏøºÎ¶¨: exp, sig, kid, uid(ÏòµÏÖò)

    Ï£ºÏùò:
    - Î∞±ÏóîÎìúÎäî "ÏÉùÏÑ±"Îßå Îã¥Îãπ
    - Í≤ÄÏ¶ù/Ï∞®Îã®ÏùÄ CDN Î†àÏù¥Ïñ¥ÏóêÏÑú ÏàòÌñâ
    """
    secret: str
    key_id: str = "v1"

    def sign(self, *, path: str, expires_at: int, user_id: Optional[int] = None) -> Dict[str, str]:
        p = path if path.startswith("/") else f"/{path}"
        uid = "" if user_id is None else str(int(user_id))

        msg = f"{p}|{int(expires_at)}|{self.key_id}|{uid}".encode("utf-8")
        mac = hmac.new(self.secret.encode("utf-8"), msg, hashlib.sha256).digest()

        params = {
            "exp": str(int(expires_at)),
            "sig": _b64url(mac),
            "kid": self.key_id,
        }
        if user_id is not None:
            params["uid"] = str(int(user_id))
        return params

    def build_url(
        self,
        *,
        cdn_base: str,
        path: str,
        expires_at: int,
        user_id: Optional[int] = None,
        extra_query: Optional[Dict[str, str]] = None,
    ) -> str:
        base = (cdn_base or "").rstrip("/")
        p = path if path.startswith("/") else f"/{path}"

        q = {}
        if extra_query:
            q.update({k: str(v) for k, v in extra_query.items()})

        q.update(self.sign(path=p, expires_at=expires_at, user_id=user_id))
        return f"{base}{p}?{urlencode(q)}"


==========================================================================================
# FILE: cdn/cloudfront.py
==========================================================================================
# apps/support/video/cdn/cloudfront.py
# ‚ùó CloudFront DEPRECATED
# ‚ùó Cloudflare CDN ÏÇ¨Ïö©
# ‚ùó Signed Cookie / RSA / hazmat Ï†ÑÎ∂Ä ÎπÑÌôúÏÑ±Ìôî

from typing import Dict


def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    Cloudflare CDN ÏÇ¨Ïö©
    - Signed Cookie ÏÇ¨Ïö© Ïïà Ìï®
    - Ìï≠ÏÉÅ Îπà dict Î∞òÌôò
    """
    return {}


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    Cloudflare CDN ÏÇ¨Ïö©
    - Ïø†ÌÇ§ ÏÑ§Ï†ï Ïïà Ìï®
    """
    return {}


==========================================================================================
# FILE: management/commands/reconcile_playback_sessions.py
==========================================================================================
# PATH: apps/support/video/management/commands/reconcile_playback_sessions.py

from django.core.management.base import BaseCommand
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.support.video.models import VideoPlaybackSession


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_user_revoked(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:revoked"


class Command(BaseCommand):
    help = "Reconcile VideoPlaybackSession DB state with Redis (EXPIRED/REVOKED)"

    def handle(self, *args, **options):
        now = timezone.now()

        qs = VideoPlaybackSession.objects.filter(
            status=VideoPlaybackSession.Status.ACTIVE
        ).select_related("enrollment", "enrollment__student")

        expired = 0
        revoked = 0

        for s in qs.iterator():
            user_id = s.enrollment.student_id
            session_id = s.session_id

            # revoked wins
            if redis_client.sismember(_key_user_revoked(user_id), session_id):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=now,
                )
                revoked += 1
                continue

            # expired if missing in zset or score <= now
            score = redis_client.zscore(_key_user_sessions(user_id), session_id)
            if score is None or int(score) <= int(now.timestamp()):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.EXPIRED,
                    ended_at=now,
                )
                expired += 1

        self.stdout.write(
            self.style.SUCCESS(
                f"reconcile done expired={expired} revoked={revoked}"
            )
        )


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-30 21:56

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("enrollment", "0001_initial"),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.CreateModel(
            name="Video",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                (
                    "file_key",
                    models.CharField(
                        blank=True,
                        help_text="S3 object key (presigned upload)",
                        max_length=500,
                    ),
                ),
                ("duration", models.PositiveIntegerField(blank=True, null=True)),
                ("order", models.PositiveIntegerField(default=1)),
                (
                    "thumbnail",
                    models.ImageField(blank=True, null=True, upload_to="thumbnails/"),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "ÏóÖÎ°úÎìú ÎåÄÍ∏∞"),
                            ("UPLOADED", "ÏóÖÎ°úÎìú ÏôÑÎ£å"),
                            ("PROCESSING", "Ï≤òÎ¶¨Ï§ë"),
                            ("READY", "ÏÇ¨Ïö© Í∞ÄÎä•"),
                            ("FAILED", "Ïã§Ìå®"),
                        ],
                        db_index=True,
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("allow_skip", models.BooleanField(default=False)),
                ("max_speed", models.FloatField(default=1.0)),
                ("show_watermark", models.BooleanField(default=True)),
                (
                    "policy_version",
                    models.PositiveIntegerField(
                        db_index=True,
                        default=1,
                        help_text="Increment on policy/permission changes to invalidate existing tokens",
                    ),
                ),
                ("error_reason", models.TextField(blank=True, default="", null=True)),
                (
                    "hls_path",
                    models.CharField(
                        blank=True,
                        help_text="HLS master playlist path (relative to CDN root)",
                        max_length=500,
                    ),
                ),
                ("processing_started_at", models.DateTimeField(blank=True, null=True)),
                ("leased_until", models.DateTimeField(blank=True, null=True)),
                ("leased_by", models.CharField(blank=True, default="", max_length=64)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="videos",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["order", "id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPermission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rule",
                    models.CharField(
                        choices=[
                            ("free", "Î¨¥Ï†úÌïú"),
                            ("once", "1Ìöå Ï†úÌïú"),
                            ("blocked", "Ï†úÌïú"),
                        ],
                        default="once",
                        max_length=20,
                    ),
                ),
                ("allow_skip_override", models.BooleanField(blank=True, null=True)),
                ("max_speed_override", models.FloatField(blank=True, null=True)),
                ("show_watermark_override", models.BooleanField(blank=True, null=True)),
                ("block_speed_control", models.BooleanField(default=False)),
                ("block_seek", models.BooleanField(default=False)),
                ("is_override", models.BooleanField(default=False)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_permissions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="permissions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoPlaybackEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("user_id", models.BigIntegerField(db_index=True)),
                (
                    "event_type",
                    models.CharField(
                        choices=[
                            ("VISIBILITY_HIDDEN", "ÌÉ≠ Ïà®ÍπÄ"),
                            ("VISIBILITY_VISIBLE", "ÌÉ≠ ÎÖ∏Ï∂ú"),
                            ("FOCUS_LOST", "Ìè¨Ïª§Ïä§ Ïù¥ÌÉà"),
                            ("FOCUS_GAINED", "Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä"),
                            ("SEEK_ATTEMPT", "ÌÉêÏÉâ ÏãúÎèÑ"),
                            ("SPEED_CHANGE_ATTEMPT", "Î∞∞ÏÜç Î≥ÄÍ≤Ω ÏãúÎèÑ"),
                            ("FULLSCREEN_ENTER", "Ï†ÑÏ≤¥ÌôîÎ©¥ ÏßÑÏûÖ"),
                            ("FULLSCREEN_EXIT", "Ï†ÑÏ≤¥ÌôîÎ©¥ Ï¢ÖÎ£å"),
                            ("PLAYER_ERROR", "ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•ò"),
                        ],
                        db_index=True,
                        max_length=32,
                    ),
                ),
                ("event_payload", models.JSONField(blank=True, default=dict)),
                ("policy_snapshot", models.JSONField(blank=True, default=dict)),
                ("violated", models.BooleanField(db_index=True, default=False)),
                (
                    "violation_reason",
                    models.CharField(blank=True, default="", max_length=64),
                ),
                (
                    "occurred_at",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                ("received_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_playback_events",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_events",
                        to="video.video",
                    ),
                ),
            ],
            options={
                "ordering": ["-received_at", "-id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackSession",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("device_id", models.CharField(db_index=True, max_length=128)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "ÌôúÏÑ±"),
                            ("ENDED", "Ï¢ÖÎ£å"),
                            ("REVOKED", "Ï∞®Îã®"),
                            ("EXPIRED", "ÎßåÎ£å"),
                        ],
                        db_index=True,
                        default="ACTIVE",
                        max_length=16,
                    ),
                ),
                ("started_at", models.DateTimeField(auto_now_add=True)),
                ("ended_at", models.DateTimeField(blank=True, null=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoProgress",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("progress", models.FloatField(default=0)),
                ("last_position", models.IntegerField(default=0)),
                ("completed", models.BooleanField(default=False)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_progress",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="progresses",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["status", "updated_at"], name="video_video_status_782ba3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["leased_until", "status"], name="video_video_leased__a8f039_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="videopermission",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_permission"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["video", "enrollment", "session_id"],
                name="video_video_video_i_1ea099_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["user_id", "session_id"], name="video_video_user_id_474fa3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["event_type", "received_at"],
                name="video_video_event_t_b8ca86_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["status", "started_at"], name="video_video_status_175f42_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["video", "enrollment", "status"],
                name="video_video_video_i_5d0bbd_idx",
            ),
        ),
        migrations.AddConstraint(
            model_name="videoplaybacksession",
            constraint=models.UniqueConstraint(
                fields=("session_id",), name="uniq_video_playback_session_id"
            ),
        ),
        migrations.AddConstraint(
            model_name="videoprogress",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_progress"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/playback_session.py
==========================================================================================
# PATH: apps/support/video/services/playback_session.py

import time
import uuid
from typing import Dict, Any, Tuple, Iterable, Optional

from django.conf import settings
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.domains.enrollment.models import Enrollment
from apps.support.video.models import (
    Video,
    VideoPlaybackSession,
)

# =======================================================
# Redis Key Helpers
# =======================================================

def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    # zset (session_id -> expires_at)
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_session(session_id: str) -> str:
    # hash
    return f"media:playback:session:{session_id}"


def _key_user_devices(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:devices"


def _key_user_revoked(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:revoked"


# ‚úÖ Î¨∏Ï†ú 1/7: ÏÑ∏ÏÖò Îã®ÏúÑ ÏúÑÎ∞ò ÎàÑÏ†Å Ïπ¥Ïö¥ÌÑ∞
def _key_session_violation(session_id: str) -> str:
    # hash: { violated, total, last_reason }
    return f"media:playback:session:{session_id}:violation"


# =======================================================
# Decode Helpers (bytes/str Î∞©Ïñ¥)
# =======================================================

def _decode(value):
    if value is None:
        return None
    if isinstance(value, (bytes, bytearray)):
        return value.decode()
    return value


def _decode_set(values: Iterable) -> set[str]:
    return {_decode(v) for v in (values or set())}


# =======================================================
# Internal Helpers
# =======================================================

def _cleanup_expired_sessions(user_id: int) -> None:
    """
    ÎßåÎ£åÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨
    - session zset
    - session hash
    - device set (ÎàÑÏàò Î∞©ÏßÄ)
    """
    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expired = redis_client.zrangebyscore(sessions_key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)

    for raw_sid in expired:
        sid = _decode(raw_sid)

        device_id = _decode(redis_client.hget(_key_session(sid), "device_id"))
        if device_id:
            pipe.srem(devices_key, device_id)

        pipe.zrem(sessions_key, sid)
        pipe.delete(_key_session(sid))

        # violation hashÎèÑ Í∞ôÏù¥ Ï†úÍ±∞(ÎàÑÏàò Î∞©ÏßÄ)
        pipe.delete(_key_session_violation(sid))

    pipe.execute()


def _session_ttl_seconds_from_expires_at(expires_at: int) -> int:
    now = _now()
    ttl = max(0, int(expires_at) - now)
    # Î≥¥Ìò∏: ÎÑàÎ¨¥ ÏßßÏúºÎ©¥ ÏµúÏÜå 30s
    return max(30, ttl)


# =======================================================
# Core Session APIs (Redis / Infra)
# =======================================================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    """
    Redis Í∏∞Î∞ò Ïû¨ÏÉù ÏÑ∏ÏÖò Î∞úÍ∏â (Í≥µÌÜµ Infra)
    """
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = _decode_set(redis_client.smembers(devices_key))

    # Í∏∞Í∏∞ Ï†úÌïú
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    # ÎèôÏãú ÏÑ∏ÏÖò Ï†úÌïú
    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)

    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(
        _key_session(session_id),
        mapping={
            "user_id": str(user_id),
            "device_id": device_id,
            "expires_at": str(expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)

    # violation state init
    pipe.hset(
        _key_session_violation(session_id),
        mapping={
            "violated": "0",
            "total": "0",
            "last_reason": "",
        },
    )
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    """
    ÏÑ∏ÏÖò TTL Ïó∞Ïû•
    - user_id ÏÜåÏú† Í≤ÄÏ¶ù Ìè¨Ìï®
    - revokedÎ©¥ False
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sid_key = _key_session(session_id)
    sessions_key = _key_user_sessions(user_id)

    owner = _decode(redis_client.hget(sid_key, "user_id"))
    if not owner or int(owner) != int(user_id):
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(
        sid_key,
        mapping={
            "expires_at": str(new_expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)

    # violation ttlÎèÑ Ìï®Íªò Ïó∞Ïû•
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True


def end_session(*, user_id: int, session_id: str) -> None:
    """
    Î™ÖÏãúÏ†Å ÏÑ∏ÏÖò Ï¢ÖÎ£å
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    pipe.execute()


def revoke_session(*, user_id: int, session_id: str) -> None:
    """
    ‚úÖ Î¨∏Ï†ú 1: ÏÑúÎ≤Ñ Í∞ïÏ†ú Ï∞®Îã®
    - revoked setÏóê Í∏∞Î°ù(Ïû¨ÏÇ¨Ïö© Î∞©ÏßÄ)
    - ÏÑ∏ÏÖò ÏûêÎ£å Ï¶âÏãú Ï†úÍ±∞
    - violation hash Ï†úÍ±∞(ÎàÑÏàò Î∞©ÏßÄ)
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.sadd(_key_user_revoked(user_id), session_id)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    # revoked set ÎàÑÏàò Î∞©ÏßÄ: TTL (ÏÑ∏ÏÖò TTL Ïïå Ïàò ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ 1h)
    try:
        pipe.expire(_key_user_revoked(user_id), int(getattr(settings, "VIDEO_REVOKED_SET_TTL_SECONDS", 3600)))
    except Exception:
        pass

    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    ÏÑ∏ÏÖò ÌôúÏÑ± Ïó¨Î∂Ä ÌôïÏù∏
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    return int(score) > _now()


# =======================================================
# ‚úÖ Î¨∏Ï†ú 1/7: ÏÑ∏ÏÖò Îã®ÏúÑ ÏúÑÎ∞ò ÎàÑÏ†Å(Ïö∞Ìöå Î∂àÍ∞Ä)
# =======================================================

def record_session_event(
    *,
    user_id: int,
    session_id: str,
    violated: bool,
    reason: str = "",
) -> Dict[str, int]:
    """
    ÏÑ∏ÏÖò Îã®ÏúÑ ÎàÑÏ†Å Ïπ¥Ïö¥ÌÑ∞:
    - total +1
    - violatedÏù¥Î©¥ violated +1
    - TTLÏùÄ ÏÑ∏ÏÖò expires_at Í∏∞Î∞òÏúºÎ°ú ÎèôÍ∏∞Ìôî
    """
    session_id = _decode(session_id)

    # ÏÑ∏ÏÖò expires_at ÏùΩÍ∏∞(ÏóÜÏúºÎ©¥ default TTL ÏÇ¨Ïö©)
    expires_at_raw = _decode(redis_client.hget(_key_session(session_id), "expires_at"))
    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
    if expires_at_raw:
        try:
            ttl = _session_ttl_seconds_from_expires_at(int(expires_at_raw))
        except Exception:
            ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    key = _key_session_violation(session_id)

    pipe = redis_client.pipeline(transaction=True)
    pipe.hincrby(key, "total", 1)
    if violated:
        pipe.hincrby(key, "violated", 1)
        if reason:
            pipe.hset(key, "last_reason", str(reason)[:200])
    pipe.expire(key, ttl + 60)
    res = pipe.execute()

    # res[0]=total, res[1]=violated or total, etc ‚Üí ÏïàÏ†Ñ ÌååÏã±
    total = 0
    violated_cnt = 0
    try:
        # total always first
        total = int(res[0] or 0)
        # if violated, second is violated; else second is expire result
        if violated:
            violated_cnt = int(res[1] or 0)
        else:
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
    except Exception:
        # fallback fetch
        try:
            total = int(_decode(redis_client.hget(key, "total")) or 0)
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
        except Exception:
            total = 0
            violated_cnt = 0

    return {"total": total, "violated": violated_cnt}


def get_session_violation_stats(*, session_id: str) -> Dict[str, int]:
    session_id = _decode(session_id)
    key = _key_session_violation(session_id)
    data = redis_client.hgetall(key) or {}
    try:
        total = int(_decode(data.get(b"total") or data.get("total") or 0))
    except Exception:
        total = 0
    try:
        violated = int(_decode(data.get(b"violated") or data.get("violated") or 0))
    except Exception:
        violated = 0
    return {"total": total, "violated": violated}


def should_revoke_by_stats(*, violated: int, total: int) -> bool:
    """
    Î≥¥ÏàòÏ†Å Ï∞®Îã® Í∏∞Ï§Ä:
    - violated >= threshold
    - ÎòêÎäî violated/total ÎπÑÏú®Ïù¥ ÎÑàÎ¨¥ ÎÜíÏúºÎ©¥ Ï∞®Îã®
    """
    threshold = int(getattr(settings, "VIDEO_VIOLATION_REVOKE_THRESHOLD", 3))
    ratio = float(getattr(settings, "VIDEO_VIOLATION_REVOKE_RATIO", 0.5))

    if int(violated) >= threshold:
        return True
    if int(total) > 0 and (float(violated) / float(total)) >= ratio:
        return True
    return False


# =======================================================
# Facade API (Student ONLY) - Í∏∞Ï°¥ Ïú†ÏßÄ
# =======================================================

def create_playback_session(
    *,
    user,
    video_id: int,
    enrollment_id: int,
    device_id: str,
) -> dict:
    """
    ÌïôÏÉù Ï†ÑÏö© Facade API

    Ï±ÖÏûÑ:
    - "Ïû¨ÏÉù ÏÑ∏ÏÖò ÏÉùÏÑ±"Îßå Îã¥Îãπ
    - Í∂åÌïú / ÏàòÍ∞ï Í≤ÄÏ¶ùÏùÄ ViewÏóêÏÑú ÏÑ†ÌñâÎêòÏñ¥Ïïº Ìï®
    """

    # üö´ Í∞ïÏÇ¨ / Ïö¥ÏòÅÏûê Ï∞®Îã®
    if getattr(user, "is_instructor", False) or getattr(user, "is_staff", False):
        return {
            "ok": False,
            "error": "instructor_must_use_play_api",
        }

    if not device_id:
        return {"ok": False, "error": "device_id_required"}

    video = Video.objects.select_related(
        "session",
        "session__lecture",
    ).get(id=video_id)

    enrollment = Enrollment.objects.select_related(
        "student",
        "lecture",
    ).get(
        id=enrollment_id,
        status="ACTIVE",
    )

    # üõ°Ô∏è ÏïàÏ†Ñ Í∞ÄÎìú (View ÎàÑÎùΩ Î∞©ÏßÄÏö©)
    if enrollment.lecture_id != video.session.lecture_id:
        return {
            "ok": False,
            "error": "enrollment_lecture_mismatch",
        }

    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    ok, sess, err = issue_session(
        user_id=user.id,
        device_id=device_id,
        ttl_seconds=ttl,
        max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
        max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
    )

    if not ok:
        return {
            "ok": False,
            "error": err,
        }

    session_id = str(sess["session_id"])
    expires_at = int(sess["expires_at"])

    VideoPlaybackSession.objects.create(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
        device_id=device_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        started_at=timezone.now(),
    )

    return {
        "ok": True,
        "video_id": video.id,
        "enrollment_id": enrollment.id,
        "session_id": session_id,
        "expires_at": expires_at,
    }


==========================================================================================
# FILE: services/video_stats.py
==========================================================================================
# PATH: apps/support/video/services/video_stats.py

from apps.domains.enrollment.models import Enrollment
from apps.domains.attendance.models import Attendance
from apps.support.video.models import VideoProgress, VideoPermission


def build_video_stats_students(video):
    """
    ‚úÖ Single Source of Truth
    - stats
    - policy-impact
    - admin preview
    Ï†ÑÎ∂Ä Ïù¥ Ìï®ÏàòÎßå ÏÇ¨Ïö©Ìï¥Ïïº Ìï®
    """

    lecture = video.session.lecture

    enrollments = Enrollment.objects.filter(
        lecture=lecture,
        status="ACTIVE",
    ).select_related("student")

    progresses = {
        p.enrollment_id: p
        for p in VideoProgress.objects.filter(video=video)
    }

    perms = {
        p.enrollment_id: p
        for p in VideoPermission.objects.filter(video=video)
    }

    attendance = {
        a.enrollment_id: a.status
        for a in Attendance.objects.filter(session=video.session)
    }

    students = []

    for e in enrollments:
        vp = progresses.get(e.id)
        perm = perms.get(e.id)

        rule = perm.rule if perm else "free"
        effective_rule = rule

        # once ‚Üí completed Ïãú free ÏäπÍ≤©
        if rule == "once" and vp and vp.completed:
            effective_rule = "free"

        students.append({
            "enrollment": e.id,
            "student_name": e.student.name,
            "attendance_status": attendance.get(e.id),
            "progress": vp.progress if vp else 0,
            "completed": vp.completed if vp else False,
            "rule": rule,
            "effective_rule": effective_rule,
        })

    return students


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/support/video/views/__init__.py

from .video_policy_impact import VideoPolicyImpactAPIView

from .video_views import VideoViewSet
from .permission_views import VideoPermissionViewSet
from .progress_views import VideoProgressViewSet
from .internal_views import VideoProcessingCompleteView
from .event_views import VideoPlaybackEventViewSet


==========================================================================================
# FILE: views/achievement_views.py
==========================================================================================
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from django.db.models import Avg, Sum

from apps.domains.attendance.models import Attendance
from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoProgress


class VideoAchievementView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session").get(id=video_id)
        lecture = video.session.lecture

        # ÏòÅÏÉÅ ÏàòÍ∞ï ÎåÄÏÉÅ ÌïôÏÉù (Ï∂úÏÑùÏù¥ ONLINE)
        online_attendance = Attendance.objects.filter(
            session=video.session,
            status="ONLINE",
        )

        enrollment_ids = online_attendance.values_list("enrollment_id", flat=True)

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(
                video=video,
                enrollment_id__in=enrollment_ids,
            )
        }

        students = []
        completed_count = 0
        total_progress = 0

        for att in online_attendance.select_related("enrollment__student"):
            enrollment = att.enrollment
            vp = progresses.get(enrollment.id)

            progress = vp.progress if vp else 0
            completed = vp.completed if vp else False

            if completed:
                completed_count += 1

            total_progress += progress

            # ÏÉÅÌÉú Í≥ÑÏÇ∞
            if progress >= 0.95:
                status = "completed"
            elif progress >= 0.5:
                status = "warning"
            else:
                status = "danger"

            students.append({
                "enrollment": enrollment.id,
                "student_name": enrollment.student.name,
                "progress": round(progress * 100, 1),
                "completed": completed,
                "watched_seconds": vp.last_position if vp else 0,
                "status": status,
            })

        total = len(students)
        avg_progress = (total_progress / total) if total else 0

        return Response({
            "summary": {
                "total_students": total,
                "avg_progress": round(avg_progress * 100, 1),
                "completed_rate": round((completed_count / total) * 100, 1) if total else 0,
                "incomplete_count": total - completed_count,
            },
            "students": students,
        })


==========================================================================================
# FILE: views/event_views.py
==========================================================================================
# PATH: apps/support/video/views/event_views.py

import csv
from datetime import timedelta

from django.http import HttpResponse
from django.utils import timezone

from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.filters import SearchFilter

from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoPlaybackEvent
from ..serializers import (
    VideoPlaybackEventListSerializer,
    VideoRiskRowSerializer,
)


def _range_to_since(range_key: str):
    now = timezone.now()
    if range_key == "24h":
        return now - timedelta(hours=24)
    if range_key == "7d":
        return now - timedelta(days=7)
    return None


def _event_score(event_type: str, violated: bool, violation_reason: str | None):
    weights = {
        "VISIBILITY_HIDDEN": 1,
        "VISIBILITY_VISIBLE": 0,
        "FOCUS_LOST": 2,
        "FOCUS_GAINED": 0,
        "SEEK_ATTEMPT": 3,
        "SPEED_CHANGE_ATTEMPT": 3,
        "FULLSCREEN_ENTER": 0,
        "FULLSCREEN_EXIT": 0,
        "PLAYER_ERROR": 1,
    }
    w = int(weights.get(event_type, 1))
    if violated:
        w *= 2
    if violation_reason:
        w += 1
    return w


class VideoPlaybackEventViewSet(ReadOnlyModelViewSet):
    """
    Admin / Staff Ï†ÑÏö©
    - list
    - risk
    - export
    """

    queryset = (
        VideoPlaybackEvent.objects
        .all()
        .select_related("enrollment", "enrollment__student", "video")
    )
    serializer_class = VideoPlaybackEventListSerializer
    permission_classes = [IsAuthenticated]

    # ‚úÖ Í≤ÄÏÉâ + ÌïÑÌÑ∞ ÎèôÏãú ÏßÄÏõê
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["video", "enrollment", "violated"]
    search_fields = [
        "enrollment__student__name",
        "session_id",
        "user_id",
    ]

    def get_queryset(self):
        qs = super().get_queryset()

        video_id = self.request.query_params.get("video")
        if video_id:
            qs = qs.filter(video_id=video_id)

        range_key = self.request.query_params.get("range", "24h")
        since = _range_to_since(range_key)
        if since:
            qs = qs.filter(occurred_at__gte=since)

        # ‚úÖ event_type Îã§Ï§ë ÌïÑÌÑ∞ (comma-separated)
        et = self.request.query_params.get("event_type")
        if et:
            types = [x for x in et.split(",") if x]
            if types:
                qs = qs.filter(event_type__in=types)

        return qs.order_by("-occurred_at", "-id")

    # --------------------------------------------------
    # Risk Top
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="risk")
    def risk(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        limit = int(request.query_params.get("limit") or 5)
        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        agg = {}
        for ev in qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment_id": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                    "danger": 0,
                    "warn": 0,
                    "info": 0,
                    "last_occurred_at": None,
                }

            s = _event_score(ev.event_type, bool(ev.violated), ev.violation_reason)
            agg[eid]["score"] += s

            if ev.violated:
                agg[eid]["danger"] += 1
            elif ev.event_type in ("SEEK_ATTEMPT", "SPEED_CHANGE_ATTEMPT", "FOCUS_LOST"):
                agg[eid]["warn"] += 1
            else:
                agg[eid]["info"] += 1

            if (
                agg[eid]["last_occurred_at"] is None
                or ev.occurred_at > agg[eid]["last_occurred_at"]
            ):
                agg[eid]["last_occurred_at"] = ev.occurred_at

        rows = sorted(
            agg.values(),
            key=lambda r: (r["score"], r["danger"], r["warn"]),
            reverse=True,
        )[:limit]

        return Response(VideoRiskRowSerializer(rows, many=True).data)

    # --------------------------------------------------
    # CSV Export
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="export")
    def export_csv(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        qs = qs.order_by("-occurred_at", "-id")

        resp = HttpResponse(content_type="text/csv; charset=utf-8")
        resp["Content-Disposition"] = (
            f'attachment; filename="video_{video_id}_events_{range_key}.csv"'
        )

        writer = csv.writer(resp)
        writer.writerow([
            "occurred_at",
            "student_name",
            "enrollment_id",
            "event_type",
            "violated",
            "violation_reason",
            "session_id",
            "user_id",
            "score",
            "payload",
        ])

        for ev in qs.iterator():
            writer.writerow([
                ev.occurred_at.isoformat(),
                ev.enrollment.student.name if ev.enrollment_id else "",
                ev.enrollment_id,
                ev.event_type,
                "Y" if ev.violated else "N",
                ev.violation_reason or "",
                ev.session_id,
                ev.user_id,
                _event_score(ev.event_type, bool(ev.violated), ev.violation_reason),
                ev.event_payload,
            ])

        return resp


==========================================================================================
# FILE: views/internal_video_worker.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker.py

from __future__ import annotations

from datetime import timedelta
from typing import Any

from django.conf import settings
from django.db import transaction
from django.http import JsonResponse
from django.utils import timezone
from django.db import models  # ‚úÖ ÏõêÎ≥∏ ÏùòÎØ∏ Ïú†ÏßÄ + ÎèôÏûë Î≥¥Í∞ï (Í∏∞Ï°¥ ÌååÏùº ÌïòÎã® import ÎåÄÏ≤¥)

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny

from apps.support.video.models import Video


def _require_worker_token(request) -> bool:
    token = request.headers.get("X-Worker-Token")
    return bool(token) and token == getattr(settings, "INTERNAL_WORKER_TOKEN", "")


def _worker_id(request) -> str:
    return (
        request.headers.get("X-Worker-Id")
        or request.headers.get("X-Worker-ID")
        or "worker-unknown"
    )


LEASE_SECONDS = int(getattr(settings, "VIDEO_WORKER_LEASE_SECONDS", 60))
MAX_BATCH = int(getattr(settings, "VIDEO_WORKER_MAX_BATCH", 1))


def _lease_cutoff(now):
    # DB Ïä§ÌÇ§Îßà Î≥ÄÍ≤Ω ÏóÜÏù¥ "PROCESSING stuck" ÌöåÏàò:
    # - processing ÏÉÅÌÉúÍ∞Ä LEASE_SECONDS Ïù¥ÏÉÅ Í∞±Ïã†Ïù¥ ÏóÜÏúºÎ©¥ reclaim ÌóàÏö©
    return now - timedelta(seconds=LEASE_SECONDS)


def _parse_int(value: Any) -> int | None:
    if value is None:
        return None
    try:
        return int(value)
    except Exception:
        return None


def _is_lease_owner(video: Video, worker_id: str) -> bool:
    """
    ‚úÖ Îã§Ï§ë ÎÖ∏Îìú Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ:
    - leased_byÍ∞Ä ÏÑ§Ï†ïÎèº ÏûàÏúºÎ©¥ ÏÜåÏú†ÏûêÎßå complete/fail/heartbeat Í∞ÄÎä•
    - leased_untilÏù¥ ÏßÄÎÇòÎ©¥(ÎßåÎ£å) owner Ï≤¥ÌÅ¨Î•º ÏôÑÌôî(ÌöåÏàò/Ïû¨Ï≤òÎ¶¨ ÌóàÏö©)
    - Í∏∞Ï°¥ Íµ¨Ï°∞(updated_at reclaim) Í∑∏ÎåÄÎ°ú Ïú†ÏßÄÌïòÎ©¥ÏÑú Ï§ëÏïô ÌÜµÏ†ú Ï∂îÍ∞Ä
    """
    if not hasattr(video, "leased_by") or not hasattr(video, "leased_until"):
        return True

    lb = (getattr(video, "leased_by", "") or "").strip()
    lu = getattr(video, "leased_until", None)

    if not lb:
        return True

    # lease ÎßåÎ£åÎ©¥ ÏÜåÏú†Í∂å Í∞ïÏ†ú Ïïà Ìï®(ÌöåÏàò Í∞ÄÎä•)
    if lu is not None and lu <= timezone.now():
        return True

    return lb == (worker_id or "")


class VideoWorkerClaimNextView(APIView):
    """
    Worker polls:
      GET /api/v1/internal/video-worker/next/
    Returns:
      200 { "job": {video_id, file_key} }  OR  204 no content

    NOTE:
    - Í∏∞Ï°¥ reclaim Î°úÏßÅ(updated_at Í∏∞Ï§Ä) Ïú†ÏßÄ
    - Ïó¨Í∏∞Ïóê leased_by/leased_untilÎßå "Ï∂îÍ∞Ä Í∏∞Î°ù"ÌïòÏó¨
      multi-host ÌôòÍ≤ΩÏóêÏÑú ÏôÑÎ£åÏ≤òÎ¶¨ Í≤ΩÌï© Î∞©ÏßÄ
    """
    permission_classes = [AllowAny]

    def get(self, request):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        now = timezone.now()
        cutoff = _lease_cutoff(now)

        wid = _worker_id(request)

        with transaction.atomic():
            video = (
                Video.objects.select_for_update(skip_locked=True)
                .filter(
                    models.Q(status=Video.Status.UPLOADED)
                    | models.Q(status=Video.Status.PROCESSING, updated_at__lt=cutoff)
                )
                .order_by("id")
                .first()
            )

            if video is None:
                return JsonResponse({}, status=204)

            # reclaimÎêú ÏûëÏóÖÏùÄ Ïã§Ìå®ÏÇ¨Ïú† ÎÇ®Í∏∞ÏßÄ ÏïäÍ≥† Ïû¨Ï≤òÎ¶¨
            video.status = Video.Status.PROCESSING

            # ‚úÖ lease ÌïÑÎìúÍ∞Ä ÏûàÏúºÎ©¥ Î∞òÎìúÏãú Í∏∞Î°ù(Ï§ëÎ≥µ ÏôÑÎ£å Î∞©ÏßÄ)
            if hasattr(video, "processing_started_at"):
                video.processing_started_at = now
            if hasattr(video, "leased_until"):
                video.leased_until = now + timedelta(seconds=LEASE_SECONDS)
            if hasattr(video, "leased_by"):
                video.leased_by = wid

            update_fields = ["status"]
            if hasattr(video, "processing_started_at"):
                update_fields.append("processing_started_at")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse(
            {"job": {"video_id": video.id, "file_key": video.file_key}},
            status=200,
        )


class VideoWorkerCompleteView(APIView):
    """
    Worker reports success:
      POST /api/v1/internal/video-worker/{video_id}/complete/
      body: {hls_path, duration}

    idempotent:
    - Ïù¥ÎØ∏ READYÎ©¥ ok Î∞òÌôò

    ‚úÖ Î≥¥Í∞ï:
    - lease owner(worker_id)Îßå complete Í∞ÄÎä•
      (multi-host Ïù¥Ï§ë Ï≤òÎ¶¨Ïùò "ÏôÑÎ£å Í≤ΩÌï©" Ï∞®Îã®)
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = request.data if hasattr(request, "data") else {}
        hls_path = data.get("hls_path")
        duration = _parse_int(data.get("duration"))

        if not hls_path:
            return JsonResponse({"detail": "hls_path required"}, status=400)

        with transaction.atomic():
            video = Video.objects.select_for_update().filter(id=video_id).first()
            if video is None:
                return JsonResponse({"detail": "Not found"}, status=404)

            # ‚úÖ lease owner Í≤ÄÏ¶ù
            if not _is_lease_owner(video, wid):
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)

            # ‚úÖ idempotent Ï≤òÎ¶¨
            if video.status == Video.Status.READY and video.hls_path:
                return JsonResponse({"ok": True, "idempotent": True}, status=200)

            video.hls_path = str(hls_path)
            if duration is not None and duration >= 0:
                video.duration = duration

            video.status = Video.Status.READY

            # lease Ìï¥Ï†ú
            if hasattr(video, "leased_until"):
                video.leased_until = None
            if hasattr(video, "leased_by"):
                video.leased_by = ""

            update_fields = ["hls_path", "status"]
            if duration is not None and duration >= 0:
                update_fields.append("duration")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse({"ok": True}, status=200)


class VideoWorkerFailView(APIView):
    """
    Worker reports failure:
      POST /api/v1/internal/video-worker/{video_id}/fail/
      body: {reason}

    idempotent:
    - Ïù¥ÎØ∏ FAILEDÎ©¥ ok Î∞òÌôò

    ‚úÖ Î≥¥Í∞ï:
    - lease owner(worker_id)Îßå fail Í∞ÄÎä•
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = request.data if hasattr(request, "data") else {}
        reason = data.get("reason") or "unknown"

        with transaction.atomic():
            video = Video.objects.select_for_update().filter(id=video_id).first()
            if video is None:
                return JsonResponse({"detail": "Not found"}, status=404)

            # ‚úÖ lease owner Í≤ÄÏ¶ù
            if not _is_lease_owner(video, wid):
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)

            # ‚úÖ idempotent Ï≤òÎ¶¨
            if video.status == Video.Status.FAILED:
                return JsonResponse({"ok": True, "idempotent": True}, status=200)

            video.status = Video.Status.FAILED

            if hasattr(video, "error_reason"):
                video.error_reason = str(reason)[:2000]

            # lease Ìï¥Ï†ú
            if hasattr(video, "leased_until"):
                video.leased_until = None
            if hasattr(video, "leased_by"):
                video.leased_by = ""

            update_fields = ["status"]
            if hasattr(video, "error_reason"):
                update_fields.append("error_reason")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse({"ok": True}, status=200)


==========================================================================================
# FILE: views/internal_video_worker_heartbeat.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker_heartbeat.py

import logging
from django.utils import timezone
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

from ..models import Video

logger = logging.getLogger("video.worker.heartbeat")


class InternalVideoWorkerHeartbeatView(APIView):
    authentication_classes = []
    permission_classes = []

    def post(self, request, video_id: int):
        worker_id = request.headers.get("X-Worker-Id") or "worker-unknown"

        video = Video.objects.filter(id=video_id).first()
        if not video:
            return Response(status=status.HTTP_404_NOT_FOUND)

        # lease owner Í≤ÄÏ¶ù
        leased_by = getattr(video, "leased_by", None)
        leased_until = getattr(video, "leased_until", None)

        if leased_by and leased_by != worker_id:
            logger.warning(
                "heartbeat rejected lease_owner_mismatch video_id=%s leased_by=%s from=%s",
                video_id, leased_by, worker_id,
            )
            return Response(status=status.HTTP_409_CONFLICT)

        if leased_until and leased_until < timezone.now():
            logger.warning(
                "heartbeat rejected lease_expired video_id=%s worker=%s",
                video_id, worker_id,
            )
            return Response(status=status.HTTP_409_CONFLICT)

        # heartbeat accept ‚Üí lease Ïó∞Ïû•
        try:
            video.processing_started_at = video.processing_started_at or timezone.now()
            video.leased_by = worker_id
            video.leased_until = timezone.now() + timezone.timedelta(seconds=60)
            video.save(update_fields=["processing_started_at", "leased_by", "leased_until"])
        except Exception:
            pass

        logger.info(
            "heartbeat ok video_id=%s worker=%s",
            video_id, worker_id,
        )
        return Response({"ok": True})


==========================================================================================
# FILE: views/internal_views.py
==========================================================================================
# PATH: apps/support/video/views/internal_views.py

from django.conf import settings
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response


class VideoProcessingCompleteView(APIView):
    """
    worker ‚Üí API ACK
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        token = request.headers.get("X-Worker-Token")
        if token != settings.INTERNAL_WORKER_TOKEN:
            return Response(status=403)

        return Response({"status": "ack"}, status=200)


==========================================================================================
# FILE: views/permission_views.py
==========================================================================================
# PATH: apps/support/video/views/permission_views.py

from django.db import models, transaction
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response

from ..models import VideoPermission, Video
from ..serializers import VideoPermissionSerializer


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_set(self, request):
        video_id = request.data.get("video_id")
        enrollments = request.data.get("enrollments", [])
        rule = request.data.get("rule", "once")

        objs = []
        for enrollment_id in enrollments:
            obj, _ = VideoPermission.objects.update_or_create(
                video_id=video_id,
                enrollment_id=enrollment_id,
                defaults={
                    "rule": rule,
                    "is_override": True,
                },
            )
            objs.append(obj)

        # ‚úÖ Ï†ïÏ±Ö Î≥ÄÍ≤Ω ‚Üí policy_version Ï¶ùÍ∞Ä (Í∏∞Ï°¥ ÌÜ†ÌÅ∞ Ï¶âÏãú Î¨¥Ìö®Ìôî)
        Video.objects.filter(id=video_id).update(
            policy_version=models.F("policy_version") + 1
        )

        return Response(VideoPermissionSerializer(objs, many=True).data)


==========================================================================================
# FILE: views/playback_mixin.py
==========================================================================================
# PATH: apps/support/video/views/playback_mixin.py

import time

from django.conf import settings
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.lectures.models import Session

from ..models import Video, VideoPermission, VideoProgress
from ..serializers import VideoSerializer
from ..drm import create_playback_token, verify_playback_token
from ..cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options

# ‚úÖ Ï∂îÍ∞Ä: Cloudflare signed url (ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ public)
from ..cdn.cloudflare_signing import CloudflareSignedURL


class VideoPlaybackMixin:
    """
    Ïû¨ÏÉù Í∂åÌïú / Ï†ïÏ±Ö / Í≥µÌÜµ Î°úÏßÅ

    Ï†ïÏ±Ö Ï†ïÏùò:
    - free    : Ìï≠ÏÉÅ Î¨¥Ï†úÌïú
    - once    : 1ÌöåÏ∞®ÏóêÎßå Ï†ïÏ±Ö Ï†ÅÏö©, ÏôÑÎ£å ÌõÑ freeÎ°ú ÏäπÍ≤©Îê®
    - blocked : Ìï≠ÏÉÅ Ï∞®Îã®
    """

    def _get_student_for_user(self, request):
        return getattr(request.user, "student_profile", None)

    # ==================================================
    # Ï†ëÍ∑º Ï†úÏñ¥ (Access Control)
    # ==================================================
    def _check_access(self, *, video, enrollment):
        """
        Ï†ëÍ∑º Í∞ÄÎä• Ïó¨Î∂ÄÎßå ÌåêÎã®ÌïúÎã§.
        onceÎäî Ï†ëÍ∑ºÏùÑ Ï∞®Îã®ÌïòÏßÄ ÏïäÎäîÎã§.
        """
        if video.status != video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        # free / once Î™®Îëê Ï†ëÍ∑º ÌóàÏö©
        return True, None

    # ==================================================
    # Permission Loader
    # ==================================================
    def _load_permission(self, *, video, enrollment):
        return VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

    # ==================================================
    # Playback Policy
    # ==================================================
    def _effective_policy(self, *, video, perm):
        """
        Ïã§Ï†ú Ïû¨ÏÉù Ï†úÏïΩ Ï†ïÏ±Ö Í≥ÑÏÇ∞
        - once : ÏôÑÎ£å Ï†ÑÍπåÏßÄ ÌÉêÏÉâ Ï†úÌïú
        - ÏôÑÎ£å ÌõÑÏóêÎäî freeÏôÄ ÎèôÏùº
        """
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        seek_policy = {
            "mode": "free",
            "forward_limit": None,
            "grace_seconds": 3,
        }

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)

            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if perm.rule == "once":
                completed = VideoProgress.objects.filter(
                    video=video,
                    enrollment=perm.enrollment,
                    completed=True,
                ).exists()

                if not completed:
                    seek_policy = {
                        "mode": "bounded_forward",
                        "forward_limit": "max_watched",
                        "grace_seconds": 3,
                    }

            if perm.block_seek:
                allow_seek = False
                seek_policy = {"mode": "blocked"}

            if perm.block_speed_control:
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "seek": seek_policy,
            "playback_rate": {
                "max": max_rate,
                "ui_control": ui_speed_control,
            },
            "watermark": {
                "enabled": watermark_enabled,
                "mode": "overlay",
                "fields": ["user_id"],
            },
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    # ==================================================
    # HLS / CDN
    # ==================================================
    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _normalize_media_path(self, path: str) -> str:
        """
        serializerÏôÄ ÎèôÏùº Ï≤†Ìïô:
        - leading slash Ï†úÍ±∞
        - legacy storage/media normalize
        """
        p = (path or "").lstrip("/")
        if p.startswith("storage/media/"):
            return p[len("storage/") :]
        return p

    def _public_play_url(self, *, video: Video, expires_at: int, user_id: int) -> str:
        """
        ‚úÖ ÏõêÎ≥∏ Í≥ÑÏïΩ Ïú†ÏßÄ + ÏµúÏÜå Î≥¥Í∞ï
        - video.hls_pathÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í≤ÉÏù¥ single source of truth
        - ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Í∏∞Î≥∏ Í≤ΩÎ°ú(master.m3u8)Î°ú fallback
        - ÏÑ§Ï†ïÍ∞íÏù¥ ÏûàÏúºÎ©¥ Cloudflare signed queryÎ•º Î∂ôÏó¨ÏÑú Î∞òÌôò
        """
        cdn_base = settings.CDN_HLS_BASE_URL.rstrip("/")

        # 1) worker Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏ ÏÇ¨Ïö©
        if getattr(video, "hls_path", ""):
            rel = self._normalize_media_path(str(video.hls_path))
            path = "/" + rel if not rel.startswith("/") else rel
        else:
            # 2) Í∏∞Ï°¥ fallback (ÏõêÎ≥∏ Ïú†ÏßÄ)
            path = f"/media/hls/videos/{video.id}/master.m3u8"

        secret = getattr(settings, "CDN_HLS_SIGNING_SECRET", None)
        if not secret:
            return f"{cdn_base}{path}"

        signer = CloudflareSignedURL(
            secret=str(secret),
            key_id=str(getattr(settings, "CDN_HLS_SIGNING_KEY_ID", "v1")),
        )
        return signer.build_url(
            cdn_base=cdn_base,
            path=path,
            expires_at=int(expires_at),
            user_id=int(user_id),
        )

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int):
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, expires_at - int(time.time()))
        for k, v in cookies.items():
            response.set_cookie(k, v, max_age=max_age, **opts)

    # ==================================================
    # ÌïôÏÉù ÏòÅÏÉÅ Î™©Î°ù (Ïû¨ÏÉù Í∞ÄÎä• Ïó¨Î∂Ä ÌåêÎã®)
    # ==================================================
    def _student_list_impl(self, request):
        session_id = request.query_params.get("session")
        if not session_id:
            return Response({"detail": "session is required"}, status=400)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        qs = Video.objects.filter(
            session_id=session_id,
            status=Video.Status.READY,
        ).order_by("order", "id")

        session = Session.objects.select_related("lecture").get(id=session_id)
        lecture = session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        data = []
        for v in qs:
            d = VideoSerializer(v).data

            if not enrollment:
                d["can_play"] = False
                d["reason"] = "not_enrolled"
                data.append(d)
                continue

            if not SessionEnrollment.objects.filter(
                session=session,
                enrollment=enrollment,
            ).exists():
                d["can_play"] = False
                d["reason"] = "no_session_access"
                data.append(d)
                continue

            ok, reason = self._check_access(video=v, enrollment=enrollment)
            d["can_play"] = bool(ok)
            d["reason"] = reason if not ok else None
            data.append(d)

        return Response(data)


==========================================================================================
# FILE: views/playback_session_views.py
==========================================================================================
from __future__ import annotations

import time
from django_redis import get_redis_connection

redis_client = get_redis_connection("default")


def _now() -> int:
    return int(time.time())


def _key_session(session_id: str) -> str:
    return f"media:playback:session:{session_id}"


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:sessions"


def _key_user_devices(user_id: int) -> str:
    return f"media:playback:user:{user_id}:devices"


def _key_revoked_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:revoked"


# ===============================
# Í∏∞Ï°¥ Ìï®Ïàò (ÏùòÎØ∏ Ïú†ÏßÄ)
# ===============================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
):
    """
    ÏõêÎ≥∏ Íµ¨ÌòÑ Ïú†ÏßÄ (Ï§ëÎûµ ÏóÜÏù¥ Í∑∏ÎåÄÎ°ú ÏûàÎã§Í≥† Í∞ÄÏ†ï)
    """
    # ‚Äª ÏõêÎ≥∏ ÏΩîÎìú Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
    raise NotImplementedError


def heartbeat_session(
    *,
    user_id: int,
    session_id: str,
    ttl_seconds: int,
) -> bool:
    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    expire_at = _now() + ttl_seconds
    redis_client.zadd(sessions_key, {session_id: expire_at})
    return True


def end_session(*, user_id: int, session_id: str) -> None:
    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(_key_user_sessions(user_id), session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


# ===============================
# ‚úÖ Î≥¥Í∞ï: Ï¶âÏãú Ï∞®Îã® (Î¨∏Ï†ú 1)
# ===============================

def revoke_session(*, user_id: int, session_id: str) -> None:
    """
    ÏÑúÎ≤Ñ Í∞ïÏ†ú Ï∞®Îã®:
    - Redis ÏÑ∏ÏÖò Ï¶âÏãú Ï†úÍ±∞
    - revoked setÏóê Í∏∞Î°ùÌïòÏó¨ Ïû¨ÏÇ¨Ïö© Î∞©ÏßÄ
    """
    pipe = redis_client.pipeline(transaction=False)
    pipe.sadd(_key_revoked_sessions(user_id), session_id)
    pipe.zrem(_key_user_sessions(user_id), session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    Redis Í∏∞Ï§Ä Îã®Ïùº ÌåêÏ†ï Ìï®Ïàò
    """
    if redis_client.sismember(_key_revoked_sessions(user_id), session_id):
        return False

    score = redis_client.zscore(_key_user_sessions(user_id), session_id)
    if score is None:
        return False

    return int(score) > _now()


==========================================================================================
# FILE: views/playback_views.py
==========================================================================================
# PATH: apps/support/video/views/playback_views.py

import uuid

from django.conf import settings
from django.utils import timezone
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from apps.domains.enrollment.models import Enrollment, SessionEnrollment

from ..models import (
    Video,
    VideoPlaybackSession,
    VideoPlaybackEvent,
    VideoProgress,
    VideoPermission,
)
from ..serializers import (
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)
from ..drm import create_playback_token, verify_playback_token
from ..services.playback_session import (
    issue_session,
    heartbeat_session,
    end_session,
    is_session_active,
    revoke_session,
    record_session_event,
    get_session_violation_stats,
    should_revoke_by_stats,
)
from .playback_mixin import VideoPlaybackMixin


# ----------------------------------------------------------
# internal helpers (ÏõêÎ≥∏ Íµ¨Ï°∞ Ïú†ÏßÄ: view ÎÇ¥Î∂Ä Î≥¥Ï°∞ Ìï®ÏàòÎ°úÎßå Ï∂îÍ∞Ä)
# ----------------------------------------------------------

def _req_id() -> str:
    return uuid.uuid4().hex


def _policy_version_of(video: Video) -> int:
    try:
        return int(getattr(video, "policy_version", 1) or 1)
    except Exception:
        return 1


def _is_policy_token_valid(payload: dict) -> bool:
    """
    token payloadÏùò pvÏôÄ ÌòÑÏû¨ video.policy_version ÎπÑÍµê.
    - Î∂àÏùºÏπò Ïãú Ï¶âÏãú Ï∞®Îã® (Î¨∏Ï†ú 6)
    """
    try:
        video_id = int(payload.get("video_id"))
    except Exception:
        return False

    # NOTE: migrations Ï†ÅÏö© Ï†ÑÏóêÎäî policy_version Ïª¨ÎüºÏù¥ ÏóÜÏúºÎ©¥ SELECTÏóêÏÑú ÌÑ∞Ïßà Ïàò ÏûàÏùå.
    # Ïã§ÏÑúÎπÑÏä§Îäî migration Ïù¥ÌõÑÎ•º Ï†ÑÏ†úÎ°ú ÌïúÎã§.
    v = Video.objects.filter(id=video_id).only("id", "policy_version").first()
    if not v:
        return False

    current = _policy_version_of(v)
    try:
        pv = int(payload.get("pv") or 0)
    except Exception:
        pv = 0

    return pv == current


def _deny(detail: str, *, code=status.HTTP_403_FORBIDDEN):
    return Response({"detail": detail}, status=code)


def _session_db_status(session_id: str):
    return (
        VideoPlaybackSession.objects
        .filter(session_id=session_id)
        .values_list("status", flat=True)
        .first()
    )


def _db_session_is_inactive(st: str | None) -> bool:
    return st in (VideoPlaybackSession.Status.REVOKED, VideoPlaybackSession.Status.EXPIRED)


# ==========================================================
# Playback Start
# ==========================================================

class PlaybackStartView(VideoPlaybackMixin, APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        request_id = _req_id()

        serializer = PlaybackStartRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        enrollment_id = serializer.validated_data["enrollment_id"]
        device_id = serializer.validated_data["device_id"]

        video_id = request.data.get("video_id")
        if not video_id:
            return Response({"detail": "video_id_required"}, status=400)

        enrollment = Enrollment.objects.select_related(
            "student",
            "lecture",
        ).get(id=enrollment_id, status="ACTIVE")

        video = Video.objects.select_related(
            "session",
            "session__lecture",
        ).get(id=int(video_id))

        # ÏàòÍ∞ï Í≤ÄÏ¶ù
        if enrollment.lecture_id != video.session.lecture_id:
            return _deny("enrollment_mismatch", code=403)

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return _deny("no_session_access", code=403)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return _deny(reason, code=403)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
            max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
        )

        if not ok:
            return Response({"detail": err}, status=409)

        session_id = sess["session_id"]
        expires_at = sess["expires_at"]

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
            started_at=timezone.now(),
        )

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        # ‚úÖ tokenÏóê pv(policy_version) Ìè¨Ìï®
        token = create_playback_token(
            payload={
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "session_id": session_id,
                "user_id": request.user.id,
                "pv": _policy_version_of(video),
                "rid": request_id,  # trace
            },
            ttl_seconds=ttl,
        )

        play_url = self._public_play_url(
            video=video,
            expires_at=expires_at,
            user_id=request.user.id,
        )

        resp = Response(
            PlaybackResponseSerializer({
                "token": token,
                "session_id": session_id,
                "expires_at": expires_at,
                "policy": policy,
                "play_url": play_url,
            }).data,
            status=201,
        )

        self._set_signed_cookies(resp, video_id=video.id, expires_at=expires_at)
        return resp


# ==========================================================
# Playback Refresh
# ==========================================================

class PlaybackRefreshView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackRefreshRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        if not is_session_active(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        ):
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback Heartbeat
# ==========================================================

class PlaybackHeartbeatView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackHeartbeatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        ok2 = heartbeat_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
            ttl_seconds=int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600)),
        )
        if not ok2:
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback End
# ==========================================================

class PlaybackEndView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEndRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        end_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        )

        VideoPlaybackSession.objects.filter(
            session_id=str(payload["session_id"])
        ).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        return Response({"ok": True})


# ==========================================================
# Event Batch
# ==========================================================

class PlaybackEventBatchView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEventBatchRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        user_id = int(payload["user_id"])
        session_id = str(payload["session_id"])

        # DB ÏÉÅÌÉú Ï∞®Îã®
        st = _session_db_status(session_id)
        if _db_session_is_inactive(st):
            return Response({"detail": "session_inactive"}, status=409)

        # Redis ÏÉÅÌÉú Ï∞®Îã®
        if not is_session_active(user_id=user_id, session_id=session_id):
            return Response({"detail": "session_inactive"}, status=409)

        events = serializer.validated_data["events"]

        # Ìè≠Ï£º Î∞©ÏßÄ
        max_batch = int(getattr(settings, "VIDEO_EVENT_BATCH_MAX", 200))
        if len(events) > max_batch:
            return Response({"detail": "batch_too_large"}, status=413)

        now = timezone.now()
        objs = []

        # policy snapshot Í≥ÑÏÇ∞ (ÏõêÎ≥∏ ÎØπÏä§Ïù∏ Ïû¨ÏÇ¨Ïö©)
        video = Video.objects.filter(id=int(payload["video_id"])).first()
        enrollment = Enrollment.objects.filter(id=int(payload["enrollment_id"])).first()
        perm = None
        if video and enrollment:
            perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

        policy_snapshot = {}
        try:
            if video:
                m = VideoPlaybackMixin()
                policy_snapshot = m._effective_policy(video=video, perm=perm)
        except Exception:
            policy_snapshot = {}

        def _is_violation(ev_type: str, snap: dict) -> tuple[bool, str]:
            """
            ‚úÖ ÏµúÏÜå Í∞ïÏ†ú ÏúÑÎ∞ò ÌåêÏ†ï(ÏÑúÎ≤Ñ Îã®):
            - seek blocked/bounded ÌôòÍ≤ΩÏóêÏÑú SEEK_ATTEMPTÎäî violated
            - speed Ï†úÌïú ÌôòÍ≤ΩÏóêÏÑú SPEED_CHANGE_ATTEMPTÎäî violated
            (Ï∂îÍ∞Ä Í∞ïÌôîÎäî Ïó¨Í∏∞Îßå ÏàòÏ†ïÌïòÎ©¥ Îê® ‚Üí Íµ¨Ï°∞ Ïú†ÏßÄ)
            """
            if ev_type == "SEEK_ATTEMPT":
                seek = (snap or {}).get("seek") or {}
                allow_seek = bool((snap or {}).get("allow_seek", True))
                mode = seek.get("mode")
                if (not allow_seek) or mode in ("blocked", "bounded_forward"):
                    return True, f"seek_{mode or 'blocked'}"
            if ev_type == "SPEED_CHANGE_ATTEMPT":
                pr = ((snap or {}).get("playback_rate") or {})
                ui = bool(pr.get("ui_control", True))
                mx = float(pr.get("max", 1.0) or 1.0)
                if (not ui) or mx <= 1.0:
                    return True, "speed_blocked"
            return False, ""

        # ‚úÖ ÏÑ∏ÏÖò Îã®ÏúÑ ÎàÑÏ†Å ÏúÑÎ∞ò ÌåêÎã®
        # - Í∞Å Ïù¥Î≤§Ìä∏ÎßàÎã§ Redis Ïπ¥Ïö¥ÌÑ∞ Í∞±Ïã† ‚Üí batch Ï™ºÍ∞úÍ∏∞ Ïö∞Ìöå Î∂àÍ∞Ä
        latest_stats = None
        revoke_reason = ""

        for e in events:
            ev_type = e["type"]
            ev_payload = e.get("payload", {}) or {}

            violated, reason = _is_violation(ev_type, policy_snapshot)
            if violated and reason:
                revoke_reason = reason

            # ‚úÖ Redis ÎàÑÏ†Å Í∞±Ïã†
            latest_stats = record_session_event(
                user_id=user_id,
                session_id=session_id,
                violated=bool(violated),
                reason=reason or "",
            )

            objs.append(
                VideoPlaybackEvent(
                    video_id=int(payload["video_id"]),
                    enrollment_id=int(payload["enrollment_id"]),
                    session_id=session_id,
                    user_id=user_id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy_snapshot,
                    violated=bool(violated),
                    violation_reason=reason or "",
                    occurred_at=now,
                )
            )

        with transaction.atomic():
            VideoPlaybackEvent.objects.bulk_create(objs, batch_size=500)

            # ‚úÖ ÎàÑÏ†Å Í∏∞Ï§ÄÏúºÎ°ú revoke Í≤∞Ï†ï
            stats = latest_stats or get_session_violation_stats(session_id=session_id)
            violated_cnt = int(stats.get("violated") or 0)
            total_cnt = int(stats.get("total") or 0)

            if should_revoke_by_stats(violated=violated_cnt, total=total_cnt):
                # Redis ÏÑ∏ÏÖò Ï¶âÏãú Ï†úÍ±∞
                revoke_session(user_id=user_id, session_id=session_id)

                # DB Î∞òÏòÅ
                VideoPlaybackSession.objects.filter(session_id=session_id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=timezone.now(),
                )

        return Response(
            PlaybackEventBatchResponseSerializer({"stored": len(objs)}).data,
            status=201,
        )


==========================================================================================
# FILE: views/progress_views.py
==========================================================================================
# apps/support/video/views/progress_views.py

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoProgress, VideoPermission
from ..serializers import VideoProgressSerializer


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    def perform_update(self, serializer):
        vp = serializer.instance
        prev_completed = vp.completed

        vp = serializer.save()

        # üî• once ‚Üí free ÏûêÎèô ÏäπÍ≤© (completed False ‚Üí True ÏàúÍ∞Ñ)
        if not prev_completed and vp.completed:
            VideoPermission.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                rule="once",
            ).update(
                rule="free",
                is_override=False,
            )


==========================================================================================
# FILE: views/video_policy_impact.py
==========================================================================================
# PATH: apps/support/video/views/video_policy_impact.py
# PATH: apps/support/video/views/video_policy_impact.py

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoPermission, VideoProgress


class VideoPolicyImpactAPIView(APIView):
    """
    Admin Ï†ÑÏö©:
    ÌäπÏ†ï ÏòÅÏÉÅ Ï†ïÏ±ÖÏù¥ ÌïôÏÉùÎì§ÏóêÍ≤å Ïñ¥Îñ§ ÏòÅÌñ•ÏùÑ Ï£ºÎäîÏßÄ ÎØ∏Î¶¨ Î≥¥Í∏∞
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session", "session__lecture").get(id=video_id)

        enrollments = Enrollment.objects.filter(
            lecture=video.session.lecture,
            status="ACTIVE",
        ).select_related("student")

        perms = {
            p.enrollment_id: p
            for p in VideoPermission.objects.filter(video=video)
        }

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }

        rows = []

        for e in enrollments:
            perm = perms.get(e.id)
            prog = progresses.get(e.id)

            rule = perm.rule if perm else "free"

            effective = rule
            if rule == "once" and prog and prog.completed:
                effective = "free"

            rows.append({
                "enrollment": e.id,
                "student_name": e.student.name,
                "rule": rule,
                "effective_rule": effective,
                "completed": bool(prog.completed) if prog else False,
            })

        return Response(rows)


==========================================================================================
# FILE: views/video_views.py
==========================================================================================
# PATH: apps/support/video/views/video_views.py

from uuid import uuid4
from datetime import timedelta

from django.conf import settings
from django.db import models, transaction
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from rest_framework.parsers import (
    JSONParser,
    MultiPartParser,
    FormParser,
)
from django_filters.rest_framework import DjangoFilterBackend

from rest_framework_simplejwt.authentication import JWTAuthentication

from libs.s3_client.presign import create_presigned_put_url, create_presigned_get_url
from libs.s3_client.client import head_object

from apps.core.permissions import IsAdminOrStaff, IsStudent
from apps.core.authentication import CsrfExemptSessionAuthentication

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from ..models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)
from ..serializers import VideoSerializer, VideoDetailSerializer
from .playback_mixin import VideoPlaybackMixin


# ==================================================
# utils
# ==================================================
def _safe_int(v, default=None):
    try:
        return int(v)
    except Exception:
        return default


def _validate_source_media_via_ffprobe(url: str) -> tuple[bool, dict, str]:
    """
    upload_complete ÏµúÏÜå Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù

    - ffprobe Í∏∞Î∞ò
    - API ÏÑúÎ≤ÑÏóêÏÑú ffmpeg import Ïã§Ìå® Ïãú:
      ‚Üí API ÌÅ¨ÎûòÏãú Î∞©ÏßÄ
      ‚Üí Ìò∏Ï∂úÎ∂ÄÏóêÏÑú graceful fallback Ï≤òÎ¶¨
    """
    if not url:
        return False, {}, "source_url_missing"

    # lazy import (gunicorn Î∂ÄÌåÖ ÌÅ¨ÎûòÏãú Î∞©ÏßÄ)
    try:
        import ffmpeg  # type: ignore
    except Exception:
        return False, {}, "ffmpeg_module_missing"

    try:
        probe = ffmpeg.probe(url)
    except Exception as e:
        return False, {}, f"ffprobe_failed:{str(e)[:200]}"

    fmt = probe.get("format") or {}
    streams = probe.get("streams") or []

    dur_raw = fmt.get("duration")
    duration = None
    try:
        if dur_raw is not None:
            duration = int(float(dur_raw))
    except Exception:
        duration = None

    has_video = any((s.get("codec_type") == "video") for s in streams)

    if not has_video:
        return False, {"duration": duration, "has_video": False}, "no_video_stream"

    if duration is None:
        return False, {"duration": None, "has_video": True}, "duration_missing"

    if duration < 0:
        return False, {"duration": duration, "has_video": True}, "duration_invalid"

    return True, {"duration": duration, "has_video": True}, ""


def _try_start_video_worker_instance() -> None:
    """
    ‚úÖ upload_complete ÏãúÏ†ê(UPLOADED Ï†ÑÌôò)Ïóê video-worker EC2 Ïù∏Ïä§ÌÑ¥Ïä§ ÏûêÎèô Í∏∞Îèô

    - ÏÑ§Ï†ïÏù¥ ÏóÜÏúºÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ ÌïòÏßÄ ÏïäÏùå (ÏïàÏ†Ñ)
    - start_instancesÎäî Î©±Îì±Ïù¥ ÏïÑÎãàÎØÄÎ°ú ÏòàÏô∏Îäî ÏÇºÌÇ§Í≥† Î°úÍ∑∏Îßå ÎÇ®ÍπÄ
    """
    instance_id = getattr(settings, "VIDEO_WORKER_INSTANCE_ID", None) or ""
    region = getattr(settings, "AWS_REGION", None) or getattr(settings, "AWS_DEFAULT_REGION", None) or ""

    if not instance_id or not region:
        return

    try:
        import boto3  # type: ignore
    except Exception:
        return

    try:
        ec2 = boto3.client("ec2", region_name=region)
        ec2.start_instances(InstanceIds=[str(instance_id)])
    except Exception:
        # Ïö¥ÏòÅÏóêÏÑú start Ïã§Ìå®Í∞Ä APIÎ•º Íπ®Î©¥ Ïïà Îê®
        return


# ==================================================
# ViewSet
# ==================================================
class VideoViewSet(VideoPlaybackMixin, ModelViewSet):
    """
    Video Í¥ÄÎ¶¨ + ÌÜµÍ≥Ñ + ÌïôÏÉù Î™©Î°ù
    """

    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer

    parser_classes = [JSONParser]

    authentication_classes = [
        JWTAuthentication,
        CsrfExemptSessionAuthentication,
    ]
    permission_classes = [IsAuthenticated]

    ADMIN_ONLY_ACTIONS = {
        "upload_init",
        "upload_complete",
        "retry",
        "create",
        "update",
        "partial_update",
        "destroy",
    }

    def get_permissions(self):
        if self.action in self.ADMIN_ONLY_ACTIONS:
            return [IsAuthenticated(), IsAdminOrStaff()]
        return [IsAuthenticated()]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # ==================================================
    # upload/init
    # ==================================================
    @transaction.atomic
    @action(
        detail=False,
        methods=["post"],
        url_path="upload/init",
        parser_classes=[JSONParser],
    )
    def upload_init(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        filename = request.data.get("filename")

        allow_skip = bool(request.data.get("allow_skip", False))
        max_speed = float(request.data.get("max_speed", 1.0) or 1.0)
        show_watermark = bool(request.data.get("show_watermark", True))

        if not session_id or not title or not filename:
            return Response(
                {"detail": "session, title, filename required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session = Session.objects.get(id=session_id)
        order = (
            session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0
        ) + 1

        ext = filename.split(".")[-1].lower() if "." in filename else "mp4"
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=key,
            order=order,
            status=Video.Status.PENDING,
            allow_skip=allow_skip,
            max_speed=max_speed,
            show_watermark=show_watermark,
        )

        content_type = (request.data.get("content_type") or "video/mp4").split(";")[0]
        upload_url = create_presigned_put_url(key=key, content_type=content_type)

        return Response(
            {
                "video": VideoSerializer(video).data,
                "upload_url": upload_url,
                "file_key": key,
                "content_type": content_type,
            },
            status=status.HTTP_201_CREATED,
        )

    # ==================================================
    # upload/complete
    # ==================================================
    @transaction.atomic
    @action(
        detail=True,
        methods=["post"],
        url_path="upload/complete",
        parser_classes=[MultiPartParser, FormParser, JSONParser],
    )
    def upload_complete(self, request, pk=None):
        video = self.get_object()

        if video.status != Video.Status.PENDING:
            return Response(
                {"detail": f"Invalid status: {video.status}"},
                status=status.HTTP_409_CONFLICT,
            )

        exists, size = head_object(video.file_key)
        if not exists or size == 0:
            video.error_reason = "source_not_found_or_empty"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "S3 object not found"},
                status=status.HTTP_409_CONFLICT,
            )

        try:
            src_url = create_presigned_get_url(key=video.file_key, expires_in=600)
        except Exception as e:
            video.error_reason = f"presigned_get_failed:{str(e)[:200]}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "presigned_get_failed"},
                status=status.HTTP_409_CONFLICT,
            )

        ok, meta, reason = _validate_source_media_via_ffprobe(src_url)

        if not ok and reason == "ffmpeg_module_missing":
            video.status = Video.Status.UPLOADED
            video.error_reason = ""
            video.save(update_fields=["status", "error_reason"])

            # ‚úÖ ÏóÖÎ°úÎìú ÏôÑÎ£å ‚Üí video-worker ÏûêÎèô Í∏∞Îèô
            _try_start_video_worker_instance()

            return Response(VideoSerializer(video).data)

        min_dur = _safe_int(getattr(settings, "VIDEO_MIN_DURATION_SECONDS", 3), 3)
        duration = _safe_int(meta.get("duration"), None)

        if duration is not None and duration < int(min_dur):  # MODIFIED
            video.duration = duration  # MODIFIED
            video.status = Video.Status.UPLOADED  # MODIFIED
            video.error_reason = ""  # MODIFIED
            video.save(update_fields=["status", "duration", "error_reason"])  # MODIFIED

            # ‚úÖ ÏóÖÎ°úÎìú ÏôÑÎ£å ‚Üí video-worker ÏûêÎèô Í∏∞Îèô
            _try_start_video_worker_instance()

            return Response(VideoSerializer(video).data)  # MODIFIED

        video.duration = duration
        video.status = Video.Status.UPLOADED
        video.error_reason = ""
        video.save(update_fields=["status", "duration", "error_reason"])

        # ‚úÖ ÏóÖÎ°úÎìú ÏôÑÎ£å ‚Üí video-worker ÏûêÎèô Í∏∞Îèô
        _try_start_video_worker_instance()

        return Response(VideoSerializer(video).data)

    # ==================================================
    # retry
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response(
                {"detail": "Cannot retry"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        video.status = Video.Status.UPLOADED
        video.save(update_fields=["status"])

        # ‚úÖ Ïû¨Ï≤òÎ¶¨ ÌÅê(HTTP polling)Î°ú ÎêòÎèåÎ¶¨Îäî ÏàúÍ∞ÑÏóêÎèÑ worker Í∏∞Îèô
        _try_start_video_worker_instance()

        return Response(
            {"detail": "Video reprocessing queued (HTTP worker polling)"},
            status=status.HTTP_202_ACCEPTED,
        )

    # ==================================================
    # stats (Í¥ÄÎ¶¨Ïûê ÏÉÅÏÑ∏)
    # ==================================================
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(
            lecture=lecture,
            status="ACTIVE",
        ).select_related("student")

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }
        perms = {
            p.enrollment_id: p
            for p in VideoPermission.objects.filter(video=video)
        }
        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            rule = perm.rule if perm else "free"
            effective_rule = rule
            if rule == "once" and vp and vp.completed:
                effective_rule = "free"

            students.append(
                {
                    "enrollment": e.id,
                    "student_name": e.student.name,
                    "attendance_status": attendance.get(e.id),
                    "progress": vp.progress if vp else 0,
                    "completed": vp.completed if vp else False,
                    "rule": rule,
                    "effective_rule": effective_rule,
                    "parent_phone": getattr(e.student, "parent_phone", None),
                    "student_phone": getattr(e.student, "phone", None),
                    "school": getattr(e.student, "school", None),
                    "grade": getattr(e.student, "grade", None),
                }
            )

        return Response(
            {
                "video": VideoDetailSerializer(video).data,
                "students": students,
                "total_filtered": len(students),
            }
        )

    # ==================================================
    # summary (ÌÜµÍ≥Ñ ÏöîÏïΩ)
    # ==================================================
    @action(detail=True, methods=["get"], url_path="summary")
    def summary(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        range_key = request.query_params.get("range", "7d")
        now = timezone.now()

        since = None
        if range_key == "24h":
            since = now - timedelta(hours=24)
        elif range_key == "7d":
            since = now - timedelta(days=7)

        enrollments = Enrollment.objects.filter(lecture=lecture)
        total = enrollments.count()

        progresses = VideoProgress.objects.filter(video=video)
        completed_count = progresses.filter(completed=True).count()

        duration = int(video.duration or 0)

        watched_seconds = 0
        for p in progresses.iterator():
            watched_seconds += int(float(p.progress or 0) * duration)

        completion_rate = (completed_count / total) if total else 0.0

        ev_qs = VideoPlaybackEvent.objects.filter(video=video).select_related(
            "enrollment", "enrollment__student"
        )

        if since:
            ev_qs = ev_qs.filter(occurred_at__gte=since)

        weights = {
            "VISIBILITY_HIDDEN": 1,
            "VISIBILITY_VISIBLE": 0,
            "FOCUS_LOST": 2,
            "FOCUS_GAINED": 0,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "FULLSCREEN_ENTER": 0,
            "FULLSCREEN_EXIT": 0,
            "PLAYER_ERROR": 1,
        }

        agg = {}
        for ev in ev_qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                }

            score = int(weights.get(ev.event_type, 1))
            if ev.violated:
                score *= 2
            if ev.violation_reason:
                score += 1

            agg[eid]["score"] += score

        risk_top = sorted(
            agg.values(),
            key=lambda x: x["score"],
            reverse=True,
        )[:5]

        return Response(
            {
                "video_id": video.id,
                "range": range_key,
                "total_students": total,
                "completed_count": completed_count,
                "completion_rate": completion_rate,
                "watched_seconds_est": watched_seconds,
                "risk_top": risk_top,
            }
        )

    # ==================================================
    # student list
    # ==================================================
    @action(
        detail=False,
        methods=["get"],
        url_path="student",
        permission_classes=[IsAuthenticated, IsStudent],
    )
    def student_list(self, request):
        return self._student_list_impl(request)
