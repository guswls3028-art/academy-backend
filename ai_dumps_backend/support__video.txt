====================================================================================================
# BACKEND APP: support__video
# ROOT PATH: C:\academy\apps\support\video
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# services package
#


==========================================================================================
# FILE: admin.py
==========================================================================================
from django.contrib import admin
from .models import (
    Video,
    VideoAccess,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


@admin.register(Video)
class VideoAdmin(admin.ModelAdmin):
    list_display = ("id", "title", "session", "order", "duration", "status")
    list_display_links = ("id", "title")
    list_filter = ("status", "session__lecture", "session")
    search_fields = ("title",)
    ordering = ("session", "order")


@admin.register(VideoAccess)
class VideoAccessAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "access_mode",
        "rule",
        "allow_skip_override",
        "max_speed_override",
        "show_watermark_override",
        "block_seek",
        "block_speed_control",
        "is_override",
        "proctored_completed_at",
    )
    list_display_links = ("id", "video")
    list_filter = ("access_mode", "rule", "video__session__lecture", "block_seek", "block_speed_control")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


@admin.register(VideoProgress)
class VideoProgressAdmin(admin.ModelAdmin):
    list_display = ("id", "video", "enrollment", "progress", "completed", "updated_at")
    list_display_links = ("id", "video")
    list_filter = ("video__session__lecture", "completed")
    search_fields = ("enrollment__student__name",)
    ordering = ("-updated_at",)


@admin.register(VideoPlaybackSession)
class VideoPlaybackSessionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "device_id",
        "status",
        "started_at",
        "ended_at",
    )
    list_filter = ("status", "video__session__lecture", "video")
    search_fields = ("session_id", "device_id", "enrollment__student__name")
    ordering = ("-started_at",)


@admin.register(VideoPlaybackEvent)
class VideoPlaybackEventAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "user_id",
        "event_type",
        "violated",
        "violation_reason",
        "occurred_at",
        "received_at",
    )
    list_filter = ("event_type", "violated", "video__session__lecture")
    search_fields = ("session_id", "enrollment__student__name", "user_id")
    ordering = ("-received_at",)


==========================================================================================
# FILE: constants.py
==========================================================================================
# PATH: apps/support/video/constants.py

from __future__ import annotations


class VideoStatus:
    """
    ‚ö†Ô∏è SSOT: models.Video.Status ÏôÄ Î∞òÎìúÏãú ÎèôÏùºÌï¥Ïïº ÌïúÎã§.

    - worker/API/servicesÏóêÏÑú Í≥µÌÜµÏúºÎ°ú Ïì∞Îäî "Ïô∏Î∂Ä ÏÉÅÏàò" Ïó≠Ìï†
    - Ïã§Ï†ú DB ÏÉÅÌÉú Î≥ÄÌôîÎäî Ìï≠ÏÉÅ Video.StatusÎ•º Í∏∞Ï§ÄÏúºÎ°ú ÌïúÎã§.
    """

    PENDING = "PENDING"
    UPLOADED = "UPLOADED"
    PROCESSING = "PROCESSING"
    READY = "READY"
    FAILED = "FAILED"

    CHOICES = (
        (PENDING, "Pending"),
        (UPLOADED, "Uploaded"),
        (PROCESSING, "Processing"),
        (READY, "Ready"),
        (FAILED, "Failed"),
    )


==========================================================================================
# FILE: drm.py
==========================================================================================
import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


==========================================================================================
# FILE: models.py
==========================================================================================
from django.db import models
from django.db.models import Q
from django.utils import timezone

from apps.core.models.base import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Access Mode (Video Access Policy)
# ========================================================

class AccessMode(models.TextChoices):
    """
    Video access mode enum.
    
    - FREE_REVIEW: Free review mode (no restrictions)
    - PROCTORED_CLASS: Proctored class mode (restrictions apply)
    - BLOCKED: Access blocked
    """
    FREE_REVIEW = "FREE_REVIEW", "Î≥µÏäµ"
    PROCTORED_CLASS = "PROCTORED_CLASS", "Ïò®ÎùºÏù∏ ÏàòÏóÖ ÎåÄÏ≤¥"
    BLOCKED = "BLOCKED", "Ï†úÌïú"


# ========================================================
# Video (ÏòÅÏÉÅ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞)
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "ÏóÖÎ°úÎìú ÎåÄÍ∏∞"
        UPLOADED = "UPLOADED", "ÏóÖÎ°úÎìú ÏôÑÎ£å"
        PROCESSING = "PROCESSING", "Ï≤òÎ¶¨Ï§ë"
        READY = "READY", "ÏÇ¨Ïö© Í∞ÄÎä•"
        FAILED = "FAILED", "Ïã§Ìå®"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # Ïç∏ÎÑ§ÏùºÏùÄ WorkerÍ∞Ä ÏÉùÏÑ±
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # Í∏∞Î≥∏ Ïû¨ÏÉù Ï†ïÏ±Ö (ÎπÑÎîîÏò§ Îã®ÏúÑ default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Ï†ïÏ±Ö Î≥ÄÍ≤Ω Ï¶âÏãú Î∞òÏòÅÏùÑ ÏúÑÌïú Î≤ÑÏ†Ñ (token versioning)
    # - Í∏∞Ï°¥ API Í≥ÑÏïΩ Íπ®ÏßÄÏßÄ ÏïäÍ≤å default=1
    # - Ï†ïÏ±Ö/Í∂åÌïú Î≥ÄÍ≤Ω Ïãú Ï¶ùÍ∞ÄÏãúÌÇ§Î©¥, Í∏∞Ï°¥ ÌÜ†ÌÅ∞ Ï¶âÏãú Î¨¥Ìö®Ìôî Í∞ÄÎä•
    # --------------------------------------------------
    policy_version = models.PositiveIntegerField(
        default=1,
        db_index=True,
        help_text="Increment on policy/permission changes to invalidate existing tokens",
    )

    # --------------------------------------------------
    # Worker Ïã§Ìå® ÏÇ¨Ïú† Í∏∞Î°ù
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    # ===============================
    # HLS Output (Worker Í≤∞Í≥º)
    # ===============================
    hls_path = models.CharField(
        max_length=500,
        blank=True,
        help_text="HLS master playlist path (relative to CDN root)",
    )

    # --------------------------------------------------
    # Worker Lease (Îã§Ï§ë ÎÖ∏Îìú Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄÏö©)
    # - Í∏∞Ï°¥ reclaim(updated_at Í∏∞Î∞ò) Íµ¨Ï°∞Î•º Ïú†ÏßÄÌïòÎ©¥ÏÑú,
    #   Ï§ëÏïô ÌÜµÏ†úÏö© lease Ï†ïÎ≥¥Î•º "Ï∂îÍ∞Ä"Î°ú Í∏∞Î°ùÌïúÎã§.
    # - ÏÑúÎ≤Ñ/ÏõåÏª§Í∞Ä ÏÑúÎ°ú ÎÇ¥Î∂Ä Íµ¨ÌòÑ Î™∞ÎùºÎèÑ ÎèôÏûë(Ìó§ÎçîÎßå ÏÇ¨Ïö©).
    # --------------------------------------------------
    processing_started_at = models.DateTimeField(null=True, blank=True)
    leased_until = models.DateTimeField(null=True, blank=True)
    leased_by = models.CharField(max_length=64, blank=True, default="")

    class Meta:
        ordering = ["order", "id"]
        indexes = [
            models.Index(fields=["status", "updated_at"]),
            models.Index(fields=["leased_until", "status"]),
        ]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        return "unknown"


# ========================================================
# Video Access (ÏàòÍ∞ïÏÉùÎ≥Ñ override + Ï†ëÍ∑º Í∑úÏπô)
# - Replaces VideoPermission semantics (SSOT)
# - DB table kept as video_videopermission for migration safety
# ========================================================

class VideoAccess(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    # Legacy field (deprecated, use access_mode instead)
    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "Î¨¥Ï†úÌïú"),
            ("once", "1Ìöå Ï†úÌïú"),
            ("blocked", "Ï†úÌïú"),
        ],
        default="free",
        null=True,
        blank=True,
        help_text="DEPRECATED: Use access_mode instead",
    )

    access_mode = models.CharField(
        max_length=20,
        choices=AccessMode.choices,
        default=AccessMode.FREE_REVIEW,
        db_index=True,
        help_text="Access mode: FREE_REVIEW, PROCTORED_CLASS, or BLOCKED",
    )

    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    # Set when PROCTORED_CLASS watch is completed -> auto-upgrade to FREE_REVIEW
    proctored_completed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the monitored class-substitute watch was completed",
    )

    class Meta:
        db_table = "video_videopermission"  # Keep existing table name
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.access_mode})"


# Backward compatibility alias
VideoPermission = VideoAccess


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (ÏÑ∏ÏÖò / Í∞êÏÇ¨)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "ÌôúÏÑ±"
        ENDED = "ENDED", "Ï¢ÖÎ£å"
        REVOKED = "REVOKED", "Ï∞®Îã®"
        EXPIRED = "EXPIRED", "ÎßåÎ£å"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)
    
    # DB-based session management fields (Redis removal)
    expires_at = models.DateTimeField(null=True, blank=True, db_index=True, help_text="Session expiration time")
    last_seen = models.DateTimeField(null=True, blank=True, help_text="Last heartbeat time")
    violated_count = models.IntegerField(default=0, help_text="Number of violations")
    total_count = models.IntegerField(default=0, help_text="Total event count")
    is_revoked = models.BooleanField(default=False, db_index=True, help_text="Whether session is revoked")

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]
        indexes = [
            models.Index(fields=["status", "started_at"]),
            models.Index(fields=["video", "enrollment", "status"]),
            models.Index(fields=["status", "expires_at"]),
            models.Index(fields=["enrollment", "status"]),
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "ÌÉ≠ Ïà®ÍπÄ"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "ÌÉ≠ ÎÖ∏Ï∂ú"
        FOCUS_LOST = "FOCUS_LOST", "Ìè¨Ïª§Ïä§ Ïù¥ÌÉà"
        FOCUS_GAINED = "FOCUS_GAINED", "Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "ÌÉêÏÉâ ÏãúÎèÑ"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "Î∞∞ÏÜç Î≥ÄÍ≤Ω ÏãúÎèÑ"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "Ï†ÑÏ≤¥ÌôîÎ©¥ ÏßÑÏûÖ"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "Ï†ÑÏ≤¥ÌôîÎ©¥ Ï¢ÖÎ£å"
        PLAYER_ERROR = "PLAYER_ERROR", "ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•ò"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"], name="vpe_session_idx"),
            models.Index(fields=["user_id", "session_id"], name="video_playback_event_user_idx"),
            # Î∂ÄÎ∂Ñ Ïù∏Îç±Ïä§: ÏúÑÎ∞ò Ïù¥Î≤§Ìä∏Îßå Ïù∏Îç±Ïã± (INSERT ÏÑ±Îä• Ìñ•ÏÉÅ, Ïù∏Îç±Ïä§ ÌÅ¨Í∏∞ 50% Í∞êÏÜå)
            models.Index(
                fields=["event_type", "received_at"],
                condition=models.Q(violated=True),
                name="vpe_violated_idx",
            ),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


==========================================================================================
# FILE: policy.py
==========================================================================================
from __future__ import annotations

from typing import Dict, Tuple, Optional


def evaluate_event_violation(
    *,
    event_type: str,
    policy: Dict,
    payload: Dict,
) -> Tuple[bool, Optional[str]]:
    """
    ÏÑúÎ≤Ñ Í∏∞Ï§Ä Ï†ïÏ±Ö ÏúÑÎ∞ò ÌåêÏ†ï (ÌîÑÎ°†Ìä∏ ÌòëÏ°∞ ÏóÜÏù¥)
    """
    if not policy:
        return False, None

    if event_type == "seek":
        if not policy.get("allow_skip", False):
            return True, "seek_not_allowed"

    if event_type == "speed":
        max_speed = policy.get("max_speed", 1.0)
        speed = float(payload.get("speed", 1.0))
        if speed > max_speed:
            return True, f"speed_exceeded:{speed}>{max_speed}"

    return False, None


def violation_should_revoke(*, violated_count: int, total: int) -> bool:
    """
    ÏúÑÎ∞ò ÎàÑÏ†Å Í∏∞Ï§Ä (Î≥¥ÏàòÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï)
    """
    if violated_count >= 3:
        return True
    if total > 0 and (violated_count / total) >= 0.5:
        return True
    return False


==========================================================================================
# FILE: serializers.py
==========================================================================================
# PATH: apps/support/video/serializers.py

from django.conf import settings
from rest_framework import serializers

from apps.domains.lectures.models import Session
from .models import (
    Video,
    VideoAccess,
    VideoProgress,
    VideoPlaybackEvent,
)

# ========================================================
# Video
# ========================================================

class VideoSerializer(serializers.ModelSerializer):
    """
    ‚úÖ FINAL SEALED VERSION (SaaS production)

    - DB Ï†ÄÏû• ÌïÑÎìúÏôÄ API ÎÖ∏Ï∂ú ÌïÑÎìú Î∂ÑÎ¶¨
    - CDN Í∏∞Î∞ò URL ÎèôÏ†Å ÏÉùÏÑ±
    - Cache-busting ÏßÄÏõê
    - Legacy Í≤ΩÎ°ú normalize
    """

    # write
    session = serializers.PrimaryKeyRelatedField(
        queryset=Session.objects.all(),
        write_only=True,
    )

    # read
    session_id = serializers.IntegerField(
        source="session.id",
        read_only=True,
    )

    source_type = serializers.SerializerMethodField()

    # CDN derived
    thumbnail_url = serializers.SerializerMethodField()
    hls_url = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session",
            "session_id",
            "title",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "thumbnail",
            "thumbnail_url",
            "hls_path",
            "hls_url",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = [
            "id",
            "session_id",
            "created_at",
            "updated_at",
            "thumbnail",
            "hls_path",
            "thumbnail_url",
            "hls_url",
        ]
        ref_name = "SealedVideo"

    # ---------------------------
    # helpers
    # ---------------------------

    def get_source_type(self, obj):
        return "s3" if obj.file_key else "unknown"

    def _cdn_base(self) -> str | None:
        base = getattr(settings, "CDN_HLS_BASE_URL", None)
        return base.rstrip("/") if base else None

    def _normalize_media_path(self, path: str) -> str:
        path = path.lstrip("/")

        if path.startswith("media/"):
            return path

        if path.startswith("storage/media/"):
            return path[len("storage/"):]

        return path

    def _cache_version(self, obj) -> int:
        try:
            return int(obj.updated_at.timestamp())
        except Exception:
            return 0

    # ---------------------------
    # CDN fields
    # ---------------------------

    def get_thumbnail_url(self, obj):
        cdn = self._cdn_base()
        if not cdn:
            return None

        # 1Ô∏è‚É£ explicit thumbnail
        if obj.thumbnail:
            path = self._normalize_media_path(obj.thumbnail.name)
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        # 2Ô∏è‚É£ READY fallback
        if obj.status == obj.Status.READY:
            path = self._normalize_media_path(
                f"media/hls/videos/{obj.session.lecture.tenant.code}/videos/{obj.id}/thumbnail.jpg"            )
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        return None

    def get_hls_url(self, obj):
        if not obj.hls_path:
            return None

        cdn = self._cdn_base()
        if not cdn:
            return None

        path = self._normalize_media_path(str(obj.hls_path))
        return f"{cdn}/{path}?v={self._cache_version(obj)}"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "SealedVideoDetail"


# ========================================================
# Permission / Progress
# ========================================================

class VideoAccessSerializer(serializers.ModelSerializer):
    """API uses access_mode (SSOT). DB table kept as video_videopermission."""
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoAccess
        fields = "__all__"
        ref_name = "SealedVideoAccess"


# Backward compat alias
VideoPermissionSerializer = VideoAccessSerializer


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    # ‚úÖ ÏßÑÌñâÎ•† % (ÌîÑÎ°†Ìä∏ ÌëúÏãúÏö©)
    progress_percent = serializers.SerializerMethodField()

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "SealedVideoProgress"

    def get_progress_percent(self, obj):
        try:
            return round(float(obj.progress or 0) * 100, 1)
        except Exception:
            return 0.0


# ========================================================
# Playback API
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField(allow_null=True, required=False)  # None for FREE_REVIEW
    expires_at = serializers.IntegerField(allow_null=True, required=False)  # None for FREE_REVIEW
    access_mode = serializers.ChoiceField(
        choices=["FREE_REVIEW", "PROCTORED_CLASS", "BLOCKED"],
        required=True,
    )
    monitoring_enabled = serializers.BooleanField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


# ========================================================
# Events
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(
        choices=VideoPlaybackEvent.EventType.choices
    )
    occurred_at = serializers.IntegerField(required=False)
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


# ========================================================
# Event List (Admin Analytics)
# ========================================================

class VideoPlaybackEventListSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )
    enrollment_id = serializers.IntegerField(
        source="enrollment.id",
        read_only=True,
    )

    severity = serializers.SerializerMethodField()
    score = serializers.SerializerMethodField()

    class Meta:
        model = VideoPlaybackEvent
        fields = [
            "id",
            "video",
            "enrollment_id",
            "student_name",
            "session_id",
            "user_id",
            "event_type",
            "violated",
            "violation_reason",
            "event_payload",
            "policy_snapshot",
            "occurred_at",
            "received_at",
            "severity",
            "score",
        ]
        ref_name = "SealedVideoPlaybackEventList"

    # ---------------------------
    # Risk classification
    # ---------------------------

    def get_severity(self, obj):
        base = {
            "SEEK_ATTEMPT": "warn",
            "SPEED_CHANGE_ATTEMPT": "warn",
            "FOCUS_LOST": "warn",
            "VISIBILITY_HIDDEN": "info",
            "PLAYER_ERROR": "info",
        }.get(obj.event_type, "info")

        return "danger" if obj.violated else base

    def get_score(self, obj):
        weights = {
            "VISIBILITY_HIDDEN": 1,
            "FOCUS_LOST": 2,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "PLAYER_ERROR": 1,
        }

        w = int(weights.get(obj.event_type, 1))

        if obj.violated:
            w *= 2
        if obj.violation_reason:
            w += 1

        return w


# ========================================================
# Aggregated Risk Row
# ========================================================

class VideoRiskRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    score = serializers.IntegerField()
    danger = serializers.IntegerField()
    warn = serializers.IntegerField()
    info = serializers.IntegerField()
    last_occurred_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/support/video/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
    VideoPlaybackEventViewSet,
    VideoProcessingCompleteView,
    VideoPolicyImpactAPIView,
)

from .views.achievement_views import VideoAchievementView
from .views.playback_views import (
    PlaybackStartView,
    PlaybackRefreshView,
    PlaybackHeartbeatView,
    PlaybackEndView,
    PlaybackEventBatchView,
)

# ========================================================
# Router
# ========================================================

router = DefaultRouter()
router.register(r"videos", VideoViewSet, basename="videos")
router.register(r"video-permissions", VideoPermissionViewSet, basename="video-permissions")
router.register(r"video-progress", VideoProgressViewSet, basename="video-progress")
router.register(r"video-playback-events", VideoPlaybackEventViewSet, basename="video-playback-events")

# ========================================================
# urlpatterns (ÏÑ†Ïñ∏ Î®ºÏ†Ä!)
# ========================================================

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / Extra APIs
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="video-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="video-video-stats-nested",
    ),
    path(
        "videos/<int:video_id>/achievement/",
        VideoAchievementView.as_view(),
        name="video-video-achievement",
    ),
]

# ========================================================
# Playback APIs (Student)
# ========================================================

urlpatterns += [
    path("playback/start/", PlaybackStartView.as_view()),
    path("playback/refresh/", PlaybackRefreshView.as_view()),
    path("playback/heartbeat/", PlaybackHeartbeatView.as_view()),
    path("playback/end/", PlaybackEndView.as_view()),
    path("playback/events/", PlaybackEventBatchView.as_view()),
]

# ========================================================
# Internal (Legacy ACK - kept)
# ========================================================

urlpatterns += [
    path(
        "internal/videos/<int:video_id>/processing-complete/",
        VideoProcessingCompleteView.as_view(),
        name="video-video-processing-complete",
    ),
]

# ========================================================
# Policy Impact (Admin preview)
# ========================================================

urlpatterns += [
    path(
        "videos/<int:video_id>/policy-impact/",
        VideoPolicyImpactAPIView.as_view(),
        name="video-video-policy-impact",
    ),
]


==========================================================================================
# FILE: urls_internal.py
==========================================================================================
# PATH: apps/support/video/urls_internal.py

from __future__ import annotations

from django.urls import path

# ==================================================
# ‚úÖ HTTP Polling ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï†úÍ±∞Îê® (SQS Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú Ï†ÑÌôò)
#
# Ï†úÍ±∞Îêú ÏóîÎìúÌè¨Ïù∏Ìä∏:
# - /video-worker/next/ (VideoWorkerClaimNextView)
# - /video-worker/<video_id>/complete/ (VideoWorkerCompleteView)
# - /video-worker/<video_id>/fail/ (VideoWorkerFailView)
# - /video-worker/<video_id>/heartbeat/ (InternalVideoWorkerHeartbeatView)
#
# ÏÉàÎ°úÏö¥ ÏïÑÌÇ§ÌÖçÏ≤ò:
# - SQS Í∏∞Î∞ò ÌÅê ÏÇ¨Ïö©
# - WorkerÎäî SQS Long PollingÏúºÎ°ú ÏûëÏóÖ ÏàòÏã†
# - ÏôÑÎ£å/Ïã§Ìå®Îäî VideoSQSQueue.complete_video() / fail_video() ÏÇ¨Ïö©
#
# Legacy Ìò∏ÌôòÏÑ±:
# - /api/v1/videos/internal/videos/<video_id>/processing-complete/ Ïú†ÏßÄ
#   (apps/support/video/urls.pyÏóê Ï†ïÏùòÎê®)
# ==================================================

urlpatterns = [
    # HTTP polling ÏóîÎìúÌè¨Ïù∏Ìä∏Îäî Î™®Îëê Ï†úÍ±∞Îê®
    # SQS Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú Ï†ÑÌôò ÏôÑÎ£å
]


==========================================================================================
# FILE: utils.py
==========================================================================================
# PATH: apps/support/video/utils.py

def extract_duration_seconds_from_url(url: str) -> int | None:
    """
    ffprobeÎ•º URLÏóê ÏßÅÏ†ë Ï†ÅÏö© (Range Request Í∏∞Î∞ò)

    ‚ö†Ô∏è API ÏÑúÎ≤Ñ ÏïàÏ†ÑÌôî:
    - ffmpeg Î™®Îìà ÏóÜÏúºÎ©¥ None Î∞òÌôò
    - API ÌÅ¨ÎûòÏãú Ï†àÎåÄ Î∞úÏÉù ‚ùå
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        probe = ffmpeg.probe(url)
        fmt = probe.get("format") or {}
        dur = fmt.get("duration")
        if dur is None:
            return None
        return int(float(dur))
    except Exception:
        return None


def generate_thumbnail_from_url(
    url: str,
    ss_seconds: int = 1,
) -> bytes | None:
    """
    URL Ïä§Ìä∏Î¶¨Î∞ç Í∏∞Î∞ò Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±

    üö´ API ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏÇ¨Ïö© Í∏àÏßÄ
    ‚úîÔ∏è Worker Ï†ÑÏö©

    - Ïã§Ìå® Ïãú None Î∞òÌôò
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        out, _ = (
            ffmpeg
            .input(url, ss=ss_seconds)
            .output(
                "pipe:",
                vframes=1,
                format="image2",
                vcodec="mjpeg",
            )
            .run(capture_stdout=True, capture_stderr=True)
        )
        return out
    except Exception:
        return None


==========================================================================================
# FILE: cdn/__init__.py
==========================================================================================
# CDN helpers package


==========================================================================================
# FILE: cdn/cloudflare_signing.py
==========================================================================================
# PATH: apps/support/video/cdn/cloudflare_signing.py

from __future__ import annotations

import base64
import hmac
import hashlib
from dataclasses import dataclass
from typing import Dict, Optional
from urllib.parse import urlencode


def _b64url(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).decode("ascii").rstrip("=")


@dataclass(frozen=True)
class CloudflareSignedURL:
    """
    CDN Edge(Cloudflare Worker Îì±)ÏóêÏÑú Í≤ÄÏ¶ù Í∞ÄÎä•Ìïú ÏøºÎ¶¨ ÏÑúÎ™Ö ÏÉùÏÑ±.
    - sig = HMAC-SHA256(secret, f"{path}|{exp}|{kid}|{uid}")
    - ÏøºÎ¶¨: exp, sig, kid, uid(ÏòµÏÖò)

    Ï£ºÏùò:
    - Î∞±ÏóîÎìúÎäî "ÏÉùÏÑ±"Îßå Îã¥Îãπ
    - Í≤ÄÏ¶ù/Ï∞®Îã®ÏùÄ CDN Î†àÏù¥Ïñ¥ÏóêÏÑú ÏàòÌñâ
    """
    secret: str
    key_id: str = "v1"

    def sign(self, *, path: str, expires_at: int, user_id: Optional[int] = None) -> Dict[str, str]:
        p = path if path.startswith("/") else f"/{path}"
        uid = "" if user_id is None else str(int(user_id))

        msg = f"{p}|{int(expires_at)}|{self.key_id}|{uid}".encode("utf-8")
        mac = hmac.new(self.secret.encode("utf-8"), msg, hashlib.sha256).digest()

        params = {
            "exp": str(int(expires_at)),
            "sig": _b64url(mac),
            "kid": self.key_id,
        }
        if user_id is not None:
            params["uid"] = str(int(user_id))
        return params

    def build_url(
        self,
        *,
        cdn_base: str,
        path: str,
        expires_at: int,
        user_id: Optional[int] = None,
        extra_query: Optional[Dict[str, str]] = None,
    ) -> str:
        base = (cdn_base or "").rstrip("/")
        p = path if path.startswith("/") else f"/{path}"

        q = {}
        if extra_query:
            q.update({k: str(v) for k, v in extra_query.items()})

        q.update(self.sign(path=p, expires_at=expires_at, user_id=user_id))
        return f"{base}{p}?{urlencode(q)}"


==========================================================================================
# FILE: management/__init__.py
==========================================================================================



==========================================================================================
# FILE: management/commands/__init__.py
==========================================================================================



==========================================================================================
# FILE: management/commands/expire_playback_sessions.py
==========================================================================================
# PATH: apps/support/video/management/commands/expire_playback_sessions.py
"""
Mark expired VideoPlaybackSession rows: ACTIVE with expires_at < now -> EXPIRED.

Run via cron (e.g. daily):
  python manage.py expire_playback_sessions

No Celery. No Redis.
"""
from django.core.management.base import BaseCommand
from django.utils import timezone

from apps.support.video.models import VideoPlaybackSession


class Command(BaseCommand):
    help = "Mark ACTIVE playback sessions with expires_at < now as EXPIRED"

    def handle(self, *args, **options):
        now = timezone.now()
        updated = VideoPlaybackSession.objects.filter(
            status=VideoPlaybackSession.Status.ACTIVE,
            expires_at__lt=now,
        ).update(
            status=VideoPlaybackSession.Status.EXPIRED,
            ended_at=now,
        )
        self.stdout.write(self.style.SUCCESS(f"Marked {updated} session(s) as EXPIRED"))


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-30 21:56

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("enrollment", "0001_initial"),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.CreateModel(
            name="Video",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                (
                    "file_key",
                    models.CharField(
                        blank=True,
                        help_text="S3 object key (presigned upload)",
                        max_length=500,
                    ),
                ),
                ("duration", models.PositiveIntegerField(blank=True, null=True)),
                ("order", models.PositiveIntegerField(default=1)),
                (
                    "thumbnail",
                    models.ImageField(blank=True, null=True, upload_to="thumbnails/"),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "ÏóÖÎ°úÎìú ÎåÄÍ∏∞"),
                            ("UPLOADED", "ÏóÖÎ°úÎìú ÏôÑÎ£å"),
                            ("PROCESSING", "Ï≤òÎ¶¨Ï§ë"),
                            ("READY", "ÏÇ¨Ïö© Í∞ÄÎä•"),
                            ("FAILED", "Ïã§Ìå®"),
                        ],
                        db_index=True,
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("allow_skip", models.BooleanField(default=False)),
                ("max_speed", models.FloatField(default=1.0)),
                ("show_watermark", models.BooleanField(default=True)),
                (
                    "policy_version",
                    models.PositiveIntegerField(
                        db_index=True,
                        default=1,
                        help_text="Increment on policy/permission changes to invalidate existing tokens",
                    ),
                ),
                ("error_reason", models.TextField(blank=True, default="", null=True)),
                (
                    "hls_path",
                    models.CharField(
                        blank=True,
                        help_text="HLS master playlist path (relative to CDN root)",
                        max_length=500,
                    ),
                ),
                ("processing_started_at", models.DateTimeField(blank=True, null=True)),
                ("leased_until", models.DateTimeField(blank=True, null=True)),
                ("leased_by", models.CharField(blank=True, default="", max_length=64)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="videos",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["order", "id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPermission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rule",
                    models.CharField(
                        choices=[
                            ("free", "Î¨¥Ï†úÌïú"),
                            ("once", "1Ìöå Ï†úÌïú"),
                            ("blocked", "Ï†úÌïú"),
                        ],
                        default="once",
                        max_length=20,
                    ),
                ),
                ("allow_skip_override", models.BooleanField(blank=True, null=True)),
                ("max_speed_override", models.FloatField(blank=True, null=True)),
                ("show_watermark_override", models.BooleanField(blank=True, null=True)),
                ("block_speed_control", models.BooleanField(default=False)),
                ("block_seek", models.BooleanField(default=False)),
                ("is_override", models.BooleanField(default=False)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_permissions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="permissions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoPlaybackEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("user_id", models.BigIntegerField(db_index=True)),
                (
                    "event_type",
                    models.CharField(
                        choices=[
                            ("VISIBILITY_HIDDEN", "ÌÉ≠ Ïà®ÍπÄ"),
                            ("VISIBILITY_VISIBLE", "ÌÉ≠ ÎÖ∏Ï∂ú"),
                            ("FOCUS_LOST", "Ìè¨Ïª§Ïä§ Ïù¥ÌÉà"),
                            ("FOCUS_GAINED", "Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä"),
                            ("SEEK_ATTEMPT", "ÌÉêÏÉâ ÏãúÎèÑ"),
                            ("SPEED_CHANGE_ATTEMPT", "Î∞∞ÏÜç Î≥ÄÍ≤Ω ÏãúÎèÑ"),
                            ("FULLSCREEN_ENTER", "Ï†ÑÏ≤¥ÌôîÎ©¥ ÏßÑÏûÖ"),
                            ("FULLSCREEN_EXIT", "Ï†ÑÏ≤¥ÌôîÎ©¥ Ï¢ÖÎ£å"),
                            ("PLAYER_ERROR", "ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•ò"),
                        ],
                        db_index=True,
                        max_length=32,
                    ),
                ),
                ("event_payload", models.JSONField(blank=True, default=dict)),
                ("policy_snapshot", models.JSONField(blank=True, default=dict)),
                ("violated", models.BooleanField(db_index=True, default=False)),
                (
                    "violation_reason",
                    models.CharField(blank=True, default="", max_length=64),
                ),
                (
                    "occurred_at",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                ("received_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_playback_events",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_events",
                        to="video.video",
                    ),
                ),
            ],
            options={
                "ordering": ["-received_at", "-id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackSession",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("device_id", models.CharField(db_index=True, max_length=128)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "ÌôúÏÑ±"),
                            ("ENDED", "Ï¢ÖÎ£å"),
                            ("REVOKED", "Ï∞®Îã®"),
                            ("EXPIRED", "ÎßåÎ£å"),
                        ],
                        db_index=True,
                        default="ACTIVE",
                        max_length=16,
                    ),
                ),
                ("started_at", models.DateTimeField(auto_now_add=True)),
                ("ended_at", models.DateTimeField(blank=True, null=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoProgress",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("progress", models.FloatField(default=0)),
                ("last_position", models.IntegerField(default=0)),
                ("completed", models.BooleanField(default=False)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_progress",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="progresses",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["status", "updated_at"], name="video_video_status_782ba3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["leased_until", "status"], name="video_video_leased__a8f039_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="videopermission",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_permission"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["video", "enrollment", "session_id"],
                name="video_video_video_i_1ea099_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["user_id", "session_id"], name="video_video_user_id_474fa3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["event_type", "received_at"],
                name="video_video_event_t_b8ca86_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["status", "started_at"], name="video_video_status_175f42_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["video", "enrollment", "status"],
                name="video_video_video_i_5d0bbd_idx",
            ),
        ),
        migrations.AddConstraint(
            model_name="videoplaybacksession",
            constraint=models.UniqueConstraint(
                fields=("session_id",), name="uniq_video_playback_session_id"
            ),
        ),
        migrations.AddConstraint(
            model_name="videoprogress",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_progress"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0002_add_playback_session_fields.py
==========================================================================================
# Generated migration: Add fields to VideoPlaybackSession for DB-based session management

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('video', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='videoplaybacksession',
            name='expires_at',
            field=models.DateTimeField(null=True, blank=True, db_index=True, help_text='Session expiration time'),
        ),
        migrations.AddField(
            model_name='videoplaybacksession',
            name='last_seen',
            field=models.DateTimeField(null=True, blank=True, help_text='Last heartbeat time'),
        ),
        migrations.AddField(
            model_name='videoplaybacksession',
            name='violated_count',
            field=models.IntegerField(default=0, help_text='Number of violations'),
        ),
        migrations.AddField(
            model_name='videoplaybacksession',
            name='total_count',
            field=models.IntegerField(default=0, help_text='Total event count'),
        ),
        migrations.AddField(
            model_name='videoplaybacksession',
            name='is_revoked',
            field=models.BooleanField(default=False, db_index=True, help_text='Whether session is revoked'),
        ),
        migrations.AddIndex(
            model_name='videoplaybacksession',
            index=models.Index(fields=['status', 'expires_at'], name='video_playback_status_expires_idx'),
        ),
        migrations.AddIndex(
            model_name='videoplaybacksession',
            index=models.Index(fields=['enrollment', 'status'], name='video_playback_enrollment_status_idx'),
        ),
    ]


==========================================================================================
# FILE: migrations/0003_add_access_mode_field.py
==========================================================================================
# Generated migration for access_mode field

from django.db import migrations, models


def migrate_rule_to_access_mode(apps, schema_editor):
    """
    Migrate existing rule values to access_mode:
    - free ‚Üí FREE_REVIEW
    - once ‚Üí PROCTORED_CLASS
    - blocked ‚Üí BLOCKED
    """
    VideoPermission = apps.get_model('video', 'VideoPermission')
    
    # Map legacy rule to access_mode
    rule_mapping = {
        'free': 'FREE_REVIEW',
        'once': 'PROCTORED_CLASS',
        'blocked': 'BLOCKED',
    }
    
    for perm in VideoPermission.objects.all():
        rule_value = perm.rule or 'free'
        access_mode_value = rule_mapping.get(rule_value, 'FREE_REVIEW')
        perm.access_mode = access_mode_value
        perm.save(update_fields=['access_mode'])


class Migration(migrations.Migration):

    dependencies = [
        ('video', '0002_add_playback_session_fields'),
    ]

    operations = [
        # Add access_mode field
        migrations.AddField(
            model_name='videopermission',
            name='access_mode',
            field=models.CharField(
                max_length=20,
                choices=[
                    ('FREE_REVIEW', 'Î≥µÏäµ'),
                    ('PROCTORED_CLASS', 'Ïò®ÎùºÏù∏ ÏàòÏóÖ ÎåÄÏ≤¥'),
                    ('BLOCKED', 'Ï†úÌïú'),
                ],
                default='FREE_REVIEW',
                db_index=True,
                help_text='Access mode: FREE_REVIEW, PROCTORED_CLASS, or BLOCKED',
            ),
        ),
        
        # Migrate existing rule values to access_mode
        migrations.RunPython(
            code=migrate_rule_to_access_mode,
            reverse_code=migrations.RunPython.noop,
        ),
        
        # Make rule field nullable for backward compatibility
        migrations.AlterField(
            model_name='videopermission',
            name='rule',
            field=models.CharField(
                max_length=20,
                choices=[
                    ('free', 'Î¨¥Ï†úÌïú'),
                    ('once', '1Ìöå Ï†úÌïú'),
                    ('blocked', 'Ï†úÌïú'),
                ],
                default='free',
                null=True,
                blank=True,
                help_text='DEPRECATED: Use access_mode instead',
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/0004_video_access_refactor.py
==========================================================================================
# Generated migration for VideoPermission -> VideoAccess refactor (SSOT)
# - Renames model in Django state only (keeps DB table video_videopermission)
# - Adds proctored_completed_at field

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("video", "0003_add_access_mode_field"),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RenameModel(
                    old_name="VideoPermission",
                    new_name="VideoAccess",
                ),
                migrations.AlterModelTable(
                    name="videoaccess",
                    table="video_videopermission",
                ),
            ],
            database_operations=[],
        ),
        migrations.AddField(
            model_name="videoaccess",
            name="proctored_completed_at",
            field=models.DateTimeField(
                blank=True,
                null=True,
                help_text="When the monitored class-substitute watch was completed (auto-upgrade to FREE_REVIEW)",
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/__init__.py
==========================================================================================
# Video services
from .sqs_queue import VideoSQSQueue

__all__ = ["VideoSQSQueue"]


==========================================================================================
# FILE: services/access_resolver.py
==========================================================================================
# PATH: apps/support/video/services/access_resolver.py

"""
Single Source of Truth for video access mode resolution.

Business Logic (SSOT):
- Default: FREE_REVIEW (unlimited review, no monitoring, no DB session/event writes)
- PROCTORED_CLASS: Only for students with Attendance.status == "ONLINE" for that session
  - First watch = class substitute: strict policy + monitoring + audit
  - After completion (VideoProgress.completed OR VideoAccess.proctored_completed_at):
    -> automatically FREE_REVIEW for that video
- Offline students: majority, never monitored
"""

from typing import Optional

from apps.domains.attendance.models import Attendance
from apps.domains.enrollment.models import Enrollment
from apps.support.video.models import Video, VideoProgress, VideoAccess, AccessMode


def resolve_access_mode(
    *,
    video: Video,
    enrollment: Enrollment,
    session_id: Optional[int] = None,
) -> AccessMode:
    """
    Resolve access mode for a video-enrollment pair (SSOT).

    Given: video, enrollment (session from video.session)
    1) BLOCKED if explicit VideoAccess override says so
    2) Attendance.status == "ONLINE" => candidate for PROCTORED_CLASS
    3) Else => FREE_REVIEW
    4) If ONLINE: check completion (VideoProgress.completed OR VideoAccess.proctored_completed_at)
       - Completed => FREE_REVIEW
       - Not completed => PROCTORED_CLASS
    """
    perm = VideoAccess.objects.filter(
        video=video,
        enrollment=enrollment,
    ).first()

    if perm and perm.access_mode == AccessMode.BLOCKED:
        return AccessMode.BLOCKED

    session = video.session
    attendance = Attendance.objects.filter(
        session=session,
        enrollment=enrollment,
    ).first()

    # Only ONLINE attendance gets PROCTORED_CLASS (not SUPPLEMENT per spec)
    if not attendance or attendance.status != "ONLINE":
        return AccessMode.FREE_REVIEW

    # Online: check if already completed (first watch done)
    progress = VideoProgress.objects.filter(
        video=video,
        enrollment=enrollment,
    ).first()

    if progress and progress.completed:
        return AccessMode.FREE_REVIEW

    if perm and perm.proctored_completed_at is not None:
        return AccessMode.FREE_REVIEW

    return AccessMode.PROCTORED_CLASS


def get_effective_access_mode(
    *,
    video: Video,
    enrollment: Enrollment,
    session_id: Optional[int] = None,
) -> AccessMode:
    """
    Effective access mode considering admin overrides.
    """
    perm = VideoAccess.objects.filter(
        video=video,
        enrollment=enrollment,
    ).first()

    if perm and perm.is_override:
        return perm.access_mode

    return resolve_access_mode(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
    )


==========================================================================================
# FILE: services/playback_session.py
==========================================================================================
# PATH: apps/support/video/services/playback_session.py

import uuid
from typing import Dict, Any, Tuple, Optional
from datetime import timedelta

from django.conf import settings
from django.utils import timezone
from django.db import transaction
from django.db.models import Q, Count

from apps.domains.enrollment.models import Enrollment
from apps.support.video.models import (
    Video,
    VideoPlaybackSession,
)

# Redis Î≥¥Ìò∏ Î†àÏù¥Ïñ¥ (ÏÑ†ÌÉùÏ†Å, Ïû•Ïï† Ïãú DB fallback)
try:
    from libs.redis import is_redis_available
    from libs.redis.watch_buffer import (
        init_session_redis,
        buffer_heartbeat_session_ttl,
        buffer_session_event,
        get_session_violation_stats_redis,
        flush_session_stats,
        flush_session_buffer,
    )
except ImportError:
    def is_redis_available():
        return False
    def init_session_redis(*args, **kwargs):
        return False
    def buffer_heartbeat_session_ttl(*args, **kwargs):
        return False
    def buffer_session_event(*args, **kwargs):
        return False, {"total": 0, "violated": 0}
    def get_session_violation_stats_redis(*args, **kwargs):
        return None
    def flush_session_stats(*args, **kwargs):
        pass
    def flush_session_buffer(*args, **kwargs):
        return False


# =======================================================
# DB-based Session Management (Redis Ï†úÍ±∞Îê®)
# =======================================================

def _cleanup_expired_sessions(student_id: int) -> None:
    """
    ÎßåÎ£åÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨ (DB Í∏∞Î∞ò)
    """
    now = timezone.now()
    VideoPlaybackSession.objects.filter(
        enrollment__student_id=student_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        expires_at__lt=now,
    ).update(
        status=VideoPlaybackSession.Status.EXPIRED,
        ended_at=now,
    )


def issue_session(
    *,
    student_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    """
    DB Í∏∞Î∞ò Ïû¨ÏÉù ÏÑ∏ÏÖò Î∞úÍ∏â
    """
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(student_id)

    now = timezone.now()
    expires_at = now + timedelta(seconds=ttl_seconds)

    # Í∏∞Í∏∞ Ï†úÌïú ÌôïÏù∏
    active_devices = VideoPlaybackSession.objects.filter(
        enrollment__student_id=student_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        expires_at__gt=now,
    ).values_list("device_id", flat=True).distinct()

    unique_devices = set(active_devices)
    if device_id not in unique_devices and len(unique_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    # ÎèôÏãú ÏÑ∏ÏÖò Ï†úÌïú ÌôïÏù∏
    active_count = VideoPlaybackSession.objects.filter(
        enrollment__student_id=student_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        expires_at__gt=now,
    ).count()

    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    return True, {"session_id": session_id, "expires_at": int(expires_at.timestamp())}, None


def heartbeat_session(*, student_id: int, session_id: str, ttl_seconds: int) -> bool:
    """
    ÏÑ∏ÏÖò TTL Ïó∞Ïû•
    - Redis ÏÇ¨Ïö© Ïãú: DB Ïì∞Í∏∞ ÏóÜÏù¥ RedisÏóêÎßå Î≤ÑÌçºÎßÅ (Write-Behind)
    - Redis ÎØ∏ÏÇ¨Ïö©/Ïû•Ïï† Ïãú: Í∏∞Ï°¥ DB Í∏∞Î∞ò Î°úÏßÅ
    """
    if is_redis_available():
        ok = buffer_heartbeat_session_ttl(session_id=session_id, ttl_seconds=ttl_seconds)
        if ok:
            return True
        # Redis Ïã§Ìå® Ïãú DB fallback

    now = timezone.now()
    new_expires_at = now + timedelta(seconds=ttl_seconds)

    try:
        session = VideoPlaybackSession.objects.select_related(
            "enrollment"
        ).get(
            session_id=session_id,
            enrollment__student_id=student_id,
            status=VideoPlaybackSession.Status.ACTIVE,
        )
    except VideoPlaybackSession.DoesNotExist:
        return False

    if session.is_revoked:
        return False

    session.expires_at = new_expires_at
    session.last_seen = now
    session.save(update_fields=["expires_at", "last_seen"])

    return True


def end_session(*, student_id: int, session_id: str) -> None:
    """
    Î™ÖÏãúÏ†Å ÏÑ∏ÏÖò Ï¢ÖÎ£å
    - Redis ÏÇ¨Ïö© Ïãú: Write-Behind flush (Redis stats ‚Üí DB) ÌõÑ Ï¢ÖÎ£å
    - Redis ÎØ∏ÏÇ¨Ïö© Ïãú: Í∏∞Ï°¥ DB Í∏∞Î∞ò
    """
    now = timezone.now()

    if is_redis_available():
        stats = get_session_violation_stats_redis(session_id)
        if stats is not None:
            VideoPlaybackSession.objects.filter(
                session_id=session_id,
                enrollment__student_id=student_id,
                status=VideoPlaybackSession.Status.ACTIVE,
            ).update(
                last_seen=now,
                violated_count=stats.get("violated", 0),
                total_count=stats.get("total", 0),
                status=VideoPlaybackSession.Status.ENDED,
                ended_at=now,
            )
            flush_session_stats(session_id)
            flush_session_buffer(session_id)
            return

    VideoPlaybackSession.objects.filter(
        session_id=session_id,
        enrollment__student_id=student_id,
        status=VideoPlaybackSession.Status.ACTIVE,
    ).update(
        status=VideoPlaybackSession.Status.ENDED,
        ended_at=now,
    )


def revoke_session(*, student_id: int, session_id: str) -> None:
    """
    ÏÑúÎ≤Ñ Í∞ïÏ†ú Ï∞®Îã®
    - Redis ÏÇ¨Ïö© Ïãú: Write-Behind flush ÌõÑ Ï∞®Îã®
    """
    now = timezone.now()

    if is_redis_available():
        stats = get_session_violation_stats_redis(session_id)
        if stats is not None:
            VideoPlaybackSession.objects.filter(
                session_id=session_id,
                enrollment__student_id=student_id,
            ).update(
                last_seen=now,
                violated_count=stats.get("violated", 0),
                total_count=stats.get("total", 0),
                status=VideoPlaybackSession.Status.REVOKED,
                is_revoked=True,
                ended_at=now,
            )
            flush_session_stats(session_id)
            flush_session_buffer(session_id)
            return

    VideoPlaybackSession.objects.filter(
        session_id=session_id,
        enrollment__student_id=student_id,
    ).update(
        status=VideoPlaybackSession.Status.REVOKED,
        is_revoked=True,
        ended_at=now,
    )


def is_session_active(*, student_id: int, session_id: str) -> bool:
    """
    ÏÑ∏ÏÖò ÌôúÏÑ± Ïó¨Î∂Ä ÌôïÏù∏
    - Redis ÏÇ¨Ïö© Ïãú: session:{session_id}:meta Ï°¥Ïû¨ Ïó¨Î∂Ä (heartbeatÎ°ú TTL Ïó∞Ïû•)
    - Redis ÎØ∏ÏÇ¨Ïö©/Ïû•Ïï† Ïãú: DB Í∏∞Î∞ò
    """
    if is_redis_available():
        try:
            from libs.redis.client import get_redis_client
            client = get_redis_client()
            if client and client.exists(f"session:{session_id}:meta"):
                return True
            # RedisÏóê ÌÇ§ ÏóÜÏúºÎ©¥ DB fallback (ÏÑ∏ÏÖò ÏãúÏûë ÏßÅÌõÑ Ï≤´ heartbeat Ï†Ñ)
        except Exception:
            pass

    now = timezone.now()

    try:
        session = VideoPlaybackSession.objects.select_related(
            "enrollment"
        ).get(
            session_id=session_id,
            enrollment__student_id=student_id,
        )
    except VideoPlaybackSession.DoesNotExist:
        return False

    if session.is_revoked:
        return False

    if session.status != VideoPlaybackSession.Status.ACTIVE:
        return False

    if session.expires_at and session.expires_at <= now:
        session.status = VideoPlaybackSession.Status.EXPIRED
        session.ended_at = now
        session.save(update_fields=["status", "ended_at"])
        return False

    return True


# =======================================================
# ÏÑ∏ÏÖò Îã®ÏúÑ ÏúÑÎ∞ò ÎàÑÏ†Å (DB Í∏∞Î∞ò)
# =======================================================

def record_session_event(
    *,
    student_id: int,
    session_id: str,
    violated: bool,
    reason: str = "",
) -> Dict[str, int]:
    """
    ÏÑ∏ÏÖò Îã®ÏúÑ ÎàÑÏ†Å Ïπ¥Ïö¥ÌÑ∞
    - Redis ÏÇ¨Ïö© Ïãú: DB Ïì∞Í∏∞ ÏóÜÏù¥ RedisÏóêÎßå Î≤ÑÌçºÎßÅ (Write-Behind)
    - Redis ÎØ∏ÏÇ¨Ïö©/Ïû•Ïï† Ïãú: DB Í∏∞Î∞ò
    """
    if is_redis_available():
        ok, stats = buffer_session_event(
            session_id=session_id,
            user_id=student_id,
            violated=violated,
            reason=reason,
        )
        if ok:
            return stats
        # Redis Ïã§Ìå® Ïãú DB fallback

    try:
        session = VideoPlaybackSession.objects.select_related(
            "enrollment"
        ).get(
            session_id=session_id,
            enrollment__student_id=student_id,
        )
    except VideoPlaybackSession.DoesNotExist:
        return {"total": 0, "violated": 0}

    with transaction.atomic():
        session.refresh_from_db()
        session.total_count += 1
        if violated:
            session.violated_count += 1
        session.save(update_fields=["total_count", "violated_count"])

    return {
        "total": session.total_count,
        "violated": session.violated_count,
    }


def get_session_violation_stats(*, session_id: str) -> Dict[str, int]:
    """
    ÏÑ∏ÏÖò ÏúÑÎ∞ò ÌÜµÍ≥Ñ Ï°∞Ìöå
    - Redis ÏÇ¨Ïö© Ïãú: RedisÏóêÏÑú Ï°∞Ìöå (Ïã§ÏãúÍ∞Ñ)
    - Redis ÎØ∏ÏÇ¨Ïö©/Ïû•Ïï† Ïãú: DB Í∏∞Î∞ò
    """
    if is_redis_available():
        stats = get_session_violation_stats_redis(session_id)
        if stats is not None:
            return stats

    try:
        session = VideoPlaybackSession.objects.get(session_id=session_id)
        return {
            "total": session.total_count,
            "violated": session.violated_count,
        }
    except VideoPlaybackSession.DoesNotExist:
        return {"total": 0, "violated": 0}


def should_revoke_by_stats(*, violated: int, total: int) -> bool:
    """
    Î≥¥ÏàòÏ†Å Ï∞®Îã® Í∏∞Ï§Ä:
    - violated >= threshold
    - ÎòêÎäî violated/total ÎπÑÏú®Ïù¥ ÎÑàÎ¨¥ ÎÜíÏúºÎ©¥ Ï∞®Îã®
    """
    threshold = int(getattr(settings, "VIDEO_VIOLATION_REVOKE_THRESHOLD", 3))
    ratio = float(getattr(settings, "VIDEO_VIOLATION_REVOKE_RATIO", 0.5))

    if int(violated) >= threshold:
        return True
    if int(total) > 0 and (float(violated) / float(total)) >= ratio:
        return True
    return False


# =======================================================
# Facade API (Student ONLY) - Í∏∞Ï°¥ Ïú†ÏßÄ
# =======================================================

def create_playback_session(
    *,
    user,
    video_id: int,
    enrollment_id: int,
    device_id: str,
) -> dict:
    """
    ÌïôÏÉù Ï†ÑÏö© Facade API

    Ï±ÖÏûÑ:
    - "Ïû¨ÏÉù ÏÑ∏ÏÖò ÏÉùÏÑ±"Îßå Îã¥Îãπ
    - Í∂åÌïú / ÏàòÍ∞ï Í≤ÄÏ¶ùÏùÄ ViewÏóêÏÑú ÏÑ†ÌñâÎêòÏñ¥Ïïº Ìï®
    """

    # üö´ Í∞ïÏÇ¨ / Ïö¥ÏòÅÏûê Ï∞®Îã®
    if getattr(user, "is_instructor", False) or getattr(user, "is_staff", False):
        return {
            "ok": False,
            "error": "instructor_must_use_play_api",
        }

    if not device_id:
        return {"ok": False, "error": "device_id_required"}

    video = Video.objects.select_related(
        "session",
        "session__lecture",
    ).get(id=video_id)

    enrollment = Enrollment.objects.select_related(
        "student",
        "lecture",
    ).get(
        id=enrollment_id,
        status="ACTIVE",
    )

    # üõ°Ô∏è ÏïàÏ†Ñ Í∞ÄÎìú (View ÎàÑÎùΩ Î∞©ÏßÄÏö©)
    if enrollment.lecture_id != video.session.lecture_id:
        return {
            "ok": False,
            "error": "enrollment_lecture_mismatch",
        }

    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    ok, sess, err = issue_session(
        student_id=enrollment.student_id,
        device_id=device_id,
        ttl_seconds=ttl,
        max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
        max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
    )

    if not ok:
        return {
            "ok": False,
            "error": err,
        }

    session_id = str(sess["session_id"])
    expires_at_timestamp = int(sess["expires_at"])
    expires_at = timezone.datetime.fromtimestamp(expires_at_timestamp, tz=timezone.utc)

    VideoPlaybackSession.objects.create(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
        device_id=device_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        started_at=timezone.now(),
        expires_at=expires_at,
        last_seen=timezone.now(),
        violated_count=0,
        total_count=0,
        is_revoked=False,
    )

    return {
        "ok": True,
        "video_id": video.id,
        "enrollment_id": enrollment.id,
        "session_id": session_id,
        "expires_at": expires_at_timestamp,
    }


==========================================================================================
# FILE: services/sqs_queue.py
==========================================================================================
"""
SQS Í∏∞Î∞ò Video Job Queue

Í∏∞Ï°¥ VideoJobQueue (DB Í∏∞Î∞ò)Î•º SQSÎ°ú ÍµêÏ≤¥
"""

from __future__ import annotations

import json
import logging
from typing import Optional

from django.conf import settings
from django.db import transaction
from django.utils import timezone

from apps.support.video.models import Video
from libs.queue import get_queue_client

logger = logging.getLogger(__name__)


class VideoSQSQueue:
    """
    SQS Í∏∞Î∞ò Video Job Queue
    
    Î©îÏãúÏßÄ ÌòïÏãù:
    {
        "video_id": int,
        "file_key": str,
        "tenant_code": str,
        "created_at": "ISO8601",
        "attempt": int  # Ïû¨ÏãúÎèÑ ÌöüÏàò
    }
    """

    QUEUE_NAME = "academy-video-jobs"
    DLQ_NAME = "academy-video-jobs-dlq"
    
    # Î©îÏãúÏßÄ ÏÜçÏÑ±
    MAX_RECEIVE_COUNT = 3  # DLQÎ°ú Ï†ÑÏÜ° Ï†Ñ ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò
    
    def __init__(self):
        self.queue_client = get_queue_client()
    
    def _get_queue_name(self) -> str:
        """ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•"""
        return getattr(settings, "VIDEO_SQS_QUEUE_NAME", self.QUEUE_NAME)
    
    def _get_dlq_name(self) -> str:
        """ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•"""
        return getattr(settings, "VIDEO_SQS_DLQ_NAME", self.DLQ_NAME)
    
    def enqueue(self, video: Video) -> bool:
        """
        ÎπÑÎîîÏò§ ÏûëÏóÖÏùÑ SQSÏóê Ï∂îÍ∞Ä
        
        Args:
            video: Video Í∞ùÏ≤¥ (statusÍ∞Ä UPLOADEDÏó¨Ïïº Ìï®)
            
        Returns:
            bool: ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        if video.status != Video.Status.UPLOADED:
            logger.warning(
                "Cannot enqueue video %s: status=%s (expected UPLOADED)",
                video.id,
                video.status,
            )
            return False
        
        # tenant_code Í∞ÄÏ†∏Ïò§Í∏∞
        try:
            tenant_code = video.session.lecture.tenant.code
        except Exception:
            logger.error("Cannot get tenant_code for video %s", video.id)
            return False
        
        message = {
            "video_id": int(video.id),
            "file_key": str(video.file_key or ""),
            "tenant_code": str(tenant_code),
            "created_at": timezone.now().isoformat(),
            "attempt": 1,
        }
        
        try:
            success = self.queue_client.send_message(
                queue_name=self._get_queue_name(),
                message=message,
            )
            
            if success:
                logger.info("Video job enqueued: video_id=%s", video.id)
            else:
                logger.error("Failed to enqueue video job: video_id=%s", video.id)
            
            return success
            
        except Exception as e:
            logger.exception("Error enqueuing video job: video_id=%s, error=%s", video.id, e)
            return False
    
    def receive_message(self, wait_time_seconds: int = 20) -> Optional[dict]:
        """
        SQSÏóêÏÑú Î©îÏãúÏßÄ ÏàòÏã† (Long Polling)
        
        Args:
            wait_time_seconds: Long Polling ÎåÄÍ∏∞ ÏãúÍ∞Ñ (ÏµúÎåÄ 20Ï¥à)
            
        Returns:
            dict: Î©îÏãúÏßÄ (video_id, file_key, tenant_code, receipt_handle Ìè¨Ìï®) ÎòêÎäî None
        """
        try:
            message = self.queue_client.receive_message(
                queue_name=self._get_queue_name(),
                wait_time_seconds=wait_time_seconds,
            )
            
            if not message:
                return None
            
            # SQS Î©îÏãúÏßÄ ÌòïÏãùÏóê Îî∞Îùº ÌååÏã±
            body = message.get("Body", "")
            receipt_handle = message.get("ReceiptHandle")
            
            # BodyÎäî Ìï≠ÏÉÅ JSON Î¨∏ÏûêÏó¥
            if isinstance(body, str):
                try:
                    job_data = json.loads(body)
                except json.JSONDecodeError:
                    logger.error("Invalid JSON in message: %s", body)
                    return None
            else:
                job_data = body
            
            # Î©îÏãúÏßÄ ÌòïÏãù Í≤ÄÏ¶ù
            if not isinstance(job_data, dict) or "video_id" not in job_data:
                logger.error("Invalid message format: %s", job_data)
                return None
            
            # ReceiptHandle ÌïÑÏàò (SQS)
            if not receipt_handle:
                logger.error("Missing ReceiptHandle in SQS message")
                return None
            
            # ÏûëÏóÖ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò (Î°úÍ∑∏ Í∞ÄÏãúÏÑ±: created_at Ìè¨Ìï®)
            return {
                "video_id": int(job_data.get("video_id")),
                "file_key": str(job_data.get("file_key", "")),
                "tenant_code": str(job_data.get("tenant_code", "")),
                "receipt_handle": receipt_handle,
                "message_id": message.get("MessageId"),
                "created_at": job_data.get("created_at"),  # SQS Î©îÏãúÏßÄ ÏàòÎ™Ö Ï∂îÏ†ÅÏö©
            }
            
        except Exception as e:
            logger.exception("Error receiving message from SQS: %s", e)
            return None
    
    def delete_message(self, receipt_handle: str) -> bool:
        """
        Ï≤òÎ¶¨ ÏôÑÎ£åÎêú Î©îÏãúÏßÄ ÏÇ≠Ï†ú
        
        Args:
            receipt_handle: SQS Î©îÏãúÏßÄ ReceiptHandle
            
        Returns:
            bool: ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        try:
            return self.queue_client.delete_message(
                queue_name=self._get_queue_name(),
                receipt_handle=receipt_handle,
            )
        except Exception as e:
            logger.exception("Error deleting message: receipt_handle=%s, error=%s", receipt_handle, e)
            return False
    
    def mark_failed(self, receipt_handle: str, reason: str) -> bool:
        """
        Ïã§Ìå®Ìïú Î©îÏãúÏßÄ Ï≤òÎ¶¨
        
        SQSÏùò ÏûêÎèô DLQ Ï†ÑÏÜ°ÏùÑ ÏÇ¨Ïö©ÌïòÎØÄÎ°ú, Ïó¨Í∏∞ÏÑúÎäî Î©îÏãúÏßÄÎßå ÏÇ≠Ï†ú
        (Ïû¨ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º Ïãú ÏûêÎèôÏúºÎ°ú DLQÎ°ú Ïù¥Îèô)
        
        ÎòêÎäî ÏàòÎèôÏúºÎ°ú DLQÏóê Ï†ÑÏÜ°Ìï† ÏàòÎèÑ ÏûàÏùå
        
        Args:
            receipt_handle: SQS Î©îÏãúÏßÄ ReceiptHandle
            reason: Ïã§Ìå® ÏÇ¨Ïú†
            
        Returns:
            bool: ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        # SQSÎäî ÏûêÎèôÏúºÎ°ú Ïû¨ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º Ïãú DLQÎ°ú Ï†ÑÏÜ°
        # Ïó¨Í∏∞ÏÑúÎäî Î©îÏãúÏßÄÎ•º ÏÇ≠Ï†úÌïòÏßÄ ÏïäÍ≥† Í∑∏ÎåÄÎ°ú ÎëêÎ©¥ ÏûêÎèô Ïû¨ÏãúÎèÑÎê®
        # ÎòêÎäî Ï¶âÏãú Ïã§Ìå® Ï≤òÎ¶¨ÌïòÎ†§Î©¥ Î©îÏãúÏßÄÎ•º ÏÇ≠Ï†ú
        
        # ÌòÑÏû¨Îäî Î©îÏãúÏßÄÎ•º ÏÇ≠Ï†úÌïòÏó¨ Ïû¨ÏãúÎèÑÌïòÏßÄ ÏïäÎèÑÎ°ù Ìï®
        # (Ïû¨ÏãúÎèÑÎäî SQS Î†àÎ≤®ÏóêÏÑú Ï≤òÎ¶¨)
        logger.warning("Video job failed: receipt_handle=%s, reason=%s", receipt_handle, reason)
        return True
    
    @transaction.atomic
    def complete_video(
        self,
        video_id: int,
        hls_path: str,
        duration: Optional[int] = None,
    ) -> tuple[bool, str]:
        """
        ÎπÑÎîîÏò§ Ï≤òÎ¶¨ ÏôÑÎ£å Ï≤òÎ¶¨
        
        Args:
            video_id: Video ID
            hls_path: HLS ÎßàÏä§ÌÑ∞ ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏ Í≤ΩÎ°ú
            duration: ÎπÑÎîîÏò§ Í∏∏Ïù¥ (Ï¥à)
            
        Returns:
            tuple[bool, str]: (ÏÑ±Í≥µ Ïó¨Î∂Ä, Ïù¥Ïú†)
        """
        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False, "not_found"
        
        # Î©±Îì±ÏÑ±: Ïù¥ÎØ∏ READY ÏÉÅÌÉúÎ©¥ OK
        if video.status == Video.Status.READY and bool(video.hls_path):
            return True, "idempotent"
        
        # ÏÉÅÌÉúÍ∞Ä PROCESSINGÏù¥ ÏïÑÎãàÎ©¥ Í≤ΩÍ≥†
        if video.status != Video.Status.PROCESSING:
            logger.warning(
                "Video %s status is %s (expected PROCESSING)",
                video_id,
                video.status,
            )
        
        video.hls_path = str(hls_path)
        if duration is not None and duration >= 0:
            video.duration = int(duration)
        video.status = Video.Status.READY
        
        # lease Ìï¥Ï†ú
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""
        
        update_fields = ["hls_path", "status"]
        if duration is not None and duration >= 0:
            update_fields.append("duration")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")
        
        video.save(update_fields=update_fields)
        return True, "ok"
    
    @transaction.atomic
    def fail_video(
        self,
        video_id: int,
        reason: str,
    ) -> tuple[bool, str]:
        """
        ÎπÑÎîîÏò§ Ï≤òÎ¶¨ Ïã§Ìå® Ï≤òÎ¶¨
        
        Args:
            video_id: Video ID
            reason: Ïã§Ìå® ÏÇ¨Ïú†
            
        Returns:
            tuple[bool, str]: (ÏÑ±Í≥µ Ïó¨Î∂Ä, Ïù¥Ïú†)
        """
        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False, "not_found"
        
        # Î©±Îì±ÏÑ±: Ïù¥ÎØ∏ FAILED ÏÉÅÌÉúÎ©¥ OK
        if video.status == Video.Status.FAILED:
            return True, "idempotent"
        
        video.status = Video.Status.FAILED
        if hasattr(video, "error_reason"):
            video.error_reason = str(reason)[:2000]
        
        # lease Ìï¥Ï†ú
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""
        
        update_fields = ["status"]
        if hasattr(video, "error_reason"):
            update_fields.append("error_reason")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")
        
        video.save(update_fields=update_fields)
        return True, "ok"
    
    @transaction.atomic
    def mark_processing(self, video_id: int) -> bool:
        """
        ÎπÑÎîîÏò§Î•º PROCESSING ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω (Î©±Îì±ÏÑ± Î≥¥Ïû•)
        
        Args:
            video_id: Video ID
            
        Returns:
            bool: ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False
        
        # Ïù¥ÎØ∏ PROCESSINGÏù¥Î©¥ OK
        if video.status == Video.Status.PROCESSING:
            return True
        
        # UPLOADED ÏÉÅÌÉúÎßå PROCESSINGÏúºÎ°ú Î≥ÄÍ≤Ω Í∞ÄÎä•
        if video.status != Video.Status.UPLOADED:
            logger.warning(
                "Cannot mark video %s as PROCESSING: status=%s",
                video_id,
                video.status,
            )
            return False
        
        video.status = Video.Status.PROCESSING
        if hasattr(video, "processing_started_at"):
            video.processing_started_at = timezone.now()
        
        update_fields = ["status"]
        if hasattr(video, "processing_started_at"):
            update_fields.append("processing_started_at")
        
        video.save(update_fields=update_fields)
        return True


==========================================================================================
# FILE: services/video_stats.py
==========================================================================================
# PATH: apps/support/video/services/video_stats.py

from apps.domains.enrollment.models import Enrollment
from apps.domains.attendance.models import Attendance
from apps.support.video.models import VideoProgress, VideoAccess, Video
from apps.support.video.services.access_resolver import resolve_access_mode


def build_video_stats_students(video):
    """
    ‚úÖ Single Source of Truth
    - stats
    - policy-impact
    - admin preview
    Ï†ÑÎ∂Ä Ïù¥ Ìï®ÏàòÎßå ÏÇ¨Ïö©Ìï¥Ïïº Ìï®
    """

    lecture = video.session.lecture

    enrollments = Enrollment.objects.filter(
        lecture=lecture,
        status="ACTIVE",
    ).select_related("student")

    progresses = {
        p.enrollment_id: p
        for p in VideoProgress.objects.filter(video=video)
    }

    perms = {
        p.enrollment_id: p
        for p in VideoAccess.objects.filter(video=video)
    }

    attendance = {
        a.enrollment_id: a.status
        for a in Attendance.objects.filter(session=video.session)
    }

    students = []

    for e in enrollments:
        vp = progresses.get(e.id)
        perm = perms.get(e.id)

        # Use SSOT access resolver
        access_mode = resolve_access_mode(video=video, enrollment=e)
        
        # Legacy rule for backward compatibility
        rule = perm.rule if perm else "free"
        effective_rule = rule
        if rule == "once" and vp and vp.completed:
            effective_rule = "free"

        students.append({
            "enrollment": e.id,
            "student_name": e.student.name,
            "attendance_status": attendance.get(e.id),
            "progress": vp.progress if vp else 0,
            "completed": vp.completed if vp else False,
            "rule": rule,  # Legacy field
            "effective_rule": effective_rule,  # Legacy field
            "access_mode": access_mode.value,  # New field
        })

    return students


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/support/video/views/__init__.py

from .video_policy_impact import VideoPolicyImpactAPIView

from .video_views import VideoViewSet
from .permission_views import VideoPermissionViewSet
from .progress_views import VideoProgressViewSet
from .internal_views import VideoProcessingCompleteView
from .event_views import VideoPlaybackEventViewSet


==========================================================================================
# FILE: views/achievement_views.py
==========================================================================================
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from django.db.models import Avg, Sum

from apps.domains.attendance.models import Attendance
from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoProgress


class VideoAchievementView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session").get(id=video_id)
        lecture = video.session.lecture

        # ÏòÅÏÉÅ ÏàòÍ∞ï ÎåÄÏÉÅ ÌïôÏÉù (Ï∂úÏÑùÏù¥ ONLINE)
        online_attendance = Attendance.objects.filter(
            session=video.session,
            status="ONLINE",
        )

        enrollment_ids = online_attendance.values_list("enrollment_id", flat=True)

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(
                video=video,
                enrollment_id__in=enrollment_ids,
            )
        }

        students = []
        completed_count = 0
        total_progress = 0

        for att in online_attendance.select_related("enrollment__student"):
            enrollment = att.enrollment
            vp = progresses.get(enrollment.id)

            progress = vp.progress if vp else 0
            completed = vp.completed if vp else False

            if completed:
                completed_count += 1

            total_progress += progress

            # ÏÉÅÌÉú Í≥ÑÏÇ∞
            if progress >= 0.95:
                status = "completed"
            elif progress >= 0.5:
                status = "warning"
            else:
                status = "danger"

            students.append({
                "enrollment": enrollment.id,
                "student_name": enrollment.student.name,
                "progress": round(progress * 100, 1),
                "completed": completed,
                "watched_seconds": vp.last_position if vp else 0,
                "status": status,
            })

        total = len(students)
        avg_progress = (total_progress / total) if total else 0

        return Response({
            "summary": {
                "total_students": total,
                "avg_progress": round(avg_progress * 100, 1),
                "completed_rate": round((completed_count / total) * 100, 1) if total else 0,
                "incomplete_count": total - completed_count,
            },
            "students": students,
        })


==========================================================================================
# FILE: views/event_views.py
==========================================================================================
# PATH: apps/support/video/views/event_views.py

import csv
from datetime import timedelta

from django.http import HttpResponse
from django.utils import timezone

from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.filters import SearchFilter

from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoPlaybackEvent
from ..serializers import (
    VideoPlaybackEventListSerializer,
    VideoRiskRowSerializer,
)


def _range_to_since(range_key: str):
    now = timezone.now()
    if range_key == "24h":
        return now - timedelta(hours=24)
    if range_key == "7d":
        return now - timedelta(days=7)
    return None


def _event_score(event_type: str, violated: bool, violation_reason: str | None):
    weights = {
        "VISIBILITY_HIDDEN": 1,
        "VISIBILITY_VISIBLE": 0,
        "FOCUS_LOST": 2,
        "FOCUS_GAINED": 0,
        "SEEK_ATTEMPT": 3,
        "SPEED_CHANGE_ATTEMPT": 3,
        "FULLSCREEN_ENTER": 0,
        "FULLSCREEN_EXIT": 0,
        "PLAYER_ERROR": 1,
    }
    w = int(weights.get(event_type, 1))
    if violated:
        w *= 2
    if violation_reason:
        w += 1
    return w


class VideoPlaybackEventViewSet(ReadOnlyModelViewSet):
    """
    Admin / Staff Ï†ÑÏö©
    - list
    - risk
    - export
    """

    queryset = (
        VideoPlaybackEvent.objects
        .all()
        .select_related("enrollment", "enrollment__student", "video")
    )
    serializer_class = VideoPlaybackEventListSerializer
    permission_classes = [IsAuthenticated]

    # ‚úÖ Í≤ÄÏÉâ + ÌïÑÌÑ∞ ÎèôÏãú ÏßÄÏõê
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["video", "enrollment", "violated"]
    search_fields = [
        "enrollment__student__name",
        "session_id",
        "user_id",
    ]

    def get_queryset(self):
        qs = super().get_queryset()

        video_id = self.request.query_params.get("video")
        if video_id:
            qs = qs.filter(video_id=video_id)

        range_key = self.request.query_params.get("range", "24h")
        since = _range_to_since(range_key)
        if since:
            qs = qs.filter(occurred_at__gte=since)

        # ‚úÖ event_type Îã§Ï§ë ÌïÑÌÑ∞ (comma-separated)
        et = self.request.query_params.get("event_type")
        if et:
            types = [x for x in et.split(",") if x]
            if types:
                qs = qs.filter(event_type__in=types)

        return qs.order_by("-occurred_at", "-id")

    # --------------------------------------------------
    # Risk Top
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="risk")
    def risk(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        limit = int(request.query_params.get("limit") or 5)
        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        agg = {}
        for ev in qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment_id": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                    "danger": 0,
                    "warn": 0,
                    "info": 0,
                    "last_occurred_at": None,
                }

            s = _event_score(ev.event_type, bool(ev.violated), ev.violation_reason)
            agg[eid]["score"] += s

            if ev.violated:
                agg[eid]["danger"] += 1
            elif ev.event_type in ("SEEK_ATTEMPT", "SPEED_CHANGE_ATTEMPT", "FOCUS_LOST"):
                agg[eid]["warn"] += 1
            else:
                agg[eid]["info"] += 1

            if (
                agg[eid]["last_occurred_at"] is None
                or ev.occurred_at > agg[eid]["last_occurred_at"]
            ):
                agg[eid]["last_occurred_at"] = ev.occurred_at

        rows = sorted(
            agg.values(),
            key=lambda r: (r["score"], r["danger"], r["warn"]),
            reverse=True,
        )[:limit]

        return Response(VideoRiskRowSerializer(rows, many=True).data)

    # --------------------------------------------------
    # CSV Export
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="export")
    def export_csv(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        qs = qs.order_by("-occurred_at", "-id")

        resp = HttpResponse(content_type="text/csv; charset=utf-8")
        resp["Content-Disposition"] = (
            f'attachment; filename="video_{video_id}_events_{range_key}.csv"'
        )

        writer = csv.writer(resp)
        writer.writerow([
            "occurred_at",
            "student_name",
            "enrollment_id",
            "event_type",
            "violated",
            "violation_reason",
            "session_id",
            "user_id",
            "score",
            "payload",
        ])

        for ev in qs.iterator():
            writer.writerow([
                ev.occurred_at.isoformat(),
                ev.enrollment.student.name if ev.enrollment_id else "",
                ev.enrollment_id,
                ev.event_type,
                "Y" if ev.violated else "N",
                ev.violation_reason or "",
                ev.session_id,
                ev.user_id,
                _event_score(ev.event_type, bool(ev.violated), ev.violation_reason),
                ev.event_payload,
            ])

        return resp


==========================================================================================
# FILE: views/internal_views.py
==========================================================================================
# PATH: apps/support/video/views/internal_views.py

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status

from apps.support.video.models import Video


class VideoProcessingCompleteView(APIView):
    """
    ‚úÖ Legacy ACK endpoint (kept)

    Í∏∞Ï°¥ Í≥ÑÏïΩÏùÑ Íπ®ÏßÄ ÏïäÍ∏∞ ÏúÑÌï¥ Ïú†ÏßÄÌïòÎêò,
    "worker queue/claim" Í∞ôÏùÄ Ï±ÖÏûÑÏùÑ Ï†àÎåÄ ÏÑûÏßÄ ÏïäÎäîÎã§.

    POST /api/v1/videos/internal/videos/<video_id>/processing-complete/
    (ÌîÑÎ°úÏ†ùÌä∏Ïùò Í∏∞Ï°¥ URL Ïó∞Í≤∞ Î∞©ÏãùÏóê ÎßûÏ∂∞ Ïú†ÏßÄ)

    body:
      {
        "hls_path": "...",
        "duration": 123
      }
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def post(self, request, video_id: int):
        data = getattr(request, "data", None) or {}

        hls_path = data.get("hls_path")
        if not hls_path:
            return Response({"detail": "hls_path required"}, status=status.HTTP_400_BAD_REQUEST)

        duration = data.get("duration")
        try:
            duration_int = int(duration) if duration is not None else None
        except Exception:
            duration_int = None

        video = Video.objects.filter(id=int(video_id)).first()
        if not video:
            return Response({"detail": "Not found"}, status=status.HTTP_404_NOT_FOUND)

        # Î©±Îì±
        if video.status == Video.Status.READY and bool(video.hls_path):
            return Response({"ok": True, "idempotent": True}, status=status.HTTP_200_OK)

        video.hls_path = str(hls_path)
        if duration_int is not None and duration_int >= 0:
            video.duration = duration_int
        video.status = Video.Status.READY

        # legacy completeÎäî lease ÌÜµÏ†úÎ•º Î™®Î•º Ïàò ÏûàÏúºÎØÄÎ°ú ÏïàÏ†ÑÌïòÍ≤å lease Ìï¥Ï†úÎßå ÏàòÌñâ
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""

        update_fields = ["hls_path", "status"]
        if duration_int is not None and duration_int >= 0:
            update_fields.append("duration")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")

        video.save(update_fields=update_fields)

        return Response({"ok": True}, status=status.HTTP_200_OK)


==========================================================================================
# FILE: views/permission_views.py
==========================================================================================
# PATH: apps/support/video/views/permission_views.py

from django.db import models, transaction
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response

from ..models import VideoAccess, Video, AccessMode
from ..serializers import VideoAccessSerializer


class VideoPermissionViewSet(ModelViewSet):
    """Video access overrides (API: video-permissions for backward compat)."""
    queryset = VideoAccess.objects.all()
    serializer_class = VideoAccessSerializer

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_set(self, request):
        video_id = request.data.get("video_id")
        enrollments = request.data.get("enrollments", [])
        
        # Support both legacy 'rule' and new 'access_mode'
        rule = request.data.get("rule")  # Legacy
        access_mode_str = request.data.get("access_mode")  # New
        
        # Map legacy rule to access_mode if needed
        if rule and not access_mode_str:
            rule_to_mode = {
                "free": AccessMode.FREE_REVIEW,
                "once": AccessMode.PROCTORED_CLASS,
                "blocked": AccessMode.BLOCKED,
            }
            access_mode = rule_to_mode.get(rule, AccessMode.FREE_REVIEW)
        elif access_mode_str:
            access_mode = AccessMode(access_mode_str)
        else:
            access_mode = AccessMode.PROCTORED_CLASS  # Default

        objs = []
        for enrollment_id in enrollments:
            obj, _ = VideoAccess.objects.update_or_create(
                video_id=video_id,
                enrollment_id=enrollment_id,
                defaults={
                    "access_mode": access_mode,
                    "rule": rule or "free",  # Legacy field
                    "is_override": True,
                },
            )
            objs.append(obj)

        # ‚úÖ Ï†ïÏ±Ö Î≥ÄÍ≤Ω ‚Üí policy_version Ï¶ùÍ∞Ä (Í∏∞Ï°¥ ÌÜ†ÌÅ∞ Ï¶âÏãú Î¨¥Ìö®Ìôî)
        Video.objects.filter(id=video_id).update(
            policy_version=models.F("policy_version") + 1
        )

        return Response(VideoAccessSerializer(objs, many=True).data)


==========================================================================================
# FILE: views/playback_mixin.py
==========================================================================================
# PATH: apps/support/video/views/playback_mixin.py

import time

from django.conf import settings
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.lectures.models import Session

from ..models import Video, VideoAccess, VideoProgress, AccessMode
from ..serializers import VideoSerializer
from ..drm import create_playback_token, verify_playback_token
from ..services.access_resolver import resolve_access_mode, get_effective_access_mode

# ‚úÖ Ï∂îÍ∞Ä: Cloudflare signed url (ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ public)
from ..cdn.cloudflare_signing import CloudflareSignedURL


class VideoPlaybackMixin:
    """
    Ïû¨ÏÉù Í∂åÌïú / Ï†ïÏ±Ö / Í≥µÌÜµ Î°úÏßÅ

    Access Mode Ï†ïÏùò:
    - FREE_REVIEW: Î≥µÏäµ Î™®Îìú (Ï†úÌïú ÏóÜÏùå)
    - PROCTORED_CLASS: Ïò®ÎùºÏù∏ ÏàòÏóÖ ÎåÄÏ≤¥ (Ï†úÌïú Ï†ÅÏö©)
    - BLOCKED: Ï†ëÍ∑º Ï∞®Îã®
    """

    def _get_student_for_user(self, request):
        return getattr(request.user, "student_profile", None)

    # ==================================================
    # Ï†ëÍ∑º Ï†úÏñ¥ (Access Control)
    # ==================================================
    def _check_access(self, *, video, enrollment):
        """
        Ï†ëÍ∑º Í∞ÄÎä• Ïó¨Î∂ÄÎßå ÌåêÎã®ÌïúÎã§.
        PROCTORED_CLASSÎäî Ï†ëÍ∑ºÏùÑ Ï∞®Îã®ÌïòÏßÄ ÏïäÎäîÎã§ (Ï†úÌïúÎßå Ï†ÅÏö©).
        """
        if video.status != video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return False, "no_session_access"

        # Use SSOT access resolver
        access_mode = resolve_access_mode(video=video, enrollment=enrollment)

        if access_mode == AccessMode.BLOCKED:
            return False, "blocked"

        # FREE_REVIEW / PROCTORED_CLASS Î™®Îëê Ï†ëÍ∑º ÌóàÏö©
        return True, None

    # ==================================================
    # Permission Loader
    # ==================================================
    def _load_permission(self, *, video, enrollment):
        return VideoAccess.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

    # ==================================================
    # Playback Policy
    # ==================================================
    def _effective_policy(self, *, video, enrollment, perm=None):
        """
        Ïã§Ï†ú Ïû¨ÏÉù Ï†úÏïΩ Ï†ïÏ±Ö Í≥ÑÏÇ∞
        
        Policy behavior:
        - PROCTORED_CLASS: allow_seek=False or bounded_forward, max_speed=1.0, watermark enabled
        - FREE_REVIEW: allow_seek=True, no restrictions, minimal logging
        """
        # Resolve access mode using SSOT
        access_mode = get_effective_access_mode(video=video, enrollment=enrollment)
        
        # Base policy from video defaults
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        seek_policy = {
            "mode": "free",
            "forward_limit": None,
            "grace_seconds": 3,
        }

        # Apply permission overrides
        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)

            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if perm.block_seek:
                allow_seek = False
                seek_policy = {"mode": "blocked"}

            if perm.block_speed_control:
                ui_speed_control = False
                max_rate = 1.0

        # Apply access mode restrictions
        if access_mode == AccessMode.PROCTORED_CLASS:
            # PROCTORED_CLASS: restrictions apply
            if not perm or not perm.block_seek:
                # If not explicitly blocked, use bounded forward
                progress = VideoProgress.objects.filter(
                    video=video,
                    enrollment=enrollment,
                ).first()
                
                if not progress or not progress.completed:
                    seek_policy = {
                        "mode": "bounded_forward",
                        "forward_limit": "max_watched",
                        "grace_seconds": 3,
                    }
            
            # Force max speed to 1.0 for proctored class
            if not perm or perm.max_speed_override is None:
                max_rate = 1.0
                ui_speed_control = True
            
            # Watermark enabled for proctored class
            if not perm or perm.show_watermark_override is None:
                watermark_enabled = True
        elif access_mode == AccessMode.FREE_REVIEW:
            # FREE_REVIEW: no restrictions
            if not perm or perm.allow_skip_override is None:
                allow_seek = True
                seek_policy = {
                    "mode": "free",
                    "forward_limit": None,
                    "grace_seconds": 3,
                }

        return {
            "access_mode": access_mode.value,
            "monitoring_enabled": (access_mode == AccessMode.PROCTORED_CLASS),
            "allow_seek": allow_seek,
            "seek": seek_policy,
            "playback_rate": {
                "max": max_rate,
                "ui_control": ui_speed_control,
            },
            "watermark": {
                "enabled": watermark_enabled,
                "mode": "overlay",
                "fields": ["user_id"],
            },
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    # ==================================================
    # HLS / CDN
    # ==================================================
    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _normalize_media_path(self, path: str) -> str:
        """
        serializerÏôÄ ÎèôÏùº Ï≤†Ìïô:
        - leading slash Ï†úÍ±∞
        - legacy storage/media normalize
        """
        p = (path or "").lstrip("/")
        if p.startswith("storage/media/"):
            return p[len("storage/") :]
        return p

    def _public_play_url(self, *, video: Video, expires_at: int, user_id: int) -> str:
        """
        ‚úÖ ÏõêÎ≥∏ Í≥ÑÏïΩ Ïú†ÏßÄ + ÏµúÏÜå Î≥¥Í∞ï
        - video.hls_pathÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í≤ÉÏù¥ single source of truth
        - ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Í∏∞Î≥∏ Í≤ΩÎ°ú(master.m3u8)Î°ú fallback
        - ÏÑ§Ï†ïÍ∞íÏù¥ ÏûàÏúºÎ©¥ Cloudflare signed queryÎ•º Î∂ôÏó¨ÏÑú Î∞òÌôò
        """
        cdn_base = settings.CDN_HLS_BASE_URL.rstrip("/")

        # 1) worker Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏ ÏÇ¨Ïö©
        if getattr(video, "hls_path", ""):
            rel = self._normalize_media_path(str(video.hls_path))
            path = "/" + rel if not rel.startswith("/") else rel
        else:
            # 2) Í∏∞Ï°¥ fallback (ÏõêÎ≥∏ Ïú†ÏßÄ)
            path = f"/media/hls/videos/{video.id}/master.m3u8"

        secret = getattr(settings, "CDN_HLS_SIGNING_SECRET", None)
        if not secret:
            return f"{cdn_base}{path}"

        signer = CloudflareSignedURL(
            secret=str(secret),
            key_id=str(getattr(settings, "CDN_HLS_SIGNING_KEY_ID", "v1")),
        )
        return signer.build_url(
            cdn_base=cdn_base,
            path=path,
            expires_at=int(expires_at),
            user_id=int(user_id),
        )

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int):
        """
        Cloudflare CDN ÏÇ¨Ïö©ÏúºÎ°ú signed cookies Î∂àÌïÑÏöî
        
        CloudflareÎäî Ïø†ÌÇ§ ÎåÄÏã† query parameter Í∏∞Î∞ò signed URL ÏÇ¨Ïö©
        Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Îπà Ìï®ÏàòÎ°ú Ïú†ÏßÄ
        """
        # Cloudflare CDNÏùÄ Ïø†ÌÇ§ ÎåÄÏã† query parameter ÏÇ¨Ïö©
        # Îπà Ìï®Ïàò Ïú†ÏßÄ (Ìò∏ÌôòÏÑ±)
        pass

    # ==================================================
    # ÌïôÏÉù ÏòÅÏÉÅ Î™©Î°ù (Ïû¨ÏÉù Í∞ÄÎä• Ïó¨Î∂Ä ÌåêÎã®)
    # ==================================================
    def _student_list_impl(self, request):
        session_id = request.query_params.get("session")
        if not session_id:
            return Response({"detail": "session is required"}, status=400)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        qs = Video.objects.filter(
            session_id=session_id,
            status=Video.Status.READY,
        ).order_by("order", "id")

        session = Session.objects.select_related("lecture").get(id=session_id)
        lecture = session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        data = []
        for v in qs:
            d = VideoSerializer(v).data

            if not enrollment:
                d["can_play"] = False
                d["reason"] = "not_enrolled"
                data.append(d)
                continue

            if not SessionEnrollment.objects.filter(
                session=session,
                enrollment=enrollment,
            ).exists():
                d["can_play"] = False
                d["reason"] = "no_session_access"
                data.append(d)
                continue

            ok, reason = self._check_access(video=v, enrollment=enrollment)
            d["can_play"] = bool(ok)
            d["reason"] = reason if not ok else None
            data.append(d)

        return Response(data)


==========================================================================================
# FILE: views/playback_views.py
==========================================================================================
# PATH: apps/support/video/views/playback_views.py

import uuid

from django.conf import settings
from django.utils import timezone
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from apps.domains.enrollment.models import Enrollment, SessionEnrollment

from ..models import (
    Video,
    VideoPlaybackSession,
    VideoPlaybackEvent,
    VideoProgress,
    VideoAccess,
    AccessMode,
)
from ..serializers import (
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)
from ..drm import create_playback_token, verify_playback_token
from ..services.playback_session import (
    issue_session,
    heartbeat_session,
    end_session,
    is_session_active,
    revoke_session,
    record_session_event,
    get_session_violation_stats,
    should_revoke_by_stats,
)
from ..services.playback_session import init_session_redis  # Redis ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî (ÏÑ†ÌÉùÏ†Å)
from .playback_mixin import VideoPlaybackMixin


# ----------------------------------------------------------
# internal helpers (ÏõêÎ≥∏ Íµ¨Ï°∞ Ïú†ÏßÄ: view ÎÇ¥Î∂Ä Î≥¥Ï°∞ Ìï®ÏàòÎ°úÎßå Ï∂îÍ∞Ä)
# ----------------------------------------------------------

def _req_id() -> str:
    return uuid.uuid4().hex


def _policy_version_of(video: Video) -> int:
    try:
        return int(getattr(video, "policy_version", 1) or 1)
    except Exception:
        return 1


def _is_policy_token_valid(payload: dict) -> bool:
    """
    token payloadÏùò pvÏôÄ ÌòÑÏû¨ video.policy_version ÎπÑÍµê.
    - Î∂àÏùºÏπò Ïãú Ï¶âÏãú Ï∞®Îã®
    - access_modeÎèÑ Í≤ÄÏ¶ù (Ï†ïÏ±Ö Î≥ÄÍ≤Ω Ïãú ÌÜ†ÌÅ∞ Î¨¥Ìö®Ìôî)
    """
    try:
        video_id = int(payload.get("video_id"))
        enrollment_id = int(payload.get("enrollment_id"))
    except Exception:
        return False

    # NOTE: migrations Ï†ÅÏö© Ï†ÑÏóêÎäî policy_version Ïª¨ÎüºÏù¥ ÏóÜÏúºÎ©¥ SELECTÏóêÏÑú ÌÑ∞Ïßà Ïàò ÏûàÏùå.
    # Ïã§ÏÑúÎπÑÏä§Îäî migration Ïù¥ÌõÑÎ•º Ï†ÑÏ†úÎ°ú ÌïúÎã§.
    v = Video.objects.filter(id=video_id).only("id", "policy_version").first()
    if not v:
        return False

    current = _policy_version_of(v)
    try:
        pv = int(payload.get("pv") or 0)
    except Exception:
        pv = 0

    if pv != current:
        return False

    # Validate access_mode consistency
    try:
        from apps.domains.enrollment.models import Enrollment
        from ..services.access_resolver import get_effective_access_mode
        
        enrollment = Enrollment.objects.filter(id=enrollment_id).first()
        if enrollment:
            current_access_mode = get_effective_access_mode(video=v, enrollment=enrollment)
            token_access_mode = payload.get("access_mode")
            
            if token_access_mode and token_access_mode != current_access_mode.value:
                return False
    except Exception:
        # If access_mode validation fails, still allow (backward compatibility)
        pass

    return True


def _deny(detail: str, *, code=status.HTTP_403_FORBIDDEN):
    return Response({"detail": detail}, status=code)


def _session_db_status(session_id: str):
    return (
        VideoPlaybackSession.objects
        .filter(session_id=session_id)
        .values_list("status", flat=True)
        .first()
    )


def _db_session_is_inactive(st: str | None) -> bool:
    return st in (VideoPlaybackSession.Status.REVOKED, VideoPlaybackSession.Status.EXPIRED)


# ==========================================================
# Playback Start
# ==========================================================

class PlaybackStartView(VideoPlaybackMixin, APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        request_id = _req_id()

        serializer = PlaybackStartRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        enrollment_id = serializer.validated_data["enrollment_id"]
        device_id = serializer.validated_data["device_id"]

        video_id = request.data.get("video_id")
        if not video_id:
            return Response({"detail": "video_id_required"}, status=400)

        enrollment = Enrollment.objects.select_related(
            "student",
            "lecture",
        ).get(id=enrollment_id, status="ACTIVE")

        video = Video.objects.select_related(
            "session",
            "session__lecture",
        ).get(id=int(video_id))

        # ÏàòÍ∞ï Í≤ÄÏ¶ù
        if enrollment.lecture_id != video.session.lecture_id:
            return _deny("enrollment_mismatch", code=403)

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return _deny("no_session_access", code=403)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return _deny(reason, code=403)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        # Resolve access mode BEFORE creating session
        from ..services.access_resolver import get_effective_access_mode
        access_mode = get_effective_access_mode(video=video, enrollment=enrollment)
        
        # Determine if monitoring is required
        monitoring_enabled = (access_mode == AccessMode.PROCTORED_CLASS)
        
        session_id = None
        expires_at = None
        
        # Only create DB session for PROCTORED_CLASS
        student_id = enrollment.student_id
        if monitoring_enabled:
            ok, sess, err = issue_session(
                student_id=student_id,
                device_id=device_id,
                ttl_seconds=ttl,
                max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            )

            if not ok:
                return Response({"detail": err}, status=409)

            session_id = sess["session_id"]
            expires_at_timestamp = int(sess["expires_at"])
            expires_at = timezone.datetime.fromtimestamp(expires_at_timestamp, tz=timezone.utc)

            VideoPlaybackSession.objects.create(
                video=video,
                enrollment=enrollment,
                session_id=session_id,
                device_id=device_id,
                status=VideoPlaybackSession.Status.ACTIVE,
                started_at=timezone.now(),
                expires_at=expires_at,
                last_seen=timezone.now(),
                violated_count=0,
                total_count=0,
                is_revoked=False,
            )
            init_session_redis(session_id=session_id, ttl_seconds=ttl)
        else:
            # FREE_REVIEW: No DB session, calculate expires_at for token only
            expires_at = timezone.now() + timezone.timedelta(seconds=ttl)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, enrollment=enrollment, perm=perm)

        # ‚úÖ tokenÏóê pv, access_mode, monitoring_enabled, student_id Ìè¨Ìï®
        token = create_playback_token(
            payload={
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "session_id": session_id,  # None for FREE_REVIEW
                "user_id": request.user.id,
                "student_id": student_id,
                "access_mode": access_mode.value,
                "monitoring_enabled": monitoring_enabled,
                "pv": _policy_version_of(video),
                "rid": request_id,
            },
            ttl_seconds=ttl,
        )

        play_url = self._public_play_url(
            video=video,
            expires_at=int(expires_at.timestamp()) if expires_at else int(timezone.now().timestamp()) + ttl,
            user_id=request.user.id,
        )

        resp = Response(
            PlaybackResponseSerializer({
                "token": token,
                "session_id": session_id,
                "expires_at": int(expires_at.timestamp()) if expires_at else None,
                "access_mode": access_mode.value,
                "monitoring_enabled": monitoring_enabled,
                "policy": policy,
                "play_url": play_url,
            }).data,
            status=201,
        )

        # Set signed cookies only if we have expires_at
        if expires_at:
            self._set_signed_cookies(resp, video_id=video.id, expires_at=int(expires_at.timestamp()))
        return resp


# ==========================================================
# Playback Refresh
# ==========================================================

class PlaybackRefreshView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackRefreshRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        # FREE_REVIEW: Skip DB operations (session_id=null, no DB)
        monitoring_enabled = payload.get("monitoring_enabled")
        if monitoring_enabled is None:
            monitoring_enabled = bool(payload.get("session_id"))
        if not monitoring_enabled:
            return Response({"ok": True})

        sid = str(payload.get("session_id") or "")
        student_id = int(payload.get("student_id") or payload.get("user_id", 0))
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        if not is_session_active(
            student_id=student_id,
            session_id=str(payload["session_id"]),
        ):
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback Heartbeat
# ==========================================================

class PlaybackHeartbeatView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackHeartbeatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        # FREE_REVIEW: Skip DB operations
        monitoring_enabled = payload.get("monitoring_enabled")
        if monitoring_enabled is None:
            monitoring_enabled = bool(payload.get("session_id"))
        if not monitoring_enabled:
            return Response({"ok": True})

        sid = str(payload.get("session_id") or "")
        student_id = int(payload.get("student_id") or payload.get("user_id", 0))
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        ok2 = heartbeat_session(
            student_id=student_id,
            session_id=str(payload["session_id"]),
            ttl_seconds=int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600)),
        )
        if not ok2:
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback End
# ==========================================================

class PlaybackEndView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEndRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        # FREE_REVIEW: Skip DB operations
        monitoring_enabled = payload.get("monitoring_enabled")
        if monitoring_enabled is None:
            monitoring_enabled = bool(payload.get("session_id"))
        if monitoring_enabled:
            session_id = str(payload.get("session_id") or "")
            student_id = int(payload.get("student_id") or payload.get("user_id", 0))
            if session_id:
                end_session(
                    student_id=student_id,
                    session_id=session_id,
                )

                VideoPlaybackSession.objects.filter(
                    session_id=session_id
                ).update(
                    status=VideoPlaybackSession.Status.ENDED,
                    ended_at=timezone.now(),
                )

        return Response({"ok": True})


# ==========================================================
# Event Batch
# ==========================================================

class PlaybackEventBatchView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEventBatchRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        # FREE_REVIEW: Skip all DB operations
        monitoring_enabled = payload.get("monitoring_enabled")
        if monitoring_enabled is None:
            monitoring_enabled = bool(payload.get("session_id"))
        if not monitoring_enabled:
            return Response(
                PlaybackEventBatchResponseSerializer({"stored": 0}).data,
                status=201,
            )

        user_id = int(payload["user_id"])
        student_id = int(payload.get("student_id") or user_id)
        session_id = str(payload["session_id"])

        # DB ÏÉÅÌÉú Ï∞®Îã®
        st = _session_db_status(session_id)
        if _db_session_is_inactive(st):
            return Response({"detail": "session_inactive"}, status=409)

        # ÏÑ∏ÏÖò ÌôúÏÑ± ÏÉÅÌÉú ÌôïÏù∏ (DB Í∏∞Î∞ò)
        if not is_session_active(student_id=student_id, session_id=session_id):
            return Response({"detail": "session_inactive"}, status=409)

        events = serializer.validated_data["events"]

        # Ìè≠Ï£º Î∞©ÏßÄ
        max_batch = int(getattr(settings, "VIDEO_EVENT_BATCH_MAX", 200))
        if len(events) > max_batch:
            return Response({"detail": "batch_too_large"}, status=413)

        now = timezone.now()
        objs = []

        # policy snapshot Í≥ÑÏÇ∞ (ÏõêÎ≥∏ ÎØπÏä§Ïù∏ Ïû¨ÏÇ¨Ïö©)
        video = Video.objects.filter(id=int(payload["video_id"])).first()
        enrollment = Enrollment.objects.filter(id=int(payload["enrollment_id"])).first()
        perm = None
        if video and enrollment:
            perm = VideoAccess.objects.filter(video=video, enrollment=enrollment).first()

        policy_snapshot = {}
        try:
            if video and enrollment:
                m = VideoPlaybackMixin()
                policy_snapshot = m._effective_policy(video=video, enrollment=enrollment, perm=perm)
        except Exception:
            policy_snapshot = {}

        def _is_violation(ev_type: str, snap: dict) -> tuple[bool, str]:
            """
            ‚úÖ ÏµúÏÜå Í∞ïÏ†ú ÏúÑÎ∞ò ÌåêÏ†ï(ÏÑúÎ≤Ñ Îã®):
            - Violation logic ONLY applies when access_mode == PROCTORED_CLASS
            - This function is only called when monitoring_enabled == True
            - seek blocked/bounded ÌôòÍ≤ΩÏóêÏÑú SEEK_ATTEMPTÎäî violated
            - speed Ï†úÌïú ÌôòÍ≤ΩÏóêÏÑú SPEED_CHANGE_ATTEMPTÎäî violated
            """
            # Double-check access mode (should already be PROCTORED_CLASS if we're here)
            access_mode_value = (snap or {}).get("access_mode")
            if access_mode_value != AccessMode.PROCTORED_CLASS.value:
                # Safety check: no violations in FREE_REVIEW mode
                return False, ""
            
            # Only check violations for PROCTORED_CLASS
            if ev_type == "SEEK_ATTEMPT":
                seek = (snap or {}).get("seek") or {}
                allow_seek = bool((snap or {}).get("allow_seek", True))
                mode = seek.get("mode")
                if (not allow_seek) or mode in ("blocked", "bounded_forward"):
                    return True, f"seek_{mode or 'blocked'}"
            if ev_type == "SPEED_CHANGE_ATTEMPT":
                pr = ((snap or {}).get("playback_rate") or {})
                ui = bool(pr.get("ui_control", True))
                mx = float(pr.get("max", 1.0) or 1.0)
                if (not ui) or mx <= 1.0:
                    return True, "speed_blocked"
            return False, ""

        # ‚úÖ ÏÑ∏ÏÖò Îã®ÏúÑ ÎàÑÏ†Å ÏúÑÎ∞ò ÌåêÎã®
        # - Í∞Å Ïù¥Î≤§Ìä∏ÎßàÎã§ DB Ïπ¥Ïö¥ÌÑ∞ Í∞±Ïã† ‚Üí batch Ï™ºÍ∞úÍ∏∞ Ïö∞Ìöå Î∂àÍ∞Ä
        latest_stats = None
        revoke_reason = ""

        for e in events:
            ev_type = e["type"]
            ev_payload = e.get("payload", {}) or {}

            violated, reason = _is_violation(ev_type, policy_snapshot)
            if violated and reason:
                revoke_reason = reason

            # ‚úÖ DB ÎàÑÏ†Å Í∞±Ïã†
            latest_stats = record_session_event(
                student_id=student_id,
                session_id=session_id,
                violated=bool(violated),
                reason=reason or "",
            )

            objs.append(
                VideoPlaybackEvent(
                    video_id=int(payload["video_id"]),
                    enrollment_id=int(payload["enrollment_id"]),
                    session_id=session_id,
                    user_id=user_id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy_snapshot,
                    violated=bool(violated),
                    violation_reason=reason or "",
                    occurred_at=now,
                )
            )

        # Ìä∏ÎûúÏû≠ÏÖò Î≤îÏúÑ ÏµúÏÜåÌôî: bulk_createÏôÄ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Î∂ÑÎ¶¨ (50Î™Ö ÏõêÏû• ÌôïÏû• ÎåÄÎπÑ)
        # Í∏¥ Ìä∏ÎûúÏû≠ÏÖòÏùÄ DB Ï†ÑÏ≤¥Î•º Î©àÏ∂ú Ïàò ÏûàÏùå
        with transaction.atomic():
            VideoPlaybackEvent.objects.bulk_create(objs, batch_size=500)
        
        # ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏Îäî Î≥ÑÎèÑ Ìä∏ÎûúÏû≠ÏÖòÏúºÎ°ú Î∂ÑÎ¶¨ (lock ÏãúÍ∞Ñ Îã®Ï∂ï)
        stats = latest_stats or get_session_violation_stats(session_id=session_id)
        violated_cnt = int(stats.get("violated") or 0)
        total_cnt = int(stats.get("total") or 0)

        if should_revoke_by_stats(violated=violated_cnt, total=total_cnt):
            with transaction.atomic():
                revoke_session(student_id=student_id, session_id=session_id)

        return Response(
            PlaybackEventBatchResponseSerializer({"stored": len(objs)}).data,
            status=201,
        )


==========================================================================================
# FILE: views/progress_views.py
==========================================================================================
# apps/support/video/views/progress_views.py

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from django.utils import timezone
from ..models import VideoProgress, VideoAccess, AccessMode
from ..serializers import VideoProgressSerializer


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    def perform_update(self, serializer):
        vp = serializer.instance
        prev_completed = vp.completed

        vp = serializer.save()

        # PROCTORED_CLASS ‚Üí FREE_REVIEW on completion (SSOT)
        if not prev_completed and vp.completed:
            now = timezone.now()
            VideoAccess.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                access_mode=AccessMode.PROCTORED_CLASS,
            ).update(
                access_mode=AccessMode.FREE_REVIEW,
                proctored_completed_at=now,
                is_override=False,
            )
            VideoAccess.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                rule="once",
            ).update(rule="free", is_override=False)


==========================================================================================
# FILE: views/video_policy_impact.py
==========================================================================================
# PATH: apps/support/video/views/video_policy_impact.py
# PATH: apps/support/video/views/video_policy_impact.py

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment
from apps.domains.attendance.models import Attendance
from ..models import Video, VideoAccess, VideoProgress
from ..services.access_resolver import resolve_access_mode


class VideoPolicyImpactAPIView(APIView):
    """
    Admin Ï†ÑÏö©:
    ÌäπÏ†ï ÏòÅÏÉÅ Ï†ïÏ±ÖÏù¥ ÌïôÏÉùÎì§ÏóêÍ≤å Ïñ¥Îñ§ ÏòÅÌñ•ÏùÑ Ï£ºÎäîÏßÄ ÎØ∏Î¶¨ Î≥¥Í∏∞
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session", "session__lecture").get(id=video_id)

        enrollments = Enrollment.objects.filter(
            lecture=video.session.lecture,
            status="ACTIVE",
        ).select_related("student")

        perms = {
            p.enrollment_id: p
            for p in VideoAccess.objects.filter(video=video)
        }

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }

        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        rows = []

        for e in enrollments:
            perm = perms.get(e.id)
            prog = progresses.get(e.id)

            # Use SSOT access resolver
            access_mode = resolve_access_mode(video=video, enrollment=e)
            
            # Legacy rule for backward compatibility
            rule = perm.rule if perm else "free"
            effective = rule
            if rule == "once" and prog and prog.completed:
                effective = "free"

            rows.append({
                "enrollment": e.id,
                "student_name": e.student.name,
                "attendance_status": attendance.get(e.id),
                "rule": rule,  # Legacy field
                "effective_rule": effective,  # Legacy field
                "access_mode": access_mode.value,  # New field
                "completed": bool(prog.completed) if prog else False,
            })

        return Response(rows)


==========================================================================================
# FILE: views/video_views.py
==========================================================================================
# PATH: apps/support/video/views/video_views.py

import logging
from uuid import uuid4
from datetime import timedelta

from django.conf import settings
from django.db import models, transaction
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from rest_framework.parsers import (
    JSONParser,
    MultiPartParser,
    FormParser,
)
from django_filters.rest_framework import DjangoFilterBackend

from rest_framework_simplejwt.authentication import JWTAuthentication

from libs.s3_client.presign import create_presigned_put_url, create_presigned_get_url
from libs.s3_client.client import head_object

from apps.core.permissions import IsAdminOrStaff, IsStudent
from apps.core.authentication import CsrfExemptSessionAuthentication

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from ..models import (
    Video,
    VideoAccess,
    VideoProgress,
    VideoPlaybackEvent,
)
from ..serializers import VideoSerializer, VideoDetailSerializer
from ..services.sqs_queue import VideoSQSQueue
from .playback_mixin import VideoPlaybackMixin

# Î°úÍ±∞ ÏÑ§Ï†ï
logger = logging.getLogger(__name__)

# ==================================================
# utils
# ==================================================
def _safe_int(v, default=None):
    try:
        return int(v)
    except Exception:
        return default


def _validate_source_media_via_ffprobe(url: str) -> tuple[bool, dict, str]:
    """
    upload_complete ÏµúÏÜå Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù
    """
    if not url:
        return False, {}, "source_url_missing"

    try:
        import ffmpeg  # type: ignore
    except Exception:
        return False, {}, "ffmpeg_module_missing"

    try:
        probe = ffmpeg.probe(url)
    except Exception as e:
        return False, {}, f"ffprobe_failed:{str(e)[:200]}"

    fmt = probe.get("format") or {}
    streams = probe.get("streams") or []

    dur_raw = fmt.get("duration")
    duration = None
    try:
        if dur_raw is not None:
            duration = int(float(dur_raw))
    except Exception:
        duration = None

    has_video = any((s.get("codec_type") == "video") for s in streams)

    if not has_video:
        return False, {"duration": duration, "has_video": False}, "no_video_stream"

    if duration is None:
        return False, {"duration": None, "has_video": True}, "duration_missing"

    if duration < 0:
        return False, {"duration": duration, "has_video": True}, "duration_invalid"

    return True, {"duration": duration, "has_video": True}, ""


# ==================================================
# ‚úÖ EC2 ÏûêÎèô ÏãúÏûë Î°úÏßÅ Ï†úÍ±∞Îê® (SQS Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú Ï†ÑÌôò)
#
# SQS Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÏóêÏÑúÎäî:
# - WorkerÎäî ECS/FargateÏóêÏÑú ÏûêÎèôÏúºÎ°ú Í¥ÄÎ¶¨Îê®
# - ÏûëÏóÖÏù¥ SQSÏóê ÏûàÏúºÎ©¥ WorkerÍ∞Ä ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨
# - EC2 Ïù∏Ïä§ÌÑ¥Ïä§ ÏàòÎèô Í¥ÄÎ¶¨ Î∂àÌïÑÏöî
# ==================================================


# ==================================================
# ViewSet
# ==================================================
class VideoViewSet(VideoPlaybackMixin, ModelViewSet):
    """
    Video Í¥ÄÎ¶¨ + ÌÜµÍ≥Ñ + ÌïôÏÉù Î™©Î°ù
    """

    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer

    parser_classes = [JSONParser]

    authentication_classes = [
        JWTAuthentication,
        CsrfExemptSessionAuthentication,
    ]
    permission_classes = [IsAuthenticated]

    ADMIN_ONLY_ACTIONS = {
        "upload_init",
        "upload_complete",
        "retry",
        "create",
        "update",
        "partial_update",
        "destroy",
    }

    def get_permissions(self):
        if self.action in self.ADMIN_ONLY_ACTIONS:
            return [IsAuthenticated(), IsAdminOrStaff()]
        return [IsAuthenticated()]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # ==================================================
    # upload/init
    # ==================================================
    @transaction.atomic
    @action(
        detail=False,
        methods=["post"],
        url_path="upload/init",
        parser_classes=[JSONParser],
    )
    def upload_init(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        filename = request.data.get("filename")

        allow_skip = bool(request.data.get("allow_skip", False))
        max_speed = float(request.data.get("max_speed", 1.0) or 1.0)
        show_watermark = bool(request.data.get("show_watermark", True))

        if not session_id or not title or not filename:
            return Response(
                {"detail": "session, title, filename required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session = Session.objects.select_related("lecture", "lecture__tenant").get(id=session_id)
        tenant_code = session.lecture.tenant.code
        order = (
            session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0
        ) + 1

        ext = filename.split(".")[-1].lower() if "." in filename else "mp4"
        key = f"videos/{tenant_code}/{session_id}/{uuid4()}.{ext}"

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=key,
            order=order,
            status=Video.Status.PENDING,
            allow_skip=allow_skip,
            max_speed=max_speed,
            show_watermark=show_watermark,
        )

        content_type = (request.data.get("content_type") or "video/mp4").split(";")[0]
        upload_url = create_presigned_put_url(key=key, content_type=content_type)

        return Response(
            {
                "video": VideoSerializer(video).data,
                "upload_url": upload_url,
                "file_key": key,
                "content_type": content_type,
            },
            status=status.HTTP_201_CREATED,
        )

    # ==================================================
    # upload/complete
    # ==================================================
    @transaction.atomic
    @action(
        detail=True,
        methods=["post"],
        url_path="upload/complete",
        parser_classes=[MultiPartParser, FormParser, JSONParser],
    )
    def upload_complete(self, request, pk=None):
        video = self.get_object()

        if video.status != Video.Status.PENDING:
            return Response(
                {"detail": f"Invalid status: {video.status}"},
                status=status.HTTP_409_CONFLICT,
            )

        exists, size = head_object(video.file_key)
        if not exists or size == 0:
            video.error_reason = "source_not_found_or_empty"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "S3 object not found"},
                status=status.HTTP_409_CONFLICT,
            )

        try:
            src_url = create_presigned_get_url(key=video.file_key, expires_in=600)
        except Exception as e:
            video.error_reason = f"presigned_get_failed:{str(e)[:200]}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "presigned_get_failed"},
                status=status.HTTP_409_CONFLICT,
            )

        ok, meta, reason = _validate_source_media_via_ffprobe(src_url)

        if not ok and reason == "ffmpeg_module_missing":
            video.status = Video.Status.UPLOADED
            video.error_reason = ""
            video.save(update_fields=["status", "error_reason"])

            # SQSÏóê ÏûëÏóÖ Ï∂îÍ∞Ä
            transaction.on_commit(lambda: VideoSQSQueue().enqueue(video))
            return Response(VideoSerializer(video).data)

        min_dur = _safe_int(getattr(settings, "VIDEO_MIN_DURATION_SECONDS", 3), 3)
        duration = _safe_int(meta.get("duration"), None)

        if duration is not None and duration < int(min_dur):
            video.duration = duration
            video.status = Video.Status.UPLOADED
            video.error_reason = ""
            video.save(update_fields=["status", "duration", "error_reason"])

            # SQSÏóê ÏûëÏóÖ Ï∂îÍ∞Ä
            transaction.on_commit(lambda: VideoSQSQueue().enqueue(video))
            return Response(VideoSerializer(video).data)

        video.duration = duration
        video.status = Video.Status.UPLOADED
        video.error_reason = ""
        video.save(update_fields=["status", "duration", "error_reason"])

        # SQSÏóê ÏûëÏóÖ Ï∂îÍ∞Ä
        transaction.on_commit(lambda: VideoSQSQueue().enqueue(video))
        return Response(VideoSerializer(video).data)

    # ==================================================
    # retry
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response(
                {"detail": "Cannot retry"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        video.status = Video.Status.UPLOADED
        video.save(update_fields=["status"])

        # SQSÏóê ÏûëÏóÖ Ï∂îÍ∞Ä
        transaction.on_commit(lambda: VideoSQSQueue().enqueue(video))
        return Response(
            {"detail": "Video reprocessing queued (SQS)"},
            status=status.HTTP_202_ACCEPTED,
        )

    # ==================================================
    # stats
    # ==================================================
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(
            lecture=lecture,
            status="ACTIVE",
        ).select_related("student")

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }
        perms = {
            p.enrollment_id: p
            for p in VideoAccess.objects.filter(video=video)
        }
        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            # Use SSOT access resolver
            from apps.support.video.services.access_resolver import resolve_access_mode
            access_mode = resolve_access_mode(video=video, enrollment=e)
            
            # Legacy rule for backward compatibility
            rule = perm.rule if perm else "free"
            effective_rule = rule
            if rule == "once" and vp and vp.completed:
                effective_rule = "free"

            students.append(
                {
                    "enrollment": e.id,
                    "student_name": e.student.name,
                    "attendance_status": attendance.get(e.id),
                    "progress": vp.progress if vp else 0,
                    "completed": vp.completed if vp else False,
                    "rule": rule,  # Legacy field
                    "effective_rule": effective_rule,  # Legacy field
                    "access_mode": access_mode.value,  # New field
                    "parent_phone": getattr(e.student, "parent_phone", None),
                    "student_phone": getattr(e.student, "phone", None),
                    "school": getattr(e.student, "school", None),
                    "grade": getattr(e.student, "grade", None),
                }
            )

        return Response(
            {
                "video": VideoDetailSerializer(video).data,
                "students": students,
                "total_filtered": len(students),
            }
        )

    # ==================================================
    # summary
    # ==================================================
    @action(detail=True, methods=["get"], url_path="summary")
    def summary(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        range_key = request.query_params.get("range", "7d")
        now = timezone.now()

        since = None
        if range_key == "24h":
            since = now - timedelta(hours=24)
        elif range_key == "7d":
            since = now - timedelta(days=7)

        enrollments = Enrollment.objects.filter(lecture=lecture)
        total = enrollments.count()

        progresses = VideoProgress.objects.filter(video=video)
        completed_count = progresses.filter(completed=True).count()

        duration = int(video.duration or 0)

        watched_seconds = 0
        for p in progresses.iterator():
            watched_seconds += int(float(p.progress or 0) * duration)

        completion_rate = (completed_count / total) if total else 0.0

        ev_qs = VideoPlaybackEvent.objects.filter(video=video).select_related(
            "enrollment", "enrollment__student"
        )

        if since:
            ev_qs = ev_qs.filter(occurred_at__gte=since)

        weights = {
            "VISIBILITY_HIDDEN": 1,
            "VISIBILITY_VISIBLE": 0,
            "FOCUS_LOST": 2,
            "FOCUS_GAINED": 0,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "FULLSCREEN_ENTER": 0,
            "FULLSCREEN_EXIT": 0,
            "PLAYER_ERROR": 1,
        }

        agg = {}
        for ev in ev_qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                }

            score = int(weights.get(ev.event_type, 1))
            if ev.violated:
                score *= 2
            if ev.violation_reason:
                score += 1

            agg[eid]["score"] += score

        risk_top = sorted(
            agg.values(),
            key=lambda x: x["score"],
            reverse=True,
        )[:5]

        return Response(
            {
                "video_id": video.id,
                "range": range_key,
                "total_students": total,
                "completed_count": completed_count,
                "completion_rate": completion_rate,
                "watched_seconds_est": watched_seconds,
                "risk_top": risk_top,
            }
        )

    # ==================================================
    # student list
    # ==================================================
    @action(
        detail=False,
        methods=["get"],
        url_path="student",
        permission_classes=[IsAuthenticated, IsStudent],
    )
    def student_list(self, request):
        return self._student_list_impl(request)
