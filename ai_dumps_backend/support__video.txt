====================================================================================================
# BACKEND APP: support__video
# ROOT PATH: C:\academy\apps\support\video
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# services package
#


==========================================================================================
# FILE: admin.py
==========================================================================================
from django.contrib import admin
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


@admin.register(Video)
class VideoAdmin(admin.ModelAdmin):
    list_display = ("id", "title", "session", "order", "duration", "status")
    list_display_links = ("id", "title")
    list_filter = ("status", "session__lecture", "session")
    search_fields = ("title",)
    ordering = ("session", "order")


@admin.register(VideoPermission)
class VideoPermissionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "rule",
        "allow_skip_override",
        "max_speed_override",
        "show_watermark_override",
        "block_seek",
        "block_speed_control",
        "is_override",
    )
    list_display_links = ("id", "video")
    list_filter = ("rule", "video__session__lecture", "block_seek", "block_speed_control")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


@admin.register(VideoProgress)
class VideoProgressAdmin(admin.ModelAdmin):
    list_display = ("id", "video", "enrollment", "progress", "completed", "updated_at")
    list_display_links = ("id", "video")
    list_filter = ("video__session__lecture", "completed")
    search_fields = ("enrollment__student__name",)
    ordering = ("-updated_at",)


@admin.register(VideoPlaybackSession)
class VideoPlaybackSessionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "device_id",
        "status",
        "started_at",
        "ended_at",
    )
    list_filter = ("status", "video__session__lecture", "video")
    search_fields = ("session_id", "device_id", "enrollment__student__name")
    ordering = ("-started_at",)


@admin.register(VideoPlaybackEvent)
class VideoPlaybackEventAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "user_id",
        "event_type",
        "violated",
        "violation_reason",
        "occurred_at",
        "received_at",
    )
    list_filter = ("event_type", "violated", "video__session__lecture")
    search_fields = ("session_id", "enrollment__student__name", "user_id")
    ordering = ("-received_at",)


==========================================================================================
# FILE: drm.py
==========================================================================================
import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


==========================================================================================
# FILE: models.py
==========================================================================================
from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (영상 메타데이터)
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "업로드 대기"
        UPLOADED = "UPLOADED", "업로드 완료"
        PROCESSING = "PROCESSING", "처리중"
        READY = "READY", "사용 가능"
        FAILED = "FAILED", "실패"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # 썸네일은 Worker가 생성
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # 기본 재생 정책 (비디오 단위 default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # 정책 변경 즉시 반영을 위한 버전 (token versioning)
    # - 기존 API 계약 깨지지 않게 default=1
    # - 정책/권한 변경 시 증가시키면, 기존 토큰 즉시 무효화 가능
    # --------------------------------------------------
    policy_version = models.PositiveIntegerField(
        default=1,
        db_index=True,
        help_text="Increment on policy/permission changes to invalidate existing tokens",
    )

    # --------------------------------------------------
    # Worker 실패 사유 기록
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    # ===============================
    # HLS Output (Worker 결과)
    # ===============================
    hls_path = models.CharField(
        max_length=500,
        blank=True,
        help_text="HLS master playlist path (relative to CDN root)",
    )

    # --------------------------------------------------
    # Worker Lease (다중 노드 중복 처리 방지용)
    # - 기존 reclaim(updated_at 기반) 구조를 유지하면서,
    #   중앙 통제용 lease 정보를 "추가"로 기록한다.
    # - 서버/워커가 서로 내부 구현 몰라도 동작(헤더만 사용).
    # --------------------------------------------------
    processing_started_at = models.DateTimeField(null=True, blank=True)
    leased_until = models.DateTimeField(null=True, blank=True)
    leased_by = models.CharField(max_length=64, blank=True, default="")

    class Meta:
        ordering = ["order", "id"]
        indexes = [
            models.Index(fields=["status", "updated_at"]),
            models.Index(fields=["leased_until", "status"]),
        ]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        return "unknown"


# ========================================================
# Video Permission (수강생별 override + 접근 규칙)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "무제한"),
            ("once", "1회 제한"),
            ("blocked", "제한"),
        ],
        default="once",
    )

    # 학생별 정책 override (null이면 Video 기본값 사용)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # 최우선 차단 플래그
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (세션 / 감사)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "활성"
        ENDED = "ENDED", "종료"
        REVOKED = "REVOKED", "차단"
        EXPIRED = "EXPIRED", "만료"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]
        indexes = [
            models.Index(fields=["status", "started_at"]),
            models.Index(fields=["video", "enrollment", "status"]),
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "탭 숨김"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "탭 노출"
        FOCUS_LOST = "FOCUS_LOST", "포커스 이탈"
        FOCUS_GAINED = "FOCUS_GAINED", "포커스 복귀"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "탐색 시도"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "배속 변경 시도"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "전체화면 진입"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "전체화면 종료"
        PLAYER_ERROR = "PLAYER_ERROR", "플레이어 오류"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


==========================================================================================
# FILE: policy.py
==========================================================================================
from __future__ import annotations

from typing import Dict, Tuple, Optional


def evaluate_event_violation(
    *,
    event_type: str,
    policy: Dict,
    payload: Dict,
) -> Tuple[bool, Optional[str]]:
    """
    서버 기준 정책 위반 판정 (프론트 협조 없이)
    """
    if not policy:
        return False, None

    if event_type == "seek":
        if not policy.get("allow_skip", False):
            return True, "seek_not_allowed"

    if event_type == "speed":
        max_speed = policy.get("max_speed", 1.0)
        speed = float(payload.get("speed", 1.0))
        if speed > max_speed:
            return True, f"speed_exceeded:{speed}>{max_speed}"

    return False, None


def violation_should_revoke(*, violated_count: int, total: int) -> bool:
    """
    위반 누적 기준 (보수적으로 설정)
    """
    if violated_count >= 3:
        return True
    if total > 0 and (violated_count / total) >= 0.5:
        return True
    return False


==========================================================================================
# FILE: serializers.py
==========================================================================================
# PATH: apps/support/video/serializers.py

from django.conf import settings
from rest_framework import serializers

from apps.domains.lectures.models import Session
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)

# ========================================================
# Video
# ========================================================

class VideoSerializer(serializers.ModelSerializer):
    """
    ✅ FINAL SEALED VERSION (SaaS production)

    - DB 저장 필드와 API 노출 필드 분리
    - CDN 기반 URL 동적 생성
    - Cache-busting 지원
    - Legacy 경로 normalize
    """

    # write
    session = serializers.PrimaryKeyRelatedField(
        queryset=Session.objects.all(),
        write_only=True,
    )

    # read
    session_id = serializers.IntegerField(
        source="session.id",
        read_only=True,
    )

    source_type = serializers.SerializerMethodField()

    # CDN derived
    thumbnail_url = serializers.SerializerMethodField()
    hls_url = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session",
            "session_id",
            "title",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "thumbnail",
            "thumbnail_url",
            "hls_path",
            "hls_url",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = [
            "id",
            "session_id",
            "created_at",
            "updated_at",
            "thumbnail",
            "hls_path",
            "thumbnail_url",
            "hls_url",
        ]
        ref_name = "SealedVideo"

    # ---------------------------
    # helpers
    # ---------------------------

    def get_source_type(self, obj):
        return "s3" if obj.file_key else "unknown"

    def _cdn_base(self) -> str | None:
        base = getattr(settings, "CDN_HLS_BASE_URL", None)
        return base.rstrip("/") if base else None

    def _normalize_media_path(self, path: str) -> str:
        path = path.lstrip("/")

        if path.startswith("media/"):
            return path

        if path.startswith("storage/media/"):
            return path[len("storage/"):]

        return path

    def _cache_version(self, obj) -> int:
        try:
            return int(obj.updated_at.timestamp())
        except Exception:
            return 0

    # ---------------------------
    # CDN fields
    # ---------------------------

    def get_thumbnail_url(self, obj):
        cdn = self._cdn_base()
        if not cdn:
            return None

        # 1️⃣ explicit thumbnail
        if obj.thumbnail:
            path = self._normalize_media_path(obj.thumbnail.name)
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        # 2️⃣ READY fallback
        if obj.status == obj.Status.READY:
            path = self._normalize_media_path(
                f"media/hls/videos/{obj.id}/thumbnail.jpg"
            )
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        return None

    def get_hls_url(self, obj):
        if not obj.hls_path:
            return None

        cdn = self._cdn_base()
        if not cdn:
            return None

        path = self._normalize_media_path(str(obj.hls_path))
        return f"{cdn}/{path}?v={self._cache_version(obj)}"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "SealedVideoDetail"


# ========================================================
# Permission / Progress
# ========================================================

class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "SealedVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "SealedVideoProgress"


# ========================================================
# Playback API
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


# ========================================================
# Events
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(
        choices=VideoPlaybackEvent.EventType.choices
    )
    occurred_at = serializers.IntegerField(required=False)
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


# ========================================================
# Event List (Admin Analytics)
# ========================================================

class VideoPlaybackEventListSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )
    enrollment_id = serializers.IntegerField(
        source="enrollment.id",
        read_only=True,
    )

    severity = serializers.SerializerMethodField()
    score = serializers.SerializerMethodField()

    class Meta:
        model = VideoPlaybackEvent
        fields = [
            "id",
            "video",
            "enrollment_id",
            "student_name",
            "session_id",
            "user_id",
            "event_type",
            "violated",
            "violation_reason",
            "event_payload",
            "policy_snapshot",
            "occurred_at",
            "received_at",
            "severity",
            "score",
        ]
        ref_name = "SealedVideoPlaybackEventList"

    # ---------------------------
    # Risk classification
    # ---------------------------

    def get_severity(self, obj):
        base = {
            "SEEK_ATTEMPT": "warn",
            "SPEED_CHANGE_ATTEMPT": "warn",
            "FOCUS_LOST": "warn",
            "VISIBILITY_HIDDEN": "info",
            "PLAYER_ERROR": "info",
        }.get(obj.event_type, "info")

        return "danger" if obj.violated else base

    def get_score(self, obj):
        weights = {
            "VISIBILITY_HIDDEN": 1,
            "FOCUS_LOST": 2,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "PLAYER_ERROR": 1,
        }

        w = int(weights.get(obj.event_type, 1))

        if obj.violated:
            w *= 2
        if obj.violation_reason:
            w += 1

        return w


# ========================================================
# Aggregated Risk Row
# ========================================================

class VideoRiskRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    score = serializers.IntegerField()
    danger = serializers.IntegerField()
    warn = serializers.IntegerField()
    info = serializers.IntegerField()
    last_occurred_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/support/video/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
    VideoPlaybackEventViewSet,
    VideoProcessingCompleteView,
    VideoPolicyImpactAPIView,
)

from .views.achievement_views import VideoAchievementView
from .views.playback_views import (
    PlaybackStartView,
    PlaybackRefreshView,
    PlaybackHeartbeatView,
    PlaybackEndView,
    PlaybackEventBatchView,
)

# ========================================================
# Router
# ========================================================

router = DefaultRouter()
router.register(r"videos", VideoViewSet, basename="videos")
router.register(r"video-permissions", VideoPermissionViewSet, basename="video-permissions")
router.register(r"video-progress", VideoProgressViewSet, basename="video-progress")
router.register(r"video-playback-events", VideoPlaybackEventViewSet, basename="video-playback-events")

# ========================================================
# urlpatterns (선언 먼저!)
# ========================================================

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / Extra APIs
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="video-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="video-video-stats-nested",
    ),
    path(
        "videos/<int:video_id>/achievement/",
        VideoAchievementView.as_view(),
        name="video-video-achievement",
    ),
]

# ========================================================
# Playback APIs (Student)
# ========================================================

urlpatterns += [
    path("playback/start/", PlaybackStartView.as_view()),
    path("playback/refresh/", PlaybackRefreshView.as_view()),
    path("playback/heartbeat/", PlaybackHeartbeatView.as_view()),
    path("playback/end/", PlaybackEndView.as_view()),
    path("playback/events/", PlaybackEventBatchView.as_view()),
]

# ========================================================
# Internal (Legacy ACK - kept)
# ========================================================

urlpatterns += [
    path(
        "internal/videos/<int:video_id>/processing-complete/",
        VideoProcessingCompleteView.as_view(),
        name="video-video-processing-complete",
    ),
]

# ========================================================
# Policy Impact (Admin preview)
# ========================================================

urlpatterns += [
    path(
        "videos/<int:video_id>/policy-impact/",
        VideoPolicyImpactAPIView.as_view(),
        name="video-video-policy-impact",
    ),
]


==========================================================================================
# FILE: urls_internal.py
==========================================================================================
# PATH: apps/support/video/urls_internal.py

from __future__ import annotations

from django.urls import path

from apps.support.video.views.internal_video_worker import (
    VideoWorkerClaimNextView,
    VideoWorkerCompleteView,
    VideoWorkerFailView,
)

from apps.support.video.views.internal_video_worker_heartbeat import (
    InternalVideoWorkerHeartbeatView,
)

urlpatterns = [
    # --------------------------------------------------
    # Worker job control
    # --------------------------------------------------
    path(
        "video-worker/next/",
        VideoWorkerClaimNextView.as_view(),
        name="video_worker_next",
    ),
    path(
        "video-worker/<int:video_id>/complete/",
        VideoWorkerCompleteView.as_view(),
        name="video_worker_complete",
    ),
    path(
        "video-worker/<int:video_id>/fail/",
        VideoWorkerFailView.as_view(),
        name="video_worker_fail",
    ),

    # --------------------------------------------------
    # Worker heartbeat (long-running protection)
    # --------------------------------------------------
    path(
        "video-worker/<int:video_id>/heartbeat/",
        InternalVideoWorkerHeartbeatView.as_view(),
        name="internal-video-worker-heartbeat",
    ),
]


==========================================================================================
# FILE: utils.py
==========================================================================================
import ffmpeg


def extract_duration_seconds_from_url(url: str) -> int | None:
    """
    ffprobe를 URL에 직접 적용 (Range Request 기반)
    """
    try:
        probe = ffmpeg.probe(url)
        fmt = probe.get("format") or {}
        dur = fmt.get("duration")
        if dur is None:
            return None
        return int(float(dur))
    except Exception as e:
        print("duration 추출 실패:", e)
        return None


def generate_thumbnail_from_url(
    url: str,
    ss_seconds: int = 1,
) -> bytes | None:
    """
    URL 스트리밍 기반 썸네일 생성 (전체 다운로드 ❌)
    """
    try:
        out, _ = (
            ffmpeg
            .input(url, ss=ss_seconds)
            .output(
                "pipe:",
                vframes=1,
                format="image2",
                vcodec="mjpeg",
            )
            .run(capture_stdout=True, capture_stderr=True)
        )
        return out
    except Exception as e:
        print("썸네일 생성 실패:", e)
        return None


==========================================================================================
# FILE: cdn/__init__.py
==========================================================================================
# CDN helpers package


==========================================================================================
# FILE: cdn/cloudflare_signing.py
==========================================================================================
# PATH: apps/support/video/cdn/cloudflare_signing.py

from __future__ import annotations

import base64
import hmac
import hashlib
from dataclasses import dataclass
from typing import Dict, Optional
from urllib.parse import urlencode


def _b64url(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).decode("ascii").rstrip("=")


@dataclass(frozen=True)
class CloudflareSignedURL:
    """
    CDN Edge(Cloudflare Worker 등)에서 검증 가능한 쿼리 서명 생성.
    - sig = HMAC-SHA256(secret, f"{path}|{exp}|{kid}|{uid}")
    - 쿼리: exp, sig, kid, uid(옵션)

    주의:
    - 백엔드는 "생성"만 담당
    - 검증/차단은 CDN 레이어에서 수행
    """
    secret: str
    key_id: str = "v1"

    def sign(self, *, path: str, expires_at: int, user_id: Optional[int] = None) -> Dict[str, str]:
        p = path if path.startswith("/") else f"/{path}"
        uid = "" if user_id is None else str(int(user_id))

        msg = f"{p}|{int(expires_at)}|{self.key_id}|{uid}".encode("utf-8")
        mac = hmac.new(self.secret.encode("utf-8"), msg, hashlib.sha256).digest()

        params = {
            "exp": str(int(expires_at)),
            "sig": _b64url(mac),
            "kid": self.key_id,
        }
        if user_id is not None:
            params["uid"] = str(int(user_id))
        return params

    def build_url(
        self,
        *,
        cdn_base: str,
        path: str,
        expires_at: int,
        user_id: Optional[int] = None,
        extra_query: Optional[Dict[str, str]] = None,
    ) -> str:
        base = (cdn_base or "").rstrip("/")
        p = path if path.startswith("/") else f"/{path}"

        q = {}
        if extra_query:
            q.update({k: str(v) for k, v in extra_query.items()})

        q.update(self.sign(path=p, expires_at=expires_at, user_id=user_id))
        return f"{base}{p}?{urlencode(q)}"


==========================================================================================
# FILE: cdn/cloudfront.py
==========================================================================================
# apps/support/video/cdn/cloudfront.py
# ❗ CloudFront DEPRECATED
# ❗ Cloudflare CDN 사용
# ❗ Signed Cookie / RSA / hazmat 전부 비활성화

from typing import Dict


def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    Cloudflare CDN 사용
    - Signed Cookie 사용 안 함
    - 항상 빈 dict 반환
    """
    return {}


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    Cloudflare CDN 사용
    - 쿠키 설정 안 함
    """
    return {}


==========================================================================================
# FILE: management/commands/reconcile_playback_sessions.py
==========================================================================================
# PATH: apps/support/video/management/commands/reconcile_playback_sessions.py

from django.core.management.base import BaseCommand
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.support.video.models import VideoPlaybackSession


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_user_revoked(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:revoked"


class Command(BaseCommand):
    help = "Reconcile VideoPlaybackSession DB state with Redis (EXPIRED/REVOKED)"

    def handle(self, *args, **options):
        now = timezone.now()

        qs = VideoPlaybackSession.objects.filter(
            status=VideoPlaybackSession.Status.ACTIVE
        ).select_related("enrollment", "enrollment__student")

        expired = 0
        revoked = 0

        for s in qs.iterator():
            user_id = s.enrollment.student_id
            session_id = s.session_id

            # revoked wins
            if redis_client.sismember(_key_user_revoked(user_id), session_id):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=now,
                )
                revoked += 1
                continue

            # expired if missing in zset or score <= now
            score = redis_client.zscore(_key_user_sessions(user_id), session_id)
            if score is None or int(score) <= int(now.timestamp()):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.EXPIRED,
                    ended_at=now,
                )
                expired += 1

        self.stdout.write(
            self.style.SUCCESS(
                f"reconcile done expired={expired} revoked={revoked}"
            )
        )


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-30 21:56

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("enrollment", "0001_initial"),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.CreateModel(
            name="Video",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                (
                    "file_key",
                    models.CharField(
                        blank=True,
                        help_text="S3 object key (presigned upload)",
                        max_length=500,
                    ),
                ),
                ("duration", models.PositiveIntegerField(blank=True, null=True)),
                ("order", models.PositiveIntegerField(default=1)),
                (
                    "thumbnail",
                    models.ImageField(blank=True, null=True, upload_to="thumbnails/"),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "업로드 대기"),
                            ("UPLOADED", "업로드 완료"),
                            ("PROCESSING", "처리중"),
                            ("READY", "사용 가능"),
                            ("FAILED", "실패"),
                        ],
                        db_index=True,
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("allow_skip", models.BooleanField(default=False)),
                ("max_speed", models.FloatField(default=1.0)),
                ("show_watermark", models.BooleanField(default=True)),
                (
                    "policy_version",
                    models.PositiveIntegerField(
                        db_index=True,
                        default=1,
                        help_text="Increment on policy/permission changes to invalidate existing tokens",
                    ),
                ),
                ("error_reason", models.TextField(blank=True, default="", null=True)),
                (
                    "hls_path",
                    models.CharField(
                        blank=True,
                        help_text="HLS master playlist path (relative to CDN root)",
                        max_length=500,
                    ),
                ),
                ("processing_started_at", models.DateTimeField(blank=True, null=True)),
                ("leased_until", models.DateTimeField(blank=True, null=True)),
                ("leased_by", models.CharField(blank=True, default="", max_length=64)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="videos",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["order", "id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPermission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rule",
                    models.CharField(
                        choices=[
                            ("free", "무제한"),
                            ("once", "1회 제한"),
                            ("blocked", "제한"),
                        ],
                        default="once",
                        max_length=20,
                    ),
                ),
                ("allow_skip_override", models.BooleanField(blank=True, null=True)),
                ("max_speed_override", models.FloatField(blank=True, null=True)),
                ("show_watermark_override", models.BooleanField(blank=True, null=True)),
                ("block_speed_control", models.BooleanField(default=False)),
                ("block_seek", models.BooleanField(default=False)),
                ("is_override", models.BooleanField(default=False)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_permissions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="permissions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoPlaybackEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("user_id", models.BigIntegerField(db_index=True)),
                (
                    "event_type",
                    models.CharField(
                        choices=[
                            ("VISIBILITY_HIDDEN", "탭 숨김"),
                            ("VISIBILITY_VISIBLE", "탭 노출"),
                            ("FOCUS_LOST", "포커스 이탈"),
                            ("FOCUS_GAINED", "포커스 복귀"),
                            ("SEEK_ATTEMPT", "탐색 시도"),
                            ("SPEED_CHANGE_ATTEMPT", "배속 변경 시도"),
                            ("FULLSCREEN_ENTER", "전체화면 진입"),
                            ("FULLSCREEN_EXIT", "전체화면 종료"),
                            ("PLAYER_ERROR", "플레이어 오류"),
                        ],
                        db_index=True,
                        max_length=32,
                    ),
                ),
                ("event_payload", models.JSONField(blank=True, default=dict)),
                ("policy_snapshot", models.JSONField(blank=True, default=dict)),
                ("violated", models.BooleanField(db_index=True, default=False)),
                (
                    "violation_reason",
                    models.CharField(blank=True, default="", max_length=64),
                ),
                (
                    "occurred_at",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                ("received_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_playback_events",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_events",
                        to="video.video",
                    ),
                ),
            ],
            options={
                "ordering": ["-received_at", "-id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackSession",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("device_id", models.CharField(db_index=True, max_length=128)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "활성"),
                            ("ENDED", "종료"),
                            ("REVOKED", "차단"),
                            ("EXPIRED", "만료"),
                        ],
                        db_index=True,
                        default="ACTIVE",
                        max_length=16,
                    ),
                ),
                ("started_at", models.DateTimeField(auto_now_add=True)),
                ("ended_at", models.DateTimeField(blank=True, null=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoProgress",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("progress", models.FloatField(default=0)),
                ("last_position", models.IntegerField(default=0)),
                ("completed", models.BooleanField(default=False)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_progress",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="progresses",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["status", "updated_at"], name="video_video_status_782ba3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["leased_until", "status"], name="video_video_leased__a8f039_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="videopermission",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_permission"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["video", "enrollment", "session_id"],
                name="video_video_video_i_1ea099_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["user_id", "session_id"], name="video_video_user_id_474fa3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["event_type", "received_at"],
                name="video_video_event_t_b8ca86_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["status", "started_at"], name="video_video_status_175f42_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["video", "enrollment", "status"],
                name="video_video_video_i_5d0bbd_idx",
            ),
        ),
        migrations.AddConstraint(
            model_name="videoplaybacksession",
            constraint=models.UniqueConstraint(
                fields=("session_id",), name="uniq_video_playback_session_id"
            ),
        ),
        migrations.AddConstraint(
            model_name="videoprogress",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_progress"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/playback_session.py
==========================================================================================
# PATH: apps/support/video/services/playback_session.py

import time
import uuid
from typing import Dict, Any, Tuple, Iterable, Optional

from django.conf import settings
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.domains.enrollment.models import Enrollment
from apps.support.video.models import (
    Video,
    VideoPlaybackSession,
)

# =======================================================
# Redis Key Helpers
# =======================================================

def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    # zset (session_id -> expires_at)
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_session(session_id: str) -> str:
    # hash
    return f"media:playback:session:{session_id}"


def _key_user_devices(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:devices"


def _key_user_revoked(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:revoked"


# ✅ 문제 1/7: 세션 단위 위반 누적 카운터
def _key_session_violation(session_id: str) -> str:
    # hash: { violated, total, last_reason }
    return f"media:playback:session:{session_id}:violation"


# =======================================================
# Decode Helpers (bytes/str 방어)
# =======================================================

def _decode(value):
    if value is None:
        return None
    if isinstance(value, (bytes, bytearray)):
        return value.decode()
    return value


def _decode_set(values: Iterable) -> set[str]:
    return {_decode(v) for v in (values or set())}


# =======================================================
# Internal Helpers
# =======================================================

def _cleanup_expired_sessions(user_id: int) -> None:
    """
    만료된 세션 정리
    - session zset
    - session hash
    - device set (누수 방지)
    """
    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expired = redis_client.zrangebyscore(sessions_key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)

    for raw_sid in expired:
        sid = _decode(raw_sid)

        device_id = _decode(redis_client.hget(_key_session(sid), "device_id"))
        if device_id:
            pipe.srem(devices_key, device_id)

        pipe.zrem(sessions_key, sid)
        pipe.delete(_key_session(sid))

        # violation hash도 같이 제거(누수 방지)
        pipe.delete(_key_session_violation(sid))

    pipe.execute()


def _session_ttl_seconds_from_expires_at(expires_at: int) -> int:
    now = _now()
    ttl = max(0, int(expires_at) - now)
    # 보호: 너무 짧으면 최소 30s
    return max(30, ttl)


# =======================================================
# Core Session APIs (Redis / Infra)
# =======================================================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    """
    Redis 기반 재생 세션 발급 (공통 Infra)
    """
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = _decode_set(redis_client.smembers(devices_key))

    # 기기 제한
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    # 동시 세션 제한
    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)

    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(
        _key_session(session_id),
        mapping={
            "user_id": str(user_id),
            "device_id": device_id,
            "expires_at": str(expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)

    # violation state init
    pipe.hset(
        _key_session_violation(session_id),
        mapping={
            "violated": "0",
            "total": "0",
            "last_reason": "",
        },
    )
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    """
    세션 TTL 연장
    - user_id 소유 검증 포함
    - revoked면 False
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sid_key = _key_session(session_id)
    sessions_key = _key_user_sessions(user_id)

    owner = _decode(redis_client.hget(sid_key, "user_id"))
    if not owner or int(owner) != int(user_id):
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(
        sid_key,
        mapping={
            "expires_at": str(new_expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)

    # violation ttl도 함께 연장
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True


def end_session(*, user_id: int, session_id: str) -> None:
    """
    명시적 세션 종료
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    pipe.execute()


def revoke_session(*, user_id: int, session_id: str) -> None:
    """
    ✅ 문제 1: 서버 강제 차단
    - revoked set에 기록(재사용 방지)
    - 세션 자료 즉시 제거
    - violation hash 제거(누수 방지)
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.sadd(_key_user_revoked(user_id), session_id)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    # revoked set 누수 방지: TTL (세션 TTL 알 수 없으면 기본 1h)
    try:
        pipe.expire(_key_user_revoked(user_id), int(getattr(settings, "VIDEO_REVOKED_SET_TTL_SECONDS", 3600)))
    except Exception:
        pass

    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    세션 활성 여부 확인
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    return int(score) > _now()


# =======================================================
# ✅ 문제 1/7: 세션 단위 위반 누적(우회 불가)
# =======================================================

def record_session_event(
    *,
    user_id: int,
    session_id: str,
    violated: bool,
    reason: str = "",
) -> Dict[str, int]:
    """
    세션 단위 누적 카운터:
    - total +1
    - violated이면 violated +1
    - TTL은 세션 expires_at 기반으로 동기화
    """
    session_id = _decode(session_id)

    # 세션 expires_at 읽기(없으면 default TTL 사용)
    expires_at_raw = _decode(redis_client.hget(_key_session(session_id), "expires_at"))
    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
    if expires_at_raw:
        try:
            ttl = _session_ttl_seconds_from_expires_at(int(expires_at_raw))
        except Exception:
            ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    key = _key_session_violation(session_id)

    pipe = redis_client.pipeline(transaction=True)
    pipe.hincrby(key, "total", 1)
    if violated:
        pipe.hincrby(key, "violated", 1)
        if reason:
            pipe.hset(key, "last_reason", str(reason)[:200])
    pipe.expire(key, ttl + 60)
    res = pipe.execute()

    # res[0]=total, res[1]=violated or total, etc → 안전 파싱
    total = 0
    violated_cnt = 0
    try:
        # total always first
        total = int(res[0] or 0)
        # if violated, second is violated; else second is expire result
        if violated:
            violated_cnt = int(res[1] or 0)
        else:
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
    except Exception:
        # fallback fetch
        try:
            total = int(_decode(redis_client.hget(key, "total")) or 0)
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
        except Exception:
            total = 0
            violated_cnt = 0

    return {"total": total, "violated": violated_cnt}


def get_session_violation_stats(*, session_id: str) -> Dict[str, int]:
    session_id = _decode(session_id)
    key = _key_session_violation(session_id)
    data = redis_client.hgetall(key) or {}
    try:
        total = int(_decode(data.get(b"total") or data.get("total") or 0))
    except Exception:
        total = 0
    try:
        violated = int(_decode(data.get(b"violated") or data.get("violated") or 0))
    except Exception:
        violated = 0
    return {"total": total, "violated": violated}


def should_revoke_by_stats(*, violated: int, total: int) -> bool:
    """
    보수적 차단 기준:
    - violated >= threshold
    - 또는 violated/total 비율이 너무 높으면 차단
    """
    threshold = int(getattr(settings, "VIDEO_VIOLATION_REVOKE_THRESHOLD", 3))
    ratio = float(getattr(settings, "VIDEO_VIOLATION_REVOKE_RATIO", 0.5))

    if int(violated) >= threshold:
        return True
    if int(total) > 0 and (float(violated) / float(total)) >= ratio:
        return True
    return False


# =======================================================
# Facade API (Student ONLY) - 기존 유지
# =======================================================

def create_playback_session(
    *,
    user,
    video_id: int,
    enrollment_id: int,
    device_id: str,
) -> dict:
    """
    학생 전용 Facade API

    책임:
    - "재생 세션 생성"만 담당
    - 권한 / 수강 검증은 View에서 선행되어야 함
    """

    # 🚫 강사 / 운영자 차단
    if getattr(user, "is_instructor", False) or getattr(user, "is_staff", False):
        return {
            "ok": False,
            "error": "instructor_must_use_play_api",
        }

    if not device_id:
        return {"ok": False, "error": "device_id_required"}

    video = Video.objects.select_related(
        "session",
        "session__lecture",
    ).get(id=video_id)

    enrollment = Enrollment.objects.select_related(
        "student",
        "lecture",
    ).get(
        id=enrollment_id,
        status="ACTIVE",
    )

    # 🛡️ 안전 가드 (View 누락 방지용)
    if enrollment.lecture_id != video.session.lecture_id:
        return {
            "ok": False,
            "error": "enrollment_lecture_mismatch",
        }

    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    ok, sess, err = issue_session(
        user_id=user.id,
        device_id=device_id,
        ttl_seconds=ttl,
        max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
        max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
    )

    if not ok:
        return {
            "ok": False,
            "error": err,
        }

    session_id = str(sess["session_id"])
    expires_at = int(sess["expires_at"])

    VideoPlaybackSession.objects.create(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
        device_id=device_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        started_at=timezone.now(),
    )

    return {
        "ok": True,
        "video_id": video.id,
        "enrollment_id": enrollment.id,
        "session_id": session_id,
        "expires_at": expires_at,
    }


==========================================================================================
# FILE: services/video_stats.py
==========================================================================================
# PATH: apps/support/video/services/video_stats.py

from apps.domains.enrollment.models import Enrollment
from apps.domains.attendance.models import Attendance
from apps.support.video.models import VideoProgress, VideoPermission


def build_video_stats_students(video):
    """
    ✅ Single Source of Truth
    - stats
    - policy-impact
    - admin preview
    전부 이 함수만 사용해야 함
    """

    lecture = video.session.lecture

    enrollments = Enrollment.objects.filter(
        lecture=lecture,
        status="ACTIVE",
    ).select_related("student")

    progresses = {
        p.enrollment_id: p
        for p in VideoProgress.objects.filter(video=video)
    }

    perms = {
        p.enrollment_id: p
        for p in VideoPermission.objects.filter(video=video)
    }

    attendance = {
        a.enrollment_id: a.status
        for a in Attendance.objects.filter(session=video.session)
    }

    students = []

    for e in enrollments:
        vp = progresses.get(e.id)
        perm = perms.get(e.id)

        rule = perm.rule if perm else "free"
        effective_rule = rule

        # once → completed 시 free 승격
        if rule == "once" and vp and vp.completed:
            effective_rule = "free"

        students.append({
            "enrollment": e.id,
            "student_name": e.student.name,
            "attendance_status": attendance.get(e.id),
            "progress": vp.progress if vp else 0,
            "completed": vp.completed if vp else False,
            "rule": rule,
            "effective_rule": effective_rule,
        })

    return students


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/support/video/views/__init__.py

from .video_policy_impact import VideoPolicyImpactAPIView

from .video_views import VideoViewSet
from .permission_views import VideoPermissionViewSet
from .progress_views import VideoProgressViewSet
from .internal_views import VideoProcessingCompleteView
from .event_views import VideoPlaybackEventViewSet


==========================================================================================
# FILE: views/achievement_views.py
==========================================================================================
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from django.db.models import Avg, Sum

from apps.domains.attendance.models import Attendance
from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoProgress


class VideoAchievementView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session").get(id=video_id)
        lecture = video.session.lecture

        # 영상 수강 대상 학생 (출석이 ONLINE)
        online_attendance = Attendance.objects.filter(
            session=video.session,
            status="ONLINE",
        )

        enrollment_ids = online_attendance.values_list("enrollment_id", flat=True)

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(
                video=video,
                enrollment_id__in=enrollment_ids,
            )
        }

        students = []
        completed_count = 0
        total_progress = 0

        for att in online_attendance.select_related("enrollment__student"):
            enrollment = att.enrollment
            vp = progresses.get(enrollment.id)

            progress = vp.progress if vp else 0
            completed = vp.completed if vp else False

            if completed:
                completed_count += 1

            total_progress += progress

            # 상태 계산
            if progress >= 0.95:
                status = "completed"
            elif progress >= 0.5:
                status = "warning"
            else:
                status = "danger"

            students.append({
                "enrollment": enrollment.id,
                "student_name": enrollment.student.name,
                "progress": round(progress * 100, 1),
                "completed": completed,
                "watched_seconds": vp.last_position if vp else 0,
                "status": status,
            })

        total = len(students)
        avg_progress = (total_progress / total) if total else 0

        return Response({
            "summary": {
                "total_students": total,
                "avg_progress": round(avg_progress * 100, 1),
                "completed_rate": round((completed_count / total) * 100, 1) if total else 0,
                "incomplete_count": total - completed_count,
            },
            "students": students,
        })


==========================================================================================
# FILE: views/event_views.py
==========================================================================================
# PATH: apps/support/video/views/event_views.py

import csv
from datetime import timedelta

from django.http import HttpResponse
from django.utils import timezone

from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.filters import SearchFilter

from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoPlaybackEvent
from ..serializers import (
    VideoPlaybackEventListSerializer,
    VideoRiskRowSerializer,
)


def _range_to_since(range_key: str):
    now = timezone.now()
    if range_key == "24h":
        return now - timedelta(hours=24)
    if range_key == "7d":
        return now - timedelta(days=7)
    return None


def _event_score(event_type: str, violated: bool, violation_reason: str | None):
    weights = {
        "VISIBILITY_HIDDEN": 1,
        "VISIBILITY_VISIBLE": 0,
        "FOCUS_LOST": 2,
        "FOCUS_GAINED": 0,
        "SEEK_ATTEMPT": 3,
        "SPEED_CHANGE_ATTEMPT": 3,
        "FULLSCREEN_ENTER": 0,
        "FULLSCREEN_EXIT": 0,
        "PLAYER_ERROR": 1,
    }
    w = int(weights.get(event_type, 1))
    if violated:
        w *= 2
    if violation_reason:
        w += 1
    return w


class VideoPlaybackEventViewSet(ReadOnlyModelViewSet):
    """
    Admin / Staff 전용
    - list
    - risk
    - export
    """

    queryset = (
        VideoPlaybackEvent.objects
        .all()
        .select_related("enrollment", "enrollment__student", "video")
    )
    serializer_class = VideoPlaybackEventListSerializer
    permission_classes = [IsAuthenticated]

    # ✅ 검색 + 필터 동시 지원
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["video", "enrollment", "violated"]
    search_fields = [
        "enrollment__student__name",
        "session_id",
        "user_id",
    ]

    def get_queryset(self):
        qs = super().get_queryset()

        video_id = self.request.query_params.get("video")
        if video_id:
            qs = qs.filter(video_id=video_id)

        range_key = self.request.query_params.get("range", "24h")
        since = _range_to_since(range_key)
        if since:
            qs = qs.filter(occurred_at__gte=since)

        # ✅ event_type 다중 필터 (comma-separated)
        et = self.request.query_params.get("event_type")
        if et:
            types = [x for x in et.split(",") if x]
            if types:
                qs = qs.filter(event_type__in=types)

        return qs.order_by("-occurred_at", "-id")

    # --------------------------------------------------
    # Risk Top
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="risk")
    def risk(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        limit = int(request.query_params.get("limit") or 5)
        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        agg = {}
        for ev in qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment_id": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                    "danger": 0,
                    "warn": 0,
                    "info": 0,
                    "last_occurred_at": None,
                }

            s = _event_score(ev.event_type, bool(ev.violated), ev.violation_reason)
            agg[eid]["score"] += s

            if ev.violated:
                agg[eid]["danger"] += 1
            elif ev.event_type in ("SEEK_ATTEMPT", "SPEED_CHANGE_ATTEMPT", "FOCUS_LOST"):
                agg[eid]["warn"] += 1
            else:
                agg[eid]["info"] += 1

            if (
                agg[eid]["last_occurred_at"] is None
                or ev.occurred_at > agg[eid]["last_occurred_at"]
            ):
                agg[eid]["last_occurred_at"] = ev.occurred_at

        rows = sorted(
            agg.values(),
            key=lambda r: (r["score"], r["danger"], r["warn"]),
            reverse=True,
        )[:limit]

        return Response(VideoRiskRowSerializer(rows, many=True).data)

    # --------------------------------------------------
    # CSV Export
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="export")
    def export_csv(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        qs = qs.order_by("-occurred_at", "-id")

        resp = HttpResponse(content_type="text/csv; charset=utf-8")
        resp["Content-Disposition"] = (
            f'attachment; filename="video_{video_id}_events_{range_key}.csv"'
        )

        writer = csv.writer(resp)
        writer.writerow([
            "occurred_at",
            "student_name",
            "enrollment_id",
            "event_type",
            "violated",
            "violation_reason",
            "session_id",
            "user_id",
            "score",
            "payload",
        ])

        for ev in qs.iterator():
            writer.writerow([
                ev.occurred_at.isoformat(),
                ev.enrollment.student.name if ev.enrollment_id else "",
                ev.enrollment_id,
                ev.event_type,
                "Y" if ev.violated else "N",
                ev.violation_reason or "",
                ev.session_id,
                ev.user_id,
                _event_score(ev.event_type, bool(ev.violated), ev.violation_reason),
                ev.event_payload,
            ])

        return resp


==========================================================================================
# FILE: views/internal_video_worker.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker.py

from __future__ import annotations

from datetime import timedelta
from typing import Any

from django.conf import settings
from django.db import transaction
from django.http import JsonResponse
from django.utils import timezone
from django.db import models  # ✅ 원본 의미 유지 + 동작 보강 (기존 파일 하단 import 대체)

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny

from apps.support.video.models import Video


def _require_worker_token(request) -> bool:
    token = request.headers.get("X-Worker-Token")
    return bool(token) and token == getattr(settings, "INTERNAL_WORKER_TOKEN", "")


def _worker_id(request) -> str:
    return (
        request.headers.get("X-Worker-Id")
        or request.headers.get("X-Worker-ID")
        or "worker-unknown"
    )


LEASE_SECONDS = int(getattr(settings, "VIDEO_WORKER_LEASE_SECONDS", 60))
MAX_BATCH = int(getattr(settings, "VIDEO_WORKER_MAX_BATCH", 1))


def _lease_cutoff(now):
    # DB 스키마 변경 없이 "PROCESSING stuck" 회수:
    # - processing 상태가 LEASE_SECONDS 이상 갱신이 없으면 reclaim 허용
    return now - timedelta(seconds=LEASE_SECONDS)


def _parse_int(value: Any) -> int | None:
    if value is None:
        return None
    try:
        return int(value)
    except Exception:
        return None


def _is_lease_owner(video: Video, worker_id: str) -> bool:
    """
    ✅ 다중 노드 중복 처리 방지:
    - leased_by가 설정돼 있으면 소유자만 complete/fail/heartbeat 가능
    - leased_until이 지나면(만료) owner 체크를 완화(회수/재처리 허용)
    - 기존 구조(updated_at reclaim) 그대로 유지하면서 중앙 통제 추가
    """
    if not hasattr(video, "leased_by") or not hasattr(video, "leased_until"):
        return True

    lb = (getattr(video, "leased_by", "") or "").strip()
    lu = getattr(video, "leased_until", None)

    if not lb:
        return True

    # lease 만료면 소유권 강제 안 함(회수 가능)
    if lu is not None and lu <= timezone.now():
        return True

    return lb == (worker_id or "")


class VideoWorkerClaimNextView(APIView):
    """
    Worker polls:
      GET /api/v1/internal/video-worker/next/
    Returns:
      200 { "job": {video_id, file_key} }  OR  204 no content

    NOTE:
    - 기존 reclaim 로직(updated_at 기준) 유지
    - 여기에 leased_by/leased_until만 "추가 기록"하여
      multi-host 환경에서 완료처리 경합 방지
    """
    permission_classes = [AllowAny]

    def get(self, request):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        now = timezone.now()
        cutoff = _lease_cutoff(now)

        wid = _worker_id(request)

        with transaction.atomic():
            video = (
                Video.objects.select_for_update(skip_locked=True)
                .filter(
                    models.Q(status=Video.Status.UPLOADED)
                    | models.Q(status=Video.Status.PROCESSING, updated_at__lt=cutoff)
                )
                .order_by("id")
                .first()
            )

            if video is None:
                return JsonResponse({}, status=204)

            # reclaim된 작업은 실패사유 남기지 않고 재처리
            video.status = Video.Status.PROCESSING

            # ✅ lease 필드가 있으면 반드시 기록(중복 완료 방지)
            if hasattr(video, "processing_started_at"):
                video.processing_started_at = now
            if hasattr(video, "leased_until"):
                video.leased_until = now + timedelta(seconds=LEASE_SECONDS)
            if hasattr(video, "leased_by"):
                video.leased_by = wid

            update_fields = ["status"]
            if hasattr(video, "processing_started_at"):
                update_fields.append("processing_started_at")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse(
            {"job": {"video_id": video.id, "file_key": video.file_key}},
            status=200,
        )


class VideoWorkerCompleteView(APIView):
    """
    Worker reports success:
      POST /api/v1/internal/video-worker/{video_id}/complete/
      body: {hls_path, duration}

    idempotent:
    - 이미 READY면 ok 반환

    ✅ 보강:
    - lease owner(worker_id)만 complete 가능
      (multi-host 이중 처리의 "완료 경합" 차단)
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = request.data if hasattr(request, "data") else {}
        hls_path = data.get("hls_path")
        duration = _parse_int(data.get("duration"))

        if not hls_path:
            return JsonResponse({"detail": "hls_path required"}, status=400)

        with transaction.atomic():
            video = Video.objects.select_for_update().filter(id=video_id).first()
            if video is None:
                return JsonResponse({"detail": "Not found"}, status=404)

            # ✅ lease owner 검증
            if not _is_lease_owner(video, wid):
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)

            # ✅ idempotent 처리
            if video.status == Video.Status.READY and video.hls_path:
                return JsonResponse({"ok": True, "idempotent": True}, status=200)

            video.hls_path = str(hls_path)
            if duration is not None and duration >= 0:
                video.duration = duration

            video.status = Video.Status.READY

            # lease 해제
            if hasattr(video, "leased_until"):
                video.leased_until = None
            if hasattr(video, "leased_by"):
                video.leased_by = ""

            update_fields = ["hls_path", "status"]
            if duration is not None and duration >= 0:
                update_fields.append("duration")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse({"ok": True}, status=200)


class VideoWorkerFailView(APIView):
    """
    Worker reports failure:
      POST /api/v1/internal/video-worker/{video_id}/fail/
      body: {reason}

    idempotent:
    - 이미 FAILED면 ok 반환

    ✅ 보강:
    - lease owner(worker_id)만 fail 가능
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = request.data if hasattr(request, "data") else {}
        reason = data.get("reason") or "unknown"

        with transaction.atomic():
            video = Video.objects.select_for_update().filter(id=video_id).first()
            if video is None:
                return JsonResponse({"detail": "Not found"}, status=404)

            # ✅ lease owner 검증
            if not _is_lease_owner(video, wid):
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)

            # ✅ idempotent 처리
            if video.status == Video.Status.FAILED:
                return JsonResponse({"ok": True, "idempotent": True}, status=200)

            video.status = Video.Status.FAILED

            if hasattr(video, "error_reason"):
                video.error_reason = str(reason)[:2000]

            # lease 해제
            if hasattr(video, "leased_until"):
                video.leased_until = None
            if hasattr(video, "leased_by"):
                video.leased_by = ""

            update_fields = ["status"]
            if hasattr(video, "error_reason"):
                update_fields.append("error_reason")
            if hasattr(video, "leased_until"):
                update_fields.append("leased_until")
            if hasattr(video, "leased_by"):
                update_fields.append("leased_by")

            video.save(update_fields=update_fields)

        return JsonResponse({"ok": True}, status=200)


==========================================================================================
# FILE: views/internal_video_worker_heartbeat.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker_heartbeat.py

import logging
from django.utils import timezone
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

from ..models import Video

logger = logging.getLogger("video.worker.heartbeat")


class InternalVideoWorkerHeartbeatView(APIView):
    authentication_classes = []
    permission_classes = []

    def post(self, request, video_id: int):
        worker_id = request.headers.get("X-Worker-Id") or "worker-unknown"

        video = Video.objects.filter(id=video_id).first()
        if not video:
            return Response(status=status.HTTP_404_NOT_FOUND)

        # lease owner 검증
        leased_by = getattr(video, "leased_by", None)
        leased_until = getattr(video, "leased_until", None)

        if leased_by and leased_by != worker_id:
            logger.warning(
                "heartbeat rejected lease_owner_mismatch video_id=%s leased_by=%s from=%s",
                video_id, leased_by, worker_id,
            )
            return Response(status=status.HTTP_409_CONFLICT)

        if leased_until and leased_until < timezone.now():
            logger.warning(
                "heartbeat rejected lease_expired video_id=%s worker=%s",
                video_id, worker_id,
            )
            return Response(status=status.HTTP_409_CONFLICT)

        # heartbeat accept → lease 연장
        try:
            video.processing_started_at = video.processing_started_at or timezone.now()
            video.leased_by = worker_id
            video.leased_until = timezone.now() + timezone.timedelta(seconds=60)
            video.save(update_fields=["processing_started_at", "leased_by", "leased_until"])
        except Exception:
            pass

        logger.info(
            "heartbeat ok video_id=%s worker=%s",
            video_id, worker_id,
        )
        return Response({"ok": True})


==========================================================================================
# FILE: views/internal_views.py
==========================================================================================
# PATH: apps/support/video/views/internal_views.py

from django.conf import settings
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response


class VideoProcessingCompleteView(APIView):
    """
    worker → API ACK
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        token = request.headers.get("X-Worker-Token")
        if token != settings.INTERNAL_WORKER_TOKEN:
            return Response(status=403)

        return Response({"status": "ack"}, status=200)


==========================================================================================
# FILE: views/permission_views.py
==========================================================================================
# PATH: apps/support/video/views/permission_views.py

from django.db import models, transaction
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response

from ..models import VideoPermission, Video
from ..serializers import VideoPermissionSerializer


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_set(self, request):
        video_id = request.data.get("video_id")
        enrollments = request.data.get("enrollments", [])
        rule = request.data.get("rule", "once")

        objs = []
        for enrollment_id in enrollments:
            obj, _ = VideoPermission.objects.update_or_create(
                video_id=video_id,
                enrollment_id=enrollment_id,
                defaults={
                    "rule": rule,
                    "is_override": True,
                },
            )
            objs.append(obj)

        # ✅ 정책 변경 → policy_version 증가 (기존 토큰 즉시 무효화)
        Video.objects.filter(id=video_id).update(
            policy_version=models.F("policy_version") + 1
        )

        return Response(VideoPermissionSerializer(objs, many=True).data)


==========================================================================================
# FILE: views/playback_mixin.py
==========================================================================================
# PATH: apps/support/video/views/playback_mixin.py

import time

from django.conf import settings
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.lectures.models import Session

from ..models import Video, VideoPermission, VideoProgress
from ..serializers import VideoSerializer
from ..drm import create_playback_token, verify_playback_token
from ..cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options

# ✅ 추가: Cloudflare signed url (있으면 사용, 없으면 기존 public)
from ..cdn.cloudflare_signing import CloudflareSignedURL


class VideoPlaybackMixin:
    """
    재생 권한 / 정책 / 공통 로직

    정책 정의:
    - free    : 항상 무제한
    - once    : 1회차에만 정책 적용, 완료 후 free로 승격됨
    - blocked : 항상 차단
    """

    def _get_student_for_user(self, request):
        return getattr(request.user, "student_profile", None)

    # ==================================================
    # 접근 제어 (Access Control)
    # ==================================================
    def _check_access(self, *, video, enrollment):
        """
        접근 가능 여부만 판단한다.
        once는 접근을 차단하지 않는다.
        """
        if video.status != video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        # free / once 모두 접근 허용
        return True, None

    # ==================================================
    # Permission Loader
    # ==================================================
    def _load_permission(self, *, video, enrollment):
        return VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

    # ==================================================
    # Playback Policy
    # ==================================================
    def _effective_policy(self, *, video, perm):
        """
        실제 재생 제약 정책 계산
        - once : 완료 전까지 탐색 제한
        - 완료 후에는 free와 동일
        """
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        seek_policy = {
            "mode": "free",
            "forward_limit": None,
            "grace_seconds": 3,
        }

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)

            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if perm.rule == "once":
                completed = VideoProgress.objects.filter(
                    video=video,
                    enrollment=perm.enrollment,
                    completed=True,
                ).exists()

                if not completed:
                    seek_policy = {
                        "mode": "bounded_forward",
                        "forward_limit": "max_watched",
                        "grace_seconds": 3,
                    }

            if perm.block_seek:
                allow_seek = False
                seek_policy = {"mode": "blocked"}

            if perm.block_speed_control:
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "seek": seek_policy,
            "playback_rate": {
                "max": max_rate,
                "ui_control": ui_speed_control,
            },
            "watermark": {
                "enabled": watermark_enabled,
                "mode": "overlay",
                "fields": ["user_id"],
            },
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    # ==================================================
    # HLS / CDN
    # ==================================================
    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _normalize_media_path(self, path: str) -> str:
        """
        serializer와 동일 철학:
        - leading slash 제거
        - legacy storage/media normalize
        """
        p = (path or "").lstrip("/")
        if p.startswith("storage/media/"):
            return p[len("storage/") :]
        return p

    def _public_play_url(self, *, video: Video, expires_at: int, user_id: int) -> str:
        """
        ✅ 원본 계약 유지 + 최소 보강
        - video.hls_path가 있으면 그것이 single source of truth
        - 없으면 기존 기본 경로(master.m3u8)로 fallback
        - 설정값이 있으면 Cloudflare signed query를 붙여서 반환
        """
        cdn_base = settings.CDN_HLS_BASE_URL.rstrip("/")

        # 1) worker 결과가 있으면 그걸 사용
        if getattr(video, "hls_path", ""):
            rel = self._normalize_media_path(str(video.hls_path))
            path = "/" + rel if not rel.startswith("/") else rel
        else:
            # 2) 기존 fallback (원본 유지)
            path = f"/media/hls/videos/{video.id}/master.m3u8"

        secret = getattr(settings, "CDN_HLS_SIGNING_SECRET", None)
        if not secret:
            return f"{cdn_base}{path}"

        signer = CloudflareSignedURL(
            secret=str(secret),
            key_id=str(getattr(settings, "CDN_HLS_SIGNING_KEY_ID", "v1")),
        )
        return signer.build_url(
            cdn_base=cdn_base,
            path=path,
            expires_at=int(expires_at),
            user_id=int(user_id),
        )

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int):
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, expires_at - int(time.time()))
        for k, v in cookies.items():
            response.set_cookie(k, v, max_age=max_age, **opts)

    # ==================================================
    # 학생 영상 목록 (재생 가능 여부 판단)
    # ==================================================
    def _student_list_impl(self, request):
        session_id = request.query_params.get("session")
        if not session_id:
            return Response({"detail": "session is required"}, status=400)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        qs = Video.objects.filter(
            session_id=session_id,
            status=Video.Status.READY,
        ).order_by("order", "id")

        session = Session.objects.select_related("lecture").get(id=session_id)
        lecture = session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        data = []
        for v in qs:
            d = VideoSerializer(v).data

            if not enrollment:
                d["can_play"] = False
                d["reason"] = "not_enrolled"
                data.append(d)
                continue

            if not SessionEnrollment.objects.filter(
                session=session,
                enrollment=enrollment,
            ).exists():
                d["can_play"] = False
                d["reason"] = "no_session_access"
                data.append(d)
                continue

            ok, reason = self._check_access(video=v, enrollment=enrollment)
            d["can_play"] = bool(ok)
            d["reason"] = reason if not ok else None
            data.append(d)

        return Response(data)


==========================================================================================
# FILE: views/playback_session_views.py
==========================================================================================
from __future__ import annotations

import time
from django_redis import get_redis_connection

redis_client = get_redis_connection("default")


def _now() -> int:
    return int(time.time())


def _key_session(session_id: str) -> str:
    return f"media:playback:session:{session_id}"


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:sessions"


def _key_user_devices(user_id: int) -> str:
    return f"media:playback:user:{user_id}:devices"


def _key_revoked_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:revoked"


# ===============================
# 기존 함수 (의미 유지)
# ===============================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
):
    """
    원본 구현 유지 (중략 없이 그대로 있다고 가정)
    """
    # ※ 원본 코드 그대로 유지
    raise NotImplementedError


def heartbeat_session(
    *,
    user_id: int,
    session_id: str,
    ttl_seconds: int,
) -> bool:
    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    expire_at = _now() + ttl_seconds
    redis_client.zadd(sessions_key, {session_id: expire_at})
    return True


def end_session(*, user_id: int, session_id: str) -> None:
    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(_key_user_sessions(user_id), session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


# ===============================
# ✅ 보강: 즉시 차단 (문제 1)
# ===============================

def revoke_session(*, user_id: int, session_id: str) -> None:
    """
    서버 강제 차단:
    - Redis 세션 즉시 제거
    - revoked set에 기록하여 재사용 방지
    """
    pipe = redis_client.pipeline(transaction=False)
    pipe.sadd(_key_revoked_sessions(user_id), session_id)
    pipe.zrem(_key_user_sessions(user_id), session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    Redis 기준 단일 판정 함수
    """
    if redis_client.sismember(_key_revoked_sessions(user_id), session_id):
        return False

    score = redis_client.zscore(_key_user_sessions(user_id), session_id)
    if score is None:
        return False

    return int(score) > _now()


==========================================================================================
# FILE: views/playback_views.py
==========================================================================================
# PATH: apps/support/video/views/playback_views.py

import uuid

from django.conf import settings
from django.utils import timezone
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from apps.domains.enrollment.models import Enrollment, SessionEnrollment

from ..models import (
    Video,
    VideoPlaybackSession,
    VideoPlaybackEvent,
    VideoProgress,
    VideoPermission,
)
from ..serializers import (
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)
from ..drm import create_playback_token, verify_playback_token
from ..services.playback_session import (
    issue_session,
    heartbeat_session,
    end_session,
    is_session_active,
    revoke_session,
    record_session_event,
    get_session_violation_stats,
    should_revoke_by_stats,
)
from .playback_mixin import VideoPlaybackMixin


# ----------------------------------------------------------
# internal helpers (원본 구조 유지: view 내부 보조 함수로만 추가)
# ----------------------------------------------------------

def _req_id() -> str:
    return uuid.uuid4().hex


def _policy_version_of(video: Video) -> int:
    try:
        return int(getattr(video, "policy_version", 1) or 1)
    except Exception:
        return 1


def _is_policy_token_valid(payload: dict) -> bool:
    """
    token payload의 pv와 현재 video.policy_version 비교.
    - 불일치 시 즉시 차단 (문제 6)
    """
    try:
        video_id = int(payload.get("video_id"))
    except Exception:
        return False

    # NOTE: migrations 적용 전에는 policy_version 컬럼이 없으면 SELECT에서 터질 수 있음.
    # 실서비스는 migration 이후를 전제로 한다.
    v = Video.objects.filter(id=video_id).only("id", "policy_version").first()
    if not v:
        return False

    current = _policy_version_of(v)
    try:
        pv = int(payload.get("pv") or 0)
    except Exception:
        pv = 0

    return pv == current


def _deny(detail: str, *, code=status.HTTP_403_FORBIDDEN):
    return Response({"detail": detail}, status=code)


def _session_db_status(session_id: str):
    return (
        VideoPlaybackSession.objects
        .filter(session_id=session_id)
        .values_list("status", flat=True)
        .first()
    )


def _db_session_is_inactive(st: str | None) -> bool:
    return st in (VideoPlaybackSession.Status.REVOKED, VideoPlaybackSession.Status.EXPIRED)


# ==========================================================
# Playback Start
# ==========================================================

class PlaybackStartView(VideoPlaybackMixin, APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        request_id = _req_id()

        serializer = PlaybackStartRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        enrollment_id = serializer.validated_data["enrollment_id"]
        device_id = serializer.validated_data["device_id"]

        video_id = request.data.get("video_id")
        if not video_id:
            return Response({"detail": "video_id_required"}, status=400)

        enrollment = Enrollment.objects.select_related(
            "student",
            "lecture",
        ).get(id=enrollment_id, status="ACTIVE")

        video = Video.objects.select_related(
            "session",
            "session__lecture",
        ).get(id=int(video_id))

        # 수강 검증
        if enrollment.lecture_id != video.session.lecture_id:
            return _deny("enrollment_mismatch", code=403)

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return _deny("no_session_access", code=403)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return _deny(reason, code=403)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
            max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
        )

        if not ok:
            return Response({"detail": err}, status=409)

        session_id = sess["session_id"]
        expires_at = sess["expires_at"]

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
            started_at=timezone.now(),
        )

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        # ✅ token에 pv(policy_version) 포함
        token = create_playback_token(
            payload={
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "session_id": session_id,
                "user_id": request.user.id,
                "pv": _policy_version_of(video),
                "rid": request_id,  # trace
            },
            ttl_seconds=ttl,
        )

        play_url = self._public_play_url(
            video=video,
            expires_at=expires_at,
            user_id=request.user.id,
        )

        resp = Response(
            PlaybackResponseSerializer({
                "token": token,
                "session_id": session_id,
                "expires_at": expires_at,
                "policy": policy,
                "play_url": play_url,
            }).data,
            status=201,
        )

        self._set_signed_cookies(resp, video_id=video.id, expires_at=expires_at)
        return resp


# ==========================================================
# Playback Refresh
# ==========================================================

class PlaybackRefreshView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackRefreshRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        if not is_session_active(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        ):
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback Heartbeat
# ==========================================================

class PlaybackHeartbeatView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackHeartbeatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        ok2 = heartbeat_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
            ttl_seconds=int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600)),
        )
        if not ok2:
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback End
# ==========================================================

class PlaybackEndView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEndRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        end_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        )

        VideoPlaybackSession.objects.filter(
            session_id=str(payload["session_id"])
        ).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        return Response({"ok": True})


# ==========================================================
# Event Batch
# ==========================================================

class PlaybackEventBatchView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEventBatchRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        user_id = int(payload["user_id"])
        session_id = str(payload["session_id"])

        # DB 상태 차단
        st = _session_db_status(session_id)
        if _db_session_is_inactive(st):
            return Response({"detail": "session_inactive"}, status=409)

        # Redis 상태 차단
        if not is_session_active(user_id=user_id, session_id=session_id):
            return Response({"detail": "session_inactive"}, status=409)

        events = serializer.validated_data["events"]

        # 폭주 방지
        max_batch = int(getattr(settings, "VIDEO_EVENT_BATCH_MAX", 200))
        if len(events) > max_batch:
            return Response({"detail": "batch_too_large"}, status=413)

        now = timezone.now()
        objs = []

        # policy snapshot 계산 (원본 믹스인 재사용)
        video = Video.objects.filter(id=int(payload["video_id"])).first()
        enrollment = Enrollment.objects.filter(id=int(payload["enrollment_id"])).first()
        perm = None
        if video and enrollment:
            perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

        policy_snapshot = {}
        try:
            if video:
                m = VideoPlaybackMixin()
                policy_snapshot = m._effective_policy(video=video, perm=perm)
        except Exception:
            policy_snapshot = {}

        def _is_violation(ev_type: str, snap: dict) -> tuple[bool, str]:
            """
            ✅ 최소 강제 위반 판정(서버 단):
            - seek blocked/bounded 환경에서 SEEK_ATTEMPT는 violated
            - speed 제한 환경에서 SPEED_CHANGE_ATTEMPT는 violated
            (추가 강화는 여기만 수정하면 됨 → 구조 유지)
            """
            if ev_type == "SEEK_ATTEMPT":
                seek = (snap or {}).get("seek") or {}
                allow_seek = bool((snap or {}).get("allow_seek", True))
                mode = seek.get("mode")
                if (not allow_seek) or mode in ("blocked", "bounded_forward"):
                    return True, f"seek_{mode or 'blocked'}"
            if ev_type == "SPEED_CHANGE_ATTEMPT":
                pr = ((snap or {}).get("playback_rate") or {})
                ui = bool(pr.get("ui_control", True))
                mx = float(pr.get("max", 1.0) or 1.0)
                if (not ui) or mx <= 1.0:
                    return True, "speed_blocked"
            return False, ""

        # ✅ 세션 단위 누적 위반 판단
        # - 각 이벤트마다 Redis 카운터 갱신 → batch 쪼개기 우회 불가
        latest_stats = None
        revoke_reason = ""

        for e in events:
            ev_type = e["type"]
            ev_payload = e.get("payload", {}) or {}

            violated, reason = _is_violation(ev_type, policy_snapshot)
            if violated and reason:
                revoke_reason = reason

            # ✅ Redis 누적 갱신
            latest_stats = record_session_event(
                user_id=user_id,
                session_id=session_id,
                violated=bool(violated),
                reason=reason or "",
            )

            objs.append(
                VideoPlaybackEvent(
                    video_id=int(payload["video_id"]),
                    enrollment_id=int(payload["enrollment_id"]),
                    session_id=session_id,
                    user_id=user_id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy_snapshot,
                    violated=bool(violated),
                    violation_reason=reason or "",
                    occurred_at=now,
                )
            )

        with transaction.atomic():
            VideoPlaybackEvent.objects.bulk_create(objs, batch_size=500)

            # ✅ 누적 기준으로 revoke 결정
            stats = latest_stats or get_session_violation_stats(session_id=session_id)
            violated_cnt = int(stats.get("violated") or 0)
            total_cnt = int(stats.get("total") or 0)

            if should_revoke_by_stats(violated=violated_cnt, total=total_cnt):
                # Redis 세션 즉시 제거
                revoke_session(user_id=user_id, session_id=session_id)

                # DB 반영
                VideoPlaybackSession.objects.filter(session_id=session_id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=timezone.now(),
                )

        return Response(
            PlaybackEventBatchResponseSerializer({"stored": len(objs)}).data,
            status=201,
        )


==========================================================================================
# FILE: views/progress_views.py
==========================================================================================
# apps/support/video/views/progress_views.py

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoProgress, VideoPermission
from ..serializers import VideoProgressSerializer


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    def perform_update(self, serializer):
        vp = serializer.instance
        prev_completed = vp.completed

        vp = serializer.save()

        # 🔥 once → free 자동 승격 (completed False → True 순간)
        if not prev_completed and vp.completed:
            VideoPermission.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                rule="once",
            ).update(
                rule="free",
                is_override=False,
            )


==========================================================================================
# FILE: views/video_policy_impact.py
==========================================================================================
# PATH: apps/support/video/views/video_policy_impact.py
# PATH: apps/support/video/views/video_policy_impact.py

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoPermission, VideoProgress


class VideoPolicyImpactAPIView(APIView):
    """
    Admin 전용:
    특정 영상 정책이 학생들에게 어떤 영향을 주는지 미리 보기
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session", "session__lecture").get(id=video_id)

        enrollments = Enrollment.objects.filter(
            lecture=video.session.lecture,
            status="ACTIVE",
        ).select_related("student")

        perms = {
            p.enrollment_id: p
            for p in VideoPermission.objects.filter(video=video)
        }

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }

        rows = []

        for e in enrollments:
            perm = perms.get(e.id)
            prog = progresses.get(e.id)

            rule = perm.rule if perm else "free"

            effective = rule
            if rule == "once" and prog and prog.completed:
                effective = "free"

            rows.append({
                "enrollment": e.id,
                "student_name": e.student.name,
                "rule": rule,
                "effective_rule": effective,
                "completed": bool(prog.completed) if prog else False,
            })

        return Response(rows)


==========================================================================================
# FILE: views/video_views.py
==========================================================================================
# PATH: apps/support/video/views/video_views.py

from uuid import uuid4
from datetime import timedelta

from django.conf import settings
from django.db import models, transaction
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from rest_framework.parsers import (
    JSONParser,
    MultiPartParser,
    FormParser,
)
from django_filters.rest_framework import DjangoFilterBackend

from rest_framework_simplejwt.authentication import JWTAuthentication

from libs.s3_client.presign import create_presigned_put_url, create_presigned_get_url
from libs.s3_client.client import head_object

from apps.core.permissions import IsAdminOrStaff, IsStudent
from apps.core.authentication import CsrfExemptSessionAuthentication

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from ..models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)
from ..serializers import VideoSerializer, VideoDetailSerializer
from .playback_mixin import VideoPlaybackMixin

import ffmpeg  # ✅ ffprobe(validate) 용도 (문제 5)


def _safe_int(v, default=None):
    try:
        return int(v)
    except Exception:
        return default


def _validate_source_media_via_ffprobe(url: str) -> tuple[bool, dict, str]:
    """
    ✅ upload_complete 최소 무결성 검증:
    - ffprobe로 format.duration 확인
    - video stream 존재 확인
    - 실패 이유 문자열 반환

    NOTE:
    - 네트워크/Range 요청 기반 (ffmpeg-python -> ffprobe)
    """
    if not url:
        return False, {}, "source_url_missing"

    try:
        probe = ffmpeg.probe(url)
    except Exception as e:
        return False, {}, f"ffprobe_failed:{str(e)[:200]}"

    fmt = probe.get("format") or {}
    streams = probe.get("streams") or []

    # duration
    dur_raw = fmt.get("duration")
    duration = None
    try:
        if dur_raw is not None:
            duration = int(float(dur_raw))
    except Exception:
        duration = None

    # video stream 존재
    has_video = any((s.get("codec_type") == "video") for s in streams)

    if not has_video:
        return False, {"duration": duration, "has_video": False}, "no_video_stream"

    if duration is None:
        return False, {"duration": None, "has_video": True}, "duration_missing"

    if duration < 0:
        return False, {"duration": duration, "has_video": True}, "duration_invalid"

    return True, {"duration": duration, "has_video": True}, ""


class VideoViewSet(VideoPlaybackMixin, ModelViewSet):
    """
    Video 관리 + 통계 + 학생 목록
    """

    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer

    parser_classes = [JSONParser]

    authentication_classes = [
        JWTAuthentication,
        CsrfExemptSessionAuthentication,
    ]
    permission_classes = [IsAuthenticated]

    ADMIN_ONLY_ACTIONS = {
        "upload_init",
        "upload_complete",
        "retry",
        "create",
        "update",
        "partial_update",
        "destroy",
    }

    def get_permissions(self):
        if self.action in self.ADMIN_ONLY_ACTIONS:
            return [IsAuthenticated(), IsAdminOrStaff()]
        return [IsAuthenticated()]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # ==================================================
    # upload/init (presigned URL 발급)
    # ==================================================
    @transaction.atomic
    @action(
        detail=False,
        methods=["post"],
        url_path="upload/init",
        parser_classes=[JSONParser],
    )
    def upload_init(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        filename = request.data.get("filename")

        allow_skip = bool(request.data.get("allow_skip", False))
        max_speed = float(request.data.get("max_speed", 1.0) or 1.0)
        show_watermark = bool(request.data.get("show_watermark", True))

        if not session_id or not title or not filename:
            return Response(
                {"detail": "session, title, filename required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session = Session.objects.get(id=session_id)
        order = (
            session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0
        ) + 1

        ext = filename.split(".")[-1].lower() if "." in filename else "mp4"
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=key,
            order=order,
            status=Video.Status.PENDING,
            allow_skip=allow_skip,
            max_speed=max_speed,
            show_watermark=show_watermark,
        )

        content_type = (request.data.get("content_type") or "video/mp4").split(";")[0]
        upload_url = create_presigned_put_url(key=key, content_type=content_type)

        return Response(
            {
                "video": VideoSerializer(video).data,
                "upload_url": upload_url,
                "file_key": key,
                "content_type": content_type,
            },
            status=status.HTTP_201_CREATED,
        )

    # ==================================================
    # upload/complete (업로드 완료 확인 + 무결성 검증 + 상태 전이)
    # ==================================================
    @transaction.atomic
    @action(
        detail=True,
        methods=["post"],
        url_path="upload/complete",
        parser_classes=[MultiPartParser, FormParser, JSONParser],
    )
    def upload_complete(self, request, pk=None):
        """
        ✅ 문제 5 해결:
        - head_object 존재 확인만 하던 것을 확장
        - presigned GET URL로 ffprobe 검증:
          - video stream 존재
          - duration 추출
          - 최소 duration 기준
        - 실패 시 status 전이 금지 + error_reason 기록
        """
        video = self.get_object()

        if video.status != Video.Status.PENDING:
            return Response(
                {"detail": f"Invalid status: {video.status}"},
                status=status.HTTP_409_CONFLICT,
            )

        exists, size = head_object(video.file_key)
        if not exists or size == 0:
            video.error_reason = "source_not_found_or_empty"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "S3 object not found"},
                status=status.HTTP_409_CONFLICT,
            )

        # ✅ presigned GET URL → ffprobe validation
        try:
            src_url = create_presigned_get_url(key=video.file_key, expires_in=600)
        except Exception as e:
            video.error_reason = f"presigned_get_failed:{str(e)[:200]}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "presigned_get_failed"},
                status=status.HTTP_409_CONFLICT,
            )

        ok, meta, reason = _validate_source_media_via_ffprobe(src_url)
        if not ok:
            video.error_reason = f"source_invalid:{reason}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "source_invalid", "reason": reason},
                status=status.HTTP_409_CONFLICT,
            )

        min_dur = _safe_int(getattr(settings, "VIDEO_MIN_DURATION_SECONDS", 3), 3)
        duration = _safe_int(meta.get("duration"), None)
        if duration is None or duration < int(min_dur):
            video.error_reason = f"duration_too_short:{duration}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "duration_too_short", "duration": duration},
                status=status.HTTP_409_CONFLICT,
            )

        # duration 저장(있으면)
        video.duration = duration

        # 상태 전이
        video.status = Video.Status.UPLOADED
        video.error_reason = ""
        video.save(update_fields=["status", "duration", "error_reason"])

        return Response(VideoSerializer(video).data)

    # ==================================================
    # retry (HTTP worker 기준: status를 UPLOADED로 돌림)
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response(
                {"detail": "Cannot retry"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        video.status = Video.Status.UPLOADED
        video.save(update_fields=["status"])

        return Response(
            {"detail": "Video reprocessing queued (HTTP worker polling)"},
            status=status.HTTP_202_ACCEPTED,
        )

    # ==================================================
    # stats (관리자 학생별 상세)
    # ==================================================
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(
            lecture=lecture,
            status="ACTIVE",
        ).select_related("student")

        progresses = {p.enrollment_id: p for p in VideoProgress.objects.filter(video=video)}
        perms = {p.enrollment_id: p for p in VideoPermission.objects.filter(video=video)}
        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            rule = perm.rule if perm else "free"
            effective_rule = rule
            if rule == "once" and vp and vp.completed:
                effective_rule = "free"

            students.append(
                {
                    "enrollment": e.id,
                    "student_name": e.student.name,
                    "attendance_status": attendance.get(e.id),
                    "progress": vp.progress if vp else 0,
                    "completed": vp.completed if vp else False,
                    "rule": rule,
                    "effective_rule": effective_rule,
                    "parent_phone": getattr(e.student, "parent_phone", None),
                    "student_phone": getattr(e.student, "phone", None),
                    "school": getattr(e.student, "school", None),
                    "grade": getattr(e.student, "grade", None),
                }
            )

        return Response(
            {
                "video": VideoDetailSerializer(video).data,
                "students": students,
                "total_filtered": len(students),
            }
        )

    # ==================================================
    # summary (통계 탭 요약)
    # ==================================================
    @action(detail=True, methods=["get"], url_path="summary")
    def summary(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        range_key = request.query_params.get("range", "7d")
        now = timezone.now()

        since = None
        if range_key == "24h":
            since = now - timedelta(hours=24)
        elif range_key == "7d":
            since = now - timedelta(days=7)

        enrollments = Enrollment.objects.filter(lecture=lecture)
        total = enrollments.count()

        progresses = VideoProgress.objects.filter(video=video)
        completed_count = progresses.filter(completed=True).count()

        duration = int(video.duration or 0)

        watched_seconds = 0
        for p in progresses.iterator():
            watched_seconds += int(float(p.progress or 0) * duration)

        completion_rate = (completed_count / total) if total else 0.0

        ev_qs = VideoPlaybackEvent.objects.filter(video=video).select_related(
            "enrollment", "enrollment__student"
        )

        if since:
            ev_qs = ev_qs.filter(occurred_at__gte=since)

        weights = {
            "VISIBILITY_HIDDEN": 1,
            "VISIBILITY_VISIBLE": 0,
            "FOCUS_LOST": 2,
            "FOCUS_GAINED": 0,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "FULLSCREEN_ENTER": 0,
            "FULLSCREEN_EXIT": 0,
            "PLAYER_ERROR": 1,
        }

        agg = {}
        for ev in ev_qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                }

            score = int(weights.get(ev.event_type, 1))
            if ev.violated:
                score *= 2
            if ev.violation_reason:
                score += 1

            agg[eid]["score"] += score

        risk_top = sorted(agg.values(), key=lambda x: x["score"], reverse=True)[:5]

        return Response(
            {
                "video_id": video.id,
                "range": range_key,
                "total_students": total,
                "completed_count": completed_count,
                "completion_rate": completion_rate,
                "watched_seconds_est": watched_seconds,
                "risk_top": risk_top,
            }
        )

    # ==================================================
    # student list
    # ==================================================
    @action(
        detail=False,
        methods=["get"],
        url_path="student",
        permission_classes=[IsAuthenticated, IsStudent],
    )
    def student_list(self, request):
        return self._student_list_impl(request)
