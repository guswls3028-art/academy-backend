====================================================================================================
# BACKEND APP: support__video
# ROOT PATH: C:\academy\apps\support\video
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# services package
#


==========================================================================================
# FILE: admin.py
==========================================================================================
from django.contrib import admin
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


@admin.register(Video)
class VideoAdmin(admin.ModelAdmin):
    list_display = ("id", "title", "session", "order", "duration", "status")
    list_display_links = ("id", "title")
    list_filter = ("status", "session__lecture", "session")
    search_fields = ("title",)
    ordering = ("session", "order")


@admin.register(VideoPermission)
class VideoPermissionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "rule",
        "allow_skip_override",
        "max_speed_override",
        "show_watermark_override",
        "block_seek",
        "block_speed_control",
        "is_override",
    )
    list_display_links = ("id", "video")
    list_filter = ("rule", "video__session__lecture", "block_seek", "block_speed_control")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


@admin.register(VideoProgress)
class VideoProgressAdmin(admin.ModelAdmin):
    list_display = ("id", "video", "enrollment", "progress", "completed", "updated_at")
    list_display_links = ("id", "video")
    list_filter = ("video__session__lecture", "completed")
    search_fields = ("enrollment__student__name",)
    ordering = ("-updated_at",)


@admin.register(VideoPlaybackSession)
class VideoPlaybackSessionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "device_id",
        "status",
        "started_at",
        "ended_at",
    )
    list_filter = ("status", "video__session__lecture", "video")
    search_fields = ("session_id", "device_id", "enrollment__student__name")
    ordering = ("-started_at",)


@admin.register(VideoPlaybackEvent)
class VideoPlaybackEventAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "user_id",
        "event_type",
        "violated",
        "violation_reason",
        "occurred_at",
        "received_at",
    )
    list_filter = ("event_type", "violated", "video__session__lecture")
    search_fields = ("session_id", "enrollment__student__name", "user_id")
    ordering = ("-received_at",)


==========================================================================================
# FILE: constants.py
==========================================================================================
# PATH: apps/support/video/constants.py

from __future__ import annotations


class VideoStatus:
    """
    âš ï¸ SSOT: models.Video.Status ì™€ ë°˜ë“œì‹œ ë™ì¼í•´ì•¼ í•œë‹¤.

    - worker/API/servicesì—ì„œ ê³µí†µìœ¼ë¡œ ì“°ëŠ” "ì™¸ë¶€ ìƒìˆ˜" ì—­í• 
    - ì‹¤ì œ DB ìƒíƒœ ë³€í™”ëŠ” í•­ìƒ Video.Statusë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œë‹¤.
    """

    PENDING = "PENDING"
    UPLOADED = "UPLOADED"
    PROCESSING = "PROCESSING"
    READY = "READY"
    FAILED = "FAILED"

    CHOICES = (
        (PENDING, "Pending"),
        (UPLOADED, "Uploaded"),
        (PROCESSING, "Processing"),
        (READY, "Ready"),
        (FAILED, "Failed"),
    )


==========================================================================================
# FILE: drm.py
==========================================================================================
import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


==========================================================================================
# FILE: models.py
==========================================================================================
from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (ì˜ìƒ ë©”íƒ€ë°ì´í„°)
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "ì—…ë¡œë“œ ëŒ€ê¸°"
        UPLOADED = "UPLOADED", "ì—…ë¡œë“œ ì™„ë£Œ"
        PROCESSING = "PROCESSING", "ì²˜ë¦¬ì¤‘"
        READY = "READY", "ì‚¬ìš© ê°€ëŠ¥"
        FAILED = "FAILED", "ì‹¤íŒ¨"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # ì¸ë„¤ì¼ì€ Workerê°€ ìƒì„±
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # ê¸°ë³¸ ì¬ìƒ ì •ì±… (ë¹„ë””ì˜¤ ë‹¨ìœ„ default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # ì •ì±… ë³€ê²½ ì¦‰ì‹œ ë°˜ì˜ì„ ìœ„í•œ ë²„ì „ (token versioning)
    # - ê¸°ì¡´ API ê³„ì•½ ê¹¨ì§€ì§€ ì•Šê²Œ default=1
    # - ì •ì±…/ê¶Œí•œ ë³€ê²½ ì‹œ ì¦ê°€ì‹œí‚¤ë©´, ê¸°ì¡´ í† í° ì¦‰ì‹œ ë¬´íš¨í™” ê°€ëŠ¥
    # --------------------------------------------------
    policy_version = models.PositiveIntegerField(
        default=1,
        db_index=True,
        help_text="Increment on policy/permission changes to invalidate existing tokens",
    )

    # --------------------------------------------------
    # Worker ì‹¤íŒ¨ ì‚¬ìœ  ê¸°ë¡
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    # ===============================
    # HLS Output (Worker ê²°ê³¼)
    # ===============================
    hls_path = models.CharField(
        max_length=500,
        blank=True,
        help_text="HLS master playlist path (relative to CDN root)",
    )

    # --------------------------------------------------
    # Worker Lease (ë‹¤ì¤‘ ë…¸ë“œ ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ìš©)
    # - ê¸°ì¡´ reclaim(updated_at ê¸°ë°˜) êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©´ì„œ,
    #   ì¤‘ì•™ í†µì œìš© lease ì •ë³´ë¥¼ "ì¶”ê°€"ë¡œ ê¸°ë¡í•œë‹¤.
    # - ì„œë²„/ì›Œì»¤ê°€ ì„œë¡œ ë‚´ë¶€ êµ¬í˜„ ëª°ë¼ë„ ë™ì‘(í—¤ë”ë§Œ ì‚¬ìš©).
    # --------------------------------------------------
    processing_started_at = models.DateTimeField(null=True, blank=True)
    leased_until = models.DateTimeField(null=True, blank=True)
    leased_by = models.CharField(max_length=64, blank=True, default="")

    class Meta:
        ordering = ["order", "id"]
        indexes = [
            models.Index(fields=["status", "updated_at"]),
            models.Index(fields=["leased_until", "status"]),
        ]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        return "unknown"


# ========================================================
# Video Permission (ìˆ˜ê°•ìƒë³„ override + ì ‘ê·¼ ê·œì¹™)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "ë¬´ì œí•œ"),
            ("once", "1íšŒ ì œí•œ"),
            ("blocked", "ì œí•œ"),
        ],
        default="once",
    )

    # í•™ìƒë³„ ì •ì±… override (nullì´ë©´ Video ê¸°ë³¸ê°’ ì‚¬ìš©)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # ìµœìš°ì„  ì°¨ë‹¨ í”Œë˜ê·¸
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (ì„¸ì…˜ / ê°ì‚¬)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "í™œì„±"
        ENDED = "ENDED", "ì¢…ë£Œ"
        REVOKED = "REVOKED", "ì°¨ë‹¨"
        EXPIRED = "EXPIRED", "ë§Œë£Œ"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]
        indexes = [
            models.Index(fields=["status", "started_at"]),
            models.Index(fields=["video", "enrollment", "status"]),
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "íƒ­ ìˆ¨ê¹€"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "íƒ­ ë…¸ì¶œ"
        FOCUS_LOST = "FOCUS_LOST", "í¬ì»¤ìŠ¤ ì´íƒˆ"
        FOCUS_GAINED = "FOCUS_GAINED", "í¬ì»¤ìŠ¤ ë³µê·€"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "íƒìƒ‰ ì‹œë„"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "ë°°ì† ë³€ê²½ ì‹œë„"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "ì „ì²´í™”ë©´ ì§„ì…"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "ì „ì²´í™”ë©´ ì¢…ë£Œ"
        PLAYER_ERROR = "PLAYER_ERROR", "í”Œë ˆì´ì–´ ì˜¤ë¥˜"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


==========================================================================================
# FILE: policy.py
==========================================================================================
from __future__ import annotations

from typing import Dict, Tuple, Optional


def evaluate_event_violation(
    *,
    event_type: str,
    policy: Dict,
    payload: Dict,
) -> Tuple[bool, Optional[str]]:
    """
    ì„œë²„ ê¸°ì¤€ ì •ì±… ìœ„ë°˜ íŒì • (í”„ë¡ íŠ¸ í˜‘ì¡° ì—†ì´)
    """
    if not policy:
        return False, None

    if event_type == "seek":
        if not policy.get("allow_skip", False):
            return True, "seek_not_allowed"

    if event_type == "speed":
        max_speed = policy.get("max_speed", 1.0)
        speed = float(payload.get("speed", 1.0))
        if speed > max_speed:
            return True, f"speed_exceeded:{speed}>{max_speed}"

    return False, None


def violation_should_revoke(*, violated_count: int, total: int) -> bool:
    """
    ìœ„ë°˜ ëˆ„ì  ê¸°ì¤€ (ë³´ìˆ˜ì ìœ¼ë¡œ ì„¤ì •)
    """
    if violated_count >= 3:
        return True
    if total > 0 and (violated_count / total) >= 0.5:
        return True
    return False


==========================================================================================
# FILE: serializers.py
==========================================================================================
# PATH: apps/support/video/serializers.py

from django.conf import settings
from rest_framework import serializers

from apps.domains.lectures.models import Session
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)

# ========================================================
# Video
# ========================================================

class VideoSerializer(serializers.ModelSerializer):
    """
    âœ… FINAL SEALED VERSION (SaaS production)

    - DB ì €ì¥ í•„ë“œì™€ API ë…¸ì¶œ í•„ë“œ ë¶„ë¦¬
    - CDN ê¸°ë°˜ URL ë™ì  ìƒì„±
    - Cache-busting ì§€ì›
    - Legacy ê²½ë¡œ normalize
    """

    # write
    session = serializers.PrimaryKeyRelatedField(
        queryset=Session.objects.all(),
        write_only=True,
    )

    # read
    session_id = serializers.IntegerField(
        source="session.id",
        read_only=True,
    )

    source_type = serializers.SerializerMethodField()

    # CDN derived
    thumbnail_url = serializers.SerializerMethodField()
    hls_url = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session",
            "session_id",
            "title",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "thumbnail",
            "thumbnail_url",
            "hls_path",
            "hls_url",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = [
            "id",
            "session_id",
            "created_at",
            "updated_at",
            "thumbnail",
            "hls_path",
            "thumbnail_url",
            "hls_url",
        ]
        ref_name = "SealedVideo"

    # ---------------------------
    # helpers
    # ---------------------------

    def get_source_type(self, obj):
        return "s3" if obj.file_key else "unknown"

    def _cdn_base(self) -> str | None:
        base = getattr(settings, "CDN_HLS_BASE_URL", None)
        return base.rstrip("/") if base else None

    def _normalize_media_path(self, path: str) -> str:
        path = path.lstrip("/")

        if path.startswith("media/"):
            return path

        if path.startswith("storage/media/"):
            return path[len("storage/"):]

        return path

    def _cache_version(self, obj) -> int:
        try:
            return int(obj.updated_at.timestamp())
        except Exception:
            return 0

    # ---------------------------
    # CDN fields
    # ---------------------------

    def get_thumbnail_url(self, obj):
        cdn = self._cdn_base()
        if not cdn:
            return None

        # 1ï¸âƒ£ explicit thumbnail
        if obj.thumbnail:
            path = self._normalize_media_path(obj.thumbnail.name)
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        # 2ï¸âƒ£ READY fallback
        if obj.status == obj.Status.READY:
            path = self._normalize_media_path(
                f"media/hls/{obj.tenant.code}/videos/{obj.id}/thumbnail.jpg"
            )
            return f"{cdn}/{path}?v={self._cache_version(obj)}"

        return None

    def get_hls_url(self, obj):
        if not obj.hls_path:
            return None

        cdn = self._cdn_base()
        if not cdn:
            return None

        path = self._normalize_media_path(str(obj.hls_path))
        return f"{cdn}/{path}?v={self._cache_version(obj)}"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "SealedVideoDetail"


# ========================================================
# Permission / Progress
# ========================================================

class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "SealedVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    # âœ… ì§„í–‰ë¥  % (í”„ë¡ íŠ¸ í‘œì‹œìš©)
    progress_percent = serializers.SerializerMethodField()

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "SealedVideoProgress"

    def get_progress_percent(self, obj):
        try:
            return round(float(obj.progress or 0) * 100, 1)
        except Exception:
            return 0.0


# ========================================================
# Playback API
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


# ========================================================
# Events
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(
        choices=VideoPlaybackEvent.EventType.choices
    )
    occurred_at = serializers.IntegerField(required=False)
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


# ========================================================
# Event List (Admin Analytics)
# ========================================================

class VideoPlaybackEventListSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )
    enrollment_id = serializers.IntegerField(
        source="enrollment.id",
        read_only=True,
    )

    severity = serializers.SerializerMethodField()
    score = serializers.SerializerMethodField()

    class Meta:
        model = VideoPlaybackEvent
        fields = [
            "id",
            "video",
            "enrollment_id",
            "student_name",
            "session_id",
            "user_id",
            "event_type",
            "violated",
            "violation_reason",
            "event_payload",
            "policy_snapshot",
            "occurred_at",
            "received_at",
            "severity",
            "score",
        ]
        ref_name = "SealedVideoPlaybackEventList"

    # ---------------------------
    # Risk classification
    # ---------------------------

    def get_severity(self, obj):
        base = {
            "SEEK_ATTEMPT": "warn",
            "SPEED_CHANGE_ATTEMPT": "warn",
            "FOCUS_LOST": "warn",
            "VISIBILITY_HIDDEN": "info",
            "PLAYER_ERROR": "info",
        }.get(obj.event_type, "info")

        return "danger" if obj.violated else base

    def get_score(self, obj):
        weights = {
            "VISIBILITY_HIDDEN": 1,
            "FOCUS_LOST": 2,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "PLAYER_ERROR": 1,
        }

        w = int(weights.get(obj.event_type, 1))

        if obj.violated:
            w *= 2
        if obj.violation_reason:
            w += 1

        return w


# ========================================================
# Aggregated Risk Row
# ========================================================

class VideoRiskRowSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    student_name = serializers.CharField()
    score = serializers.IntegerField()
    danger = serializers.IntegerField()
    warn = serializers.IntegerField()
    info = serializers.IntegerField()
    last_occurred_at = serializers.DateTimeField(allow_null=True)


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/support/video/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
    VideoPlaybackEventViewSet,
    VideoProcessingCompleteView,
    VideoPolicyImpactAPIView,
)

from .views.achievement_views import VideoAchievementView
from .views.playback_views import (
    PlaybackStartView,
    PlaybackRefreshView,
    PlaybackHeartbeatView,
    PlaybackEndView,
    PlaybackEventBatchView,
)

# ========================================================
# Router
# ========================================================

router = DefaultRouter()
router.register(r"videos", VideoViewSet, basename="videos")
router.register(r"video-permissions", VideoPermissionViewSet, basename="video-permissions")
router.register(r"video-progress", VideoProgressViewSet, basename="video-progress")
router.register(r"video-playback-events", VideoPlaybackEventViewSet, basename="video-playback-events")

# ========================================================
# urlpatterns (ì„ ì–¸ ë¨¼ì €!)
# ========================================================

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / Extra APIs
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="video-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="video-video-stats-nested",
    ),
    path(
        "videos/<int:video_id>/achievement/",
        VideoAchievementView.as_view(),
        name="video-video-achievement",
    ),
]

# ========================================================
# Playback APIs (Student)
# ========================================================

urlpatterns += [
    path("playback/start/", PlaybackStartView.as_view()),
    path("playback/refresh/", PlaybackRefreshView.as_view()),
    path("playback/heartbeat/", PlaybackHeartbeatView.as_view()),
    path("playback/end/", PlaybackEndView.as_view()),
    path("playback/events/", PlaybackEventBatchView.as_view()),
]

# ========================================================
# Internal (Legacy ACK - kept)
# ========================================================

urlpatterns += [
    path(
        "internal/videos/<int:video_id>/processing-complete/",
        VideoProcessingCompleteView.as_view(),
        name="video-video-processing-complete",
    ),
]

# ========================================================
# Policy Impact (Admin preview)
# ========================================================

urlpatterns += [
    path(
        "videos/<int:video_id>/policy-impact/",
        VideoPolicyImpactAPIView.as_view(),
        name="video-video-policy-impact",
    ),
]


==========================================================================================
# FILE: urls_internal.py
==========================================================================================
# PATH: apps/support/video/urls_internal.py

from __future__ import annotations

from django.urls import path

from apps.support.video.views.internal_video_worker import (
    VideoWorkerClaimNextView,
    VideoWorkerCompleteView,
    VideoWorkerFailView,
)
from apps.support.video.views.internal_video_worker_heartbeat import (
    InternalVideoWorkerHeartbeatView,
)

urlpatterns = [
    # --------------------------------------------------
    # Worker job control (SSOT)
    # --------------------------------------------------
    path(
        "video-worker/next/",
        VideoWorkerClaimNextView.as_view(),
        name="video_worker_next",
    ),
    path(
        "video-worker/<int:video_id>/complete/",
        VideoWorkerCompleteView.as_view(),
        name="video_worker_complete",
    ),
    path(
        "video-worker/<int:video_id>/fail/",
        VideoWorkerFailView.as_view(),
        name="video_worker_fail",
    ),
    # --------------------------------------------------
    # Worker heartbeat (lease extension)
    # --------------------------------------------------
    path(
        "video-worker/<int:video_id>/heartbeat/",
        InternalVideoWorkerHeartbeatView.as_view(),
        name="internal_video_worker_heartbeat",
    ),

    # ==================================================
    # âœ… Compatibility Alias (ê²½ë¡œ í˜¼ë™ í¡ìˆ˜)
    #
    # ì¼ë¶€ ì›Œì»¤/ìŠ¤í¬ë¦½íŠ¸ê°€ /internal/video-worker/... ë¡œ í˜¸ì¶œí•˜ëŠ” ê²½ìš°ê°€ ìˆì–´
    # ë™ì¼ Viewë¡œ ë¼ìš°íŒ…ë˜ëŠ” aliasë¥¼ ì œê³µí•œë‹¤.
    #
    # - /api/v1/internal/ ì•„ë˜ì— includeë˜ë©´:
    #     /api/v1/internal/internal/video-worker/... ê°€ ë  ìˆ˜ ìˆìœ¼ë‹ˆ
    #     "ì´ íŒŒì¼ì´ ì–´ë””ì— includeë˜ëŠ”ì§€"ì— ê´€ê³„ì—†ì´
    #     ìµœì†Œ í•œìª½ì€ ë°˜ë“œì‹œ ë§ë„ë¡ ì¤‘ë³µ ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë‘”ë‹¤.
    #
    # - ë§Œì•½ í”„ë¡œì íŠ¸ì—ì„œ ì´ë¯¸ "/internal/" prefixë¡œ ë³„ë„ mount ì¤‘ì´ë©´:
    #     /internal/video-worker/... ë¡œ ë°”ë¡œ ë§¤ì¹­ëœë‹¤.
    # ==================================================
    path(
        "internal/video-worker/next/",
        VideoWorkerClaimNextView.as_view(),
        name="video_worker_next_alias_internal",
    ),
    path(
        "internal/video-worker/<int:video_id>/complete/",
        VideoWorkerCompleteView.as_view(),
        name="video_worker_complete_alias_internal",
    ),
    path(
        "internal/video-worker/<int:video_id>/fail/",
        VideoWorkerFailView.as_view(),
        name="video_worker_fail_alias_internal",
    ),
    path(
        "internal/video-worker/<int:video_id>/heartbeat/",
        InternalVideoWorkerHeartbeatView.as_view(),
        name="internal_video_worker_heartbeat_alias_internal",
    ),
]


==========================================================================================
# FILE: utils.py
==========================================================================================
# PATH: apps/support/video/utils.py

def extract_duration_seconds_from_url(url: str) -> int | None:
    """
    ffprobeë¥¼ URLì— ì§ì ‘ ì ìš© (Range Request ê¸°ë°˜)

    âš ï¸ API ì„œë²„ ì•ˆì „í™”:
    - ffmpeg ëª¨ë“ˆ ì—†ìœ¼ë©´ None ë°˜í™˜
    - API í¬ë˜ì‹œ ì ˆëŒ€ ë°œìƒ âŒ
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        probe = ffmpeg.probe(url)
        fmt = probe.get("format") or {}
        dur = fmt.get("duration")
        if dur is None:
            return None
        return int(float(dur))
    except Exception:
        return None


def generate_thumbnail_from_url(
    url: str,
    ss_seconds: int = 1,
) -> bytes | None:
    """
    URL ìŠ¤íŠ¸ë¦¬ë° ê¸°ë°˜ ì¸ë„¤ì¼ ìƒì„±

    ğŸš« API ì„œë²„ì—ì„œëŠ” ì‚¬ìš© ê¸ˆì§€
    âœ”ï¸ Worker ì „ìš©

    - ì‹¤íŒ¨ ì‹œ None ë°˜í™˜
    """
    if not url:
        return None

    try:
        import ffmpeg  # lazy import
    except Exception:
        return None

    try:
        out, _ = (
            ffmpeg
            .input(url, ss=ss_seconds)
            .output(
                "pipe:",
                vframes=1,
                format="image2",
                vcodec="mjpeg",
            )
            .run(capture_stdout=True, capture_stderr=True)
        )
        return out
    except Exception:
        return None


==========================================================================================
# FILE: cdn/__init__.py
==========================================================================================
# CDN helpers package


==========================================================================================
# FILE: cdn/cloudflare_signing.py
==========================================================================================
# PATH: apps/support/video/cdn/cloudflare_signing.py

from __future__ import annotations

import base64
import hmac
import hashlib
from dataclasses import dataclass
from typing import Dict, Optional
from urllib.parse import urlencode


def _b64url(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).decode("ascii").rstrip("=")


@dataclass(frozen=True)
class CloudflareSignedURL:
    """
    CDN Edge(Cloudflare Worker ë“±)ì—ì„œ ê²€ì¦ ê°€ëŠ¥í•œ ì¿¼ë¦¬ ì„œëª… ìƒì„±.
    - sig = HMAC-SHA256(secret, f"{path}|{exp}|{kid}|{uid}")
    - ì¿¼ë¦¬: exp, sig, kid, uid(ì˜µì…˜)

    ì£¼ì˜:
    - ë°±ì—”ë“œëŠ” "ìƒì„±"ë§Œ ë‹´ë‹¹
    - ê²€ì¦/ì°¨ë‹¨ì€ CDN ë ˆì´ì–´ì—ì„œ ìˆ˜í–‰
    """
    secret: str
    key_id: str = "v1"

    def sign(self, *, path: str, expires_at: int, user_id: Optional[int] = None) -> Dict[str, str]:
        p = path if path.startswith("/") else f"/{path}"
        uid = "" if user_id is None else str(int(user_id))

        msg = f"{p}|{int(expires_at)}|{self.key_id}|{uid}".encode("utf-8")
        mac = hmac.new(self.secret.encode("utf-8"), msg, hashlib.sha256).digest()

        params = {
            "exp": str(int(expires_at)),
            "sig": _b64url(mac),
            "kid": self.key_id,
        }
        if user_id is not None:
            params["uid"] = str(int(user_id))
        return params

    def build_url(
        self,
        *,
        cdn_base: str,
        path: str,
        expires_at: int,
        user_id: Optional[int] = None,
        extra_query: Optional[Dict[str, str]] = None,
    ) -> str:
        base = (cdn_base or "").rstrip("/")
        p = path if path.startswith("/") else f"/{path}"

        q = {}
        if extra_query:
            q.update({k: str(v) for k, v in extra_query.items()})

        q.update(self.sign(path=p, expires_at=expires_at, user_id=user_id))
        return f"{base}{p}?{urlencode(q)}"


==========================================================================================
# FILE: cdn/cloudfront.py
==========================================================================================
# apps/support/video/cdn/cloudfront.py
# â— CloudFront DEPRECATED
# â— Cloudflare CDN ì‚¬ìš©
# â— Signed Cookie / RSA / hazmat ì „ë¶€ ë¹„í™œì„±í™”

from typing import Dict


def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    Cloudflare CDN ì‚¬ìš©
    - Signed Cookie ì‚¬ìš© ì•ˆ í•¨
    - í•­ìƒ ë¹ˆ dict ë°˜í™˜
    """
    return {}


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    Cloudflare CDN ì‚¬ìš©
    - ì¿ í‚¤ ì„¤ì • ì•ˆ í•¨
    """
    return {}


==========================================================================================
# FILE: management/commands/reconcile_playback_sessions.py
==========================================================================================
# PATH: apps/support/video/management/commands/reconcile_playback_sessions.py

from django.core.management.base import BaseCommand
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.support.video.models import VideoPlaybackSession


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_user_revoked(user_id: int) -> str:
    return f"media:playback:user:{int(user_id)}:revoked"


class Command(BaseCommand):
    help = "Reconcile VideoPlaybackSession DB state with Redis (EXPIRED/REVOKED)"

    def handle(self, *args, **options):
        now = timezone.now()

        qs = VideoPlaybackSession.objects.filter(
            status=VideoPlaybackSession.Status.ACTIVE
        ).select_related("enrollment", "enrollment__student")

        expired = 0
        revoked = 0

        for s in qs.iterator():
            user_id = s.enrollment.student_id
            session_id = s.session_id

            # revoked wins
            if redis_client.sismember(_key_user_revoked(user_id), session_id):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=now,
                )
                revoked += 1
                continue

            # expired if missing in zset or score <= now
            score = redis_client.zscore(_key_user_sessions(user_id), session_id)
            if score is None or int(score) <= int(now.timestamp()):
                VideoPlaybackSession.objects.filter(id=s.id).update(
                    status=VideoPlaybackSession.Status.EXPIRED,
                    ended_at=now,
                )
                expired += 1

        self.stdout.write(
            self.style.SUCCESS(
                f"reconcile done expired={expired} revoked={revoked}"
            )
        )


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-01-30 21:56

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("enrollment", "0001_initial"),
        ("lectures", "0002_remove_session_exam"),
    ]

    operations = [
        migrations.CreateModel(
            name="Video",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                (
                    "file_key",
                    models.CharField(
                        blank=True,
                        help_text="S3 object key (presigned upload)",
                        max_length=500,
                    ),
                ),
                ("duration", models.PositiveIntegerField(blank=True, null=True)),
                ("order", models.PositiveIntegerField(default=1)),
                (
                    "thumbnail",
                    models.ImageField(blank=True, null=True, upload_to="thumbnails/"),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "ì—…ë¡œë“œ ëŒ€ê¸°"),
                            ("UPLOADED", "ì—…ë¡œë“œ ì™„ë£Œ"),
                            ("PROCESSING", "ì²˜ë¦¬ì¤‘"),
                            ("READY", "ì‚¬ìš© ê°€ëŠ¥"),
                            ("FAILED", "ì‹¤íŒ¨"),
                        ],
                        db_index=True,
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("allow_skip", models.BooleanField(default=False)),
                ("max_speed", models.FloatField(default=1.0)),
                ("show_watermark", models.BooleanField(default=True)),
                (
                    "policy_version",
                    models.PositiveIntegerField(
                        db_index=True,
                        default=1,
                        help_text="Increment on policy/permission changes to invalidate existing tokens",
                    ),
                ),
                ("error_reason", models.TextField(blank=True, default="", null=True)),
                (
                    "hls_path",
                    models.CharField(
                        blank=True,
                        help_text="HLS master playlist path (relative to CDN root)",
                        max_length=500,
                    ),
                ),
                ("processing_started_at", models.DateTimeField(blank=True, null=True)),
                ("leased_until", models.DateTimeField(blank=True, null=True)),
                ("leased_by", models.CharField(blank=True, default="", max_length=64)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="videos",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["order", "id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPermission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rule",
                    models.CharField(
                        choices=[
                            ("free", "ë¬´ì œí•œ"),
                            ("once", "1íšŒ ì œí•œ"),
                            ("blocked", "ì œí•œ"),
                        ],
                        default="once",
                        max_length=20,
                    ),
                ),
                ("allow_skip_override", models.BooleanField(blank=True, null=True)),
                ("max_speed_override", models.FloatField(blank=True, null=True)),
                ("show_watermark_override", models.BooleanField(blank=True, null=True)),
                ("block_speed_control", models.BooleanField(default=False)),
                ("block_seek", models.BooleanField(default=False)),
                ("is_override", models.BooleanField(default=False)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_permissions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="permissions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoPlaybackEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("user_id", models.BigIntegerField(db_index=True)),
                (
                    "event_type",
                    models.CharField(
                        choices=[
                            ("VISIBILITY_HIDDEN", "íƒ­ ìˆ¨ê¹€"),
                            ("VISIBILITY_VISIBLE", "íƒ­ ë…¸ì¶œ"),
                            ("FOCUS_LOST", "í¬ì»¤ìŠ¤ ì´íƒˆ"),
                            ("FOCUS_GAINED", "í¬ì»¤ìŠ¤ ë³µê·€"),
                            ("SEEK_ATTEMPT", "íƒìƒ‰ ì‹œë„"),
                            ("SPEED_CHANGE_ATTEMPT", "ë°°ì† ë³€ê²½ ì‹œë„"),
                            ("FULLSCREEN_ENTER", "ì „ì²´í™”ë©´ ì§„ì…"),
                            ("FULLSCREEN_EXIT", "ì „ì²´í™”ë©´ ì¢…ë£Œ"),
                            ("PLAYER_ERROR", "í”Œë ˆì´ì–´ ì˜¤ë¥˜"),
                        ],
                        db_index=True,
                        max_length=32,
                    ),
                ),
                ("event_payload", models.JSONField(blank=True, default=dict)),
                ("policy_snapshot", models.JSONField(blank=True, default=dict)),
                ("violated", models.BooleanField(db_index=True, default=False)),
                (
                    "violation_reason",
                    models.CharField(blank=True, default="", max_length=64),
                ),
                (
                    "occurred_at",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                ("received_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_playback_events",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_events",
                        to="video.video",
                    ),
                ),
            ],
            options={
                "ordering": ["-received_at", "-id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackSession",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("device_id", models.CharField(db_index=True, max_length=128)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "í™œì„±"),
                            ("ENDED", "ì¢…ë£Œ"),
                            ("REVOKED", "ì°¨ë‹¨"),
                            ("EXPIRED", "ë§Œë£Œ"),
                        ],
                        db_index=True,
                        default="ACTIVE",
                        max_length=16,
                    ),
                ),
                ("started_at", models.DateTimeField(auto_now_add=True)),
                ("ended_at", models.DateTimeField(blank=True, null=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="VideoProgress",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("progress", models.FloatField(default=0)),
                ("last_position", models.IntegerField(default=0)),
                ("completed", models.BooleanField(default=False)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_progress",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="progresses",
                        to="video.video",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["status", "updated_at"], name="video_video_status_782ba3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="video",
            index=models.Index(
                fields=["leased_until", "status"], name="video_video_leased__a8f039_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="videopermission",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_permission"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["video", "enrollment", "session_id"],
                name="video_video_video_i_1ea099_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["user_id", "session_id"], name="video_video_user_id_474fa3_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybackevent",
            index=models.Index(
                fields=["event_type", "received_at"],
                name="video_video_event_t_b8ca86_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["status", "started_at"], name="video_video_status_175f42_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="videoplaybacksession",
            index=models.Index(
                fields=["video", "enrollment", "status"],
                name="video_video_video_i_5d0bbd_idx",
            ),
        ),
        migrations.AddConstraint(
            model_name="videoplaybacksession",
            constraint=models.UniqueConstraint(
                fields=("session_id",), name="uniq_video_playback_session_id"
            ),
        ),
        migrations.AddConstraint(
            model_name="videoprogress",
            constraint=models.UniqueConstraint(
                fields=("video", "enrollment"), name="unique_video_progress"
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/__init__.py
==========================================================================================



==========================================================================================
# FILE: services/playback_session.py
==========================================================================================
# PATH: apps/support/video/services/playback_session.py

import time
import uuid
from typing import Dict, Any, Tuple, Iterable, Optional

from django.conf import settings
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.domains.enrollment.models import Enrollment
from apps.support.video.models import (
    Video,
    VideoPlaybackSession,
)

# =======================================================
# Redis Key Helpers
# =======================================================

def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    # zset (session_id -> expires_at)
    return f"media:playback:user:{int(user_id)}:sessions"


def _key_session(session_id: str) -> str:
    # hash
    return f"media:playback:session:{session_id}"


def _key_user_devices(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:devices"


def _key_user_revoked(user_id: int) -> str:
    # set
    return f"media:playback:user:{int(user_id)}:revoked"


# âœ… ë¬¸ì œ 1/7: ì„¸ì…˜ ë‹¨ìœ„ ìœ„ë°˜ ëˆ„ì  ì¹´ìš´í„°
def _key_session_violation(session_id: str) -> str:
    # hash: { violated, total, last_reason }
    return f"media:playback:session:{session_id}:violation"


# =======================================================
# Decode Helpers (bytes/str ë°©ì–´)
# =======================================================

def _decode(value):
    if value is None:
        return None
    if isinstance(value, (bytes, bytearray)):
        return value.decode()
    return value


def _decode_set(values: Iterable) -> set[str]:
    return {_decode(v) for v in (values or set())}


# =======================================================
# Internal Helpers
# =======================================================

def _cleanup_expired_sessions(user_id: int) -> None:
    """
    ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬
    - session zset
    - session hash
    - device set (ëˆ„ìˆ˜ ë°©ì§€)
    """
    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expired = redis_client.zrangebyscore(sessions_key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)

    for raw_sid in expired:
        sid = _decode(raw_sid)

        device_id = _decode(redis_client.hget(_key_session(sid), "device_id"))
        if device_id:
            pipe.srem(devices_key, device_id)

        pipe.zrem(sessions_key, sid)
        pipe.delete(_key_session(sid))

        # violation hashë„ ê°™ì´ ì œê±°(ëˆ„ìˆ˜ ë°©ì§€)
        pipe.delete(_key_session_violation(sid))

    pipe.execute()


def _session_ttl_seconds_from_expires_at(expires_at: int) -> int:
    now = _now()
    ttl = max(0, int(expires_at) - now)
    # ë³´í˜¸: ë„ˆë¬´ ì§§ìœ¼ë©´ ìµœì†Œ 30s
    return max(30, ttl)


# =======================================================
# Core Session APIs (Redis / Infra)
# =======================================================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    """
    Redis ê¸°ë°˜ ì¬ìƒ ì„¸ì…˜ ë°œê¸‰ (ê³µí†µ Infra)
    """
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = _decode_set(redis_client.smembers(devices_key))

    # ê¸°ê¸° ì œí•œ
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    # ë™ì‹œ ì„¸ì…˜ ì œí•œ
    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)

    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(
        _key_session(session_id),
        mapping={
            "user_id": str(user_id),
            "device_id": device_id,
            "expires_at": str(expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)

    # violation state init
    pipe.hset(
        _key_session_violation(session_id),
        mapping={
            "violated": "0",
            "total": "0",
            "last_reason": "",
        },
    )
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    """
    ì„¸ì…˜ TTL ì—°ì¥
    - user_id ì†Œìœ  ê²€ì¦ í¬í•¨
    - revokedë©´ False
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sid_key = _key_session(session_id)
    sessions_key = _key_user_sessions(user_id)

    owner = _decode(redis_client.hget(sid_key, "user_id"))
    if not owner or int(owner) != int(user_id):
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(
        sid_key,
        mapping={
            "expires_at": str(new_expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)

    # violation ttlë„ í•¨ê»˜ ì—°ì¥
    pipe.expire(_key_session_violation(session_id), ttl_seconds + 60)

    pipe.execute()

    return True


def end_session(*, user_id: int, session_id: str) -> None:
    """
    ëª…ì‹œì  ì„¸ì…˜ ì¢…ë£Œ
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    pipe.execute()


def revoke_session(*, user_id: int, session_id: str) -> None:
    """
    âœ… ë¬¸ì œ 1: ì„œë²„ ê°•ì œ ì°¨ë‹¨
    - revoked setì— ê¸°ë¡(ì¬ì‚¬ìš© ë°©ì§€)
    - ì„¸ì…˜ ìë£Œ ì¦‰ì‹œ ì œê±°
    - violation hash ì œê±°(ëˆ„ìˆ˜ ë°©ì§€)
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.sadd(_key_user_revoked(user_id), session_id)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)
    pipe.delete(_key_session_violation(session_id))

    if device_id:
        pipe.srem(devices_key, device_id)

    # revoked set ëˆ„ìˆ˜ ë°©ì§€: TTL (ì„¸ì…˜ TTL ì•Œ ìˆ˜ ì—†ìœ¼ë©´ ê¸°ë³¸ 1h)
    try:
        pipe.expire(_key_user_revoked(user_id), int(getattr(settings, "VIDEO_REVOKED_SET_TTL_SECONDS", 3600)))
    except Exception:
        pass

    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    ì„¸ì…˜ í™œì„± ì—¬ë¶€ í™•ì¸
    """
    session_id = _decode(session_id)

    if redis_client.sismember(_key_user_revoked(user_id), session_id):
        return False

    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    return int(score) > _now()


# =======================================================
# âœ… ë¬¸ì œ 1/7: ì„¸ì…˜ ë‹¨ìœ„ ìœ„ë°˜ ëˆ„ì (ìš°íšŒ ë¶ˆê°€)
# =======================================================

def record_session_event(
    *,
    user_id: int,
    session_id: str,
    violated: bool,
    reason: str = "",
) -> Dict[str, int]:
    """
    ì„¸ì…˜ ë‹¨ìœ„ ëˆ„ì  ì¹´ìš´í„°:
    - total +1
    - violatedì´ë©´ violated +1
    - TTLì€ ì„¸ì…˜ expires_at ê¸°ë°˜ìœ¼ë¡œ ë™ê¸°í™”
    """
    session_id = _decode(session_id)

    # ì„¸ì…˜ expires_at ì½ê¸°(ì—†ìœ¼ë©´ default TTL ì‚¬ìš©)
    expires_at_raw = _decode(redis_client.hget(_key_session(session_id), "expires_at"))
    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
    if expires_at_raw:
        try:
            ttl = _session_ttl_seconds_from_expires_at(int(expires_at_raw))
        except Exception:
            ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    key = _key_session_violation(session_id)

    pipe = redis_client.pipeline(transaction=True)
    pipe.hincrby(key, "total", 1)
    if violated:
        pipe.hincrby(key, "violated", 1)
        if reason:
            pipe.hset(key, "last_reason", str(reason)[:200])
    pipe.expire(key, ttl + 60)
    res = pipe.execute()

    # res[0]=total, res[1]=violated or total, etc â†’ ì•ˆì „ íŒŒì‹±
    total = 0
    violated_cnt = 0
    try:
        # total always first
        total = int(res[0] or 0)
        # if violated, second is violated; else second is expire result
        if violated:
            violated_cnt = int(res[1] or 0)
        else:
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
    except Exception:
        # fallback fetch
        try:
            total = int(_decode(redis_client.hget(key, "total")) or 0)
            violated_cnt = int(_decode(redis_client.hget(key, "violated")) or 0)
        except Exception:
            total = 0
            violated_cnt = 0

    return {"total": total, "violated": violated_cnt}


def get_session_violation_stats(*, session_id: str) -> Dict[str, int]:
    session_id = _decode(session_id)
    key = _key_session_violation(session_id)
    data = redis_client.hgetall(key) or {}
    try:
        total = int(_decode(data.get(b"total") or data.get("total") or 0))
    except Exception:
        total = 0
    try:
        violated = int(_decode(data.get(b"violated") or data.get("violated") or 0))
    except Exception:
        violated = 0
    return {"total": total, "violated": violated}


def should_revoke_by_stats(*, violated: int, total: int) -> bool:
    """
    ë³´ìˆ˜ì  ì°¨ë‹¨ ê¸°ì¤€:
    - violated >= threshold
    - ë˜ëŠ” violated/total ë¹„ìœ¨ì´ ë„ˆë¬´ ë†’ìœ¼ë©´ ì°¨ë‹¨
    """
    threshold = int(getattr(settings, "VIDEO_VIOLATION_REVOKE_THRESHOLD", 3))
    ratio = float(getattr(settings, "VIDEO_VIOLATION_REVOKE_RATIO", 0.5))

    if int(violated) >= threshold:
        return True
    if int(total) > 0 and (float(violated) / float(total)) >= ratio:
        return True
    return False


# =======================================================
# Facade API (Student ONLY) - ê¸°ì¡´ ìœ ì§€
# =======================================================

def create_playback_session(
    *,
    user,
    video_id: int,
    enrollment_id: int,
    device_id: str,
) -> dict:
    """
    í•™ìƒ ì „ìš© Facade API

    ì±…ì„:
    - "ì¬ìƒ ì„¸ì…˜ ìƒì„±"ë§Œ ë‹´ë‹¹
    - ê¶Œí•œ / ìˆ˜ê°• ê²€ì¦ì€ Viewì—ì„œ ì„ í–‰ë˜ì–´ì•¼ í•¨
    """

    # ğŸš« ê°•ì‚¬ / ìš´ì˜ì ì°¨ë‹¨
    if getattr(user, "is_instructor", False) or getattr(user, "is_staff", False):
        return {
            "ok": False,
            "error": "instructor_must_use_play_api",
        }

    if not device_id:
        return {"ok": False, "error": "device_id_required"}

    video = Video.objects.select_related(
        "session",
        "session__lecture",
    ).get(id=video_id)

    enrollment = Enrollment.objects.select_related(
        "student",
        "lecture",
    ).get(
        id=enrollment_id,
        status="ACTIVE",
    )

    # ğŸ›¡ï¸ ì•ˆì „ ê°€ë“œ (View ëˆ„ë½ ë°©ì§€ìš©)
    if enrollment.lecture_id != video.session.lecture_id:
        return {
            "ok": False,
            "error": "enrollment_lecture_mismatch",
        }

    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    ok, sess, err = issue_session(
        user_id=user.id,
        device_id=device_id,
        ttl_seconds=ttl,
        max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
        max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
    )

    if not ok:
        return {
            "ok": False,
            "error": err,
        }

    session_id = str(sess["session_id"])
    expires_at = int(sess["expires_at"])

    VideoPlaybackSession.objects.create(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
        device_id=device_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        started_at=timezone.now(),
    )

    return {
        "ok": True,
        "video_id": video.id,
        "enrollment_id": enrollment.id,
        "session_id": session_id,
        "expires_at": expires_at,
    }


==========================================================================================
# FILE: services/queue.py
==========================================================================================
# PATH: apps/support/video/services/queue.py

from __future__ import annotations

from dataclasses import dataclass
from datetime import timedelta
from typing import Optional

from django.db import transaction
from django.db.models import Q
from django.utils import timezone

from apps.support.video.models import Video


@dataclass(frozen=True)
class ClaimResult:
    video: Video
    leased_until: timezone.datetime


class VideoJobQueue:
    """
    âœ… SSOT (DB ê¸°ë°˜ Video Worker Queue)

    ì² í•™:
    - DBê°€ ë‹¨ì¼ ì§„ì‹¤
    - claimì€ ì›ìì (select_for_update + skip_locked)
    - stuck reclaimì€ "updated_at" ê¸°ë°˜(ê¸°ì¡´ ì² í•™ ìœ ì§€) + lease í•„ë“œë¡œ ì¤‘ì•™ í†µì œ ë³´ê°•
    - ë©±ë“±/ê²½í•© ë°©ì§€: leased_by/leased_until ownerë§Œ complete/fail/heartbeat í—ˆìš©
    """

    @classmethod
    def _lease_seconds(cls) -> int:
        # settings ì˜ì¡´ì„ queue ë ˆë²¨ì—ì„œ ê°•ì œí•˜ì§€ ì•Šê¸° ìœ„í•´ model í•„ë“œ ê¸°ë°˜ìœ¼ë¡œë§Œ ì„¤ê³„
        # (settingsê°€ í•„ìš”í•˜ë©´ View ë ˆë²¨ì—ì„œ ì „ë‹¬)
        return 60

    @classmethod
    def _reclaim_cutoff(cls, now) -> timezone.datetime:
        # PROCESSING ìƒíƒœê°€ ì˜¤ë˜ ê°±ì‹ ì´ ì—†ìœ¼ë©´ reclaim ê°€ëŠ¥
        return now - timedelta(seconds=cls._lease_seconds())

    @classmethod
    @transaction.atomic
    def claim_next(
        cls,
        *,
        worker_id: str,
        lease_seconds: int = 60,
        max_batch: int = 1,
    ) -> Optional[Video]:
        """
        ì²˜ë¦¬ ëŒ€ê¸° Video 1ê°œë¥¼ claim í•œë‹¤.
        - ë°˜í™˜: Video | None
        """
        wid = (worker_id or "").strip() or "worker-unknown"
        now = timezone.now()
        cutoff = now - timedelta(seconds=int(lease_seconds or 60))

        # 1) UPLOADED ìš°ì„ 
        # 2) PROCESSING ì´ë©´ì„œ ì˜¤ë˜ëœ(updated_at < cutoff) ì‘ì—… reclaim í—ˆìš©
        video = (
            Video.objects.select_for_update(skip_locked=True)
            .filter(
                Q(status=Video.Status.UPLOADED)
                | Q(status=Video.Status.PROCESSING, updated_at__lt=cutoff)
            )
            .order_by("id")
            .first()
        )

        if not video:
            return None

        video.status = Video.Status.PROCESSING

        # lease í•„ë“œê°€ ì¡´ì¬í•˜ë©´ ë°˜ë“œì‹œ ê¸°ë¡ (ëª¨ë¸ì— ì´ë¯¸ ì¡´ì¬)
        if hasattr(video, "processing_started_at"):
            video.processing_started_at = now
        if hasattr(video, "leased_until"):
            video.leased_until = now + timedelta(seconds=int(lease_seconds or 60))
        if hasattr(video, "leased_by"):
            video.leased_by = wid

        update_fields = ["status"]
        if hasattr(video, "processing_started_at"):
            update_fields.append("processing_started_at")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")

        video.save(update_fields=update_fields)
        return video

    @classmethod
    @transaction.atomic
    def heartbeat(
        cls,
        *,
        video_id: int,
        worker_id: str,
        lease_seconds: int = 60,
    ) -> bool:
        """
        lease ì—°ì¥.
        - owner mismatchë©´ False
        """
        wid = (worker_id or "").strip() or "worker-unknown"
        now = timezone.now()

        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False

        # owner check (leaseê°€ ì—†ìœ¼ë©´ í†µê³¼)
        leased_by = (getattr(video, "leased_by", "") or "").strip()
        leased_until = getattr(video, "leased_until", None)

        if leased_by and leased_by != wid:
            return False
        if leased_until and leased_until < now:
            return False

        if hasattr(video, "processing_started_at") and not video.processing_started_at:
            video.processing_started_at = now

        if hasattr(video, "leased_by"):
            video.leased_by = wid
        if hasattr(video, "leased_until"):
            video.leased_until = now + timedelta(seconds=int(lease_seconds or 60))

        update_fields = []
        if hasattr(video, "processing_started_at"):
            update_fields.append("processing_started_at")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")

        if update_fields:
            video.save(update_fields=update_fields)
        return True

    @classmethod
    @transaction.atomic
    def complete(
        cls,
        *,
        video_id: int,
        worker_id: str,
        hls_path: str,
        duration: int | None = None,
    ) -> tuple[bool, str]:
        """
        ì™„ë£Œ ì²˜ë¦¬.
        - owner mismatchë©´ (False, "lease_owner_mismatch")
        - ì´ë¯¸ READY + hls_pathë©´ ë©±ë“± OK
        """
        wid = (worker_id or "").strip() or "worker-unknown"

        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False, "not_found"

        leased_by = (getattr(video, "leased_by", "") or "").strip()
        leased_until = getattr(video, "leased_until", None)
        now = timezone.now()

        if leased_by and leased_by != wid and (not leased_until or leased_until > now):
            return False, "lease_owner_mismatch"

        if video.status == Video.Status.READY and bool(video.hls_path):
            return True, "idempotent"

        video.hls_path = str(hls_path)

        if duration is not None and int(duration) >= 0:
            video.duration = int(duration)

        video.status = Video.Status.READY

        # lease í•´ì œ
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""

        update_fields = ["hls_path", "status"]
        if duration is not None and int(duration) >= 0:
            update_fields.append("duration")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")

        video.save(update_fields=update_fields)
        return True, "ok"

    @classmethod
    @transaction.atomic
    def fail(
        cls,
        *,
        video_id: int,
        worker_id: str,
        reason: str = "unknown",
    ) -> tuple[bool, str]:
        """
        ì‹¤íŒ¨ ì²˜ë¦¬.
        - owner mismatchë©´ (False, "lease_owner_mismatch")
        - ì´ë¯¸ FAILEDë©´ ë©±ë“± OK
        """
        wid = (worker_id or "").strip() or "worker-unknown"

        video = Video.objects.select_for_update().filter(id=int(video_id)).first()
        if not video:
            return False, "not_found"

        leased_by = (getattr(video, "leased_by", "") or "").strip()
        leased_until = getattr(video, "leased_until", None)
        now = timezone.now()

        if leased_by and leased_by != wid and (not leased_until or leased_until > now):
            return False, "lease_owner_mismatch"

        if video.status == Video.Status.FAILED:
            return True, "idempotent"

        video.status = Video.Status.FAILED
        if hasattr(video, "error_reason"):
            video.error_reason = str(reason)[:2000]

        # lease í•´ì œ
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""

        update_fields = ["status"]
        if hasattr(video, "error_reason"):
            update_fields.append("error_reason")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")

        video.save(update_fields=update_fields)
        return True, "ok"


==========================================================================================
# FILE: services/video_stats.py
==========================================================================================
# PATH: apps/support/video/services/video_stats.py

from apps.domains.enrollment.models import Enrollment
from apps.domains.attendance.models import Attendance
from apps.support.video.models import VideoProgress, VideoPermission


def build_video_stats_students(video):
    """
    âœ… Single Source of Truth
    - stats
    - policy-impact
    - admin preview
    ì „ë¶€ ì´ í•¨ìˆ˜ë§Œ ì‚¬ìš©í•´ì•¼ í•¨
    """

    lecture = video.session.lecture

    enrollments = Enrollment.objects.filter(
        lecture=lecture,
        status="ACTIVE",
    ).select_related("student")

    progresses = {
        p.enrollment_id: p
        for p in VideoProgress.objects.filter(video=video)
    }

    perms = {
        p.enrollment_id: p
        for p in VideoPermission.objects.filter(video=video)
    }

    attendance = {
        a.enrollment_id: a.status
        for a in Attendance.objects.filter(session=video.session)
    }

    students = []

    for e in enrollments:
        vp = progresses.get(e.id)
        perm = perms.get(e.id)

        rule = perm.rule if perm else "free"
        effective_rule = rule

        # once â†’ completed ì‹œ free ìŠ¹ê²©
        if rule == "once" and vp and vp.completed:
            effective_rule = "free"

        students.append({
            "enrollment": e.id,
            "student_name": e.student.name,
            "attendance_status": attendance.get(e.id),
            "progress": vp.progress if vp else 0,
            "completed": vp.completed if vp else False,
            "rule": rule,
            "effective_rule": effective_rule,
        })

    return students


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/support/video/views/__init__.py

from .video_policy_impact import VideoPolicyImpactAPIView

from .video_views import VideoViewSet
from .permission_views import VideoPermissionViewSet
from .progress_views import VideoProgressViewSet
from .internal_views import VideoProcessingCompleteView
from .event_views import VideoPlaybackEventViewSet


==========================================================================================
# FILE: views/achievement_views.py
==========================================================================================
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from django.db.models import Avg, Sum

from apps.domains.attendance.models import Attendance
from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoProgress


class VideoAchievementView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session").get(id=video_id)
        lecture = video.session.lecture

        # ì˜ìƒ ìˆ˜ê°• ëŒ€ìƒ í•™ìƒ (ì¶œì„ì´ ONLINE)
        online_attendance = Attendance.objects.filter(
            session=video.session,
            status="ONLINE",
        )

        enrollment_ids = online_attendance.values_list("enrollment_id", flat=True)

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(
                video=video,
                enrollment_id__in=enrollment_ids,
            )
        }

        students = []
        completed_count = 0
        total_progress = 0

        for att in online_attendance.select_related("enrollment__student"):
            enrollment = att.enrollment
            vp = progresses.get(enrollment.id)

            progress = vp.progress if vp else 0
            completed = vp.completed if vp else False

            if completed:
                completed_count += 1

            total_progress += progress

            # ìƒíƒœ ê³„ì‚°
            if progress >= 0.95:
                status = "completed"
            elif progress >= 0.5:
                status = "warning"
            else:
                status = "danger"

            students.append({
                "enrollment": enrollment.id,
                "student_name": enrollment.student.name,
                "progress": round(progress * 100, 1),
                "completed": completed,
                "watched_seconds": vp.last_position if vp else 0,
                "status": status,
            })

        total = len(students)
        avg_progress = (total_progress / total) if total else 0

        return Response({
            "summary": {
                "total_students": total,
                "avg_progress": round(avg_progress * 100, 1),
                "completed_rate": round((completed_count / total) * 100, 1) if total else 0,
                "incomplete_count": total - completed_count,
            },
            "students": students,
        })


==========================================================================================
# FILE: views/event_views.py
==========================================================================================
# PATH: apps/support/video/views/event_views.py

import csv
from datetime import timedelta

from django.http import HttpResponse
from django.utils import timezone

from rest_framework.viewsets import ReadOnlyModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.filters import SearchFilter

from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoPlaybackEvent
from ..serializers import (
    VideoPlaybackEventListSerializer,
    VideoRiskRowSerializer,
)


def _range_to_since(range_key: str):
    now = timezone.now()
    if range_key == "24h":
        return now - timedelta(hours=24)
    if range_key == "7d":
        return now - timedelta(days=7)
    return None


def _event_score(event_type: str, violated: bool, violation_reason: str | None):
    weights = {
        "VISIBILITY_HIDDEN": 1,
        "VISIBILITY_VISIBLE": 0,
        "FOCUS_LOST": 2,
        "FOCUS_GAINED": 0,
        "SEEK_ATTEMPT": 3,
        "SPEED_CHANGE_ATTEMPT": 3,
        "FULLSCREEN_ENTER": 0,
        "FULLSCREEN_EXIT": 0,
        "PLAYER_ERROR": 1,
    }
    w = int(weights.get(event_type, 1))
    if violated:
        w *= 2
    if violation_reason:
        w += 1
    return w


class VideoPlaybackEventViewSet(ReadOnlyModelViewSet):
    """
    Admin / Staff ì „ìš©
    - list
    - risk
    - export
    """

    queryset = (
        VideoPlaybackEvent.objects
        .all()
        .select_related("enrollment", "enrollment__student", "video")
    )
    serializer_class = VideoPlaybackEventListSerializer
    permission_classes = [IsAuthenticated]

    # âœ… ê²€ìƒ‰ + í•„í„° ë™ì‹œ ì§€ì›
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["video", "enrollment", "violated"]
    search_fields = [
        "enrollment__student__name",
        "session_id",
        "user_id",
    ]

    def get_queryset(self):
        qs = super().get_queryset()

        video_id = self.request.query_params.get("video")
        if video_id:
            qs = qs.filter(video_id=video_id)

        range_key = self.request.query_params.get("range", "24h")
        since = _range_to_since(range_key)
        if since:
            qs = qs.filter(occurred_at__gte=since)

        # âœ… event_type ë‹¤ì¤‘ í•„í„° (comma-separated)
        et = self.request.query_params.get("event_type")
        if et:
            types = [x for x in et.split(",") if x]
            if types:
                qs = qs.filter(event_type__in=types)

        return qs.order_by("-occurred_at", "-id")

    # --------------------------------------------------
    # Risk Top
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="risk")
    def risk(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        limit = int(request.query_params.get("limit") or 5)
        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        agg = {}
        for ev in qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment_id": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                    "danger": 0,
                    "warn": 0,
                    "info": 0,
                    "last_occurred_at": None,
                }

            s = _event_score(ev.event_type, bool(ev.violated), ev.violation_reason)
            agg[eid]["score"] += s

            if ev.violated:
                agg[eid]["danger"] += 1
            elif ev.event_type in ("SEEK_ATTEMPT", "SPEED_CHANGE_ATTEMPT", "FOCUS_LOST"):
                agg[eid]["warn"] += 1
            else:
                agg[eid]["info"] += 1

            if (
                agg[eid]["last_occurred_at"] is None
                or ev.occurred_at > agg[eid]["last_occurred_at"]
            ):
                agg[eid]["last_occurred_at"] = ev.occurred_at

        rows = sorted(
            agg.values(),
            key=lambda r: (r["score"], r["danger"], r["warn"]),
            reverse=True,
        )[:limit]

        return Response(VideoRiskRowSerializer(rows, many=True).data)

    # --------------------------------------------------
    # CSV Export
    # --------------------------------------------------
    @action(detail=False, methods=["get"], url_path="export")
    def export_csv(self, request):
        video_id = request.query_params.get("video")
        if not video_id:
            return Response({"detail": "video is required"}, status=400)

        range_key = request.query_params.get("range", "24h")
        since = _range_to_since(range_key)

        qs = VideoPlaybackEvent.objects.filter(video_id=video_id).select_related(
            "enrollment", "enrollment__student"
        )
        if since:
            qs = qs.filter(occurred_at__gte=since)

        qs = qs.order_by("-occurred_at", "-id")

        resp = HttpResponse(content_type="text/csv; charset=utf-8")
        resp["Content-Disposition"] = (
            f'attachment; filename="video_{video_id}_events_{range_key}.csv"'
        )

        writer = csv.writer(resp)
        writer.writerow([
            "occurred_at",
            "student_name",
            "enrollment_id",
            "event_type",
            "violated",
            "violation_reason",
            "session_id",
            "user_id",
            "score",
            "payload",
        ])

        for ev in qs.iterator():
            writer.writerow([
                ev.occurred_at.isoformat(),
                ev.enrollment.student.name if ev.enrollment_id else "",
                ev.enrollment_id,
                ev.event_type,
                "Y" if ev.violated else "N",
                ev.violation_reason or "",
                ev.session_id,
                ev.user_id,
                _event_score(ev.event_type, bool(ev.violated), ev.violation_reason),
                ev.event_payload,
            ])

        return resp


==========================================================================================
# FILE: views/internal_video_worker.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker.py

from __future__ import annotations

from typing import Any

from django.conf import settings
from django.http import JsonResponse

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny

from apps.support.video.services.queue import VideoJobQueue


def _require_worker_token(request) -> bool:
    expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
    if not expected:
        return False

    token = (
        request.headers.get("X-Worker-Token")
        or request.META.get("HTTP_X_WORKER_TOKEN")
        or ""
    )
    return str(token) == expected


def _worker_id(request) -> str:
    return (
        request.headers.get("X-Worker-Id")
        or request.headers.get("X-Worker-ID")
        or request.META.get("HTTP_X_WORKER_ID")
        or "worker-unknown"
    )


def _parse_int(value: Any) -> int | None:
    if value is None:
        return None
    try:
        return int(value)
    except Exception:
        return None


LEASE_SECONDS = int(getattr(settings, "VIDEO_WORKER_LEASE_SECONDS", 60))
MAX_BATCH = int(getattr(settings, "VIDEO_WORKER_MAX_BATCH", 1))


class VideoWorkerClaimNextView(APIView):
    """
    Worker polls (SSOT):

      GET  /.../video-worker/next/
      GET  /.../internal/video-worker/next/   (compat alias)

    Returns:
      200 { "job": { video_id, file_key, tenant_code } }
      204 no content

    âœ… SSOT:
    - claimì€ VideoJobQueue.claim_next
    - ìƒíƒœ ë³€í™”ëŠ” Video.Status ê¸°ì¤€
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def get(self, request):
        if not _require_worker_token(request):
            expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
            if not expected:
                return JsonResponse(
                    {"detail": "INTERNAL_WORKER_TOKEN not configured"},
                    status=503,
                )
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        video = VideoJobQueue.claim_next(
            worker_id=wid,
            lease_seconds=LEASE_SECONDS,
            max_batch=MAX_BATCH,
        )

        if video is None:
            return JsonResponse({}, status=204)

        # âœ… tenant context (R2 / HLS path isolation)
        lecture = video.session.lecture
        tenant = lecture.tenant

        return JsonResponse(
            {
                "job": {
                    "video_id": int(video.id),
                    "file_key": str(video.file_key or ""),
                    "tenant_code": str(tenant.code),
                }
            },
            status=200,
        )


class VideoWorkerCompleteView(APIView):
    """
    Worker reports success:

      POST /.../video-worker/{video_id}/complete/
      POST /.../internal/video-worker/{video_id}/complete/   (compat alias)

      body: { hls_path, duration }

    âœ… SSOT:
    - owner(leased_by)ë§Œ complete ê°€ëŠ¥
    - ë©±ë“± ì²˜ë¦¬: ì´ë¯¸ READY + hls_pathë©´ OK
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
            if not expected:
                return JsonResponse(
                    {"detail": "INTERNAL_WORKER_TOKEN not configured"},
                    status=503,
                )
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = getattr(request, "data", None) or {}
        hls_path = data.get("hls_path")
        duration = _parse_int(data.get("duration"))

        if not hls_path:
            return JsonResponse({"detail": "hls_path required"}, status=400)

        ok, reason = VideoJobQueue.complete(
            video_id=int(video_id),
            worker_id=wid,
            hls_path=str(hls_path),
            duration=duration,
        )

        if not ok:
            if reason == "not_found":
                return JsonResponse({"detail": "Not found"}, status=404)
            if reason == "lease_owner_mismatch":
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)
            return JsonResponse({"detail": reason}, status=400)

        return JsonResponse({"ok": True, "reason": reason}, status=200)


class VideoWorkerFailView(APIView):
    """
    Worker reports failure:

      POST /.../video-worker/{video_id}/fail/
      POST /.../internal/video-worker/{video_id}/fail/   (compat alias)

      body: { reason }

    âœ… SSOT:
    - owner(leased_by)ë§Œ fail ê°€ëŠ¥
    - ë©±ë“± ì²˜ë¦¬: ì´ë¯¸ FAILEDë©´ OK
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
            if not expected:
                return JsonResponse(
                    {"detail": "INTERNAL_WORKER_TOKEN not configured"},
                    status=503,
                )
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        data = getattr(request, "data", None) or {}
        reason = str(data.get("reason") or "unknown")

        ok, why = VideoJobQueue.fail(
            video_id=int(video_id),
            worker_id=wid,
            reason=reason,
        )

        if not ok:
            if why == "not_found":
                return JsonResponse({"detail": "Not found"}, status=404)
            if why == "lease_owner_mismatch":
                return JsonResponse({"detail": "lease_owner_mismatch"}, status=409)
            return JsonResponse({"detail": why}, status=400)

        return JsonResponse({"ok": True, "reason": why}, status=200)


==========================================================================================
# FILE: views/internal_video_worker_heartbeat.py
==========================================================================================
# PATH: apps/support/video/views/internal_video_worker_heartbeat.py

from __future__ import annotations

import logging

from django.conf import settings
from django.http import JsonResponse

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny

from apps.support.video.services.queue import VideoJobQueue


logger = logging.getLogger("video.worker.heartbeat")


def _require_worker_token(request) -> bool:
    expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
    if not expected:
        return False

    token = (
        request.headers.get("X-Worker-Token")
        or request.META.get("HTTP_X_WORKER_TOKEN")
        or ""
    )
    return str(token) == expected


def _worker_id(request) -> str:
    return (
        request.headers.get("X-Worker-Id")
        or request.headers.get("X-Worker-ID")
        or request.META.get("HTTP_X_WORKER_ID")
        or "worker-unknown"
    )


LEASE_SECONDS = int(getattr(settings, "VIDEO_WORKER_LEASE_SECONDS", 60))


class InternalVideoWorkerHeartbeatView(APIView):
    """
    POST /internal/video-worker/<video_id>/heartbeat/

    âœ… SSOT:
    - queue.heartbeat()ê°€ lease ì—°ì¥ ë‹¨ì¼ ì§„ì…ì 
    - owner mismatch/lease expiredë©´ 409
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def post(self, request, video_id: int):
        if not _require_worker_token(request):
            expected = str(getattr(settings, "INTERNAL_WORKER_TOKEN", "") or "")
            if not expected:
                return JsonResponse(
                    {"detail": "INTERNAL_WORKER_TOKEN not configured"},
                    status=503,
                )
            return JsonResponse({"detail": "Unauthorized"}, status=401)

        wid = _worker_id(request)

        ok = VideoJobQueue.heartbeat(
            video_id=int(video_id),
            worker_id=wid,
            lease_seconds=LEASE_SECONDS,
        )

        if not ok:
            logger.warning(
                "heartbeat rejected video_id=%s worker=%s",
                str(video_id),
                wid,
            )
            return JsonResponse({"detail": "lease_owner_mismatch_or_expired"}, status=409)

        logger.info(
            "heartbeat ok video_id=%s worker=%s",
            str(video_id),
            wid,
        )
        return JsonResponse({"ok": True}, status=200)


==========================================================================================
# FILE: views/internal_views.py
==========================================================================================
# PATH: apps/support/video/views/internal_views.py

from __future__ import annotations

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status

from apps.support.video.models import Video


class VideoProcessingCompleteView(APIView):
    """
    âœ… Legacy ACK endpoint (kept)

    ê¸°ì¡´ ê³„ì•½ì„ ê¹¨ì§€ ì•Šê¸° ìœ„í•´ ìœ ì§€í•˜ë˜,
    "worker queue/claim" ê°™ì€ ì±…ì„ì„ ì ˆëŒ€ ì„ì§€ ì•ŠëŠ”ë‹¤.

    POST /api/v1/videos/internal/videos/<video_id>/processing-complete/
    (í”„ë¡œì íŠ¸ì˜ ê¸°ì¡´ URL ì—°ê²° ë°©ì‹ì— ë§ì¶° ìœ ì§€)

    body:
      {
        "hls_path": "...",
        "duration": 123
      }
    """

    permission_classes = [AllowAny]
    authentication_classes = []

    def post(self, request, video_id: int):
        data = getattr(request, "data", None) or {}

        hls_path = data.get("hls_path")
        if not hls_path:
            return Response({"detail": "hls_path required"}, status=status.HTTP_400_BAD_REQUEST)

        duration = data.get("duration")
        try:
            duration_int = int(duration) if duration is not None else None
        except Exception:
            duration_int = None

        video = Video.objects.filter(id=int(video_id)).first()
        if not video:
            return Response({"detail": "Not found"}, status=status.HTTP_404_NOT_FOUND)

        # ë©±ë“±
        if video.status == Video.Status.READY and bool(video.hls_path):
            return Response({"ok": True, "idempotent": True}, status=status.HTTP_200_OK)

        video.hls_path = str(hls_path)
        if duration_int is not None and duration_int >= 0:
            video.duration = duration_int
        video.status = Video.Status.READY

        # legacy completeëŠ” lease í†µì œë¥¼ ëª¨ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ lease í•´ì œë§Œ ìˆ˜í–‰
        if hasattr(video, "leased_until"):
            video.leased_until = None
        if hasattr(video, "leased_by"):
            video.leased_by = ""

        update_fields = ["hls_path", "status"]
        if duration_int is not None and duration_int >= 0:
            update_fields.append("duration")
        if hasattr(video, "leased_until"):
            update_fields.append("leased_until")
        if hasattr(video, "leased_by"):
            update_fields.append("leased_by")

        video.save(update_fields=update_fields)

        return Response({"ok": True}, status=status.HTTP_200_OK)


==========================================================================================
# FILE: views/permission_views.py
==========================================================================================
# PATH: apps/support/video/views/permission_views.py

from django.db import models, transaction
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.response import Response

from ..models import VideoPermission, Video
from ..serializers import VideoPermissionSerializer


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_set(self, request):
        video_id = request.data.get("video_id")
        enrollments = request.data.get("enrollments", [])
        rule = request.data.get("rule", "once")

        objs = []
        for enrollment_id in enrollments:
            obj, _ = VideoPermission.objects.update_or_create(
                video_id=video_id,
                enrollment_id=enrollment_id,
                defaults={
                    "rule": rule,
                    "is_override": True,
                },
            )
            objs.append(obj)

        # âœ… ì •ì±… ë³€ê²½ â†’ policy_version ì¦ê°€ (ê¸°ì¡´ í† í° ì¦‰ì‹œ ë¬´íš¨í™”)
        Video.objects.filter(id=video_id).update(
            policy_version=models.F("policy_version") + 1
        )

        return Response(VideoPermissionSerializer(objs, many=True).data)


==========================================================================================
# FILE: views/playback_mixin.py
==========================================================================================
# PATH: apps/support/video/views/playback_mixin.py

import time

from django.conf import settings
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.lectures.models import Session

from ..models import Video, VideoPermission, VideoProgress
from ..serializers import VideoSerializer
from ..drm import create_playback_token, verify_playback_token
from ..cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options

# âœ… ì¶”ê°€: Cloudflare signed url (ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ public)
from ..cdn.cloudflare_signing import CloudflareSignedURL


class VideoPlaybackMixin:
    """
    ì¬ìƒ ê¶Œí•œ / ì •ì±… / ê³µí†µ ë¡œì§

    ì •ì±… ì •ì˜:
    - free    : í•­ìƒ ë¬´ì œí•œ
    - once    : 1íšŒì°¨ì—ë§Œ ì •ì±… ì ìš©, ì™„ë£Œ í›„ freeë¡œ ìŠ¹ê²©ë¨
    - blocked : í•­ìƒ ì°¨ë‹¨
    """

    def _get_student_for_user(self, request):
        return getattr(request.user, "student_profile", None)

    # ==================================================
    # ì ‘ê·¼ ì œì–´ (Access Control)
    # ==================================================
    def _check_access(self, *, video, enrollment):
        """
        ì ‘ê·¼ ê°€ëŠ¥ ì—¬ë¶€ë§Œ íŒë‹¨í•œë‹¤.
        onceëŠ” ì ‘ê·¼ì„ ì°¨ë‹¨í•˜ì§€ ì•ŠëŠ”ë‹¤.
        """
        if video.status != video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        # free / once ëª¨ë‘ ì ‘ê·¼ í—ˆìš©
        return True, None

    # ==================================================
    # Permission Loader
    # ==================================================
    def _load_permission(self, *, video, enrollment):
        return VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

    # ==================================================
    # Playback Policy
    # ==================================================
    def _effective_policy(self, *, video, perm):
        """
        ì‹¤ì œ ì¬ìƒ ì œì•½ ì •ì±… ê³„ì‚°
        - once : ì™„ë£Œ ì „ê¹Œì§€ íƒìƒ‰ ì œí•œ
        - ì™„ë£Œ í›„ì—ëŠ” freeì™€ ë™ì¼
        """
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        seek_policy = {
            "mode": "free",
            "forward_limit": None,
            "grace_seconds": 3,
        }

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)

            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if perm.rule == "once":
                completed = VideoProgress.objects.filter(
                    video=video,
                    enrollment=perm.enrollment,
                    completed=True,
                ).exists()

                if not completed:
                    seek_policy = {
                        "mode": "bounded_forward",
                        "forward_limit": "max_watched",
                        "grace_seconds": 3,
                    }

            if perm.block_seek:
                allow_seek = False
                seek_policy = {"mode": "blocked"}

            if perm.block_speed_control:
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "seek": seek_policy,
            "playback_rate": {
                "max": max_rate,
                "ui_control": ui_speed_control,
            },
            "watermark": {
                "enabled": watermark_enabled,
                "mode": "overlay",
                "fields": ["user_id"],
            },
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    # ==================================================
    # HLS / CDN
    # ==================================================
    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _normalize_media_path(self, path: str) -> str:
        """
        serializerì™€ ë™ì¼ ì² í•™:
        - leading slash ì œê±°
        - legacy storage/media normalize
        """
        p = (path or "").lstrip("/")
        if p.startswith("storage/media/"):
            return p[len("storage/") :]
        return p

    def _public_play_url(self, *, video: Video, expires_at: int, user_id: int) -> str:
        """
        âœ… ì›ë³¸ ê³„ì•½ ìœ ì§€ + ìµœì†Œ ë³´ê°•
        - video.hls_pathê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì´ single source of truth
        - ì—†ìœ¼ë©´ ê¸°ì¡´ ê¸°ë³¸ ê²½ë¡œ(master.m3u8)ë¡œ fallback
        - ì„¤ì •ê°’ì´ ìˆìœ¼ë©´ Cloudflare signed queryë¥¼ ë¶™ì—¬ì„œ ë°˜í™˜
        """
        cdn_base = settings.CDN_HLS_BASE_URL.rstrip("/")

        # 1) worker ê²°ê³¼ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì‚¬ìš©
        if getattr(video, "hls_path", ""):
            rel = self._normalize_media_path(str(video.hls_path))
            path = "/" + rel if not rel.startswith("/") else rel
        else:
            # 2) ê¸°ì¡´ fallback (ì›ë³¸ ìœ ì§€)
            path = f"/media/hls/videos/{video.id}/master.m3u8"

        secret = getattr(settings, "CDN_HLS_SIGNING_SECRET", None)
        if not secret:
            return f"{cdn_base}{path}"

        signer = CloudflareSignedURL(
            secret=str(secret),
            key_id=str(getattr(settings, "CDN_HLS_SIGNING_KEY_ID", "v1")),
        )
        return signer.build_url(
            cdn_base=cdn_base,
            path=path,
            expires_at=int(expires_at),
            user_id=int(user_id),
        )

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int):
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, expires_at - int(time.time()))
        for k, v in cookies.items():
            response.set_cookie(k, v, max_age=max_age, **opts)

    # ==================================================
    # í•™ìƒ ì˜ìƒ ëª©ë¡ (ì¬ìƒ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨)
    # ==================================================
    def _student_list_impl(self, request):
        session_id = request.query_params.get("session")
        if not session_id:
            return Response({"detail": "session is required"}, status=400)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        qs = Video.objects.filter(
            session_id=session_id,
            status=Video.Status.READY,
        ).order_by("order", "id")

        session = Session.objects.select_related("lecture").get(id=session_id)
        lecture = session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        data = []
        for v in qs:
            d = VideoSerializer(v).data

            if not enrollment:
                d["can_play"] = False
                d["reason"] = "not_enrolled"
                data.append(d)
                continue

            if not SessionEnrollment.objects.filter(
                session=session,
                enrollment=enrollment,
            ).exists():
                d["can_play"] = False
                d["reason"] = "no_session_access"
                data.append(d)
                continue

            ok, reason = self._check_access(video=v, enrollment=enrollment)
            d["can_play"] = bool(ok)
            d["reason"] = reason if not ok else None
            data.append(d)

        return Response(data)


==========================================================================================
# FILE: views/playback_views.py
==========================================================================================
# PATH: apps/support/video/views/playback_views.py

import uuid

from django.conf import settings
from django.utils import timezone
from django.db import transaction

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from apps.domains.enrollment.models import Enrollment, SessionEnrollment

from ..models import (
    Video,
    VideoPlaybackSession,
    VideoPlaybackEvent,
    VideoProgress,
    VideoPermission,
)
from ..serializers import (
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)
from ..drm import create_playback_token, verify_playback_token
from ..services.playback_session import (
    issue_session,
    heartbeat_session,
    end_session,
    is_session_active,
    revoke_session,
    record_session_event,
    get_session_violation_stats,
    should_revoke_by_stats,
)
from .playback_mixin import VideoPlaybackMixin


# ----------------------------------------------------------
# internal helpers (ì›ë³¸ êµ¬ì¡° ìœ ì§€: view ë‚´ë¶€ ë³´ì¡° í•¨ìˆ˜ë¡œë§Œ ì¶”ê°€)
# ----------------------------------------------------------

def _req_id() -> str:
    return uuid.uuid4().hex


def _policy_version_of(video: Video) -> int:
    try:
        return int(getattr(video, "policy_version", 1) or 1)
    except Exception:
        return 1


def _is_policy_token_valid(payload: dict) -> bool:
    """
    token payloadì˜ pvì™€ í˜„ì¬ video.policy_version ë¹„êµ.
    - ë¶ˆì¼ì¹˜ ì‹œ ì¦‰ì‹œ ì°¨ë‹¨ (ë¬¸ì œ 6)
    """
    try:
        video_id = int(payload.get("video_id"))
    except Exception:
        return False

    # NOTE: migrations ì ìš© ì „ì—ëŠ” policy_version ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ SELECTì—ì„œ í„°ì§ˆ ìˆ˜ ìˆìŒ.
    # ì‹¤ì„œë¹„ìŠ¤ëŠ” migration ì´í›„ë¥¼ ì „ì œë¡œ í•œë‹¤.
    v = Video.objects.filter(id=video_id).only("id", "policy_version").first()
    if not v:
        return False

    current = _policy_version_of(v)
    try:
        pv = int(payload.get("pv") or 0)
    except Exception:
        pv = 0

    return pv == current


def _deny(detail: str, *, code=status.HTTP_403_FORBIDDEN):
    return Response({"detail": detail}, status=code)


def _session_db_status(session_id: str):
    return (
        VideoPlaybackSession.objects
        .filter(session_id=session_id)
        .values_list("status", flat=True)
        .first()
    )


def _db_session_is_inactive(st: str | None) -> bool:
    return st in (VideoPlaybackSession.Status.REVOKED, VideoPlaybackSession.Status.EXPIRED)


# ==========================================================
# Playback Start
# ==========================================================

class PlaybackStartView(VideoPlaybackMixin, APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        request_id = _req_id()

        serializer = PlaybackStartRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        enrollment_id = serializer.validated_data["enrollment_id"]
        device_id = serializer.validated_data["device_id"]

        video_id = request.data.get("video_id")
        if not video_id:
            return Response({"detail": "video_id_required"}, status=400)

        enrollment = Enrollment.objects.select_related(
            "student",
            "lecture",
        ).get(id=enrollment_id, status="ACTIVE")

        video = Video.objects.select_related(
            "session",
            "session__lecture",
        ).get(id=int(video_id))

        # ìˆ˜ê°• ê²€ì¦
        if enrollment.lecture_id != video.session.lecture_id:
            return _deny("enrollment_mismatch", code=403)

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return _deny("no_session_access", code=403)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return _deny(reason, code=403)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
            max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
        )

        if not ok:
            return Response({"detail": err}, status=409)

        session_id = sess["session_id"]
        expires_at = sess["expires_at"]

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
            started_at=timezone.now(),
        )

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        # âœ… tokenì— pv(policy_version) í¬í•¨
        token = create_playback_token(
            payload={
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "session_id": session_id,
                "user_id": request.user.id,
                "pv": _policy_version_of(video),
                "rid": request_id,  # trace
            },
            ttl_seconds=ttl,
        )

        play_url = self._public_play_url(
            video=video,
            expires_at=expires_at,
            user_id=request.user.id,
        )

        resp = Response(
            PlaybackResponseSerializer({
                "token": token,
                "session_id": session_id,
                "expires_at": expires_at,
                "policy": policy,
                "play_url": play_url,
            }).data,
            status=201,
        )

        self._set_signed_cookies(resp, video_id=video.id, expires_at=expires_at)
        return resp


# ==========================================================
# Playback Refresh
# ==========================================================

class PlaybackRefreshView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackRefreshRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        if not is_session_active(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        ):
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback Heartbeat
# ==========================================================

class PlaybackHeartbeatView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackHeartbeatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        sid = str(payload.get("session_id") or "")
        if sid:
            st = _session_db_status(sid)
            if _db_session_is_inactive(st):
                return Response({"detail": "session_inactive"}, status=409)

        ok2 = heartbeat_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
            ttl_seconds=int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600)),
        )
        if not ok2:
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback End
# ==========================================================

class PlaybackEndView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEndRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        end_session(
            user_id=int(payload["user_id"]),
            session_id=str(payload["session_id"]),
        )

        VideoPlaybackSession.objects.filter(
            session_id=str(payload["session_id"])
        ).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        return Response({"ok": True})


# ==========================================================
# Event Batch
# ==========================================================

class PlaybackEventBatchView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEventBatchRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return _deny(err, code=403)

        if not _is_policy_token_valid(payload):
            return _deny("policy_changed", code=403)

        user_id = int(payload["user_id"])
        session_id = str(payload["session_id"])

        # DB ìƒíƒœ ì°¨ë‹¨
        st = _session_db_status(session_id)
        if _db_session_is_inactive(st):
            return Response({"detail": "session_inactive"}, status=409)

        # Redis ìƒíƒœ ì°¨ë‹¨
        if not is_session_active(user_id=user_id, session_id=session_id):
            return Response({"detail": "session_inactive"}, status=409)

        events = serializer.validated_data["events"]

        # í­ì£¼ ë°©ì§€
        max_batch = int(getattr(settings, "VIDEO_EVENT_BATCH_MAX", 200))
        if len(events) > max_batch:
            return Response({"detail": "batch_too_large"}, status=413)

        now = timezone.now()
        objs = []

        # policy snapshot ê³„ì‚° (ì›ë³¸ ë¯¹ìŠ¤ì¸ ì¬ì‚¬ìš©)
        video = Video.objects.filter(id=int(payload["video_id"])).first()
        enrollment = Enrollment.objects.filter(id=int(payload["enrollment_id"])).first()
        perm = None
        if video and enrollment:
            perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

        policy_snapshot = {}
        try:
            if video:
                m = VideoPlaybackMixin()
                policy_snapshot = m._effective_policy(video=video, perm=perm)
        except Exception:
            policy_snapshot = {}

        def _is_violation(ev_type: str, snap: dict) -> tuple[bool, str]:
            """
            âœ… ìµœì†Œ ê°•ì œ ìœ„ë°˜ íŒì •(ì„œë²„ ë‹¨):
            - seek blocked/bounded í™˜ê²½ì—ì„œ SEEK_ATTEMPTëŠ” violated
            - speed ì œí•œ í™˜ê²½ì—ì„œ SPEED_CHANGE_ATTEMPTëŠ” violated
            (ì¶”ê°€ ê°•í™”ëŠ” ì—¬ê¸°ë§Œ ìˆ˜ì •í•˜ë©´ ë¨ â†’ êµ¬ì¡° ìœ ì§€)
            """
            if ev_type == "SEEK_ATTEMPT":
                seek = (snap or {}).get("seek") or {}
                allow_seek = bool((snap or {}).get("allow_seek", True))
                mode = seek.get("mode")
                if (not allow_seek) or mode in ("blocked", "bounded_forward"):
                    return True, f"seek_{mode or 'blocked'}"
            if ev_type == "SPEED_CHANGE_ATTEMPT":
                pr = ((snap or {}).get("playback_rate") or {})
                ui = bool(pr.get("ui_control", True))
                mx = float(pr.get("max", 1.0) or 1.0)
                if (not ui) or mx <= 1.0:
                    return True, "speed_blocked"
            return False, ""

        # âœ… ì„¸ì…˜ ë‹¨ìœ„ ëˆ„ì  ìœ„ë°˜ íŒë‹¨
        # - ê° ì´ë²¤íŠ¸ë§ˆë‹¤ Redis ì¹´ìš´í„° ê°±ì‹  â†’ batch ìª¼ê°œê¸° ìš°íšŒ ë¶ˆê°€
        latest_stats = None
        revoke_reason = ""

        for e in events:
            ev_type = e["type"]
            ev_payload = e.get("payload", {}) or {}

            violated, reason = _is_violation(ev_type, policy_snapshot)
            if violated and reason:
                revoke_reason = reason

            # âœ… Redis ëˆ„ì  ê°±ì‹ 
            latest_stats = record_session_event(
                user_id=user_id,
                session_id=session_id,
                violated=bool(violated),
                reason=reason or "",
            )

            objs.append(
                VideoPlaybackEvent(
                    video_id=int(payload["video_id"]),
                    enrollment_id=int(payload["enrollment_id"]),
                    session_id=session_id,
                    user_id=user_id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy_snapshot,
                    violated=bool(violated),
                    violation_reason=reason or "",
                    occurred_at=now,
                )
            )

        with transaction.atomic():
            VideoPlaybackEvent.objects.bulk_create(objs, batch_size=500)

            # âœ… ëˆ„ì  ê¸°ì¤€ìœ¼ë¡œ revoke ê²°ì •
            stats = latest_stats or get_session_violation_stats(session_id=session_id)
            violated_cnt = int(stats.get("violated") or 0)
            total_cnt = int(stats.get("total") or 0)

            if should_revoke_by_stats(violated=violated_cnt, total=total_cnt):
                # Redis ì„¸ì…˜ ì¦‰ì‹œ ì œê±°
                revoke_session(user_id=user_id, session_id=session_id)

                # DB ë°˜ì˜
                VideoPlaybackSession.objects.filter(session_id=session_id).update(
                    status=VideoPlaybackSession.Status.REVOKED,
                    ended_at=timezone.now(),
                )

        return Response(
            PlaybackEventBatchResponseSerializer({"stored": len(objs)}).data,
            status=201,
        )


==========================================================================================
# FILE: views/progress_views.py
==========================================================================================
# apps/support/video/views/progress_views.py

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoProgress, VideoPermission
from ..serializers import VideoProgressSerializer


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    def perform_update(self, serializer):
        vp = serializer.instance
        prev_completed = vp.completed

        vp = serializer.save()

        # ğŸ”¥ once â†’ free ìë™ ìŠ¹ê²© (completed False â†’ True ìˆœê°„)
        if not prev_completed and vp.completed:
            VideoPermission.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                rule="once",
            ).update(
                rule="free",
                is_override=False,
            )


==========================================================================================
# FILE: views/video_policy_impact.py
==========================================================================================
# PATH: apps/support/video/views/video_policy_impact.py
# PATH: apps/support/video/views/video_policy_impact.py

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment
from ..models import Video, VideoPermission, VideoProgress


class VideoPolicyImpactAPIView(APIView):
    """
    Admin ì „ìš©:
    íŠ¹ì • ì˜ìƒ ì •ì±…ì´ í•™ìƒë“¤ì—ê²Œ ì–´ë–¤ ì˜í–¥ì„ ì£¼ëŠ”ì§€ ë¯¸ë¦¬ ë³´ê¸°
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, video_id: int):
        video = Video.objects.select_related("session", "session__lecture").get(id=video_id)

        enrollments = Enrollment.objects.filter(
            lecture=video.session.lecture,
            status="ACTIVE",
        ).select_related("student")

        perms = {
            p.enrollment_id: p
            for p in VideoPermission.objects.filter(video=video)
        }

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }

        rows = []

        for e in enrollments:
            perm = perms.get(e.id)
            prog = progresses.get(e.id)

            rule = perm.rule if perm else "free"

            effective = rule
            if rule == "once" and prog and prog.completed:
                effective = "free"

            rows.append({
                "enrollment": e.id,
                "student_name": e.student.name,
                "rule": rule,
                "effective_rule": effective,
                "completed": bool(prog.completed) if prog else False,
            })

        return Response(rows)


==========================================================================================
# FILE: views/video_views.py
==========================================================================================
# PATH: apps/support/video/views/video_views.py

import logging
from uuid import uuid4
from datetime import timedelta

from django.conf import settings
from django.db import models, transaction
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from rest_framework.parsers import (
    JSONParser,
    MultiPartParser,
    FormParser,
)
from django_filters.rest_framework import DjangoFilterBackend

from rest_framework_simplejwt.authentication import JWTAuthentication

from libs.s3_client.presign import create_presigned_put_url, create_presigned_get_url
from libs.s3_client.client import head_object

from apps.core.permissions import IsAdminOrStaff, IsStudent
from apps.core.authentication import CsrfExemptSessionAuthentication

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from ..models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackEvent,
)
from ..serializers import VideoSerializer, VideoDetailSerializer
from .playback_mixin import VideoPlaybackMixin

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)

# ==================================================
# utils
# ==================================================
def _safe_int(v, default=None):
    try:
        return int(v)
    except Exception:
        return default


def _validate_source_media_via_ffprobe(url: str) -> tuple[bool, dict, str]:
    """
    upload_complete ìµœì†Œ ë¬´ê²°ì„± ê²€ì¦
    """
    if not url:
        return False, {}, "source_url_missing"

    try:
        import ffmpeg  # type: ignore
    except Exception:
        return False, {}, "ffmpeg_module_missing"

    try:
        probe = ffmpeg.probe(url)
    except Exception as e:
        return False, {}, f"ffprobe_failed:{str(e)[:200]}"

    fmt = probe.get("format") or {}
    streams = probe.get("streams") or []

    dur_raw = fmt.get("duration")
    duration = None
    try:
        if dur_raw is not None:
            duration = int(float(dur_raw))
    except Exception:
        duration = None

    has_video = any((s.get("codec_type") == "video") for s in streams)

    if not has_video:
        return False, {"duration": duration, "has_video": False}, "no_video_stream"

    if duration is None:
        return False, {"duration": None, "has_video": True}, "duration_missing"

    if duration < 0:
        return False, {"duration": duration, "has_video": True}, "duration_invalid"

    return True, {"duration": duration, "has_video": True}, ""


def _try_start_video_worker_instance(retry_count=0) -> None:
    """
    upload_complete ì‹œì ì— video-worker EC2 ì¸ìŠ¤í„´ìŠ¤ ìë™ ê¸°ë™ (ë¡œê·¸ ë¶„ì„ ê°•í™”)
    - ìˆ˜ì •ì‚¬í•­: ì¤‘ì§€ ì¤‘(Stopping) ìƒíƒœ ëŒ€ì‘ì„ ìœ„í•´ 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ìµœëŒ€ 120ì´ˆ(12íšŒ) ì¬ì‹œë„ ìˆ˜í–‰
    """
    import threading
    
    instance_id = getattr(settings, "VIDEO_WORKER_INSTANCE_ID", None) or ""
    region = (
        getattr(settings, "AWS_REGION", None)
        or getattr(settings, "AWS_DEFAULT_REGION", None)
        or "ap-northeast-2"
    )

    if not instance_id:
        logger.error("[EC2-START] VIDEO_WORKER_INSTANCE_ID ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.")
        return

    # ì¬ì‹œë„ ì„¤ì •: 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ìµœëŒ€ 12ë²ˆ (ì´ 120ì´ˆ)
    MAX_RETRIES = 12
    RETRY_INTERVAL = 10

    try:
        import boto3  # type: ignore
        ec2 = boto3.client("ec2", region_name=region)
        
        # ê¸°ë™ ì‹œë„ ë° ì‘ë‹µ ë¡œê·¸ ê¸°ë¡
        response = ec2.start_instances(InstanceIds=[str(instance_id)])
        logger.info(f"[EC2-START] ì„±ê³µ: {instance_id} ê¸°ë™ ëª…ë ¹ ì „ì†¡ (ì‹œë„ {retry_count + 1}íšŒ). ì‘ë‹µ: {response.get('StartingInstances')}")
        
    except Exception as e:
        error_str = str(e)
        # ì¸ìŠ¤í„´ìŠ¤ê°€ ì¤‘ì§€ ì¤‘(Stopping)ì´ê±°ë‚˜ ì¼ì‹œì ì¸ ìƒíƒœ ì˜¤ë¥˜ì¸ ê²½ìš°
        if "IncorrectInstanceState" in error_str or "InstanceInterrupted" in error_str:
            if retry_count < MAX_RETRIES:
                logger.warning(f"[EC2-START] ì¸ìŠ¤í„´ìŠ¤ê°€ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ. {RETRY_INTERVAL}ì´ˆ í›„ ì¬ì‹œë„... ({retry_count + 1}/{MAX_RETRIES})")
                threading.Timer(
                    RETRY_INTERVAL, 
                    _try_start_video_worker_instance, 
                    args=[retry_count + 1]
                ).start()
            else:
                logger.error(f"[EC2-START] ìµœëŒ€ ì¬ì‹œë„(120ì´ˆ) ì´ˆê³¼. ê¸°ë™ ì‹¤íŒ¨: {error_str}")
        else:
            # ì‹¤íŒ¨ ì‹œ êµ¬ì²´ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ ë¡œê¹…
            logger.error(f"[EC2-START] ì‹¤íŒ¨: {error_str}", exc_info=True)


def _try_start_video_worker_instance_after_job_creation() -> None:
    """
    job ìƒì„± ì´í›„ EC2 ì¸ìŠ¤í„´ìŠ¤ í™œì„±í™”:
    - ì“°ë ˆë“œ ë”œë ˆì´ ì œê±°: ìš”ì²­ ì‘ë‹µ ì „/í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì „ ì•ˆì •ì ì¸ í˜¸ì¶œ ë³´ì¥
    """
    _try_start_video_worker_instance()


# ==================================================
# ViewSet
# ==================================================
class VideoViewSet(VideoPlaybackMixin, ModelViewSet):
    """
    Video ê´€ë¦¬ + í†µê³„ + í•™ìƒ ëª©ë¡
    """

    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer

    parser_classes = [JSONParser]

    authentication_classes = [
        JWTAuthentication,
        CsrfExemptSessionAuthentication,
    ]
    permission_classes = [IsAuthenticated]

    ADMIN_ONLY_ACTIONS = {
        "upload_init",
        "upload_complete",
        "retry",
        "create",
        "update",
        "partial_update",
        "destroy",
    }

    def get_permissions(self):
        if self.action in self.ADMIN_ONLY_ACTIONS:
            return [IsAuthenticated(), IsAdminOrStaff()]
        return [IsAuthenticated()]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # ==================================================
    # upload/init
    # ==================================================
    @transaction.atomic
    @action(
        detail=False,
        methods=["post"],
        url_path="upload/init",
        parser_classes=[JSONParser],
    )
    def upload_init(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        filename = request.data.get("filename")

        allow_skip = bool(request.data.get("allow_skip", False))
        max_speed = float(request.data.get("max_speed", 1.0) or 1.0)
        show_watermark = bool(request.data.get("show_watermark", True))

        if not session_id or not title or not filename:
            return Response(
                {"detail": "session, title, filename required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session = Session.objects.select_related("lecture", "lecture__tenant").get(id=session_id)
        tenant_code = session.lecture.tenant.code
        order = (
            session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0
        ) + 1

        ext = filename.split(".")[-1].lower() if "." in filename else "mp4"
        key = f"videos/{tenant_code}/{session_id}/{uuid4()}.{ext}"

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=key,
            order=order,
            status=Video.Status.PENDING,
            allow_skip=allow_skip,
            max_speed=max_speed,
            show_watermark=show_watermark,
        )

        content_type = (request.data.get("content_type") or "video/mp4").split(";")[0]
        upload_url = create_presigned_put_url(key=key, content_type=content_type)

        return Response(
            {
                "video": VideoSerializer(video).data,
                "upload_url": upload_url,
                "file_key": key,
                "content_type": content_type,
            },
            status=status.HTTP_201_CREATED,
        )

    # ==================================================
    # upload/complete
    # ==================================================
    @transaction.atomic
    @action(
        detail=True,
        methods=["post"],
        url_path="upload/complete",
        parser_classes=[MultiPartParser, FormParser, JSONParser],
    )
    def upload_complete(self, request, pk=None):
        video = self.get_object()

        if video.status != Video.Status.PENDING:
            return Response(
                {"detail": f"Invalid status: {video.status}"},
                status=status.HTTP_409_CONFLICT,
            )

        exists, size = head_object(video.file_key)
        if not exists or size == 0:
            video.error_reason = "source_not_found_or_empty"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "S3 object not found"},
                status=status.HTTP_409_CONFLICT,
            )

        try:
            src_url = create_presigned_get_url(key=video.file_key, expires_in=600)
        except Exception as e:
            video.error_reason = f"presigned_get_failed:{str(e)[:200]}"
            video.save(update_fields=["error_reason"])
            return Response(
                {"detail": "presigned_get_failed"},
                status=status.HTTP_409_CONFLICT,
            )

        ok, meta, reason = _validate_source_media_via_ffprobe(src_url)

        if not ok and reason == "ffmpeg_module_missing":
            video.status = Video.Status.UPLOADED
            video.error_reason = ""
            video.save(update_fields=["status", "error_reason"])

            transaction.on_commit(_try_start_video_worker_instance_after_job_creation)
            return Response(VideoSerializer(video).data)

        min_dur = _safe_int(getattr(settings, "VIDEO_MIN_DURATION_SECONDS", 3), 3)
        duration = _safe_int(meta.get("duration"), None)

        if duration is not None and duration < int(min_dur):
            video.duration = duration
            video.status = Video.Status.UPLOADED
            video.error_reason = ""
            video.save(update_fields=["status", "duration", "error_reason"])

            transaction.on_commit(_try_start_video_worker_instance_after_job_creation)
            return Response(VideoSerializer(video).data)

        video.duration = duration
        video.status = Video.Status.UPLOADED
        video.error_reason = ""
        video.save(update_fields=["status", "duration", "error_reason"])

        transaction.on_commit(_try_start_video_worker_instance_after_job_creation)
        return Response(VideoSerializer(video).data)

    # ==================================================
    # retry
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response(
                {"detail": "Cannot retry"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        video.status = Video.Status.UPLOADED
        video.save(update_fields=["status"])

        transaction.on_commit(_try_start_video_worker_instance_after_job_creation)
        return Response(
            {"detail": "Video reprocessing queued (HTTP worker polling)"},
            status=status.HTTP_202_ACCEPTED,
        )

    # ==================================================
    # stats
    # ==================================================
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(
            lecture=lecture,
            status="ACTIVE",
        ).select_related("student")

        progresses = {
            p.enrollment_id: p
            for p in VideoProgress.objects.filter(video=video)
        }
        perms = {
            p.enrollment_id: p
            for p in VideoPermission.objects.filter(video=video)
        }
        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            rule = perm.rule if perm else "free"
            effective_rule = rule
            if rule == "once" and vp and vp.completed:
                effective_rule = "free"

            students.append(
                {
                    "enrollment": e.id,
                    "student_name": e.student.name,
                    "attendance_status": attendance.get(e.id),
                    "progress": vp.progress if vp else 0,
                    "completed": vp.completed if vp else False,
                    "rule": rule,
                    "effective_rule": effective_rule,
                    "parent_phone": getattr(e.student, "parent_phone", None),
                    "student_phone": getattr(e.student, "phone", None),
                    "school": getattr(e.student, "school", None),
                    "grade": getattr(e.student, "grade", None),
                }
            )

        return Response(
            {
                "video": VideoDetailSerializer(video).data,
                "students": students,
                "total_filtered": len(students),
            }
        )

    # ==================================================
    # summary
    # ==================================================
    @action(detail=True, methods=["get"], url_path="summary")
    def summary(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        range_key = request.query_params.get("range", "7d")
        now = timezone.now()

        since = None
        if range_key == "24h":
            since = now - timedelta(hours=24)
        elif range_key == "7d":
            since = now - timedelta(days=7)

        enrollments = Enrollment.objects.filter(lecture=lecture)
        total = enrollments.count()

        progresses = VideoProgress.objects.filter(video=video)
        completed_count = progresses.filter(completed=True).count()

        duration = int(video.duration or 0)

        watched_seconds = 0
        for p in progresses.iterator():
            watched_seconds += int(float(p.progress or 0) * duration)

        completion_rate = (completed_count / total) if total else 0.0

        ev_qs = VideoPlaybackEvent.objects.filter(video=video).select_related(
            "enrollment", "enrollment__student"
        )

        if since:
            ev_qs = ev_qs.filter(occurred_at__gte=since)

        weights = {
            "VISIBILITY_HIDDEN": 1,
            "VISIBILITY_VISIBLE": 0,
            "FOCUS_LOST": 2,
            "FOCUS_GAINED": 0,
            "SEEK_ATTEMPT": 3,
            "SPEED_CHANGE_ATTEMPT": 3,
            "FULLSCREEN_ENTER": 0,
            "FULLSCREEN_EXIT": 0,
            "PLAYER_ERROR": 1,
        }

        agg = {}
        for ev in ev_qs.iterator():
            eid = ev.enrollment_id
            if eid not in agg:
                agg[eid] = {
                    "enrollment": eid,
                    "student_name": ev.enrollment.student.name,
                    "score": 0,
                }

            score = int(weights.get(ev.event_type, 1))
            if ev.violated:
                score *= 2
            if ev.violation_reason:
                score += 1

            agg[eid]["score"] += score

        risk_top = sorted(
            agg.values(),
            key=lambda x: x["score"],
            reverse=True,
        )[:5]

        return Response(
            {
                "video_id": video.id,
                "range": range_key,
                "total_students": total,
                "completed_count": completed_count,
                "completion_rate": completion_rate,
                "watched_seconds_est": watched_seconds,
                "risk_top": risk_top,
            }
        )

    # ==================================================
    # student list
    # ==================================================
    @action(
        detail=False,
        methods=["get"],
        url_path="student",
        permission_classes=[IsAuthenticated, IsStudent],
    )
    def student_list(self, request):
        return self._student_list_impl(request)
