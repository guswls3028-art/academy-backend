====================================================================================================
# BACKEND APP: domains__homework_results
# ROOT PATH: C:\academy\apps\domains\homework_results
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================
# apps/domains/homework_results/__init__.py
# homework_results domain package
#
# DESIGN:
# - Runtime 결과(스냅샷) 전용 도메인
# - Homework 정의/정책(homework 도메인)과 분리하여
#   results(exam 결과)와 같은 레이어링을 만든다.


==========================================================================================
# FILE: apps.py
==========================================================================================
# apps/domains/homework_results/apps.py
from django.apps import AppConfig


class HomeworkResultsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.homework_results"
    label = "homework_results"


==========================================================================================
# FILE: score_status.py
==========================================================================================
# PATH: apps/domains/homework_results/utils/score_status.py

from __future__ import annotations

from typing import Any, Literal, Optional, Tuple

from apps.domains.homework_results.models.score import HomeworkScore

HomeworkScoreState = Literal["UNSET", "NOT_SUBMITTED", "ZERO", "SCORED"]


def _meta_status(meta: Any) -> Optional[str]:
    if not isinstance(meta, dict):
        return None
    v = meta.get("status")
    if v is None:
        return None
    s = str(v).strip()
    return s or None


def classify_homework_score_state(
    *,
    score: Optional[float],
    meta: Any,
) -> Tuple[HomeworkScoreState, Optional[str]]:
    """
    ✅ 상태 판별 단일 함수 (if-else 고정 / 서버 내부 SSOT)

    - UNSET        : score=None & meta.status=None
    - NOT_SUBMITTED: meta.status == "NOT_SUBMITTED"
    - ZERO         : score == 0
    - SCORED       : score > 0 (또는 일반적인 점수 입력 완료)

    반환:
      (state, meta_status)
    """
    st = _meta_status(meta)

    if st == HomeworkScore.MetaStatus.NOT_SUBMITTED:
        return "NOT_SUBMITTED", st

    if score is None and st is None:
        return "UNSET", st

    # NOTE: score가 0.0이면 "가져왔으나 안 함(0점)"으로 취급
    if score is not None and float(score) == 0.0:
        return "ZERO", st

    return "SCORED", st


==========================================================================================
# FILE: urls.py
==========================================================================================
# PATH: apps/domains/homework_results/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from apps.domains.homework_results.views.homework_view import HomeworkViewSet

router = DefaultRouter()
router.register("", HomeworkViewSet, basename="homeworks")  # ✅ 핵심

urlpatterns = [
    path("", include(router.urls)),
]


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-15 06:03

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("lectures", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Homework",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("DRAFT", "초안"),
                            ("OPEN", "진행중"),
                            ("CLOSED", "마감"),
                        ],
                        db_index=True,
                        default="DRAFT",
                        max_length=20,
                    ),
                ),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="homeworks",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["-updated_at", "-id"],
            },
        ),
        migrations.CreateModel(
            name="HomeworkScore",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("enrollment_id", models.PositiveIntegerField(db_index=True)),
                ("score", models.FloatField(blank=True, null=True)),
                ("max_score", models.FloatField(blank=True, null=True)),
                ("teacher_approved", models.BooleanField(default=False)),
                ("passed", models.BooleanField(default=False)),
                ("clinic_required", models.BooleanField(default=False)),
                ("is_locked", models.BooleanField(default=False)),
                (
                    "lock_reason",
                    models.CharField(
                        blank=True,
                        choices=[
                            ("GRADING", "채점중"),
                            ("PUBLISHED", "게시됨"),
                            ("MANUAL", "수동잠금"),
                            ("OTHER", "기타"),
                        ],
                        max_length=30,
                        null=True,
                    ),
                ),
                (
                    "updated_by_user_id",
                    models.PositiveIntegerField(blank=True, null=True),
                ),
                ("meta", models.JSONField(blank=True, null=True)),
                (
                    "homework",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="scores",
                        to="homework_results.homework",
                    ),
                ),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="homework_scores",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "db_table": "homework_results_homeworkscore",
                "ordering": ["-updated_at", "-id"],
            },
        ),
        migrations.AddIndex(
            model_name="homework",
            index=models.Index(
                fields=["session", "updated_at"], name="homework_re_session_2c33a5_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="homework",
            index=models.Index(
                fields=["session", "status"], name="homework_re_session_c13723_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="homeworkscore",
            index=models.Index(
                fields=["enrollment_id", "updated_at"], name="hwres_enroll_upd_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="homeworkscore",
            index=models.Index(
                fields=["session", "updated_at"], name="hwres_session_upd_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="homeworkscore",
            index=models.Index(
                fields=["homework", "updated_at"], name="hwres_homework_upd_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="homeworkscore",
            constraint=models.UniqueConstraint(
                fields=("enrollment_id", "session", "homework"),
                name="uniq_hwscore_enrollment_session_homework",
            ),
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================
# apps/domains/homework_results/migrations/__init__.py


==========================================================================================
# FILE: models/__init__.py
==========================================================================================
# PATH: apps/domains/homework_results/models/__init__.py

from .homework import Homework
from .score import HomeworkScore

__all__ = ["Homework", "HomeworkScore"]


==========================================================================================
# FILE: models/homework.py
==========================================================================================
# PATH: apps/domains/homework_results/models/homework.py
"""
Homework Entity (Runtime / Operational)

✅ 목적
- "과제 목록/상세"를 제공하기 위한 실체 엔티티
- 프론트 좌측 패널(시험/과제 리스트)에서 사용
- HomeworkPolicy(세션 1:1 정책)과는 별개로,
  실제 "과제"는 세션 내 여러 개가 존재할 수 있다.

✅ 추가 (2026-01)
- SessionScores 메타에서 사용할
  "대표 과제 제목" 조회 헬퍼 제공
"""

from __future__ import annotations

from django.db import models

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session


class Homework(TimestampModel):
    """
    Session 단위 과제 엔티티
    """

    class Status(models.TextChoices):
        DRAFT = "DRAFT", "초안"
        OPEN = "OPEN", "진행중"
        CLOSED = "CLOSED", "마감"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="homeworks",
        db_index=True,
    )

    title = models.CharField(max_length=255)

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.DRAFT,
        db_index=True,
    )

    meta = models.JSONField(null=True, blank=True)

    class Meta:
        ordering = ["-updated_at", "-id"]
        indexes = [
            models.Index(fields=["session", "updated_at"]),
            models.Index(fields=["session", "status"]),
        ]

    def __str__(self) -> str:
        return f"Homework(id={self.id}, session={self.session_id}, title={self.title})"

    # =========================================================
    # ✅ 추가: SessionScores 메타용 대표 과제 제목 헬퍼
    # =========================================================
    @classmethod
    def get_representative_title_for_session(
        cls,
        *,
        session: Session,
        fallback: str = "과제",
    ) -> str:
        """
        SessionScores meta.homework.title 용

        규칙:
        1) 해당 세션의 Homework 중
           - 최신(updated_at desc)
           - CLOSED → OPEN → DRAFT 우선
        2) 없으면 fallback 반환

        ❗ 책임:
        - "어떤 과제를 대표로 보여줄지" 결정만 한다
        - 점수/정책/판정 ❌
        """

        qs = (
            cls.objects
            .filter(session=session)
            .order_by(
                models.Case(
                    models.When(status=cls.Status.CLOSED, then=0),
                    models.When(status=cls.Status.OPEN, then=1),
                    models.When(status=cls.Status.DRAFT, then=2),
                    default=3,
                    output_field=models.IntegerField(),
                ),
                "-updated_at",
                "-id",
            )
        )

        hw = qs.first()
        if hw and hw.title:
            return str(hw.title)

        return fallback


==========================================================================================
# FILE: models/score.py
==========================================================================================
# PATH: apps/domains/homework_results/models/score.py

from __future__ import annotations

from django.db import models

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.homework_results.models.homework import Homework


class HomeworkScore(TimestampModel):
    """
    Enrollment x Session x Homework 단위 숙제 점수/승인 스냅샷

    ✅ 상태(운영 기준) — DB 표현 (고정)
    - 미입력     : score=None & meta.status=None
    - 미제출     : meta.status="NOT_SUBMITTED"   (0점과 다름 / 클리닉 대상)
    - 0점        : score=0
    - 정상 점수  : score>=0

    ❗RULE 3: meta(JSONField)는 확장 정보만 담는다.
    단, 본 모델은 "미제출" 상태를 meta.status로만 표현한다(마이그레이션 없이 확장).
    """

    class LockReason(models.TextChoices):
        GRADING = "GRADING", "채점중"
        PUBLISHED = "PUBLISHED", "게시됨"
        MANUAL = "MANUAL", "수동잠금"
        OTHER = "OTHER", "기타"

    class MetaStatus:
        """
        ✅ meta.status enum (고정)
        - NOT_SUBMITTED: 숙제 미제출(클리닉 대상)
        """
        NOT_SUBMITTED = "NOT_SUBMITTED"

    enrollment_id = models.PositiveIntegerField(db_index=True)

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="homework_scores",
    )

    homework = models.ForeignKey(
        Homework,
        on_delete=models.CASCADE,
        related_name="scores",
        db_index=True,
    )

    # percent 또는 raw/max 형태 모두 지원
    score = models.FloatField(null=True, blank=True)
    max_score = models.FloatField(null=True, blank=True)

    teacher_approved = models.BooleanField(default=False)

    passed = models.BooleanField(default=False)
    clinic_required = models.BooleanField(default=False)

    is_locked = models.BooleanField(default=False)
    lock_reason = models.CharField(
        max_length=30,
        choices=LockReason.choices,
        null=True,
        blank=True,
    )

    updated_by_user_id = models.PositiveIntegerField(null=True, blank=True)

    # ✅ 확장 필드(마이그레이션 없이): meta.status 만 사용
    meta = models.JSONField(null=True, blank=True)

    class Meta:
        db_table = "homework_results_homeworkscore"

        constraints = [
            models.UniqueConstraint(
                fields=["enrollment_id", "session", "homework"],
                name="uniq_hwscore_enrollment_session_homework",
            )
        ]

        # ✅ 운영 성능 필수 인덱스 (삭제 금지: RULE 2)
        indexes = [
            models.Index(
                fields=["enrollment_id", "updated_at"],
                name="hwres_enroll_upd_idx",
            ),
            models.Index(
                fields=["session", "updated_at"],
                name="hwres_session_upd_idx",
            ),
            models.Index(
                fields=["homework", "updated_at"],
                name="hwres_homework_upd_idx",
            ),
        ]

        ordering = ["-updated_at", "-id"]

    def __str__(self) -> str:
        return (
            f"HomeworkScore("
            f"enroll={self.enrollment_id}, "
            f"session={self.session_id}, "
            f"homework={self.homework_id}, "
            f"score={self.score})"
        )


==========================================================================================
# FILE: serializers/__init__.py
==========================================================================================
# PATH: apps/domains/homework/serializers/__init__.py

from .homework_score import HomeworkQuickPatchSerializer, HomeworkScoreSerializer

__all__ = [
    "HomeworkScoreSerializer",
    "HomeworkQuickPatchSerializer",
]


==========================================================================================
# FILE: serializers/homework.py
==========================================================================================
# PATH: apps/domains/homework_results/serializers/homework.py

from rest_framework import serializers

from apps.domains.homework_results.models import Homework



class HomeworkSerializer(serializers.ModelSerializer):
    class Meta:
        model = Homework
        fields = [
            "id",
            "session",
            "title",
            "status",
            "meta",
            "updated_at",
            "created_at",
        ]
        read_only_fields = [
            "id",
            "updated_at",
            "created_at",
        ]


==========================================================================================
# FILE: serializers/homework_score.py
==========================================================================================
# PATH: apps/domains/homework/serializers/homework_score.py

from __future__ import annotations

from typing import Any, Optional

from rest_framework import serializers

from apps.domains.homework_results.models import HomeworkScore


class _StatusField(serializers.CharField):
    """
    ✅ status 입력 계약 (기존 API 유지 + 분기 추가)
    - 미제출 저장: "NOT_SUBMITTED"
    - 해제: null 또는 "" (요청에 status 키가 '존재'할 때만 반영)
    """

    def to_internal_value(self, data):
        if data is None:
            return None
        s = str(data).strip()
        return s or None


class HomeworkScoreSerializer(serializers.ModelSerializer):
    """
    ✅ 응답 계약:
    - 프론트는 (score, meta.status)로 상태 구분 가능해야 한다.
    - 기존 meta 응답은 유지되며, status는 meta.status로만 표현한다(필드 추가 X).
    """

    # write-only convenience field (DB 컬럼 추가 아님)
    status = _StatusField(required=False, allow_null=True, allow_blank=True, write_only=True)

    class Meta:
        model = HomeworkScore
        fields = [
            "id",
            "enrollment_id",
            "session",
            "homework",
            "score",
            "max_score",
            "teacher_approved",
            "passed",
            "clinic_required",
            "is_locked",
            "lock_reason",
            "updated_by_user_id",
            "meta",
            "created_at",
            "updated_at",
            # input-only
            "status",
        ]

    def validate_status(self, value: Optional[str]) -> Optional[str]:
        if value is None:
            return None
        if value == HomeworkScore.MetaStatus.NOT_SUBMITTED:
            return value
        raise serializers.ValidationError(
            "status must be NOT_SUBMITTED or null/empty",
            code="INVALID",
        )


class HomeworkQuickPatchSerializer(serializers.Serializer):
    """
    Quick Patch (MVP)
    - homework_id + enrollment_id 기반 upsert
    - score 입력 방식 2가지:
      - percent 직접 입력(score=85, max_score=None)
      - raw/max 입력(score=18, max_score=20)

    ✅ 확장:
    - status="NOT_SUBMITTED" 저장/해제 지원 (meta.status)
      - 저장 시: score/max_score는 강제로 None 처리(미제출 ≠ 0점)
      - 해제 시: status 키가 존재하고 null/""이면 meta.status 제거
    """

    homework_id = serializers.IntegerField()
    enrollment_id = serializers.IntegerField()

    # score는 "미제출" 입력에서 생략 가능하도록 allow_null
    score = serializers.FloatField(required=False, allow_null=True)
    max_score = serializers.FloatField(required=False, allow_null=True)

    # convenience input
    status = _StatusField(required=False, allow_null=True, allow_blank=True)

    def validate(self, attrs: dict) -> dict:
        status = attrs.get("status", serializers.empty)

        # status 키가 있으면 (저장/해제)로 처리 가능
        if status is not serializers.empty:
            if status is None:
                # 해제: score 없이도 허용 (기존 점수 유지)
                return attrs
            if status == HomeworkScore.MetaStatus.NOT_SUBMITTED:
                # 저장: score/max_score는 의미 없으므로 무시 가능
                return attrs
            raise serializers.ValidationError(
                {"status": "status must be NOT_SUBMITTED or null/empty"},
                code="INVALID",
            )

        # status 키가 없으면 기존 규칙: score는 있어야 함
        if "score" not in attrs:
            raise serializers.ValidationError(
                {"score": "score is required when status is not provided"},
                code="INVALID",
            )

        return attrs


==========================================================================================
# FILE: views/__init__.py
==========================================================================================
# PATH: apps/domains/homework_results/views/__init__.py

from .homework_view import HomeworkViewSet

__all__ = ["HomeworkViewSet"]


==========================================================================================
# FILE: views/homework_score_viewset.py
==========================================================================================
# PATH: apps/domains/homework/views/homework_score_viewset.py

"""
HomeworkScore API (Admin / Teacher)

Endpoint:
- GET    /homework/scores/?enrollment_id=&session=&lecture=&is_locked=
- PATCH  /homework/scores/{id}/
- PATCH  /homework/scores/quick/

상태(운영 기준) — DB 표현 (고정)
- 미입력     : score=None & meta.status=None
- 미제출     : meta.status="NOT_SUBMITTED"   (0점과 다름 / 클리닉 대상)
- 0점        : score=0
- 정상 점수  : score>=0

IMPORTANT (리팩토링 금지)
- HomeworkScore 스냅샷의 단일 진실은 homework_results 도메인
- /homework/scores/* 라우팅은 프론트 편의를 위한 얇은 API
"""

from __future__ import annotations

from django.db import transaction
from django.db.models import QuerySet
from django.utils import timezone

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status as drf_status
from rest_framework.decorators import action

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter

from apps.domains.homework_results.models import HomeworkScore
from apps.domains.homework_results.models import Homework

from apps.domains.homework.serializers import (
    HomeworkScoreSerializer,
    HomeworkQuickPatchSerializer,
)
from apps.domains.homework.filters import HomeworkScoreFilter

from apps.domains.results.permissions import IsTeacherOrAdmin

from apps.domains.submissions.models import Submission

from apps.domains.progress.dispatcher import dispatch_progress_pipeline

from apps.domains.homework.utils.homework_policy import (
    calc_homework_passed_and_clinic,
)

from apps.domains.progress.models import ClinicLink

# 상태 판별 유틸(서버 내부 SSOT)
from apps.domains.homework_results.utils.score_status import classify_homework_score_state


# =====================================================
# helpers
# =====================================================
def _safe_user_id(request) -> int | None:
    return getattr(getattr(request, "user", None), "id", None)


def _locked_response(obj: HomeworkScore) -> Response:
    return Response(
        {
            "detail": "score block is locked",
            "code": "LOCKED",
            "lock_reason": getattr(obj, "lock_reason", None),
        },
        status=drf_status.HTTP_409_CONFLICT,
    )


def _normalize_status_from_request(request) -> tuple[bool, str | None]:
    """
    ✅ status 입력 처리 규칙 (기존 API 유지, 분기만 추가)

    반환:
      (status_key_present, normalized_value)

    - status 키가 없으면: (False, None)  -> 아무 변화 없음
    - status 키가 있고 null/""이면: (True, None) -> 해제
    - status 키가 있고 "NOT_SUBMITTED"이면: (True, "NOT_SUBMITTED") -> 저장
    """
    if "status" not in request.data:
        return False, None

    raw = request.data.get("status")
    if raw is None:
        return True, None

    s = str(raw).strip()
    if not s:
        return True, None

    if s == HomeworkScore.MetaStatus.NOT_SUBMITTED:
        return True, s

    # 다른 값은 허용하지 않음
    return True, "__INVALID__"


def _set_meta_status(obj: HomeworkScore, status_value: str | None) -> HomeworkScore:
    meta = obj.meta if isinstance(obj.meta, dict) else {}
    meta = {**meta}

    if status_value is None:
        # 해제
        meta.pop("status", None)
    else:
        meta["status"] = str(status_value)

    obj.meta = meta or None
    return obj


def _sync_clinic_link_for_not_submitted(
    *,
    enrollment_id: int,
    session_id: int,
    now_not_submitted: bool,
) -> None:
    """
    ✅ 클리닉 트리거 연결 (progress 파이프라인 수정 금지)

    규칙:
    - meta.status="NOT_SUBMITTED"  => 클리닉 대상 (ClinicLink 생성/유지)
    - 해제(None)                   => 본 API가 만든 "미제출" 클리닉 링크만 resolved_at 처리

    ❗Reason 확장은 migration 필요하므로 기존 AUTO_FAILED를 사용하고 meta로 kind를 구분한다.
    """
    if now_not_submitted:
        obj, created = ClinicLink.objects.get_or_create(
            enrollment_id=int(enrollment_id),
            session_id=int(session_id),
            reason=ClinicLink.Reason.AUTO_FAILED,
            defaults={
                "is_auto": True,
                "approved": False,
                "resolved_at": None,
                "meta": {
                    "kind": "HOMEWORK_NOT_SUBMITTED",
                },
            },
        )
        if not created:
            meta = obj.meta if isinstance(obj.meta, dict) else {}
            meta = {**meta}
            meta["kind"] = "HOMEWORK_NOT_SUBMITTED"
            obj.meta = meta
            obj.is_auto = True
            if getattr(obj, "resolved_at", None) is not None:
                obj.resolved_at = None
            obj.save(update_fields=["meta", "is_auto", "resolved_at", "updated_at"])
        return

    # 해제: 본 API가 만든 HOMEWORK_NOT_SUBMITTED 링크만 resolved 처리
    qs = ClinicLink.objects.filter(
        enrollment_id=int(enrollment_id),
        session_id=int(session_id),
        is_auto=True,
        resolved_at__isnull=True,
    ).exclude(meta__isnull=True)

    # meta.kind 필터는 DB마다 JSON 쿼리 지원이 달라질 수 있으므로 방어적으로 파이썬 필터링
    for link in qs.order_by("-id")[:20]:
        meta = getattr(link, "meta", None)
        if isinstance(meta, dict) and meta.get("kind") == "HOMEWORK_NOT_SUBMITTED":
            link.resolved_at = timezone.now()
            link.save(update_fields=["resolved_at", "updated_at"])


def _apply_score_and_policy(
    *,
    obj: HomeworkScore,
    score: float | None,
    max_score: float | None,
    request,
    save_fields: list[str],
) -> HomeworkScore:
    """
    HomeworkScore 점수 반영 + HomeworkPolicy 계산
    (동작 변경 없음 / 중복 제거만)

    ⚠️ meta.status="NOT_SUBMITTED" 인 경우:
    - 점수는 None으로 유지 (미제출 ≠ 0점)
    """
    obj.score = score
    obj.max_score = max_score

    passed, clinic_required, _ = calc_homework_passed_and_clinic(
        session=obj.session,
        score=score,
        max_score=max_score,
    )

    obj.passed = bool(passed)
    obj.clinic_required = bool(clinic_required)
    obj.updated_by_user_id = _safe_user_id(request)

    obj.save(update_fields=save_fields + ["updated_at"])
    return obj


def _maybe_fix_submission(
    submission: Submission,
    *,
    score_obj: HomeworkScore,
    teacher_approved: bool | None,
) -> None:
    """
    Submission 구조는 프로젝트마다 다를 수 있으므로
    "필드가 존재할 때만" 방어적으로 보정한다.
    """
    if hasattr(submission, "homework_submitted"):
        submission.homework_submitted = True

    if hasattr(submission, "homework_teacher_approved") and teacher_approved is not None:
        submission.homework_teacher_approved = bool(teacher_approved)

    if hasattr(submission, "meta"):
        meta = submission.meta if isinstance(submission.meta, dict) else {}
        meta = {**meta}

        homework_meta = meta.get("homework")
        if not isinstance(homework_meta, dict):
            homework_meta = {}

        # meta.status까지 포함해서 프론트 디버깅/추적 가능
        hs_meta = score_obj.meta if isinstance(score_obj.meta, dict) else {}

        homework_meta.update(
            {
                "homework_score_id": score_obj.id,
                "homework_id": score_obj.homework_id,
                "score": score_obj.score,
                "max_score": score_obj.max_score,
                "passed": score_obj.passed,
                "clinic_required": score_obj.clinic_required,
                "teacher_approved": getattr(submission, "homework_teacher_approved", None),
                "status": hs_meta.get("status"),
            }
        )

        meta["homework"] = homework_meta
        submission.meta = meta

    update_fields = ["updated_at"]
    for f in ["homework_submitted", "homework_teacher_approved", "meta"]:
        if hasattr(submission, f):
            update_fields.append(f)

    submission.save(update_fields=list(dict.fromkeys(update_fields)))


# =====================================================
# ViewSet
# =====================================================
class HomeworkScoreViewSet(ModelViewSet):
    """
    HomeworkScore 관리 ViewSet
    """

    queryset: QuerySet[HomeworkScore] = HomeworkScore.objects.select_related(
        "session",
        "session__lecture",
        "homework",
    ).all()

    serializer_class = HomeworkScoreSerializer
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]

    filter_backends = [
        DjangoFilterBackend,
        SearchFilter,
        OrderingFilter,
    ]
    filterset_class = HomeworkScoreFilter

    search_fields = [
        "enrollment_id",
        "session__title",
        "session__lecture__title",
        "homework__title",
    ]

    ordering_fields = [
        "id",
        "created_at",
        "updated_at",
        "is_locked",
        "score",
        "passed",
    ]
    ordering = ["-updated_at", "-id"]

    # =================================================
    # PATCH /homework/scores/{id}/
    # =================================================
    def partial_update(self, request, *args, **kwargs):
        obj: HomeworkScore = self.get_object()

        if getattr(obj, "is_locked", False):
            return _locked_response(obj)

        status_key_present, normalized_status = _normalize_status_from_request(request)
        if status_key_present and normalized_status == "__INVALID__":
            return Response(
                {"detail": "invalid status", "code": "INVALID", "allowed": [HomeworkScore.MetaStatus.NOT_SUBMITTED, None]},
                status=drf_status.HTTP_400_BAD_REQUEST,
            )

        serializer = self.get_serializer(obj, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)

        vd = serializer.validated_data
        next_score = vd.get("score", obj.score)
        next_max = vd.get("max_score", obj.max_score)
        teacher_approved = vd.get("teacher_approved")

        progress_info = {"dispatched": False, "reason": None}

        with transaction.atomic():
            serializer.save(
                passed=obj.passed,
                clinic_required=obj.clinic_required,
                updated_by_user_id=_safe_user_id(request),
            )

            score_obj: HomeworkScore = serializer.instance

            # ✅ status 분기 (기존 API 유지)
            if status_key_present:
                score_obj = _set_meta_status(score_obj, normalized_status)

                # 미제출 저장 시: 점수는 None으로 강제(미제출 ≠ 0점)
                if normalized_status == HomeworkScore.MetaStatus.NOT_SUBMITTED:
                    next_score = None
                    next_max = None

                score_obj.save(update_fields=["meta", "updated_at"])

                # 클리닉 트리거 연결 (progress 수정 금지)
                _sync_clinic_link_for_not_submitted(
                    enrollment_id=int(score_obj.enrollment_id),
                    session_id=int(score_obj.session_id),
                    now_not_submitted=(normalized_status == HomeworkScore.MetaStatus.NOT_SUBMITTED),
                )

            # 점수/정책 계산 (기존 로직 유지)
            score_obj = _apply_score_and_policy(
                obj=score_obj,
                score=next_score,
                max_score=next_max,
                request=request,
                save_fields=[
                    "score",
                    "max_score",
                    "passed",
                    "clinic_required",
                    "updated_by_user_id",
                    "meta",
                ],
            )

            submission = (
                Submission.objects.filter(
                    enrollment_id=score_obj.enrollment_id,
                    session_id=score_obj.session_id,
                )
                .order_by("-id")
                .first()
            )

            if submission:
                _maybe_fix_submission(
                    submission,
                    score_obj=score_obj,
                    teacher_approved=teacher_approved,
                )

                sub_id = int(submission.id)

                def _dispatch():
                    # ✅ progress 파이프라인 "호출만 유지" (수정 금지)
                    dispatch_progress_pipeline(submission_id=sub_id)

                transaction.on_commit(_dispatch)
                progress_info = {"dispatched": True, "reason": None}
            else:
                progress_info = {"dispatched": False, "reason": "NO_SUBMISSION"}

        data = self.get_serializer(score_obj).data

        # ✅ 프론트 편의: 상태를 명확히 구분 가능한 server-side 판별 값(응답 계약 파괴 X: meta는 그대로)
        state, _ = classify_homework_score_state(score=score_obj.score, meta=score_obj.meta)
        data["state"] = state  # optional; 기존 필드 파괴 없음
        data["progress"] = progress_info

        return Response(data, status=drf_status.HTTP_200_OK)

    # =================================================
    # PATCH /homework/scores/quick/
    # =================================================
    @action(detail=False, methods=["patch"], url_path="quick")
    def quick_patch(self, request):
        """
        Quick input (MVP)

        - % 입력: score=85, max_score 생략(percent 직접 입력)
        - raw/max: score=32, max_score=64

        ✅ 확장:
        - status="NOT_SUBMITTED" 저장/해제
        """
        serializer = HomeworkQuickPatchSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        homework_id = serializer.validated_data["homework_id"]
        enrollment_id = serializer.validated_data["enrollment_id"]

        status_key_present, normalized_status = _normalize_status_from_request(request)
        if status_key_present and normalized_status == "__INVALID__":
            return Response(
                {"detail": "invalid status", "code": "INVALID", "allowed": [HomeworkScore.MetaStatus.NOT_SUBMITTED, None]},
                status=drf_status.HTTP_400_BAD_REQUEST,
            )

        score = serializer.validated_data.get("score", None)
        max_score = serializer.validated_data.get("max_score", None)

        homework = Homework.objects.select_related("session").get(id=homework_id)
        session = homework.session

        with transaction.atomic():
            obj = (
                HomeworkScore.objects.select_for_update()
                .filter(
                    homework_id=homework_id,
                    enrollment_id=enrollment_id,
                )
                .select_related("session", "homework")
                .first()
            )

            if obj and obj.is_locked:
                return _locked_response(obj)

            if not obj:
                obj = HomeworkScore.objects.create(
                    homework=homework,
                    session=session,
                    enrollment_id=enrollment_id,
                    score=None,
                    max_score=None,
                    updated_by_user_id=_safe_user_id(request),
                )

            # ✅ status 분기 (기존 API 유지)
            if status_key_present:
                obj = _set_meta_status(obj, normalized_status)
                obj.save(update_fields=["meta", "updated_at"])

                # 미제출 저장 시: 점수 강제 None
                if normalized_status == HomeworkScore.MetaStatus.NOT_SUBMITTED:
                    score = None
                    max_score = None

                # 클리닉 트리거 연결
                _sync_clinic_link_for_not_submitted(
                    enrollment_id=int(obj.enrollment_id),
                    session_id=int(obj.session_id),
                    now_not_submitted=(normalized_status == HomeworkScore.MetaStatus.NOT_SUBMITTED),
                )

            obj = _apply_score_and_policy(
                obj=obj,
                score=score,
                max_score=max_score,
                request=request,
                save_fields=[
                    "score",
                    "max_score",
                    "passed",
                    "clinic_required",
                    "updated_by_user_id",
                    "meta",
                ],
            )

        data = HomeworkScoreSerializer(obj).data
        state, _ = classify_homework_score_state(score=obj.score, meta=obj.meta)
        data["state"] = state  # optional
        return Response(data, status=drf_status.HTTP_200_OK)


==========================================================================================
# FILE: views/homework_view.py
==========================================================================================
# PATH: apps/domains/homework_results/views/homework_view.py
"""
Homework API (List/Retrieve/Create)

✅ 프론트 요구사항 (즉시 해결 포인트)
- GET /homeworks/?session_id={sessionId}
- GET /homeworks/{id}/

(선택)
- POST /homeworks/   ← "과제 추가" 모달이 실제 생성하려면 필요
"""

from __future__ import annotations

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.filters import OrderingFilter

from django.db.models import QuerySet

from apps.domains.results.permissions import IsTeacherOrAdmin

from apps.domains.homework_results.models import Homework
from apps.domains.homework_results.serializers.homework import HomeworkSerializer

class HomeworkViewSet(ModelViewSet):
    permission_classes = [IsAuthenticated, IsTeacherOrAdmin]
    serializer_class = HomeworkSerializer

    filter_backends = [OrderingFilter]
    ordering_fields = ["id", "created_at", "updated_at", "status"]
    ordering = ["-updated_at", "-id"]

    def get_queryset(self) -> QuerySet[Homework]:
        qs = Homework.objects.select_related("session", "session__lecture")

        # ✅ 프론트가 session_id로 필터링
        session_id = self.request.query_params.get("session_id")
        if session_id:
            try:
                sid = int(session_id)
                qs = qs.filter(session_id=sid)
            except Exception:
                qs = qs.none()

        return qs
