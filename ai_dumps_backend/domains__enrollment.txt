====================================================================================================
# BACKEND APP: domains__enrollment
# ROOT PATH: C:\academy\apps\domains\enrollment
====================================================================================================


==========================================================================================
# FILE: __init__.py
==========================================================================================



==========================================================================================
# FILE: admin.py
==========================================================================================
from django.contrib import admin
from .models import Enrollment, SessionEnrollment


@admin.register(Enrollment)
class EnrollmentAdmin(admin.ModelAdmin):
    list_display = ("id", "student", "lecture", "status", "enrolled_at")
    list_display_links = ("id", "student")
    list_filter = ("status", "lecture")
    search_fields = ("student__name", "lecture__title")
    ordering = ("-id",)


@admin.register(SessionEnrollment)
class SessionEnrollmentAdmin(admin.ModelAdmin):
    list_display = ("id", "session", "enrollment", "created_at")
    list_display_links = ("id", "session")
    list_filter = ("session__lecture", "session")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


==========================================================================================
# FILE: apps.py
==========================================================================================
from django.apps import AppConfig


class EnrollmentConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.domains.enrollment"


==========================================================================================
# FILE: filters.py
==========================================================================================
# apps/domains/enrollment/filters.py

import django_filters

from .models import Enrollment


class EnrollmentFilter(django_filters.FilterSet):
    """
    Enrollment list filtering.
    Front uses: /lectures/enrollments/?lecture={lectureId}
    """

    class Meta:
        model = Enrollment
        fields = {
            "lecture": ["exact"],
            "student": ["exact"],
            "status": ["exact"],
        }


==========================================================================================
# FILE: models.py
==========================================================================================
# PATH: apps/domains/enrollment/models.py

from django.db import models

from apps.api.common.models import TimestampModel
from apps.domains.students.models import Student
from apps.domains.lectures.models import Lecture, Session
from apps.core.models import Tenant


# ========================================================
# Enrollment (강의 단위 수강 등록)
# ========================================================

class Enrollment(TimestampModel):
    """
    학생이 특정 강의를 수강하는 행위.
    강의 정의(Lecture)와 분리된 '수강 행위' 도메인이다.

    ✅ 운영 기준:
    - Enrollment는 반드시 tenant 단위로 격리됨
    """

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="enrollments",
        null=False,  # ✅ NOT NULL로 변경 (프로덕션 준비)
        blank=False,
        db_index=True,  # ✅ tenant_id 인덱스 추가
    )

    student = models.ForeignKey(
        Student,
        on_delete=models.CASCADE,
        related_name="enrollments",
    )
    lecture = models.ForeignKey(
        Lecture,
        on_delete=models.CASCADE,
        related_name="enrollments",
    )

    status = models.CharField(
        max_length=20,
        choices=[
            ("ACTIVE", "활성"),
            ("INACTIVE", "비활성"),
            ("PENDING", "대기"),
        ],
        default="ACTIVE",
    )

    enrolled_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["tenant", "created_at"]),  # ✅ 복합 인덱스 추가
        ]
        constraints = [
            models.UniqueConstraint(
                fields=["tenant", "student", "lecture"],
                name="unique_enrollment_per_tenant_lecture",
            )
        ]

    def __str__(self):
        return f"{self.student.name} -> {self.lecture.title}"


# ========================================================
# SessionEnrollment (차시 단위 수강 권한)
# ========================================================

class SessionEnrollment(models.Model):
    """
    특정 Enrollment가 어떤 Session(차시)에 접근 가능한지 정의.
    출결/영상/자료 접근의 기준이 되는 중간 테이블.
    """

    tenant = models.ForeignKey(
        Tenant,
        on_delete=models.CASCADE,
        related_name="session_enrollments",
        null=False,  # ✅ NOT NULL로 변경 (프로덕션 준비)
        blank=False,
        db_index=True,  # ✅ tenant_id 인덱스 추가
    )

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="session_enrollments",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="session_enrollments",
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("tenant", "session", "enrollment")

    def __str__(self):
        return f"{self.session} - {self.enrollment.student.name}"


==========================================================================================
# FILE: permissions.py
==========================================================================================
# PATH: apps/domains/enrollment/permissions.py

from rest_framework.permissions import BasePermission
from apps.domains.enrollment.models import Enrollment


class HasEnrollmentAccess(BasePermission):
    """
    학생이 해당 Enrollment(수강 정보)에 접근 가능한지 검증
    (tenant 기준 강제)
    """
    message = "You do not have access to this enrollment."

    def has_permission(self, request, view):
        user = request.user

        if not user or not user.is_authenticated:
            return False

        student = getattr(user, "student_profile", None)
        if not student:
            return False

        enrollment_id = (
            request.data.get("enrollment_id")
            or request.query_params.get("enrollment_id")
        )
        if not enrollment_id:
            return False

        tenant = getattr(request, "tenant", None)

        return Enrollment.objects.filter(
            id=enrollment_id,
            student=student,
            tenant=tenant,          # ✅ tenant 안전장치
            status="ACTIVE",
        ).exists()


==========================================================================================
# FILE: serializers.py
==========================================================================================
from rest_framework import serializers

from .models import Enrollment, SessionEnrollment
from apps.domains.students.models import Student


class StudentShortSerializer(serializers.ModelSerializer):
    class Meta:
        model = Student
        fields = [
            "id",
            "name",
            "grade",
            "high_school",
            "high_school_class",
            "major",
            "phone",
            "parent_phone",
        ]


class EnrollmentSerializer(serializers.ModelSerializer):
    student = StudentShortSerializer(read_only=True)

    class Meta:
        model = Enrollment
        fields = "__all__"


class SessionEnrollmentSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name", read_only=True
    )
    student_id = serializers.IntegerField(
        source="enrollment.student_id", read_only=True
    )

    class Meta:
        model = SessionEnrollment
        fields = "__all__"


==========================================================================================
# FILE: services.py
==========================================================================================
# PATH: apps/domains/enrollment/services.py
# 강의 엑셀 원테이크 로직 — API 뷰와 워커에서 공통 사용 (헥사고날: 애플리케이션 서비스 계층)

from __future__ import annotations

import logging

from django.db import transaction

from academy.adapters.db.django import repositories_enrollment as enroll_repo
from apps.domains.lectures.models import Session, Lecture
from apps.domains.students.services import get_or_create_student_for_lecture_enroll

from .models import Enrollment, SessionEnrollment

logger = logging.getLogger(__name__)


def _mask_phone(phone: str) -> str:
    """로깅용 전화번호 마스킹 (앞3·뒤4만 노출)"""
    if not phone or len(phone) < 7:
        return "***"
    return f"{phone[:3]}****{phone[-4:]}"


def lecture_enroll_from_excel_rows(
    *,
    tenant_id: int,
    lecture_id: int,
    students_data: list[dict],
    initial_password: str,
    session_id: int | None = None,
) -> dict:
    """
    엑셀 파싱된 행으로 강의 수강 등록 + 차시 등록·출결.
    session_id가 있으면 해당 차시에만 등록, 없으면 1차시 생성/사용 후 등록.
    API(lecture_enroll_from_excel)와 워커(EXCEL_PARSING)에서 공통 호출.
    """
    tenant = enroll_repo.get_tenant_by_id(tenant_id)
    if not tenant:
        raise ValueError("tenant_id not found")

    lecture = enroll_repo.get_lecture_by_id_tenant_id(lecture_id, tenant)
    if not lecture:
        raise ValueError("해당 학원의 강의가 아닙니다.")

    initial_password = (initial_password or "").strip()
    if len(initial_password) < 4:
        raise ValueError("initial_password는 4자 이상이어야 합니다.")

    with transaction.atomic():
        student_ids: list[int] = []
        created_student_count = 0
        seen: set[tuple[str, str]] = set()

        for row_index, item in enumerate(students_data, start=1):
            raw = dict(item) if isinstance(item, dict) else {}
            name = (raw.get("name") or "").strip()
            parent_phone = (raw.get("parent_phone") or raw.get("parentPhone") or "")
            parent_phone = "".join(c for c in parent_phone if c.isdigit())

            if not name or len(parent_phone) != 11 or not parent_phone.startswith("010"):
                logger.debug(
                    "[lecture_enroll_excel] row=%s skip name=%r parent_phone_len=%s reason=invalid_or_missing",
                    row_index,
                    name or "(empty)",
                    len(parent_phone),
                )
                continue
            key = (name, parent_phone)
            if key in seen:
                logger.debug(
                    "[lecture_enroll_excel] row=%s skip name=%r parent=%s reason=duplicate",
                    row_index,
                    name,
                    _mask_phone(parent_phone),
                )
                continue
            seen.add(key)

            row = {
                "name": name,
                "parent_phone": parent_phone,
                "phone": raw.get("phone") or raw.get("studentPhone"),
                "school": raw.get("school"),
                "school_type": raw.get("school_type"),
                "grade": raw.get("grade"),
                "memo": raw.get("memo"),
                "uses_identifier": raw.get("uses_identifier", False),
                "gender": raw.get("gender"),
                "high_school_class": raw.get("high_school_class"),
                "major": raw.get("major"),
            }
            try:
                student, created = get_or_create_student_for_lecture_enroll(tenant, row, initial_password)
            except Exception as e:
                logger.warning(
                    "[lecture_enroll_excel] row=%s name=%r parent=%s error=%s",
                    row_index,
                    name,
                    _mask_phone(parent_phone),
                    e,
                    exc_info=True,
                )
                raise
            if student:
                student_ids.append(student.id)
                if created:
                    created_student_count += 1
                logger.debug(
                    "[lecture_enroll_excel] row=%s name=%r student_id=%s created=%s",
                    row_index,
                    name,
                    student.id,
                    created,
                )
            else:
                logger.debug(
                    "[lecture_enroll_excel] row=%s name=%r skip reason=student_resolve_failed",
                    row_index,
                    name,
                )

        if not student_ids:
            raise ValueError(
                "등록할 수 있는 학생이 없습니다. 이름·학부모 전화번호(010 11자리)를 확인해 주세요."
            )

        enrollments_created: list = []
        for sid in student_ids:
            if not enroll_repo.student_exists(sid, tenant):
                logger.warning("[lecture_enroll_excel] student_id=%s not in tenant, skip", sid)
                continue
            obj, created = enroll_repo.enrollment_get_or_create_ret(
                tenant=tenant,
                lecture=lecture,
                student_id=sid,
                defaults={"status": "ACTIVE"},
            )
            enrollments_created.append(obj)
            if created:
                logger.debug("[lecture_enroll_excel] enrollment created lecture_id=%s student_id=%s", lecture_id, sid)

        if session_id:
            target_session = enroll_repo.get_session_by_id_lecture(session_id, lecture)
            if not target_session:
                raise ValueError("해당 차시가 이 강의의 차시가 아닙니다.")
        else:
            target_session = enroll_repo.get_session_by_lecture_order(lecture, 1)
            if not target_session:
                target_session = enroll_repo.create_session_with_meta(
                    lecture=lecture,
                    order=1,
                    title="1차시",
                    date=lecture.start_date,
                )
                logger.info(
                    "[lecture_enroll_excel] session created lecture_id=%s session_id=%s order=1",
                    lecture_id,
                    target_session.id,
                )

        for enrollment in enrollments_created:
            enroll_repo.session_enrollment_get_or_create_tenant(
                tenant=tenant,
                session=target_session,
                enrollment=enrollment,
            )
            enroll_repo.attendance_get_or_create_tenant(
                tenant=tenant,
                enrollment=enrollment,
                session=target_session,
                defaults={"status": "PRESENT"},
            )

        return {
            "enrolled_count": len(enrollments_created),
            "created_students_count": created_student_count,
            "session_id": target_session.id,
        }


==========================================================================================
# FILE: urls.py
==========================================================================================
from rest_framework.routers import DefaultRouter
from .views import EnrollmentViewSet, SessionEnrollmentViewSet

router = DefaultRouter()

# ==================================================
# SessionEnrollment (⚠️ 반드시 먼저!)
# ==================================================
router.register(
    r"session-enrollments",
    SessionEnrollmentViewSet,
    basename="session-enrollment",
)

# ==================================================
# Enrollment (⚠️ r"" 는 항상 맨 마지막)
# ==================================================
router.register(
    r"",
    EnrollmentViewSet,
    basename="enrollment",
)

urlpatterns = router.urls


==========================================================================================
# FILE: views.py
==========================================================================================
# PATH: apps/domains/enrollment/views.py

import logging
import uuid

from django.db import transaction
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.response import Response
from rest_framework import status
from rest_framework.exceptions import ValidationError, NotFound

from academy.adapters.db.django import repositories_enrollment as enroll_repo
from .models import Enrollment, SessionEnrollment
from .serializers import EnrollmentSerializer, SessionEnrollmentSerializer
from .filters import EnrollmentFilter
from apps.domains.lectures.models import Session, Lecture
from apps.domains.students.models import Student
from apps.domains.attendance.models import Attendance
from apps.domains.ai.gateway import dispatch_job
from django.conf import settings
from apps.infrastructure.storage.r2 import upload_fileobj_to_r2_excel

logger = logging.getLogger(__name__)


class EnrollmentViewSet(ModelViewSet):
    serializer_class = EnrollmentSerializer

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_class = EnrollmentFilter
    search_fields = ["student__name"]

    def get_queryset(self):
        tenant = getattr(self.request, "tenant", None)
        return (
            Enrollment.objects
            .filter(tenant=tenant)
            .filter(student__deleted_at__isnull=True)
            .select_related("student", "lecture")
        )

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_create(self, request):
        tenant = getattr(request, "tenant", None)

        lecture_id = request.data.get("lecture")
        student_ids = request.data.get("students", [])

        if not lecture_id or not isinstance(student_ids, list):
            return Response(
                {"detail": "lecture, students(list)는 필수입니다"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # ✅ lecture tenant 검증
        lecture = enroll_repo.get_lecture_by_id_tenant(lecture_id, tenant)
        if not lecture:
            raise ValidationError({"detail": "해당 학원의 강의가 아닙니다."})

        created = []
        for sid in student_ids:
            # ✅ student tenant 검증
            if not enroll_repo.student_exists_for_tenant(sid, tenant):
                raise ValidationError(
                    {"detail": f"학생(id={sid})은 현재 학원 소속이 아닙니다."}
                )

            obj, _ = enroll_repo.enrollment_get_or_create(
                tenant=tenant,
                lecture=lecture,
                student_id=sid,
                defaults={"status": "ACTIVE"},
            )
            created.append(obj)

        return Response(
            EnrollmentSerializer(created, many=True).data,
            status=status.HTTP_201_CREATED,
        )

    @transaction.atomic
    def destroy(self, request, *args, **kwargs):
        enrollment = self.get_object()

        enroll_repo.session_enrollment_filter_delete(enrollment.tenant, enrollment)

        enrollment.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

    @action(detail=False, methods=["post"], url_path="lecture_enroll_from_excel")
    def lecture_enroll_from_excel(self, request):
        """
        강의 엑셀 수강등록 — 워커 전담.
        API는 파일 수신 → R2 엑셀 버킷 업로드 → SQS EXCEL_PARSING job 등록만 수행하며,
        파싱·등록 로직은 워커에서만 실행됩니다 (구조적으로 API에서 동기 처리 불가).
        POST: multipart/form-data — file (엑셀), lecture_id, initial_password
        응답: { "job_id": str } → 클라이언트는 excel_job_status 로 폴링.
        """
        request_id = str(uuid.uuid4())[:8]
        tenant = getattr(request, "tenant", None)
        if not tenant:
            return Response(
                {"detail": "tenant가 필요합니다."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        upload_file = request.FILES.get("file")
        lecture_id = request.data.get("lecture_id")
        session_id_raw = request.data.get("session_id")  # 선택: 있으면 해당 차시에만 등록
        session_id = None
        if session_id_raw not in (None, ""):
            try:
                session_id = int(session_id_raw)
            except (TypeError, ValueError):
                session_id = None
        initial_password = (request.data.get("initial_password") or "").strip()

        if not upload_file or not lecture_id:
            return Response(
                {"detail": "file(엑셀), lecture_id는 필수입니다."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        if len(initial_password) < 4:
            return Response(
                {"detail": "initial_password는 4자 이상 필요합니다."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # 강의 소속 tenant 검증
        lecture = enroll_repo.get_lecture_by_id_tenant_raw(lecture_id, tenant)
        if not lecture:
            raise ValidationError({"detail": "해당 학원의 강의가 아닙니다."})

        if session_id is not None:
            session = enroll_repo.get_session_by_id_lecture(session_id, lecture)
            if not session:
                raise ValidationError({"detail": "해당 차시가 이 강의의 차시가 아닙니다."})

        # R2 엑셀 버킷에 업로드 (워커가 동일 버킷에서 다운로드)
        ext = "xlsx"
        if getattr(upload_file, "name", "") and "." in upload_file.name:
            ext = upload_file.name.rsplit(".", 1)[-1].lower() or "xlsx"
        file_key = f"excel/{tenant.id}/{uuid.uuid4().hex}.{ext}"
        bucket = getattr(settings, "R2_EXCEL_BUCKET", "academy-excel")
        upload_fileobj_to_r2_excel(
            fileobj=upload_file,
            key=file_key,
            content_type=getattr(upload_file, "content_type", None)
            or "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

        payload = {
            "file_key": file_key,
            "bucket": bucket,
            "tenant_id": tenant.id,
            "lecture_id": int(lecture_id),
            "initial_password": initial_password,
        }
        if session_id is not None:
            payload["session_id"] = session_id
        out = dispatch_job(
            job_type="excel_parsing",
            payload=payload,
            tenant_id=str(tenant.id),
            source_domain="enrollment",
            source_id=str(lecture_id),
            tier="basic",
            idempotency_key=f"excel:{file_key}",
        )
        if not out.get("ok"):
            return Response(
                {"detail": out.get("error", "job 등록 실패")},
                status=status.HTTP_400_BAD_REQUEST,
            )
        logger.info(
            "EXCEL_PARSING dispatch request_id=%s job_id=%s tenant_id=%s lecture_id=%s",
            request_id,
            out["job_id"],
            tenant.id,
            lecture_id,
        )
        return Response(
            {"job_id": out["job_id"], "status": "PENDING"},
            status=status.HTTP_202_ACCEPTED,
        )

    @action(detail=False, methods=["get"], url_path="excel_job_status/<str:job_id>")
    def excel_job_status(self, request, job_id=None):
        """
        엑셀 수강등록(excel_parsing) job 상태 조회 (폴링용).
        GET /api/v1/enrollments/excel_job_status/<job_id>/
        공통 응답 형식: build_job_status_response (GET /api/v1/jobs/<id>/ 와 동일).
        """
        tenant = getattr(request, "tenant", None)
        if not tenant:
            return Response(
                {"detail": "tenant가 필요합니다."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        from academy.adapters.db.django.repositories_ai import DjangoAIJobRepository
        from apps.domains.ai.services.job_status_response import build_job_status_response

        repo = DjangoAIJobRepository()
        job = repo.get_job_model_for_status(job_id, str(tenant.id), job_type="excel_parsing")
        if not job:
            raise NotFound("해당 job을 찾을 수 없습니다.")
        return Response(build_job_status_response(job))


class SessionEnrollmentViewSet(ModelViewSet):
    serializer_class = SessionEnrollmentSerializer

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "enrollment"]
    search_fields = ["enrollment__student__name"]

    def get_queryset(self):
        tenant = getattr(self.request, "tenant", None)
        return (
            SessionEnrollment.objects
            .filter(tenant=tenant)
            .filter(enrollment__student__deleted_at__isnull=True)
            .select_related(
                "session",
                "enrollment",
                "enrollment__student",
            )
        )

    @transaction.atomic
    @action(detail=False, methods=["post"])
    def bulk_create(self, request):
        tenant = getattr(request, "tenant", None)

        session_id = request.data.get("session")
        enrollment_ids = request.data.get("enrollments", [])

        if not session_id or not isinstance(enrollment_ids, list):
            return Response(
                {"detail": "session, enrollments(list)는 필수입니다"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session = enroll_repo.get_session_by_id_with_lecture(session_id)

        # ✅ session 소속 lecture tenant 검증
        if session.lecture.tenant_id != tenant.id:
            raise ValidationError({"detail": "다른 학원의 세션입니다."})

        created = []
        for eid in enrollment_ids:
            enrollment = enroll_repo.get_enrollment_by_id_with_lecture(eid, tenant)

            if enrollment.lecture_id != session.lecture_id:
                raise ValidationError(
                    {"detail": "다른 강의 수강자는 이 세션에 추가할 수 없습니다."}
                )

            obj, _ = enroll_repo.session_enrollment_get_or_create_tenant(
                tenant=tenant,
                session=session,
                enrollment=enrollment,
            )
            created.append(obj)
            # 차시 수강생 등록 시 기본 출결 행 생성 → 출결 탭에서 학생 목록이 바로 보이도록
            enroll_repo.attendance_get_or_create_tenant(
                tenant=tenant,
                enrollment=enrollment,
                session=session,
                defaults={"status": "PRESENT"},
            )

        return Response(
            SessionEnrollmentSerializer(created, many=True).data,
            status=status.HTTP_201_CREATED,
        )


==========================================================================================
# FILE: migrations/0001_initial.py
==========================================================================================
# Generated by Django 5.2.9 on 2026-02-15 06:03

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("core", "0001_initial"),
        ("lectures", "0001_initial"),
        ("students", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Enrollment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "활성"),
                            ("INACTIVE", "비활성"),
                            ("PENDING", "대기"),
                        ],
                        default="ACTIVE",
                        max_length=20,
                    ),
                ),
                ("enrolled_at", models.DateTimeField(auto_now_add=True)),
                (
                    "lecture",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="enrollments",
                        to="lectures.lecture",
                    ),
                ),
                (
                    "student",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="enrollments",
                        to="students.student",
                    ),
                ),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="enrollments",
                        to="core.tenant",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="SessionEnrollment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="session_enrollments",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="session_enrollments",
                        to="lectures.session",
                    ),
                ),
                (
                    "tenant",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="session_enrollments",
                        to="core.tenant",
                    ),
                ),
            ],
        ),
        migrations.AddIndex(
            model_name="enrollment",
            index=models.Index(
                fields=["tenant", "created_at"], name="enrollment__tenant__5d24f1_idx"
            ),
        ),
        migrations.AddConstraint(
            model_name="enrollment",
            constraint=models.UniqueConstraint(
                fields=("tenant", "student", "lecture"),
                name="unique_enrollment_per_tenant_lecture",
            ),
        ),
        migrations.AlterUniqueTogether(
            name="sessionenrollment",
            unique_together={("tenant", "session", "enrollment")},
        ),
    ]


==========================================================================================
# FILE: migrations/__init__.py
==========================================================================================

