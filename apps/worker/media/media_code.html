
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>media Code Browser</title>
<style>
body {
    background:#0f1115;
    color:#eaeaea;
    font-family:Consolas, monospace;
    padding:24px;
}
h1 { margin-bottom:24px; }
h2 { color:#7dd3fc; font-size:15px; }
pre {
    background:#111418;
    padding:16px;
    border-radius:8px;
    overflow-x:auto;
    font-size:13px;
    line-height:1.5;
}
section { margin-bottom:32px; }
</style>
</head>
<body>
<h1>üì¶ apps\worker\media</h1>

        <section>
            <h2>__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>drm\__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>r2_uploader.py</h2>
            <pre><code># apps/worker/media/r2_uploader.py

import boto3
import mimetypes
from pathlib import Path
from django.conf import settings

s3 = boto3.client(
    &quot;s3&quot;,
    endpoint_url=settings.R2_ENDPOINT,
    aws_access_key_id=settings.R2_ACCESS_KEY,
    aws_secret_access_key=settings.R2_SECRET_KEY,
    region_name=&quot;auto&quot;,
)

def upload_dir(local_dir: Path, prefix: str):
    &quot;&quot;&quot;
    local_dir Ï†ÑÏ≤¥Î•º prefix Í∏∞Ï§ÄÏúºÎ°ú R2Ïóê ÏóÖÎ°úÎìú
    (Windows Í≤ΩÎ°ú Î¨∏Ï†ú Î∞©ÏßÄÏö© ÌëúÏ§ÄÌòï)
    &quot;&quot;&quot;
    for path in local_dir.rglob(&quot;*&quot;):
        if not path.is_file():
            continue

        # üî•üî•üî• ÌïµÏã¨
        relative_path = path.relative_to(local_dir).as_posix()
        key = f&quot;{prefix}/{relative_path}&quot;

        content_type, _ = mimetypes.guess_type(path.name)

        s3.upload_file(
            str(path),
            settings.R2_BUCKET,
            key,
            ExtraArgs={
                &quot;ContentType&quot;: content_type or &quot;application/octet-stream&quot;
            },
        )
</code></pre>
        </section>
        
        <section>
            <h2>tasks.py</h2>
            <pre><code># worker/media/tasks.py
# Worker ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä media taskÎ•º ÌôïÏã§Ìûà importÌïòÎèÑÎ°ù Í≥†Ï†ïÏ†ê Ïó≠Ìï†
from apps.shared.tasks.media import process_video_media  # noqa: F401
# worker Ï™Ω ÏΩîÎìú ÏòàÏãú (apps/shared/tasks/media.py ÎÇ¥Î∂Ä)

import requests
from django.conf import settings

def notify_processing_complete(*, video_id: int, hls_path: str, duration: int | None):
    url = f&quot;{settings.API_BASE_URL}/internal/videos/{video_id}/processing-complete/&quot;
    requests.post(
        url,
        json={
            &quot;hls_path&quot;: hls_path,
            &quot;duration&quot;: duration,
        },
        timeout=5,
    )
</code></pre>
        </section>
        
        <section>
            <h2>video\__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>video\processor.py</h2>
            <pre><code># apps/worker/media/video/processor.py

from __future__ import annotations

import json
import shutil
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Optional, Union

import requests

from .transcoder import transcode_to_hls


# ---------------------------------------------------------------------
# Errors (processor -&gt; task boundary)
# ---------------------------------------------------------------------

class MediaProcessingError(RuntimeError):
    &quot;&quot;&quot;
    Processor-level error with structured context.
    Task layer should catch this and mark Video as FAILED.
    &quot;&quot;&quot;

    def __init__(
        self,
        *,
        stage: str,
        code: str,
        message: str,
        context: Optional[Dict[str, Any]] = None,
    ) -&gt; None:
        super().__init__(message)
        self.stage = stage
        self.code = code
        self.context = context or {}

    def to_dict(self) -&gt; Dict[str, Any]:
        return {
            &quot;stage&quot;: self.stage,
            &quot;code&quot;: self.code,
            &quot;message&quot;: str(self),
            &quot;context&quot;: self.context,
        }


# ---------------------------------------------------------------------
# Result contract (processor -&gt; task)
# ---------------------------------------------------------------------

@dataclass(frozen=True)
class ProcessResult:
    video_id: int
    duration_seconds: float
    thumbnail_path: Path
    master_playlist_path: Path
    output_root: Path


# ---------------------------------------------------------------------
# Processor (single responsibility: make one video READY)
# ---------------------------------------------------------------------

class VideoProcessor:
    &quot;&quot;&quot;
    The single authority that turns one uploaded video into READY artifacts:
      - download source to local
      - duration (ffprobe local)
      - thumbnail (ffmpeg local)
      - HLS (transcoder.transcode_to_hls local)
      - verification (master.m3u8 exists)
    &quot;&quot;&quot;

    def run(
        self,
        *,
        video_id: int,
        input_url: str,
        output_root: Union[str, Path],
        timeout_download: Optional[int] = 60 * 30,
        timeout_probe: Optional[int] = 60,
        timeout_thumbnail: Optional[int] = 120,
        timeout_hls: Optional[int] = None,
        cleanup_source: bool = False,
    ) -&gt; ProcessResult:
        out_root = Path(output_root)

        # 1) pre-clean
        self._pre_clean_output_root(
            video_id=video_id,
            output_root=out_root,
        )

        # 2) download source to local (Ï†ïÏÑù)
        local_input_path = self._download_source(
            video_id=video_id,
            input_url=input_url,
            output_root=out_root,
            timeout=timeout_download,
        )

        try:
            # 3) probe duration (local)
            duration = self._probe_duration_seconds(
                video_id=video_id,
                input_path=str(local_input_path),
                timeout=timeout_probe,
            )

            # 4) thumbnail (local)
            thumb_path = out_root / &quot;thumbnail.jpg&quot;
            self._generate_thumbnail(
                video_id=video_id,
                input_path=str(local_input_path),
                output_path=thumb_path,
                timeout=timeout_thumbnail,
            )

            # 5) HLS transcode (local)
            master_path = self._transcode_hls(
                video_id=video_id,
                input_path=str(local_input_path),
                output_root=out_root, 
                timeout=timeout_hls,
            )

            # 6) verify
            self._verify_ready(
                video_id=video_id,
                master_path=master_path,
            )

            return ProcessResult(
                video_id=video_id,
                duration_seconds=duration,
                thumbnail_path=thumb_path,
                master_playlist_path=master_path,
                output_root=out_root,
            )

        finally:
            if cleanup_source:
                try:
                    if local_input_path.exists():
                        local_input_path.unlink()
                except Exception:
                    pass

    # -----------------------------------------------------------------
    # Internal steps
    # -----------------------------------------------------------------

    def _pre_clean_output_root(self, *, video_id: int, output_root: Path) -&gt; None:
        &quot;&quot;&quot;
        Delete output_root entirely if exists, then recreate.
        Prevents stale artifacts from making retries look successful.
        &quot;&quot;&quot;
        try:
            if output_root.exists():
                shutil.rmtree(output_root)
            output_root.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            raise MediaProcessingError(
                stage=&quot;CLEAN&quot;,
                code=&quot;CLEAN_FAILED&quot;,
                message=f&quot;Failed to pre-clean output_root (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;output_root&quot;: str(output_root),
                    &quot;error&quot;: repr(e),
                },
            ) from e

    def _download_source(
        self,
        *,
        video_id: int,
        input_url: str,
        output_root: Path,
        timeout: Optional[int] = 60 * 30,  # 30m
        chunk_size: int = 1024 * 1024,      # 1MB
    ) -&gt; Path:
        &quot;&quot;&quot;
        Download source MP4 from presigned GET URL to local disk.
        &quot;&quot;&quot;
        output_root.mkdir(parents=True, exist_ok=True)

        final_path = output_root / &quot;_source.mp4&quot;
        tmp_path = output_root / &quot;_source.mp4.part&quot;

        try:
            with requests.get(input_url, stream=True, timeout=30) as r:
                r.raise_for_status()

                expected_len = r.headers.get(&quot;Content-Length&quot;)
                expected_len_int = int(expected_len) if expected_len and expected_len.isdigit() else None

                written = 0
                with open(tmp_path, &quot;wb&quot;) as f:
                    for chunk in r.iter_content(chunk_size=chunk_size):
                        if not chunk:
                            continue
                        f.write(chunk)
                        written += len(chunk)

                if expected_len_int is not None and written != expected_len_int:
                    raise RuntimeError(
                        f&quot;download size mismatch (expected={expected_len_int}, got={written})&quot;
                    )

            tmp_path.replace(final_path)
            return final_path

        except Exception as e:
            try:
                if tmp_path.exists():
                    tmp_path.unlink()
            except Exception:
                pass

            raise MediaProcessingError(
                stage=&quot;DOWNLOAD&quot;,
                code=&quot;DOWNLOAD_FAILED&quot;,
                message=f&quot;Failed to download source (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;input_url&quot;: input_url[:2000],
                    &quot;output_root&quot;: str(output_root),
                    &quot;error&quot;: repr(e),
                },
            ) from e

    def _probe_duration_seconds(
        self,
        *,
        video_id: int,
        input_path: str,
        timeout: Optional[int],
    ) -&gt; float:
        &quot;&quot;&quot;
        ffprobe local file.
        &quot;&quot;&quot;
        cmd = [
            &quot;ffprobe&quot;,
            &quot;-v&quot;, &quot;error&quot;,
            &quot;-print_format&quot;, &quot;json&quot;,
            &quot;-show_format&quot;,
            &quot;-show_streams&quot;,
            input_path,
        ]

        try:
            p = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=timeout,
                check=False,
            )
        except Exception as e:
            raise MediaProcessingError(
                stage=&quot;PROBE&quot;,
                code=&quot;PROBE_FAILED&quot;,
                message=f&quot;ffprobe execution failed (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;error&quot;: repr(e),
                },
            ) from e

        if p.returncode != 0:
            raise MediaProcessingError(
                stage=&quot;PROBE&quot;,
                code=&quot;PROBE_FAILED&quot;,
                message=f&quot;ffprobe returned non-zero (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;returncode&quot;: p.returncode,
                    &quot;stderr&quot;: p.stderr,
                },
            )

        try:
            data = json.loads(p.stdout)
            fmt = data.get(&quot;format&quot;) or {}
            duration_str = fmt.get(&quot;duration&quot;)
            duration = float(duration_str) if duration_str is not None else 0.0
        except Exception as e:
            raise MediaProcessingError(
                stage=&quot;PROBE&quot;,
                code=&quot;PROBE_FAILED&quot;,
                message=f&quot;Failed to parse ffprobe output (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;stdout&quot;: p.stdout[:4000],
                    &quot;error&quot;: repr(e),
                },
            ) from e

        if duration &lt;= 0:
            raise MediaProcessingError(
                stage=&quot;PROBE&quot;,
                code=&quot;PROBE_FAILED&quot;,
                message=f&quot;Invalid duration from ffprobe (video_id={video_id}, duration={duration})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;duration&quot;: duration,
                },
            )

        return duration

    def _generate_thumbnail(
        self,
        *,
        video_id: int,
        input_path: str,
        output_path: Path,
        timeout: Optional[int],
    ) -&gt; None:
        &quot;&quot;&quot;
        Generate one thumbnail jpg from local file.
        &quot;&quot;&quot;
        output_path.parent.mkdir(parents=True, exist_ok=True)

        cmd = [
            &quot;ffmpeg&quot;,
            &quot;-y&quot;,
            &quot;-i&quot;, input_path,
            &quot;-vf&quot;, &quot;thumbnail,scale=1280:-2&quot;,
            &quot;-frames:v&quot;, &quot;1&quot;,
            str(output_path),
        ]

        try:
            p = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=timeout,
                check=False,
            )
        except Exception as e:
            raise MediaProcessingError(
                stage=&quot;THUMBNAIL&quot;,
                code=&quot;THUMBNAIL_FAILED&quot;,
                message=f&quot;ffmpeg thumbnail execution failed (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;error&quot;: repr(e),
                },
            ) from e

        if p.returncode != 0:
            raise MediaProcessingError(
                stage=&quot;THUMBNAIL&quot;,
                code=&quot;THUMBNAIL_FAILED&quot;,
                message=f&quot;ffmpeg thumbnail returned non-zero (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;cmd&quot;: cmd,
                    &quot;returncode&quot;: p.returncode,
                    &quot;stderr&quot;: p.stderr,
                },
            )

        if not output_path.exists():
            raise MediaProcessingError(
                stage=&quot;THUMBNAIL&quot;,
                code=&quot;THUMBNAIL_FAILED&quot;,
                message=f&quot;thumbnail file not created (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;output_path&quot;: str(output_path),
                },
            )

    def _transcode_hls(
        self,
        *,
        video_id: int,
        input_path: str,
        output_root: Path, 
        timeout: Optional[int],
    ) -&gt; Path:
        &quot;&quot;&quot;
        Delegate to transcoder (local input).
        &quot;&quot;&quot;
        try:
            master_path = transcode_to_hls(
                video_id=video_id,
                input_path=input_path,
                output_root=output_root, 
                timeout=timeout,
            )
            return master_path
        except Exception as e:
            raise MediaProcessingError(
                stage=&quot;HLS&quot;,
                code=&quot;HLS_FAILED&quot;,
                message=f&quot;HLS transcode failed (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;input_path&quot;: input_path,
                    &quot;error&quot;: repr(e),
                },
            ) from e

    def _verify_ready(self, *, video_id: int, master_path: Path) -&gt; None:
        &quot;&quot;&quot;
        READY criterion is strictly: master.m3u8 exists.
        &quot;&quot;&quot;
        if not master_path.exists():
            raise MediaProcessingError(
                stage=&quot;VERIFY&quot;,
                code=&quot;OUTPUT_INVALID&quot;,
                message=f&quot;READY criterion failed: master.m3u8 missing (video_id={video_id})&quot;,
                context={
                    &quot;video_id&quot;: video_id,
                    &quot;master_path&quot;: str(master_path),
                },
            )


# ---------------------------------------------------------------------
# Public entry
# ---------------------------------------------------------------------

def run(
    *,
    video_id: int,
    input_url: str,
    output_root: Union[str, Path],
    timeout_download: Optional[int] = 60 * 30,
    timeout_probe: Optional[int] = 60,
    timeout_thumbnail: Optional[int] = 120,
    timeout_hls: Optional[int] = None,
) -&gt; ProcessResult:
    return VideoProcessor().run(
        video_id=video_id,
        input_url=input_url,
        output_root=output_root,
        timeout_download=timeout_download,
        timeout_probe=timeout_probe,
        timeout_thumbnail=timeout_thumbnail,
        timeout_hls=timeout_hls,
    )
</code></pre>
        </section>
        
        <section>
            <h2>video\transcoder.py</h2>
            <pre><code>from __future__ import annotations

import subprocess
from pathlib import Path
from typing import List


# ---------------------------------------------------------------------
# HLS Variant Ladder
# ---------------------------------------------------------------------
# ‚ö†Ô∏è nameÏóêÎäî Ï†àÎåÄ &#x27;v&#x27; Î∂ôÏù¥ÏßÄ Îßê Í≤É
HLS_VARIANTS = [
    {&quot;name&quot;: &quot;1&quot;, &quot;width&quot;: 426,  &quot;height&quot;: 240,  &quot;video_bitrate&quot;: &quot;400k&quot;,  &quot;audio_bitrate&quot;: &quot;64k&quot;},
    {&quot;name&quot;: &quot;2&quot;, &quot;width&quot;: 640,  &quot;height&quot;: 360,  &quot;video_bitrate&quot;: &quot;800k&quot;,  &quot;audio_bitrate&quot;: &quot;96k&quot;},
    {&quot;name&quot;: &quot;3&quot;, &quot;width&quot;: 1280, &quot;height&quot;: 720,  &quot;video_bitrate&quot;: &quot;2500k&quot;, &quot;audio_bitrate&quot;: &quot;128k&quot;},
]


# ---------------------------------------------------------------------
# Directory preparation
# ---------------------------------------------------------------------
def prepare_output_dirs(output_root: Path) -&gt; None:
    &quot;&quot;&quot;
    storage/media/hls/videos/{video_id}/
      ‚îú‚îÄ master.m3u8
      ‚îú‚îÄ v1/
      ‚îÇ   ‚îú‚îÄ index.m3u8
      ‚îÇ   ‚îî‚îÄ index0.ts ...
      ‚îú‚îÄ v2/
      ‚îî‚îÄ v3/
    &quot;&quot;&quot;
    output_root.mkdir(parents=True, exist_ok=True)

    # v1, v2, v3 ÎîîÎ†âÌÜ†Î¶¨ ÎØ∏Î¶¨ ÏÉùÏÑ±
    for v in HLS_VARIANTS:
        (output_root / f&quot;v{v[&#x27;name&#x27;]}&quot;).mkdir(parents=True, exist_ok=True)


# ---------------------------------------------------------------------
# ffmpeg filter_complex builder
# ---------------------------------------------------------------------
def build_filter_complex() -&gt; str:
    parts: List[str] = []
    split_count = len(HLS_VARIANTS)

    parts.append(
        &quot;[0:v]split={}&quot;.format(split_count)
        + &quot;&quot;.join(f&quot;[v{i}]&quot; for i in range(split_count))
    )

    for i, v in enumerate(HLS_VARIANTS):
        parts.append(f&quot;[v{i}]scale={v[&#x27;width&#x27;]}:{v[&#x27;height&#x27;]}[v{i}out]&quot;)

    return &quot;;&quot;.join(parts)


# ---------------------------------------------------------------------
# ffmpeg command builder (‚≠ê ÌëúÏ§ÄÌòï)
# ---------------------------------------------------------------------
def build_ffmpeg_command(input_path: str) -&gt; List[str]:
    &quot;&quot;&quot;
    ‚ö†Ô∏è Î™®Îì† Ï∂úÎ†• Í≤ΩÎ°úÎäî &#x27;ÏÉÅÎåÄ Í≤ΩÎ°ú&#x27;Îßå ÏÇ¨Ïö©
    ‚ö†Ô∏è cwd Í∏∞Ï§ÄÏúºÎ°ú ffmpeg Ïã§ÌñâÎê®
    &quot;&quot;&quot;
    cmd: List[str] = [
        &quot;ffmpeg&quot;,
        &quot;-y&quot;,
        &quot;-i&quot;, input_path,  # ÏûÖÎ†•ÏùÄ Ï†àÎåÄ Í≤ΩÎ°úÏó¨ÎèÑ OK
        &quot;-filter_complex&quot;, build_filter_complex(),
    ]

    for i, v in enumerate(HLS_VARIANTS):
        cmd += [
            &quot;-map&quot;, f&quot;[v{i}out]&quot;,
            &quot;-map&quot;, &quot;0:a?&quot;,

            f&quot;-c:v:{i}&quot;, &quot;libx264&quot;,
            &quot;-profile:v&quot;, &quot;main&quot;,
            &quot;-pix_fmt&quot;, &quot;yuv420p&quot;,
            f&quot;-b:v:{i}&quot;, v[&quot;video_bitrate&quot;],

            &quot;-g&quot;, &quot;48&quot;,
            &quot;-keyint_min&quot;, &quot;48&quot;,
            &quot;-sc_threshold&quot;, &quot;0&quot;,

            f&quot;-c:a:{i}&quot;, &quot;aac&quot;,
            &quot;-ac&quot;, &quot;2&quot;,
            f&quot;-b:a:{i}&quot;, v[&quot;audio_bitrate&quot;],
        ]

    cmd += [
        &quot;-f&quot;, &quot;hls&quot;,
        &quot;-hls_time&quot;, &quot;4&quot;,
        &quot;-hls_playlist_type&quot;, &quot;vod&quot;,
        &quot;-hls_flags&quot;, &quot;independent_segments&quot;,

        # ‚úÖ ÌëúÏ§Ä: ÏÉÅÎåÄ Í≤ΩÎ°ú + POSIX Ïä¨ÎûòÏãú
        &quot;-hls_segment_filename&quot;, &quot;v%v/index%d.ts&quot;,
        &quot;-master_pl_name&quot;, &quot;master.m3u8&quot;,

        &quot;-var_stream_map&quot;,
        &quot; &quot;.join(
            f&quot;v:{i},a:{i},name:{v[&#x27;name&#x27;]}&quot;
            for i, v in enumerate(HLS_VARIANTS)
        ),

        # ‚úÖ variant playlistÎèÑ ÏÉÅÎåÄ Í≤ΩÎ°ú
        &quot;v%v/index.m3u8&quot;,
    ]

    return cmd


# ---------------------------------------------------------------------
# Public API (‚≠ê ÌëúÏ§ÄÌòï Ïã§ÌñâÎ∂Ä)
# ---------------------------------------------------------------------
def transcode_to_hls(
    *,
    video_id: int,
    input_path: str,
    output_root: Path,
    timeout: int | None = None,
) -&gt; Path:
    &quot;&quot;&quot;
    Execute HLS transcoding from local mp4 (Best Practice)
    &quot;&quot;&quot;

    # 1. Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ Ï§ÄÎπÑ
    prepare_output_dirs(output_root)

    # 2. ffmpeg Î™ÖÎ†πÏñ¥ ÏÉùÏÑ±
    cmd = build_ffmpeg_command(input_path)

    # 3. ‚≠ê ÌïµÏã¨: output_rootÎ•º cwdÎ°ú Ïã§Ìñâ
    process = subprocess.run(
        cmd,
        cwd=str(output_root.resolve()),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        timeout=timeout,
        check=False,
    )

    if process.returncode != 0:
        raise RuntimeError({
            &quot;video_id&quot;: video_id,
            &quot;cmd&quot;: cmd,
            &quot;stderr&quot;: process.stderr,
        })

    master_path = output_root / &quot;master.m3u8&quot;
    if not master_path.exists():
        raise RuntimeError(&quot;master.m3u8 not created&quot;)

    return master_path
</code></pre>
        </section>
        
</body>
</html>
