
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>shared Code Browser</title>
<style>
body {
    background:#0f1115;
    color:#eaeaea;
    font-family:Consolas, monospace;
    padding:24px;
}
h1 { margin-bottom:24px; }
h2 { color:#7dd3fc; font-size:15px; }
pre {
    background:#111418;
    padding:16px;
    border-radius:8px;
    overflow-x:auto;
    font-size:13px;
    line-height:1.5;
}
section { margin-bottom:32px; }
</style>
</head>
<body>
<h1>ğŸ“¦ apps\shared</h1>

        <section>
            <h2>__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>contracts\__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>contracts\ai_job.py</h2>
            <pre><code># apps/shared/contracts/ai_job.py
from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import Any, Dict, Literal, Optional
import json
import uuid
from datetime import datetime, timezone


AIJobType = Literal[
    &quot;ocr&quot;,
    &quot;question_segmentation&quot;,
    &quot;handwriting_analysis&quot;,
    &quot;embedding&quot;,
    &quot;problem_generation&quot;,
    &quot;homework_video_analysis&quot;,
    &quot;omr_grading&quot;,
]


def _now_iso() -&gt; str:
    return datetime.now(timezone.utc).isoformat()


@dataclass(frozen=True)
class AIJob:
    &quot;&quot;&quot;
    API â†’ Worker ë¡œ ì „ë‹¬ë˜ëŠ” &#x27;ê³„ì•½&#x27; (Contract)

    ì›ì¹™:
    - WorkerëŠ” DB/ORM/ë¹„ì¦ˆë‹ˆìŠ¤ ë¬¸ë§¥ì„ ëª°ë¼ì•¼ í•˜ë¯€ë¡œ
      job payloadì—ëŠ” file path / ids / ìµœì†Œ ë©”íƒ€ë§Œ ë‹´ëŠ”ë‹¤.
    &quot;&quot;&quot;

    id: str
    type: AIJobType

    # í…Œë„ŒíŠ¸/ìŠ¤ì½”í•‘ (APIì—ì„œë§Œ ì˜ë¯¸ ìˆìŒ. workerëŠ” ê·¸ëŒ€ë¡œ echoë§Œ)
    tenant_id: Optional[str] = None

    # ì–´ë–¤ ë„ë©”ì¸ ì´ë²¤íŠ¸ì—ì„œ ë°œìƒí–ˆëŠ”ì§€ ì¶”ì ìš©
    source_domain: Optional[str] = None  # e.g. &quot;submissions&quot;, &quot;exams&quot;, &quot;homework&quot;
    source_id: Optional[str] = None      # e.g. submission_id

    # ì‹¤ì œ ì²˜ë¦¬ì— í•„ìš”í•œ ë°ì´í„°
    payload: Dict[str, Any] = None  # type: ignore

    # ì¶”ì 
    created_at: str = &quot;&quot;

    @staticmethod
    def new(
        *,
        type: AIJobType,
        payload: Dict[str, Any],
        tenant_id: Optional[str] = None,
        source_domain: Optional[str] = None,
        source_id: Optional[str] = None,
    ) -&gt; &quot;AIJob&quot;:
        return AIJob(
            id=str(uuid.uuid4()),
            type=type,
            tenant_id=tenant_id,
            source_domain=source_domain,
            source_id=source_id,
            payload=payload or {},
            created_at=_now_iso(),
        )

    def to_dict(self) -&gt; Dict[str, Any]:
        d = asdict(self)
        if d[&quot;payload&quot;] is None:
            d[&quot;payload&quot;] = {}
        return d

    def to_json(self) -&gt; str:
        return json.dumps(self.to_dict(), ensure_ascii=False)

    @staticmethod
    def from_dict(data: Dict[str, Any]) -&gt; &quot;AIJob&quot;:
        return AIJob(
            id=str(data.get(&quot;id&quot;)),
            type=data.get(&quot;type&quot;),
            tenant_id=data.get(&quot;tenant_id&quot;),
            source_domain=data.get(&quot;source_domain&quot;),
            source_id=data.get(&quot;source_id&quot;),
            payload=data.get(&quot;payload&quot;) or {},
            created_at=str(data.get(&quot;created_at&quot;) or &quot;&quot;),
        )

    @staticmethod
    def from_json(raw: str) -&gt; &quot;AIJob&quot;:
        return AIJob.from_dict(json.loads(raw))
</code></pre>
        </section>
        
        <section>
            <h2>contracts\ai_result.py</h2>
            <pre><code># apps/shared/contracts/ai_result.py
from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import Any, Dict, Literal, Optional
import json
from datetime import datetime, timezone


AIJobStatus = Literal[&quot;DONE&quot;, &quot;FAILED&quot;]


def _now_iso() -&gt; str:
    return datetime.now(timezone.utc).isoformat()


@dataclass(frozen=True)
class AIResult:
    &quot;&quot;&quot;
    Worker â†’ API ë¡œ ì „ë‹¬ë˜ëŠ” &#x27;ê³„ì•½&#x27; (Contract)

    ì›ì¹™:
    - WorkerëŠ” ì €ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤. ê²°ê³¼ë¥¼ &#x27;ì „ë‹¬&#x27;ë§Œ í•œë‹¤.
    - APIëŠ” ê²°ê³¼ë¥¼ ë°›ì•„ì„œ results/facts í˜¹ì€ submission meta ë“±ì— ë°˜ì˜í•œë‹¤.
    &quot;&quot;&quot;

    job_id: str
    status: AIJobStatus

    # ê²°ê³¼ ë°ì´í„° (job type ë³„ ìŠ¤í‚¤ë§ˆëŠ” payload/resultë¡œ êµ¬ë¶„)
    result: Dict[str, Any] = None  # type: ignore

    # ì˜¤ë¥˜ ì •ë³´
    error: Optional[str] = None

    finished_at: str = &quot;&quot;

    @staticmethod
    def done(job_id: str, result: Dict[str, Any]) -&gt; &quot;AIResult&quot;:
        return AIResult(
            job_id=job_id,
            status=&quot;DONE&quot;,
            result=result or {},
            error=None,
            finished_at=_now_iso(),
        )

    @staticmethod
    def failed(job_id: str, error: str) -&gt; &quot;AIResult&quot;:
        return AIResult(
            job_id=job_id,
            status=&quot;FAILED&quot;,
            result={},
            error=error,
            finished_at=_now_iso(),
        )

    def to_dict(self) -&gt; Dict[str, Any]:
        d = asdict(self)
        if d[&quot;result&quot;] is None:
            d[&quot;result&quot;] = {}
        return d

    def to_json(self) -&gt; str:
        return json.dumps(self.to_dict(), ensure_ascii=False)

    @staticmethod
    def from_dict(data: Dict[str, Any]) -&gt; &quot;AIResult&quot;:
        return AIResult(
            job_id=str(data.get(&quot;job_id&quot;)),
            status=data.get(&quot;status&quot;),
            result=data.get(&quot;result&quot;) or {},
            error=data.get(&quot;error&quot;),
            finished_at=str(data.get(&quot;finished_at&quot;) or &quot;&quot;),
        )

    @staticmethod
    def from_json(raw: str) -&gt; &quot;AIResult&quot;:
        return AIResult.from_dict(json.loads(raw))
</code></pre>
        </section>
        
        <section>
            <h2>contracts\message_job.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>tasks\__init__.py</h2>
            <pre><code></code></pre>
        </section>
        
        <section>
            <h2>tasks\media.py</h2>
            <pre><code>from __future__ import annotations

import logging
from pathlib import Path

from celery import shared_task
from django.conf import settings
from django.db import transaction

from apps.support.media.models import Video
from libs.s3_client.presign import create_presigned_get_url
from apps.worker.media.video import processor
from apps.worker.media.video.processor import MediaProcessingError
from apps.worker.media.r2_uploader import upload_dir

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------

def _get_hls_output_root(video_id: int) -&gt; Path:
    &quot;&quot;&quot;
    storage/media/hls/videos/{video_id}
    &quot;&quot;&quot;
    return (
        Path(settings.BASE_DIR)
        / &quot;storage&quot;
        / &quot;media&quot;
        / &quot;hls&quot;
        / &quot;videos&quot;
        / str(video_id)
    )


def _to_relative_media_path(path: Path) -&gt; str:
    &quot;&quot;&quot;
    Convert absolute path under BASE_DIR/storage to relative media path.
    &quot;&quot;&quot;
    base = Path(settings.BASE_DIR)
    try:
        return str(path.relative_to(base))
    except ValueError:
        return str(path)


# ---------------------------------------------------------------------
# Celery Task
# ---------------------------------------------------------------------

@shared_task(
    bind=True,
    queue=&quot;video&quot;,
    autoretry_for=(),
    retry_backoff=False,
)
def process_video_media(self, video_id: int) -&gt; None:
    &quot;&quot;&quot;
    Orchestrates media processing for a single Video.
    &quot;&quot;&quot;

    # 1ï¸âƒ£ Lock &amp; ìƒíƒœ ì „ì´
    with transaction.atomic():
        video = (
            Video.objects
            .select_for_update()
            .filter(id=video_id)
            .first()
        )

        if video is None:
            logger.warning(&quot;[media] Video not found (video_id=%s)&quot;, video_id)
            return

        if video.status != Video.Status.UPLOADED:
            logger.info(
                &quot;[media] Skip processing (status=%s, video_id=%s)&quot;,
                video.status,
                video_id,
            )
            return

        video.status = Video.Status.PROCESSING
        video.save(update_fields=[&quot;status&quot;])

    # 2ï¸âƒ£ ì…ë ¥ URL + ì¶œë ¥ ê²½ë¡œ ì¤€ë¹„
    try:
        input_url = create_presigned_get_url(
            key=video.file_key,
            expires_in=60 * 60,
        )
        output_root = _get_hls_output_root(video_id)

    except Exception:
        logger.exception(
            &quot;[media] Failed to prepare input/output (video_id=%s)&quot;,
            video_id,
        )
        _mark_failed(video_id)
        return

    # 3ï¸âƒ£ ì‹¤ì œ ì²˜ë¦¬ (ffmpeg)
    try:
        result = processor.run(
            video_id=video_id,
            input_url=input_url,
            output_root=output_root,
        )

    except MediaProcessingError as e:
        logger.error(
            &quot;[media] Media processing failed (video_id=%s) %s&quot;,
            video_id,
            e.to_dict(),
        )
        _mark_failed(video_id)
        return

    except Exception:
        logger.exception(
            &quot;[media] Unexpected error during media processing (video_id=%s)&quot;,
            video_id,
        )
        _mark_failed(video_id)
        return

    # 4ï¸âƒ£ DB ê²°ê³¼ ë°˜ì˜ (READY)
    with transaction.atomic():
        video = (
            Video.objects
            .select_for_update()
            .filter(id=video_id)
            .first()
        )

        if video is None:
            logger.warning(
                &quot;[media] Video disappeared before READY persist (video_id=%s)&quot;,
                video_id,
            )
            return

        video.duration = result.duration_seconds
        video.thumbnail = _to_relative_media_path(result.thumbnail_path)
        video.hls_path = _to_relative_media_path(result.master_playlist_path)
        video.status = Video.Status.READY

        video.save(
            update_fields=[
                &quot;duration&quot;,
                &quot;thumbnail&quot;,
                &quot;hls_path&quot;,
                &quot;status&quot;,
            ]
        )

    # 5ï¸âƒ£ R2 ì—…ë¡œë“œ (ğŸš¨ ë°˜ë“œì‹œ íŠ¸ëœì­ì…˜ ë°–)
    try:
        upload_dir(
            local_dir=output_root,
            prefix=f&quot;media/hls/videos/{video_id}&quot;,
        )
    except Exception:
        logger.exception(
            &quot;[media] R2 upload failed (video_id=%s)&quot;,
            video_id,
        )
        _mark_failed(video_id)
        return

    logger.info(
        &quot;[media] Video media processing READY (video_id=%s)&quot;,
        video_id,
    )


# ---------------------------------------------------------------------
# Failure handling
# ---------------------------------------------------------------------

def _mark_failed(video_id: int) -&gt; None:
    &quot;&quot;&quot;
    Mark Video as FAILED.
    &quot;&quot;&quot;
    with transaction.atomic():
        video = (
            Video.objects
            .select_for_update()
            .filter(id=video_id)
            .first()
        )
        if video is None:
            return

        video.status = Video.Status.FAILED
        video.save(update_fields=[&quot;status&quot;])
</code></pre>
        </section>
        
</body>
</html>
