
================================================================================
# FILE: __init__.py
================================================================================
# services package


================================================================================
# FILE: admin.py
================================================================================
from django.contrib import admin
from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


@admin.register(Video)
class VideoAdmin(admin.ModelAdmin):
    list_display = ("id", "title", "session", "order", "duration", "status")
    list_display_links = ("id", "title")
    list_filter = ("status", "session__lecture", "session")
    search_fields = ("title",)
    ordering = ("session", "order")


@admin.register(VideoPermission)
class VideoPermissionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "rule",
        "allow_skip_override",
        "max_speed_override",
        "show_watermark_override",
        "block_seek",
        "block_speed_control",
        "is_override",
    )
    list_display_links = ("id", "video")
    list_filter = ("rule", "video__session__lecture", "block_seek", "block_speed_control")
    search_fields = ("enrollment__student__name",)
    ordering = ("-id",)


@admin.register(VideoProgress)
class VideoProgressAdmin(admin.ModelAdmin):
    list_display = ("id", "video", "enrollment", "progress", "completed", "updated_at")
    list_display_links = ("id", "video")
    list_filter = ("video__session__lecture", "completed")
    search_fields = ("enrollment__student__name",)
    ordering = ("-updated_at",)


@admin.register(VideoPlaybackSession)
class VideoPlaybackSessionAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "device_id",
        "status",
        "started_at",
        "ended_at",
    )
    list_filter = ("status", "video__session__lecture", "video")
    search_fields = ("session_id", "device_id", "enrollment__student__name")
    ordering = ("-started_at",)


@admin.register(VideoPlaybackEvent)
class VideoPlaybackEventAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "video",
        "enrollment",
        "session_id",
        "user_id",
        "event_type",
        "violated",
        "violation_reason",
        "occurred_at",
        "received_at",
    )
    list_filter = ("event_type", "violated", "video__session__lecture")
    search_fields = ("session_id", "enrollment__student__name", "user_id")
    ordering = ("-received_at",)


================================================================================
# FILE: drm.py
================================================================================
import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


================================================================================
# FILE: models.py
================================================================================
from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (ì˜ìƒ ë©”íƒ€ë°ì´í„°)
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "ì—…ë¡œë“œ ëŒ€ê¸°"
        UPLOADED = "UPLOADED", "ì—…ë¡œë“œ ì™„ë£Œ"
        PROCESSING = "PROCESSING", "ì²˜ë¦¬ì¤‘"
        READY = "READY", "ì‚¬ìš© ê°€ëŠ¥"
        FAILED = "FAILED", "ì‹¤íŒ¨"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # ì¸ë„¤ì¼ì€ Workerê°€ ìƒì„±
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # ê¸°ë³¸ ì¬ìƒ ì •ì±… (ë¹„ë””ì˜¤ ë‹¨ìœ„ default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Worker ì‹¤íŒ¨ ì‚¬ìœ  ê¸°ë¡
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    class Meta:
        ordering = ["order", "id"]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        return "unknown"

    
    # ===============================
    # HLS Output (Worker ê²°ê³¼)
    # ===============================
    hls_path = models.CharField(
        max_length=500,
        blank=True,
        help_text="HLS master playlist path (relative to CDN root)",
    )



# ========================================================
# Video Permission (ìˆ˜ê°•ìƒë³„ override + ì ‘ê·¼ ê·œì¹™)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "ë¬´ì œí•œ"),
            ("once", "1íšŒ ì œí•œ"),
            ("blocked", "ì œí•œ"),
        ],
        default="once",
    )

    # í•™ìƒë³„ ì •ì±… override (nullì´ë©´ Video ê¸°ë³¸ê°’ ì‚¬ìš©)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # ìµœìš°ì„  ì°¨ë‹¨ í”Œë˜ê·¸
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (ì„¸ì…˜ / ê°ì‚¬)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "í™œì„±"
        ENDED = "ENDED", "ì¢…ë£Œ"
        REVOKED = "REVOKED", "ì°¨ë‹¨"
        EXPIRED = "EXPIRED", "ë§Œë£Œ"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "íƒ­ ìˆ¨ê¹€"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "íƒ­ ë…¸ì¶œ"
        FOCUS_LOST = "FOCUS_LOST", "í¬ì»¤ìŠ¤ ì´íƒˆ"
        FOCUS_GAINED = "FOCUS_GAINED", "í¬ì»¤ìŠ¤ ë³µê·€"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "íƒìƒ‰ ì‹œë„"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "ë°°ì† ë³€ê²½ ì‹œë„"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "ì „ì²´í™”ë©´ ì§„ì…"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "ì „ì²´í™”ë©´ ì¢…ë£Œ"
        PLAYER_ERROR = "PLAYER_ERROR", "í”Œë ˆì´ì–´ ì˜¤ë¥˜"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


================================================================================
# FILE: serializers.py
================================================================================
from rest_framework import serializers

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)

from rest_framework import serializers
from apps.support.media.models import Video
from apps.domains.lectures.models import Session


class VideoSerializer(serializers.ModelSerializer):
    # ğŸ”¥ í•µì‹¬ 1: ìƒì„± ì‹œ ë°›ì„ session (write only)
    session = serializers.PrimaryKeyRelatedField(
        queryset=Session.objects.all(),
        write_only=True,
    )

    # ğŸ”¥ í•µì‹¬ 2: ì‘ë‹µìš© session_id (read only)
    session_id = serializers.IntegerField(
        source="session.id",
        read_only=True,
    )

    source_type = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session",        # âœ… ì¶”ê°€
            "session_id",
            "title",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "hls_path",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = [
            "id",
            "session_id",
            "created_at",
            "updated_at",
        ]
        ref_name = "MediaVideo"

    def get_source_type(self, obj):
        return "s3" if obj.file_key else "unknown"


class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "MediaVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "MediaVideoProgress"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "MediaVideoDetail"



# ========================================================
# Playback API (v1)
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


# ========================================================
# Playback Session (Student Facade API)
# ========================================================

class PlaybackSessionSerializer(serializers.Serializer):
    """
    Facade API ì „ìš© Serializer

    âš ï¸ ì£¼ì˜
    - VideoPlaybackSession(Model)ê³¼ ë¬´ê´€
    - create_playback_session() ë°˜í™˜ dict ì „ìš©
    """

    video_id = serializers.IntegerField()
    enrollment_id = serializers.IntegerField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()


# ========================================================
# Event collection (v1: audit-only)
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(choices=VideoPlaybackEvent.EventType.choices)
    occurred_at = serializers.IntegerField(required=False)  # epoch seconds
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()

class PlaybackStartFacadeRequestSerializer(serializers.Serializer):
    device_id = serializers.CharField(max_length=128)


================================================================================
# FILE: urls.py
================================================================================
# app/support/media/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter


from .views import VideoProcessingCompleteView

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
)

router = DefaultRouter()

# ========================================================
# Video
# ========================================================

router.register(r"videos", VideoViewSet, basename="videos")
router.register(r"video-permissions", VideoPermissionViewSet, basename="video-permissions")
router.register(r"video-progress", VideoProgressViewSet, basename="video-progress")

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / ìƒì„¸ Video API
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="media-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="media-video-stats-nested",
    ),
]

# ëŒ€ì¶© ë¶™ì´ê¸°

# playback APIs (token-based)

from .views.playback_views import (
    PlaybackStartView,
    PlaybackRefreshView,
    PlaybackHeartbeatView,
    PlaybackEndView,
    PlaybackEventBatchView,
)

urlpatterns += [
    path("playback/start/", PlaybackStartView.as_view()),
    path("playback/refresh/", PlaybackRefreshView.as_view()),
    path("playback/heartbeat/", PlaybackHeartbeatView.as_view()),
    path("playback/end/", PlaybackEndView.as_view()),
    path("playback/events/", PlaybackEventBatchView.as_view()),
]


================================================================================
# FILE: utils.py
================================================================================
import ffmpeg


def extract_duration_seconds_from_url(url: str) -> int | None:
    """
    ffprobeë¥¼ URLì— ì§ì ‘ ì ìš© (Range Request ê¸°ë°˜)
    """
    try:
        probe = ffmpeg.probe(url)
        fmt = probe.get("format") or {}
        dur = fmt.get("duration")
        if dur is None:
            return None
        return int(float(dur))
    except Exception as e:
        print("duration ì¶”ì¶œ ì‹¤íŒ¨:", e)
        return None


def generate_thumbnail_from_url(
    url: str,
    ss_seconds: int = 1,
) -> bytes | None:
    """
    URL ìŠ¤íŠ¸ë¦¬ë° ê¸°ë°˜ ì¸ë„¤ì¼ ìƒì„± (ì „ì²´ ë‹¤ìš´ë¡œë“œ âŒ)
    """
    try:
        out, _ = (
            ffmpeg
            .input(url, ss=ss_seconds)
            .output(
                "pipe:",
                vframes=1,
                format="image2",
                vcodec="mjpeg",
            )
            .run(capture_stdout=True, capture_stderr=True)
        )
        return out
    except Exception as e:
        print("ì¸ë„¤ì¼ ìƒì„± ì‹¤íŒ¨:", e)
        return None


================================================================================
# FILE: cdn/__init__.py
================================================================================
# CDN helpers package


================================================================================
# FILE: cdn/cloudfront.py
================================================================================
import base64
import json
from typing import Dict
from django.conf import settings


# =========================
# Public API
# =========================

def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    DEV/LOCAL:
      - CloudFront ì‚¬ìš© ì•ˆ í•¨ â†’ ë¹ˆ dict ë°˜í™˜

    PROD:
      - CloudFront Signed Cookies ìƒì„±
    """
    if settings.DEBUG:
        return {}

    key_pair_id = _required("CLOUDFRONT_KEY_PAIR_ID")
    domain = _required("CLOUDFRONT_DOMAIN").rstrip("/")

    resource = f"https://{domain}{path_prefix}*"

    policy = {
        "Statement": [{
            "Resource": resource,
            "Condition": {
                "DateLessThan": {"AWS:EpochTime": int(expires_at)}
            }
        }]
    }

    policy_json = json.dumps(policy, separators=(",", ":")).encode("utf-8")

    from botocore.signers import CloudFrontSigner

    signer = CloudFrontSigner(key_pair_id, _rsa_signer)

    signed_policy = _b64_urlsafe(policy_json)
    signature = signer._sign(policy_json)

    return {
        "CloudFront-Policy": signed_policy,
        "CloudFront-Signature": _b64_urlsafe(signature),
        "CloudFront-Key-Pair-Id": key_pair_id,
    }


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    DEV: cookie ì„¤ì • ì•ˆ í•¨
    PROD: CloudFront ë„ë©”ì¸ ì¿ í‚¤ ì„¤ì •
    """
    if settings.DEBUG:
        return {}

    domain = _required("CLOUDFRONT_DOMAIN")

    secure = bool(getattr(settings, "SESSION_COOKIE_SECURE", False))

    return {
        "domain": domain,
        "path": path_prefix,
        "httponly": True,
        "secure": secure,
        "samesite": "Lax",
    }


# =========================
# Internal helpers
# =========================

def _required(name: str) -> str:
    v = getattr(settings, name, None)
    if not v:
        raise RuntimeError(f"Missing setting: {name}")
    return str(v)


def _load_private_key_pem() -> bytes:
    pem = _required("CLOUDFRONT_PRIVATE_KEY_PEM")
    pem = pem.replace("\\n", "\n")
    return pem.encode("utf-8")


def _rsa_signer(message: bytes) -> bytes:
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.primitives.asymmetric import padding

    key = load_pem_private_key(_load_private_key_pem(), password=None)
    return key.sign(message, padding.PKCS1v15(), hashes.SHA1())


def _b64_urlsafe(data: bytes) -> str:
    return (
        base64.b64encode(data)
        .decode("utf-8")
        .replace("+", "-")
        .replace("=", "_")
        .replace("/", "~")
    )


================================================================================
# FILE: migrations/0001_initial.py
================================================================================
# Generated by Django 5.2.9 on 2025-12-19 02:06

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("enrollment", "0001_initial"),
        ("lectures", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Video",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("title", models.CharField(max_length=255)),
                ("youtube_id", models.CharField(blank=True, max_length=100)),
                ("external_url", models.URLField(blank=True)),
                ("file", models.FileField(blank=True, upload_to="videos/%Y/%m/%d/")),
                (
                    "file_key",
                    models.CharField(
                        blank=True,
                        help_text="S3 object key (presigned upload)",
                        max_length=500,
                    ),
                ),
                ("duration", models.PositiveIntegerField(blank=True, null=True)),
                ("order", models.PositiveIntegerField(default=1)),
                (
                    "thumbnail",
                    models.ImageField(blank=True, null=True, upload_to="thumbnails/"),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("PENDING", "ì—…ë¡œë“œ ëŒ€ê¸°"),
                            ("UPLOADED", "ì—…ë¡œë“œ ì™„ë£Œ"),
                            ("PROCESSING", "ì²˜ë¦¬ì¤‘"),
                            ("READY", "ì‚¬ìš© ê°€ëŠ¥"),
                            ("FAILED", "ì‹¤íŒ¨"),
                        ],
                        db_index=True,
                        default="PENDING",
                        max_length=20,
                    ),
                ),
                ("allow_skip", models.BooleanField(default=False)),
                ("max_speed", models.FloatField(default=1.0)),
                ("show_watermark", models.BooleanField(default=True)),
                ("error_reason", models.TextField(blank=True, default="", null=True)),
                (
                    "session",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="videos",
                        to="lectures.session",
                    ),
                ),
            ],
            options={
                "ordering": ["order", "id"],
            },
        ),
        migrations.CreateModel(
            name="VideoPermission",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rule",
                    models.CharField(
                        choices=[
                            ("free", "ë¬´ì œí•œ"),
                            ("once", "1íšŒ ì œí•œ"),
                            ("blocked", "ì œí•œ"),
                        ],
                        default="once",
                        max_length=20,
                    ),
                ),
                ("allow_skip_override", models.BooleanField(blank=True, null=True)),
                ("max_speed_override", models.FloatField(blank=True, null=True)),
                ("show_watermark_override", models.BooleanField(blank=True, null=True)),
                ("block_speed_control", models.BooleanField(default=False)),
                ("block_seek", models.BooleanField(default=False)),
                ("is_override", models.BooleanField(default=False)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_permissions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="permissions",
                        to="media.video",
                    ),
                ),
            ],
            options={
                "constraints": [
                    models.UniqueConstraint(
                        fields=("video", "enrollment"), name="unique_video_permission"
                    )
                ],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("user_id", models.BigIntegerField(db_index=True)),
                (
                    "event_type",
                    models.CharField(
                        choices=[
                            ("VISIBILITY_HIDDEN", "íƒ­ ìˆ¨ê¹€"),
                            ("VISIBILITY_VISIBLE", "íƒ­ ë…¸ì¶œ"),
                            ("FOCUS_LOST", "í¬ì»¤ìŠ¤ ì´íƒˆ"),
                            ("FOCUS_GAINED", "í¬ì»¤ìŠ¤ ë³µê·€"),
                            ("SEEK_ATTEMPT", "íƒìƒ‰ ì‹œë„"),
                            ("SPEED_CHANGE_ATTEMPT", "ë°°ì† ë³€ê²½ ì‹œë„"),
                            ("FULLSCREEN_ENTER", "ì „ì²´í™”ë©´ ì§„ì…"),
                            ("FULLSCREEN_EXIT", "ì „ì²´í™”ë©´ ì¢…ë£Œ"),
                            ("PLAYER_ERROR", "í”Œë ˆì´ì–´ ì˜¤ë¥˜"),
                        ],
                        db_index=True,
                        max_length=32,
                    ),
                ),
                ("event_payload", models.JSONField(blank=True, default=dict)),
                ("policy_snapshot", models.JSONField(blank=True, default=dict)),
                ("violated", models.BooleanField(db_index=True, default=False)),
                (
                    "violation_reason",
                    models.CharField(blank=True, default="", max_length=64),
                ),
                (
                    "occurred_at",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                ("received_at", models.DateTimeField(auto_now_add=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_playback_events",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_events",
                        to="media.video",
                    ),
                ),
            ],
            options={
                "ordering": ["-received_at", "-id"],
                "indexes": [
                    models.Index(
                        fields=["video", "enrollment", "session_id"],
                        name="media_video_video_i_39e1b5_idx",
                    ),
                    models.Index(
                        fields=["user_id", "session_id"],
                        name="media_video_user_id_b29204_idx",
                    ),
                    models.Index(
                        fields=["event_type", "received_at"],
                        name="media_video_event_t_cf6a6f_idx",
                    ),
                ],
            },
        ),
        migrations.CreateModel(
            name="VideoPlaybackSession",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("session_id", models.CharField(db_index=True, max_length=64)),
                ("device_id", models.CharField(db_index=True, max_length=128)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("ACTIVE", "í™œì„±"),
                            ("ENDED", "ì¢…ë£Œ"),
                            ("REVOKED", "ì°¨ë‹¨"),
                            ("EXPIRED", "ë§Œë£Œ"),
                        ],
                        db_index=True,
                        default="ACTIVE",
                        max_length=16,
                    ),
                ),
                ("started_at", models.DateTimeField(auto_now_add=True)),
                ("ended_at", models.DateTimeField(blank=True, null=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="playback_sessions",
                        to="media.video",
                    ),
                ),
            ],
            options={
                "constraints": [
                    models.UniqueConstraint(
                        fields=("session_id",), name="uniq_video_playback_session_id"
                    )
                ],
            },
        ),
        migrations.CreateModel(
            name="VideoProgress",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("progress", models.FloatField(default=0)),
                ("last_position", models.IntegerField(default=0)),
                ("completed", models.BooleanField(default=False)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "enrollment",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="video_progress",
                        to="enrollment.enrollment",
                    ),
                ),
                (
                    "video",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="progresses",
                        to="media.video",
                    ),
                ),
            ],
            options={
                "constraints": [
                    models.UniqueConstraint(
                        fields=("video", "enrollment"), name="unique_video_progress"
                    )
                ],
            },
        ),
    ]


================================================================================
# FILE: migrations/0002_remove_video_external_url_remove_video_file_and_more.py
================================================================================
# Generated by Django 5.2.9 on 2025-12-22 23:19

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("media", "0001_initial"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="video",
            name="external_url",
        ),
        migrations.RemoveField(
            model_name="video",
            name="file",
        ),
        migrations.RemoveField(
            model_name="video",
            name="youtube_id",
        ),
        migrations.AddField(
            model_name="video",
            name="hls_path",
            field=models.CharField(
                blank=True,
                help_text="HLS master playlist path (relative to CDN root)",
                max_length=500,
            ),
        ),
    ]


================================================================================
# FILE: migrations/__init__.py
================================================================================



================================================================================
# FILE: services/__init__.py
================================================================================



================================================================================
# FILE: services/playback_session.py
================================================================================
import time
import uuid
from typing import Dict, Any, Tuple, Iterable

from django.conf import settings
from django.utils import timezone

from libs.redis_client.client import redis_client

from apps.domains.enrollment.models import Enrollment
from apps.support.media.models import (
    Video,
    VideoPlaybackSession,
)

# =======================================================
# Redis Key Helpers
# =======================================================

def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    # zset (session_id -> expires_at)
    return f"media:playback:user:{user_id}:sessions"


def _key_session(session_id: str) -> str:
    # hash
    return f"media:playback:session:{session_id}"


def _key_user_devices(user_id: int) -> str:
    # set
    return f"media:playback:user:{user_id}:devices"


# =======================================================
# Decode Helpers (bytes/str ë°©ì–´)
# =======================================================

def _decode(value):
    if value is None:
        return None
    if isinstance(value, (bytes, bytearray)):
        return value.decode()
    return value


def _decode_set(values: Iterable) -> set[str]:
    return {_decode(v) for v in (values or set())}


# =======================================================
# Internal Helpers
# =======================================================

def _cleanup_expired_sessions(user_id: int) -> None:
    """
    ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬
    - session zset
    - session hash
    - device set (ëˆ„ìˆ˜ ë°©ì§€)
    """
    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expired = redis_client.zrangebyscore(sessions_key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)

    for raw_sid in expired:
        sid = _decode(raw_sid)

        device_id = _decode(
            redis_client.hget(_key_session(sid), "device_id")
        )
        if device_id:
            pipe.srem(devices_key, device_id)

        pipe.zrem(sessions_key, sid)
        pipe.delete(_key_session(sid))

    pipe.execute()


# =======================================================
# Core Session APIs (Redis / Infra)
# =======================================================

def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    """
    Redis ê¸°ë°˜ ì¬ìƒ ì„¸ì…˜ ë°œê¸‰ (ê³µí†µ Infra)
    """
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = _decode_set(
        redis_client.smembers(devices_key)
    )

    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)

    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(
        _key_session(session_id),
        mapping={
            "user_id": str(user_id),
            "device_id": device_id,
            "expires_at": str(expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)

    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    """
    ì„¸ì…˜ TTL ì—°ì¥
    - user_id ì†Œìœ  ê²€ì¦ í¬í•¨
    """
    session_id = _decode(session_id)
    sid_key = _key_session(session_id)
    sessions_key = _key_user_sessions(user_id)

    owner = _decode(redis_client.hget(sid_key, "user_id"))
    if not owner or int(owner) != int(user_id):
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(
        sid_key,
        mapping={
            "expires_at": str(new_expires_at),
            "last_seen": str(now),
        },
    )
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)
    pipe.execute()

    return True


def end_session(*, user_id: int, session_id: str) -> None:
    """
    ëª…ì‹œì  ì„¸ì…˜ ì¢…ë£Œ
    """
    session_id = _decode(session_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)
    sid_key = _key_session(session_id)

    device_id = _decode(redis_client.hget(sid_key, "device_id"))

    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(sid_key)

    if device_id:
        pipe.srem(devices_key, device_id)

    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    """
    ì„¸ì…˜ í™œì„± ì—¬ë¶€ í™•ì¸
    """
    session_id = _decode(session_id)
    sessions_key = _key_user_sessions(user_id)

    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False

    return int(score) > _now()


# =======================================================
# Facade API (Student ONLY)
# =======================================================

def create_playback_session(*, user, video_id: int, enrollment_id: int) -> dict:
    """
    í•™ìƒ ì „ìš© Facade API

    ì±…ì„:
    - "ì¬ìƒ ì„¸ì…˜ ìƒì„±"ë§Œ ë‹´ë‹¹
    - ê¶Œí•œ / ìˆ˜ê°• ê²€ì¦ì€ ë°˜ë“œì‹œ Viewì—ì„œ ì„ í–‰ë˜ì–´ì•¼ í•¨

    âš ï¸ ì£¼ì˜
    - ì´ í•¨ìˆ˜ëŠ” Facade View ì „ìš©ì´ë‹¤.
    - ë‹¤ë¥¸ View / Task / Scriptì—ì„œ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ë§ ê²ƒ.
    """

    # ğŸš« ê°•ì‚¬ / ìš´ì˜ì ì°¨ë‹¨
    if getattr(user, "is_instructor", False) or getattr(user, "is_staff", False):
        return {
            "ok": False,
            "error": "instructor_must_use_play_api",
        }

    video = Video.objects.select_related(
        "session",
        "session__lecture",
    ).get(id=video_id)

    enrollment = Enrollment.objects.select_related(
        "student",
        "lecture",
    ).get(
        id=enrollment_id,
        status="ACTIVE",
    )

    # ğŸ›¡ï¸ ì•ˆì „ ê°€ë“œ (View ëˆ„ë½ ë°©ì§€ìš©, ì •ìƒ ê²½ë¡œì—ì„œëŠ” í•­ìƒ í†µê³¼)
    if enrollment.lecture_id != video.session.lecture_id:
        return {
            "ok": False,
            "error": "enrollment_lecture_mismatch",
        }

    ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

    # Facade ì „ìš© ë…¼ë¦¬ device
    device_id = f"facade:{uuid.uuid4()}"

    ok, sess, err = issue_session(
        user_id=user.id,
        device_id=device_id,
        ttl_seconds=ttl,
        max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
        max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
    )

    if not ok:
        return {
            "ok": False,
            "error": err,
        }

    session_id = str(sess["session_id"])
    expires_at = int(sess["expires_at"])

    VideoPlaybackSession.objects.create(
        video=video,
        enrollment=enrollment,
        session_id=session_id,
        device_id=device_id,
        status=VideoPlaybackSession.Status.ACTIVE,
        started_at=timezone.now(),
    )

    return {
        "ok": True,
        "video_id": video.id,
        "enrollment_id": enrollment.id,
        "session_id": session_id,
        "expires_at": expires_at,
    }


================================================================================
# FILE: views/__init__.py
================================================================================
# apps/support/media/views/__init__.py

from .video_views import VideoViewSet
from .permission_views import VideoPermissionViewSet
from .progress_views import VideoProgressViewSet
from .playback_session_views import PlaybackSessionView
from .internal_views import VideoProcessingCompleteView


================================================================================
# FILE: views/internal_views.py
================================================================================
# apps/support/media/views/internal_views.py


from django.conf import settings
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response


class VideoProcessingCompleteView(APIView):
    """
    worker â†’ API ACK
    """
    permission_classes = [AllowAny]

    def post(self, request, video_id: int):
        token = request.headers.get("X-Worker-Token")
        if token != settings.INTERNAL_WORKER_TOKEN:
            return Response(status=403)

        return Response({"status": "ack"}, status=200)


================================================================================
# FILE: views/permission_views.py
================================================================================
# apps/support/media/views/permission_views.py

# test change

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status

from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoPermission
from ..serializers import VideoPermissionSerializer


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    @action(detail=False, methods=["post"], url_path="bulk-set")
    def bulk_set(self, request):
        """
        payload:
        {
          "video": 1,
          "enrollments": [3,4,5],
          "rule": "blocked"
        }
        """
        video_id = request.data.get("video")
        enrollments = request.data.get("enrollments", [])
        rule = request.data.get("rule")

        if not video_id or not enrollments or not rule:
            return Response(
                {"detail": "video, enrollments, rule required"},
                status=400,
            )

        objs = []
        for enrollment_id in enrollments:
            obj, _ = VideoPermission.objects.update_or_create(
                video_id=video_id,
                enrollment_id=enrollment_id,
                defaults={"rule": rule},
            )
            objs.append(obj)

        return Response(
            VideoPermissionSerializer(objs, many=True).data,
            status=status.HTTP_200_OK,
        )


================================================================================
# FILE: views/playback_mixin.py
================================================================================
import time

from django.conf import settings
from rest_framework.response import Response

from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.lectures.models import Session

from ..models import Video, VideoPermission, VideoProgress
from ..serializers import VideoSerializer
from ..drm import create_playback_token, verify_playback_token
from ..cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options


class VideoPlaybackMixin:
    """
    ì¬ìƒ ê¶Œí•œ / ì •ì±… / ê³µí†µ ë¡œì§

    ì •ì±… ì •ì˜:
    - free    : í•­ìƒ ë¬´ì œí•œ
    - once    : 1íšŒì°¨ì—ë§Œ ì •ì±… ì ìš©, ì™„ë£Œ í›„ freeë¡œ ìŠ¹ê²©ë¨
    - blocked : í•­ìƒ ì°¨ë‹¨
    """

    def _get_student_for_user(self, request):
        return getattr(request.user, "student_profile", None)

    # ==================================================
    # ì ‘ê·¼ ì œì–´ (Access Control)
    # ==================================================
    def _check_access(self, *, video, enrollment):
        """
        ì ‘ê·¼ ê°€ëŠ¥ ì—¬ë¶€ë§Œ íŒë‹¨í•œë‹¤.
        onceëŠ” ì ‘ê·¼ì„ ì°¨ë‹¨í•˜ì§€ ì•ŠëŠ”ë‹¤.
        """
        if video.status != video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        # free / once ëª¨ë‘ ì ‘ê·¼ í—ˆìš©
        return True, None

    # ==================================================
    # Permission Loader
    # ==================================================
    def _load_permission(self, *, video, enrollment):
        return VideoPermission.objects.filter(
            video=video,
            enrollment=enrollment,
        ).first()

    # ==================================================
    # Playback Policy
    # ==================================================
    def _effective_policy(self, *, video, perm):
        """
        ì‹¤ì œ ì¬ìƒ ì œì•½ ì •ì±… ê³„ì‚°
        - once : ì™„ë£Œ ì „ê¹Œì§€ íƒìƒ‰ ì œí•œ
        - ì™„ë£Œ í›„ì—ëŠ” freeì™€ ë™ì¼
        """
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        seek_policy = {
            "mode": "free",
            "forward_limit": None,
            "grace_seconds": 3,
        }

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)

            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if perm.rule == "once":
                completed = VideoProgress.objects.filter(
                    video=video,
                    enrollment=perm.enrollment,
                    completed=True,
                ).exists()

                if not completed:
                    seek_policy = {
                        "mode": "bounded_forward",
                        "forward_limit": "max_watched",
                        "grace_seconds": 3,
                    }

            if perm.block_seek:
                allow_seek = False
                seek_policy = {"mode": "blocked"}

            if perm.block_speed_control:
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "seek": seek_policy,
            "playback_rate": {
                "max": max_rate,
                "ui_control": ui_speed_control,
            },
            "watermark": {
                "enabled": watermark_enabled,
                "mode": "overlay",
                "fields": ["user_id"],
            },
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    # ==================================================
    # HLS / CDN
    # ==================================================
    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _public_play_url(self, video_id: int) -> str:
        cdn_base = settings.CDN_HLS_BASE_URL.rstrip("/")
        return f"{cdn_base}/media/hls/videos/{video_id}/master.m3u8"

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int):
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix, expires_at)
        opts = default_cookie_options(path_prefix)

        max_age = max(0, expires_at - int(time.time()))
        for k, v in cookies.items():
            response.set_cookie(k, v, max_age=max_age, **opts)

    # ==================================================
    # í•™ìƒ ì˜ìƒ ëª©ë¡ (ì¬ìƒ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨)
    # ==================================================
    def _student_list_impl(self, request):
        session_id = request.query_params.get("session")
        if not session_id:
            return Response({"detail": "session is required"}, status=400)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        qs = Video.objects.filter(
            session_id=session_id,
            status=Video.Status.READY,
        ).order_by("order", "id")

        session = Session.objects.select_related("lecture").get(id=session_id)
        lecture = session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        data = []
        for v in qs:
            d = VideoSerializer(v).data

            if not enrollment:
                d["can_play"] = False
                d["reason"] = "not_enrolled"
                data.append(d)
                continue

            if not SessionEnrollment.objects.filter(
                session=session,
                enrollment=enrollment,
            ).exists():
                d["can_play"] = False
                d["reason"] = "no_session_access"
                data.append(d)
                continue

            ok, reason = self._check_access(video=v, enrollment=enrollment)
            d["can_play"] = bool(ok)
            d["reason"] = reason if not ok else None
            data.append(d)

        return Response(data)


================================================================================
# FILE: views/playback_session_views.py
================================================================================
# apps/support/media/views/playback_session_views.py

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from django.shortcuts import get_object_or_404
from rest_framework.exceptions import PermissionDenied, ValidationError

from ..models import Video
from ..serializers import PlaybackSessionSerializer
from ..services.playback_session import create_playback_session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment


class PlaybackSessionView(APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        student = request.user.student_profile
        video_id = request.data.get("video_id")

        if not video_id:
            raise ValidationError("video_id is required")

        video = get_object_or_404(Video, id=video_id)
        lecture = video.session.lecture

        enrollment = Enrollment.objects.filter(
            student=student,
            lecture=lecture,
            status="ACTIVE",
        ).first()

        if not enrollment:
            raise PermissionDenied("Not enrolled")

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            raise PermissionDenied("No session access")

        result = create_playback_session(
            user=request.user,
            video_id=video.id,
            enrollment_id=enrollment.id,
        )

        if not result.get("ok"):
            return Response({"detail": result["error"]}, status=409)

        return Response(PlaybackSessionSerializer(result).data, status=201)


================================================================================
# FILE: views/playback_views.py
================================================================================
# apps/support/media/views/playback_views.py

import time

from django.conf import settings
from django.utils import timezone

from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from apps.core.permissions import IsStudent
from apps.domains.enrollment.models import Enrollment, SessionEnrollment

from ..models import (
    Video,
    VideoPlaybackSession,
    VideoPlaybackEvent,
    VideoProgress,
    VideoPermission,
)
from ..serializers import (
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)
from ..drm import create_playback_token, verify_playback_token
from ..services.playback_session import (
    issue_session,
    heartbeat_session,
    end_session,
    is_session_active,
)
from .playback_mixin import VideoPlaybackMixin


# ==========================================================
# Playback Start
# ==========================================================

class PlaybackStartView(VideoPlaybackMixin, APIView):
    permission_classes = [IsAuthenticated, IsStudent]

    def post(self, request):
        serializer = PlaybackStartRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        enrollment_id = serializer.validated_data["enrollment_id"]
        device_id = serializer.validated_data["device_id"]

        enrollment = Enrollment.objects.select_related(
            "student",
            "lecture",
        ).get(id=enrollment_id, status="ACTIVE")

        video = Video.objects.select_related(
            "session",
            "session__lecture",
        ).get(id=request.data.get("video_id"))

        # ìˆ˜ê°• ê²€ì¦
        if enrollment.lecture_id != video.session.lecture_id:
            return Response({"detail": "enrollment_mismatch"}, status=403)

        if not SessionEnrollment.objects.filter(
            session=video.session,
            enrollment=enrollment,
        ).exists():
            return Response({"detail": "no_session_access"}, status=403)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return Response({"detail": reason}, status=403)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
            max_devices=int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
        )

        if not ok:
            return Response({"detail": err}, status=409)

        session_id = sess["session_id"]
        expires_at = sess["expires_at"]

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
            started_at=timezone.now(),
        )

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        token = create_playback_token(
            payload={
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "session_id": session_id,
                "user_id": request.user.id,
            },
            ttl_seconds=ttl,
        )

        play_url = self._public_play_url(video.id)

        resp = Response(
            PlaybackResponseSerializer({
                "token": token,
                "session_id": session_id,
                "expires_at": expires_at,
                "policy": policy,
                "play_url": play_url,
            }).data,
            status=201,
        )

        self._set_signed_cookies(resp, video_id=video.id, expires_at=expires_at)
        return resp


# ==========================================================
# Playback Refresh
# ==========================================================

class PlaybackRefreshView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackRefreshRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return Response({"detail": err}, status=403)

        if not is_session_active(
            user_id=payload["user_id"],
            session_id=payload["session_id"],
        ):
            return Response({"detail": "session_inactive"}, status=409)

        return Response({"ok": True})


# ==========================================================
# Playback Heartbeat
# ==========================================================

class PlaybackHeartbeatView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackHeartbeatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return Response({"detail": err}, status=403)

        heartbeat_session(
            user_id=payload["user_id"],
            session_id=payload["session_id"],
            ttl_seconds=int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600)),
        )

        return Response({"ok": True})


# ==========================================================
# Playback End
# ==========================================================

class PlaybackEndView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEndRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return Response({"detail": err}, status=403)

        end_session(
            user_id=payload["user_id"],
            session_id=payload["session_id"],
        )

        VideoPlaybackSession.objects.filter(
            session_id=payload["session_id"]
        ).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        return Response({"ok": True})


# ==========================================================
# Event Batch (audit-only)
# ==========================================================

class PlaybackEventBatchView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = PlaybackEventBatchRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        ok, payload, err = verify_playback_token(serializer.validated_data["token"])
        if not ok:
            return Response({"detail": err}, status=403)

        events = serializer.validated_data["events"]
        stored = 0

        for e in events:
            VideoPlaybackEvent.objects.create(
                video_id=payload["video_id"],
                enrollment_id=payload["enrollment_id"],
                session_id=payload["session_id"],
                user_id=payload["user_id"],
                event_type=e["type"],
                event_payload=e.get("payload", {}),
                occurred_at=timezone.now(),
            )
            stored += 1

        return Response(
            PlaybackEventBatchResponseSerializer({"stored": stored}).data,
            status=201,
        )


================================================================================
# FILE: views/progress_views.py
================================================================================
# apps/support/media/views/progress_views.py

from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from ..models import VideoProgress, VideoPermission
from ..serializers import VideoProgressSerializer


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]

    def perform_update(self, serializer):
        vp = serializer.instance
        prev_completed = vp.completed

        vp = serializer.save()

        # ğŸ”¥ once â†’ free ìë™ ìŠ¹ê²© (completed False â†’ True ìˆœê°„)
        if not prev_completed and vp.completed:
            VideoPermission.objects.filter(
                video=vp.video,
                enrollment=vp.enrollment,
                rule="once",
            ).update(
                rule="free",
                is_override=False,
            )


================================================================================
# FILE: views/video_views.py
================================================================================
# apps/support/media/views/video_views.py

from uuid import uuid4

from django.conf import settings
from django.db import models, transaction
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from rest_framework.parsers import JSONParser
from django_filters.rest_framework import DjangoFilterBackend

from rest_framework_simplejwt.authentication import JWTAuthentication

from libs.s3_client.presign import create_presigned_put_url
from libs.s3_client.client import head_object

from apps.core.permissions import IsAdminOrStaff, IsStudent
from apps.core.authentication import CsrfExemptSessionAuthentication

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from apps.shared.tasks.media import process_video_media

from ..models import Video, VideoPermission, VideoProgress
from ..serializers import VideoSerializer, VideoDetailSerializer
from .playback_mixin import VideoPlaybackMixin


class VideoViewSet(VideoPlaybackMixin, ModelViewSet):
    """
    Video ê´€ë¦¬ + í†µê³„ + í•™ìƒ ëª©ë¡
    """

    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer
    parser_classes = [JSONParser]

    authentication_classes = [
        JWTAuthentication,
        CsrfExemptSessionAuthentication,
    ]
    permission_classes = [IsAuthenticated]

    ADMIN_ONLY_ACTIONS = {
        "upload_init",
        "upload_complete",
        "retry",
        "create",
        "update",
        "partial_update",
        "destroy",
    }

    def get_permissions(self):
        if self.action in self.ADMIN_ONLY_ACTIONS:
            return [IsAuthenticated(), IsAdminOrStaff()]
        return [IsAuthenticated()]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # ==================================================
    # upload/init
    # ==================================================
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="upload/init")
    def upload_init(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        filename = request.data.get("filename")

        allow_skip = bool(request.data.get("allow_skip", False))
        max_speed = float(request.data.get("max_speed", 1.0) or 1.0)
        show_watermark = bool(request.data.get("show_watermark", True))

        if not session_id or not title or not filename:
            return Response({"detail": "session, title, filename required"}, status=400)

        session = Session.objects.get(id=session_id)
        order = (session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0) + 1

        ext = filename.split(".")[-1].lower() if "." in filename else "mp4"
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=key,
            order=order,
            status=Video.Status.PENDING,
            allow_skip=allow_skip,
            max_speed=max_speed,
            show_watermark=show_watermark,
        )

        content_type = (request.data.get("content_type") or "video/mp4").split(";")[0]

        upload_url = create_presigned_put_url(key=key, content_type=content_type)

        return Response(
            {
                "video": VideoSerializer(video).data,
                "upload_url": upload_url,
                "file_key": key,
                "content_type": content_type,
            },
            status=201,
        )

    # ==================================================
    # upload/complete
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="upload/complete")
    def upload_complete(self, request, pk=None):
        video = self.get_object()

        if video.status != Video.Status.PENDING:
            return Response({"detail": f"Invalid status: {video.status}"}, status=409)

        exists, size = head_object(video.file_key)
        if not exists or size == 0:
            return Response({"detail": "S3 object not found"}, status=409)

        video.status = Video.Status.UPLOADED
        video.save(update_fields=["status"])

        process_video_media.delay(video.id)
        return Response(VideoSerializer(video).data)

    # ==================================================
    # retry
    # ==================================================
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response({"detail": "Cannot retry"}, status=400)

        process_video_media.delay(video.id)
        return Response({"detail": "Video reprocessing started"}, status=202)

    # ==================================================
    # stats
    # ==================================================
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(lecture=lecture)
        progresses = {p.enrollment_id: p for p in VideoProgress.objects.filter(video=video)}
        perms = {p.enrollment_id: p for p in VideoPermission.objects.filter(video=video)}
        attendance = {
            a.enrollment_id: a.status
            for a in Attendance.objects.filter(session=video.session)
        }

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)
            students.append({
                "student_name": e.student.name,
                "progress": vp.progress if vp else 0,
                "completed": vp.completed if vp else False,
                "attendance_status": attendance.get(e.id),
                "rule": perm.rule if perm else "free",
            })

        return Response({
            "video": VideoDetailSerializer(video).data,
            "students": students,
        })

    # ==================================================
    # student list
    # ==================================================
    @action(detail=False, methods=["get"], url_path="student", permission_classes=[IsAuthenticated, IsStudent])
    def student_list(self, request):
        return self._student_list_impl(request)
