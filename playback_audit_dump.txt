

====================
FILE: C:\academy\apps\support\media\views.py
====================

import os
import time
from datetime import datetime
from uuid import uuid4

from django.conf import settings
from django.db import models, transaction
from django.http import FileResponse, Http404
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.permissions import IsAuthenticated

from libs.s3_client.presign import create_presigned_put_url
from libs.s3_client.client import head_object

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from .serializers import (
    VideoSerializer,
    VideoDetailSerializer,
    VideoPermissionSerializer,
    VideoProgressSerializer,
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)

from apps.shared.tasks.media import process_video_media

from .drm import create_playback_token, verify_playback_token
from .services.playback_session import issue_session, heartbeat_session, end_session, is_session_active
from .cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options


class VideoViewSet(ModelViewSet):
    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer
    parser_classes = [MultiPartParser, FormParser, JSONParser]
    permission_classes = [IsAuthenticated]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # --------------------------------------------------
    # Legacy local upload (?좎?)
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="upload")
    def upload(self, request):
        session_id = request.data.get("session")
        files = request.FILES.getlist("files")

        session = Session.objects.get(id=session_id)
        base_order = session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0

        created = []
        for idx, f in enumerate(files, start=1):
            created.append(
                Video.objects.create(
                    session=session,
                    title=os.path.splitext(f.name)[0],
                    file=f,
                    order=base_order + idx,
                    status=Video.Status.READY,
                )
            )

        return Response(VideoSerializer(created, many=True).data, status=201)

    # --------------------------------------------------
    # Presigned URL 諛쒓툒
    # --------------------------------------------------
    @action(detail=False, methods=["post"], url_path="presign")
    def presign(self, request):
        session_id = request.data.get("session")
        filename = request.data.get("filename")

        if not session_id or not filename:
            return Response({"detail": "session, filename required"}, status=status.HTTP_400_BAD_REQUEST)

        ext = filename.split(".")[-1]
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        upload_url = create_presigned_put_url(key=key, content_type="video/mp4")

        return Response({"upload_url": upload_url, "file_key": key})

    # --------------------------------------------------
    # ?낅줈???꾨즺 + S3 寃利?+ Worker ?몃━嫄?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="complete")
    def complete(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        file_key = request.data.get("file_key")

        if not all([session_id, title, file_key]):
            return Response({"detail": "session, title, file_key required"}, status=status.HTTP_400_BAD_REQUEST)

        exists, size = head_object(file_key)
        if not exists or size == 0:
            return Response({"detail": "S3 object not found"}, status=status.HTTP_409_CONFLICT)

        session = Session.objects.get(id=session_id)

        order = (session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0) + 1

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=file_key,
            order=order,
            status=Video.Status.UPLOADED,
        )

        transaction.on_commit(lambda: process_video_media.delay(video.id))

        return Response(VideoSerializer(video).data, status=201)

    # --------------------------------------------------
    # FAILED ?곸긽 ?ъ쿂由?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response({"detail": f"Cannot retry video in status {video.status}"}, status=status.HTTP_400_BAD_REQUEST)

        transaction.on_commit(lambda: process_video_media.delay(video.id))
        return Response({"detail": "Video reprocessing started"}, status=status.HTTP_202_ACCEPTED)

    # --------------------------------------------------
    # Download (legacy)
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="download")
    def download(self, request, pk=None):
        video = self.get_object()
        if not video.file:
            raise Http404
        return FileResponse(video.file.open("rb"), as_attachment=True)

    # --------------------------------------------------
    # Stats
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(lecture=lecture)
        progresses = {p.enrollment_id: p for p in VideoProgress.objects.filter(video=video)}
        perms = {p.enrollment_id: p for p in VideoPermission.objects.filter(video=video)}
        attendance = {a.enrollment_id: a.status for a in Attendance.objects.filter(session=video.session)}

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            students.append({
                "student_name": e.student.name,
                "progress": vp.progress if vp else 0,
                "completed": vp.completed if vp else False,
                "attendance_status": attendance.get(e.id),
                "rule": perm.rule if perm else "free",
            })

        return Response({"video": VideoDetailSerializer(video).data, "students": students})

    # =======================================================
    # Playback API (v1 + CDN Signed Cookie + ?뺤콉 override)
    # =======================================================

    def _get_student_for_user(self, request):
        # Student.user (OneToOne, related_name="student_profile") 媛 ?덉뼱????
        return getattr(request.user, "student_profile", None)

    def _check_access(self, *, video: Video, enrollment: Enrollment) -> tuple[bool, str | None]:
        if video.status != Video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(session=video.session, enrollment=enrollment).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()
        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        if rule == "once":
            vp = VideoProgress.objects.filter(video=video, enrollment=enrollment).first()
            if vp and vp.completed:
                return False, "already_completed_once"

        return True, None

    def _load_permission(self, *, video: Video, enrollment: Enrollment) -> VideoPermission | None:
        return VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

    def _effective_policy(self, *, video: Video, perm: VideoPermission | None) -> dict:
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)
            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if getattr(perm, "block_seek", False):
                allow_seek = False

            if getattr(perm, "block_speed_control", False):
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "playback_rate": {"max": max_rate, "ui_control": ui_speed_control},
            "watermark": {"enabled": watermark_enabled, "mode": "overlay", "fields": ["user_id"]},
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _public_play_url(self, video_id: int) -> str:
        cdn_base = getattr(settings, "CDN_HLS_BASE_URL", "").rstrip("/")
        path = f"/hls/videos/{video_id}/master.m3u8"
        return f"{cdn_base}{path}" if cdn_base else path

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int) -> None:
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, int(expires_at - int(time.time())))
        for k, v in cookies.items():
            response.set_cookie(
                key=k,
                value=v,
                max_age=max_age,
                expires=None,
                **opts,
            )

    @action(detail=True, methods=["post"], url_path="play")
    def play(self, request, pk=None):
        video = self.get_object()

        req = PlaybackStartRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        enrollment_id = req.validated_data["enrollment_id"]
        device_id = req.validated_data["device_id"]

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.select_related("student", "lecture").get(
                id=enrollment_id,
                student=student,
                status="ACTIVE",
            )
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        max_sessions = int(policy["concurrency"]["max_sessions"])
        max_devices = int(policy["concurrency"]["max_devices"])

        ok_sess, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=max_sessions,
            max_devices=max_devices,
        )
        if not ok_sess:
            return Response({"detail": err}, status=409)

        session_id = str(sess["session_id"])
        expires_at = int(sess["expires_at"])

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
        )

        token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        resp = PlaybackResponseSerializer({
            "token": token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })

        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="refresh")
    def refresh(self, request, pk=None):
        video = self.get_object()

        req = PlaybackRefreshRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        device_id = str(payload.get("device_id") or "")
        enrollment_id = int(payload.get("enrollment_id") or 0)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        new_token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        expires_at = int(time.time()) + ttl

        resp = PlaybackResponseSerializer({
            "token": new_token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })
        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="heartbeat")
    def heartbeat(self, request, pk=None):
        req = PlaybackHeartbeatRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        return Response({"status": "ok"}, status=200)

    @action(detail=True, methods=["post"], url_path="end")
    def end(self, request, pk=None):
        req = PlaybackEndRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        end_session(user_id=request.user.id, session_id=session_id)

        VideoPlaybackSession.objects.filter(session_id=session_id).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        response = Response({"status": "ended"}, status=200)

        path_prefix = self._hls_path_prefix_for_video(int(pk))
        opts = default_cookie_options(path_prefix=path_prefix)

        response.delete_cookie("CloudFront-Policy", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Signature", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Key-Pair-Id", domain=opts.get("domain"), path=opts.get("path"))
        return response

    # =======================================================
    # Events API (v1: audit-only)
    # POST /media/videos/{id}/events/
    # =======================================================

    def _epoch_to_dt(self, epoch: int | None) -> datetime:
        if not epoch:
            return timezone.now()
        try:
            return datetime.fromtimestamp(int(epoch), tz=timezone.get_current_timezone())
        except Exception:
            return timezone.now()

    def _evaluate_violation(self, *, event_type: str, payload: dict, policy: dict) -> tuple[bool, str]:
        """
        v1: ?먮떒留???? 李⑤떒/?쒖옱???섏? ?딅뒗??
        """
        if event_type == VideoPlaybackEvent.EventType.SEEK_ATTEMPT:
            if not bool(policy.get("allow_seek", False)):
                return True, "seek_not_allowed"

        if event_type == VideoPlaybackEvent.EventType.SPEED_CHANGE_ATTEMPT:
            pr = policy.get("playback_rate") or {}
            ui_control = bool(pr.get("ui_control", True))
            max_rate = float(pr.get("max", 1.0) or 1.0)

            to_rate = payload.get("to")
            try:
                to_rate = float(to_rate)
            except Exception:
                to_rate = None

            if not ui_control:
                return True, "speed_control_disabled"
            if to_rate is not None and to_rate > max_rate:
                return True, "speed_exceeds_max"

        return False, ""

    @action(detail=True, methods=["post"], url_path="events")
    def events(self, request, pk=None):
        """
        Batch ?대깽???섏쭛(媛먯궗 濡쒓렇).
        - token?쇰줈 video/enrollment/user/session??媛뺥븯寃??곌퀎
        - DB??payload + policy snapshot + violated ?먯젙 ???
        """
        video = self.get_object()

        req = PlaybackEventBatchRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        token = req.validated_data["token"]
        events = req.validated_data["events"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        enrollment_id = int(payload.get("enrollment_id") or 0)
        session_id = str(payload.get("session_id") or "")

        if not is_session_active(user_id=request.user.id, session_id=session_id):
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        rows: list[VideoPlaybackEvent] = []
        for ev in events:
            ev_type = ev.get("type")
            ev_payload = ev.get("payload") or {}
            occurred_at_epoch = ev.get("occurred_at")

            violated, reason = self._evaluate_violation(
                event_type=ev_type,
                payload=ev_payload,
                policy=policy,
            )

            rows.append(
                VideoPlaybackEvent(
                    video=video,
                    enrollment=enrollment,
                    session_id=session_id,
                    user_id=request.user.id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy,
                    violated=violated,
                    violation_reason=reason,
                    occurred_at=self._epoch_to_dt(occurred_at_epoch),
                )
            )

        if rows:
            VideoPlaybackEvent.objects.bulk_create(rows, batch_size=500)

        resp = PlaybackEventBatchResponseSerializer({"stored": len(rows)})
        return Response(resp.data, status=200)


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


====================
FILE: C:\academy\apps\support\media\urls.py
====================

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
)

router = DefaultRouter()

# ========================================================
# Video
# ========================================================

router.register(r"videos", VideoViewSet, basename="videos")
router.register(
    r"video-permissions",
    VideoPermissionViewSet,
    basename="video-permissions",
)
router.register(
    r"video-progress",
    VideoProgressViewSet,
    basename="video-progress",
)

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / ?곸꽭 Video API
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="media-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="media-video-stats-nested",
    ),
]


====================
FILE: C:\academy\apps\support\media\services\playback_session.py
====================

import time
import uuid
from typing import Dict, Any, Tuple

from libs.redis_client.client import redis_client


def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:sessions"  # zset (sid -> expires_at)


def _key_session(session_id: str) -> str:
    return f"media:playback:session:{session_id}"     # hash


def _key_user_devices(user_id: int) -> str:
    return f"media:playback:user:{user_id}:devices"   # set


def _cleanup_expired_sessions(user_id: int) -> None:
    key = _key_user_sessions(user_id)
    now = _now()

    expired = redis_client.zrangebyscore(key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)
    for sid in expired:
        pipe.zrem(key, sid)
        pipe.delete(_key_session(str(sid)))
    pipe.execute()


def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = redis_client.smembers(devices_key) or set()
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(_key_session(session_id), mapping={
        "user_id": str(user_id),
        "device_id": device_id,
        "expires_at": str(expires_at),
        "last_seen": str(now),
    })
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)
    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    sessions_key = _key_user_sessions(user_id)
    sid_key = _key_session(session_id)

    raw = redis_client.hget(sid_key, "expires_at")
    if not raw:
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(sid_key, mapping={"expires_at": str(new_expires_at), "last_seen": str(now)})
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)
    pipe.execute()
    return True


def end_session(*, user_id: int, session_id: str) -> None:
    sessions_key = _key_user_sessions(user_id)
    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False
    return int(score) > _now()


====================
FILE: C:\academy\apps\support\media\serializers.py
====================

from rest_framework import serializers

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


class VideoSerializer(serializers.ModelSerializer):
    source_type = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session_id",
            "title",
            "youtube_id",
            "external_url",
            "file",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = ["created_at", "updated_at"]
        ref_name = "MediaVideo"

    def get_source_type(self, obj):
        return obj.source_type


class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "MediaVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "MediaVideoProgress"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "MediaVideoDetail"


# ========================================================
# Playback API (v1)
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


class PlaybackSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = VideoPlaybackSession
        fields = "__all__"
        ref_name = "MediaVideoPlaybackSession"


# ========================================================
# Event collection (v1: audit-only)
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(choices=VideoPlaybackEvent.EventType.choices)
    occurred_at = serializers.IntegerField(required=False)  # epoch seconds
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


====================
FILE: C:\academy\apps\support\media\drm.py
====================

import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


====================
FILE: C:\academy\apps\support\media\cdn\cloudfront.py
====================

import base64
import json
from typing import Dict
from django.conf import settings


# =========================
# Public API
# =========================

def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    DEV/LOCAL:
      - CloudFront ?ъ슜 ??????鍮?dict 諛섑솚

    PROD:
      - CloudFront Signed Cookies ?앹꽦
    """
    if settings.DEBUG:
        return {}

    key_pair_id = _required("CLOUDFRONT_KEY_PAIR_ID")
    domain = _required("CLOUDFRONT_DOMAIN").rstrip("/")

    resource = f"https://{domain}{path_prefix}*"

    policy = {
        "Statement": [{
            "Resource": resource,
            "Condition": {
                "DateLessThan": {"AWS:EpochTime": int(expires_at)}
            }
        }]
    }

    policy_json = json.dumps(policy, separators=(",", ":")).encode("utf-8")

    from botocore.signers import CloudFrontSigner

    signer = CloudFrontSigner(key_pair_id, _rsa_signer)

    signed_policy = _b64_urlsafe(policy_json)
    signature = signer._sign(policy_json)

    return {
        "CloudFront-Policy": signed_policy,
        "CloudFront-Signature": _b64_urlsafe(signature),
        "CloudFront-Key-Pair-Id": key_pair_id,
    }


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    DEV: cookie ?ㅼ젙 ????
    PROD: CloudFront ?꾨찓??荑좏궎 ?ㅼ젙
    """
    if settings.DEBUG:
        return {}

    domain = _required("CLOUDFRONT_DOMAIN")

    secure = bool(getattr(settings, "SESSION_COOKIE_SECURE", False))

    return {
        "domain": domain,
        "path": path_prefix,
        "httponly": True,
        "secure": secure,
        "samesite": "Lax",
    }


# =========================
# Internal helpers
# =========================

def _required(name: str) -> str:
    v = getattr(settings, name, None)
    if not v:
        raise RuntimeError(f"Missing setting: {name}")
    return str(v)


def _load_private_key_pem() -> bytes:
    pem = _required("CLOUDFRONT_PRIVATE_KEY_PEM")
    pem = pem.replace("\\n", "\n")
    return pem.encode("utf-8")


def _rsa_signer(message: bytes) -> bytes:
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.primitives.asymmetric import padding

    key = load_pem_private_key(_load_private_key_pem(), password=None)
    return key.sign(message, padding.PKCS1v15(), hashes.SHA1())


def _b64_urlsafe(data: bytes) -> str:
    return (
        base64.b64encode(data)
        .decode("utf-8")
        .replace("+", "-")
        .replace("=", "_")
        .replace("/", "~")
    )


====================
FILE: C:\academy\apps\support\media\models.py
====================

from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (?곸긽 硫뷀??곗씠??
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "?낅줈???湲?
        UPLOADED = "UPLOADED", "?낅줈???꾨즺"
        PROCESSING = "PROCESSING", "泥섎━以?
        READY = "READY", "?ъ슜 媛??
        FAILED = "FAILED", "?ㅽ뙣"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # Legacy sources (?좎?)
    # ===============================
    youtube_id = models.CharField(max_length=100, blank=True)
    external_url = models.URLField(blank=True)
    file = models.FileField(upload_to="videos/%Y/%m/%d/", blank=True)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # ?몃꽕?쇱? Worker媛 ?앹꽦
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # 湲곕낯 ?ъ깮 ?뺤콉 (鍮꾨뵒???⑥쐞 default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Worker ?ㅽ뙣 ?ъ쑀 湲곕줉
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    class Meta:
        ordering = ["order", "id"]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        if self.file:
            return "file"
        if self.youtube_id:
            return "youtube"
        if self.external_url:
            return "external"
        return "unknown"


# ========================================================
# Video Permission (?섍컯?앸퀎 override + ?묎렐 洹쒖튃)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "臾댁젣??),
            ("once", "1???쒗븳"),
            ("blocked", "?쒗븳"),
        ],
        default="once",
    )

    # ?숈깮蹂??뺤콉 override (null?대㈃ Video 湲곕낯媛??ъ슜)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # 理쒖슦??李⑤떒 ?뚮옒洹?
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (?몄뀡 / 媛먯궗)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "?쒖꽦"
        ENDED = "ENDED", "醫낅즺"
        REVOKED = "REVOKED", "李⑤떒"
        EXPIRED = "EXPIRED", "留뚮즺"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "???④?"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "???몄텧"
        FOCUS_LOST = "FOCUS_LOST", "?ъ빱???댄깉"
        FOCUS_GAINED = "FOCUS_GAINED", "?ъ빱??蹂듦?"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "?먯깋 ?쒕룄"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "諛곗냽 蹂寃??쒕룄"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "?꾩껜?붾㈃ 吏꾩엯"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "?꾩껜?붾㈃ 醫낅즺"
        PLAYER_ERROR = "PLAYER_ERROR", "?뚮젅?댁뼱 ?ㅻ쪟"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


====================
FILE: C:\academy\apps\api\config\settings.py
====================



====================
FILE: 
====================



====================
FILE: C:\academyfront\src\features\media\playback\api\playback.ts
====================

// src/features/media/playback/api/playback.ts

import api from "@/shared/api/axios";
import type { PlaybackStartResponse, PostEventsBody } from "./types";

/**
 * ??以묒슂
 * heartbeat/refresh/end ?붾뱶?ъ씤??寃쎈줈??"?덈? 異붿륫 湲덉?".
 * 諛깆뿏?쒖뿉???ㅼ젣 URL???뺤젙?????ш린留?梨꾩슦硫???
 */
export const PLAYBACK_ENDPOINTS = {
  // play??怨좎젙(?꾩젣)
  play: (videoId: number) => `/api/v1/media/videos/${videoId}/play/`,

  // ?꾨옒 3媛쒕뒗 諛깆뿏???ㅼ젣 寃쎈줈濡?梨꾩썙????(?꾩옱??placeholders)
  heartbeat: (videoId: number) => `/api/v1/media/videos/${videoId}/heartbeat/`,
  refresh: (videoId: number) => `/api/v1/media/videos/${videoId}/refresh/`,
  end: (videoId: number) => `/api/v1/media/videos/${videoId}/end/`,

  // events??怨좎젙(?꾩젣)
  events: (videoId: number) => `/api/v1/media/videos/${videoId}/events/`,
};

export async function playVideo(params: {
  videoId: number;
  enrollment_id: number;
  device_id: string;
}): Promise<PlaybackStartResponse> {
  const res = await api.post(PLAYBACK_ENDPOINTS.play(params.videoId), {
    enrollment_id: params.enrollment_id,
    device_id: params.device_id,
  });
  return res.data as PlaybackStartResponse;
}

export async function postPlaybackEvents(videoId: number, body: PostEventsBody) {
  // v1: ?ㅽ뙣?대룄 ?ъ떆???놁쓬 ???몄텧?먮뒗 catch ??踰꾨━硫???
  await api.post(PLAYBACK_ENDPOINTS.events(videoId), body);
}

/**
 * best-effort flush (visibilitychange / beforeunload)
 * - 媛?ν븯硫?sendBeacon
 * - ?꾨땲硫?fetch keepalive
 * - ?ㅽ뙣?대룄 臾댁떆
 */
export async function postPlaybackEventsBestEffort(
  videoId: number,
  body: PostEventsBody,
) {
  try {
    const url = PLAYBACK_ENDPOINTS.events(videoId);

    // sendBeacon ?ъ슜 媛????
    if (typeof navigator !== "undefined" && "sendBeacon" in navigator) {
      const blob = new Blob([JSON.stringify(body)], {
        type: "application/json",
      });
      // sendBeacon? boolean 諛섑솚, ?ㅽ뙣?대룄 ??
      (navigator as any).sendBeacon(url, blob);
      return;
    }

    // fetch keepalive
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      keepalive: true,
      credentials: "include",
    });
  } catch {
    // v1: drop
  }
}

export async function heartbeatSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.heartbeat(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}

export async function refreshSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}): Promise<PlaybackStartResponse | { token: string; expires_at: number }> {
  const res = await api.post(PLAYBACK_ENDPOINTS.refresh(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
  return res.data;
}

export async function endSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.end(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}


====================
FILE: C:\academyfront\src\features\media\playback\api\types.ts
====================

// src/features/media/playback/api/types.ts

export type PlaybackConcurrencyPolicy = {
  max_devices?: number;
  max_concurrent_sessions?: number;
};

export type PlaybackRatePolicy =
  | { max?: number }
  | { max: number; allowed?: number[] };

export type WatermarkPolicy =
  | { enabled?: boolean; text?: string }
  | { enabled: boolean; mode?: "overlay" | "burnin" };

export type PlaybackPolicy = {
  allow_seek?: boolean;
  playback_rate?: PlaybackRatePolicy | number | null;
  watermark?: WatermarkPolicy | null;
  concurrency?: PlaybackConcurrencyPolicy | null;
};

export type PlaybackStartResponse = {
  token: string;
  session_id: string;
  expires_at: number; // epoch seconds
  policy: PlaybackPolicy;
  play_url: string; // may be relative: /hls/...
};

export type PlaybackEventType =
  | "play_start"
  | "pause"
  | "ended"
  | "seek_attempt"
  | "speed_change_attempt"
  | "visibility_change";

export type PlaybackEvent = {
  type: PlaybackEventType;
  payload?: Record<string, any>;
  occurred_at: number; // epoch seconds
};

export type PostEventsBody = {
  token: string;
  events: PlaybackEvent[];
};


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackSession.ts
====================

// src/features/media/playback/hooks/usePlaybackSession.ts

import { useCallback, useEffect, useRef, useState } from "react";
import type { PlaybackPolicy, PlaybackStartResponse } from "../api/types";
import {
  playVideo,
  heartbeatSession,
  refreshSession,
  endSession,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type State = {
  token: string | null;
  sessionId: string | null;
  expiresAt: number | null;
  policy: PlaybackPolicy | null;
  playUrl: string | null; // raw play_url (may be relative)
};

type Args = {
  videoId: number;
  enrollmentId: number | null;
  deviceId: string;
  enabled: boolean;
};

export function usePlaybackSession({
  videoId,
  enrollmentId,
  deviceId,
  enabled,
}: Args) {
  const [state, setState] = useState<State>({
    token: null,
    sessionId: null,
    expiresAt: null,
    policy: null,
    playUrl: null,
  });

  const tokenRef = useRef<string | null>(null);
  const sessionRef = useRef<string | null>(null);
  const expiresRef = useRef<number | null>(null);

  const refreshInFlightRef = useRef(false);

  const setFromStart = useCallback((resp: PlaybackStartResponse) => {
    tokenRef.current = resp.token;
    sessionRef.current = resp.session_id;
    expiresRef.current = resp.expires_at;

    setState({
      token: resp.token,
      sessionId: resp.session_id,
      expiresAt: resp.expires_at,
      policy: resp.policy,
      playUrl: resp.play_url,
    });
  }, []);

  const start = useCallback(async () => {
    if (!enabled) return;
    if (!enrollmentId) return;

    const resp = await playVideo({
      videoId,
      enrollment_id: enrollmentId,
      device_id: deviceId,
    });

    setFromStart(resp);
  }, [deviceId, enabled, enrollmentId, setFromStart, videoId]);

  const heartbeat = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;

    if (!enabled || !token || !session_id) return;

    try {
      await heartbeatSession({ videoId, token, session_id });
    } catch {
      // v1: heartbeat ?ㅽ뙣濡?利됱떆 UX ?곹뼢 二쇱? ?딆쓬 (drop)
    }
  }, [enabled, videoId]);

  const refresh = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    const expiresAt = expiresRef.current;

    if (!enabled || !token || !session_id || !expiresAt) return;

    const now = nowEpochSeconds();
    const left = expiresAt - now;

    // 60珥??대궡 ?꾨컯 ??refresh
    if (left > 60) return;
    if (refreshInFlightRef.current) return;

    refreshInFlightRef.current = true;
    try {
      const resp = await refreshSession({ videoId, token, session_id });

      // refresh ?묐떟 ?ㅽ궎留덇? 2媛吏?????덉뼱 ?좎뿰 泥섎━
      if ((resp as any).session_id && (resp as any).play_url) {
        // full PlaybackStartResponse ?뺥깭
        setFromStart(resp as any);
      } else {
        // token + expires_at留?媛깆떊
        const nextToken = (resp as any).token;
        const nextExpires = (resp as any).expires_at;

        if (typeof nextToken === "string") tokenRef.current = nextToken;
        if (typeof nextExpires === "number") expiresRef.current = nextExpires;

        setState((prev) => ({
          ...prev,
          token: tokenRef.current,
          expiresAt: expiresRef.current,
        }));
      }
    } catch {
      // v1: drop
    } finally {
      refreshInFlightRef.current = false;
    }
  }, [enabled, setFromStart, videoId]);

  const end = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    if (!enabled || !token || !session_id) return;

    try {
      await endSession({ videoId, token, session_id });
    } catch {
      // v1: drop
    }
  }, [enabled, videoId]);

  // enabled ??start 1??
  useEffect(() => {
    if (!enabled) return;
    if (!enrollmentId) return;

    void start();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [enabled, enrollmentId, videoId]);

  // heartbeat 45珥?二쇨린
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void heartbeat();
      void refresh();
    }, 45000);

    return () => window.clearInterval(t);
  }, [enabled, heartbeat, refresh]);

  // unmount end 1??
  useEffect(() => {
    return () => {
      void end();
    };
  }, [end]);

  return {
    ...state,
    getToken: () => tokenRef.current,
    start,
    heartbeat,
    refresh,
    end,
  };
}


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackEvents.ts
====================

// src/features/media/playback/hooks/usePlaybackEvents.ts

import { useCallback, useEffect, useRef } from "react";
import type { PlaybackEvent } from "../api/types";
import {
  postPlaybackEvents,
  postPlaybackEventsBestEffort,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type Args = {
  videoId: number;
  getToken: () => string | null;
  enabled: boolean;
};

export function usePlaybackEvents({ videoId, getToken, enabled }: Args) {
  const queueRef = useRef<PlaybackEvent[]>([]);
  const flushingRef = useRef(false);

  const push = useCallback(
    (type: PlaybackEvent["type"], payload?: PlaybackEvent["payload"]) => {
      if (!enabled) return;

      queueRef.current.push({
        type,
        payload,
        occurred_at: nowEpochSeconds(),
      });

      if (queueRef.current.length >= 10) {
        void flush(false);
      }
    },
    [enabled],
  );

  const flush = useCallback(
    async (bestEffort: boolean) => {
      if (!enabled) return;
      if (flushingRef.current) return;

      const token = getToken();
      if (!token) return;

      const events = queueRef.current;
      if (!events.length) return;

      queueRef.current = [];
      flushingRef.current = true;

      try {
        const body = { token, events };
        if (bestEffort) {
          await postPlaybackEventsBestEffort(videoId, body);
        } else {
          await postPlaybackEvents(videoId, body);
        }
      } catch {
        // v1: ?ъ떆???놁쓬, drop
      } finally {
        flushingRef.current = false;
      }
    },
    [enabled, getToken, videoId],
  );

  // 5珥?二쇨린 flush
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void flush(false);
    }, 5000);

    return () => window.clearInterval(t);
  }, [enabled, flush]);

  // visibilitychange hidden ??best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      if (document.visibilityState === "hidden") {
        void flush(true);
      } else {
        push("visibility_change", { state: "visible" });
      }
    };

    document.addEventListener("visibilitychange", handler);
    return () => document.removeEventListener("visibilitychange", handler);
  }, [enabled, flush, push]);

  // beforeunload best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      void flush(true);
    };

    window.addEventListener("beforeunload", handler);
    return () => window.removeEventListener("beforeunload", handler);
  }, [enabled, flush]);

  return { push, flush };
}


====================
FILE: C:\academyfront\src\features\media\playback\player\StudentVideoPlayer.tsx
====================

import { useEffect, useRef, useState, useCallback } from "react";
import Hls from "hls.js";

import { usePlaybackEvents } from "@/features/media/playback/hooks/usePlaybackEvents";
import { usePlaybackSession } from "@/features/media/playback/hooks/usePlaybackSession";
import { resolvePlayUrl } from "@/features/media/playback/utils/resolvePlayUrl";
import { getDeviceId } from "@/features/media/playback/utils/deviceId";
import WatermarkOverlay from "@/features/media/playback/player/WatermarkOverlay";

type Props = {
  videoId: number;
  enrollmentId: number;
};

export default function StudentVideoPlayer({
  videoId,
  enrollmentId,
}: Props) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const hlsRef = useRef<Hls | null>(null);

  // playback session state
  const {
    start,
    refresh,
    heartbeat,
    end,
    token,
    playUrl,
    policy,
    expiresAt,
    ready,
  } = usePlaybackSession();

  // audit events
  const { push } = usePlaybackEvents({
    videoId,
    enabled: ready,
    getToken: () => token,
  });

  // ---------------------------------------------
  // START playback session on mount
  // ---------------------------------------------
  useEffect(() => {
    start({
      videoId,
      enrollmentId,
      deviceId: getDeviceId(),
    });

    return () => {
      end(); // best-effort
    };
  }, [videoId, enrollmentId, start, end]);

  // ---------------------------------------------
  // HEARTBEAT (30s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready) return;

    const t = window.setInterval(() => {
      heartbeat();
    }, 30_000);

    return () => window.clearInterval(t);
  }, [ready, heartbeat]);

  // ---------------------------------------------
  // REFRESH (expires_at - 60s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !expiresAt) return;

    const now = Date.now() / 1000;
    const delay = Math.max((expiresAt - 60 - now) * 1000, 5_000);

    const t = window.setTimeout(() => {
      refresh();
    }, delay);

    return () => window.clearTimeout(t);
  }, [ready, expiresAt, refresh]);

  // ---------------------------------------------
  // ATTACH VIDEO (HLS)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !playUrl || !videoRef.current) return;

    const video = videoRef.current;
    const src = resolvePlayUrl(playUrl);

    // Safari / iOS
    if (video.canPlayType("application/vnd.apple.mpegurl")) {
      video.src = src;
    } else if (Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: false,
      });

      hls.loadSource(src);
      hls.attachMedia(video);
      hlsRef.current = hls;
    }

    return () => {
      hlsRef.current?.destroy();
      hlsRef.current = null;
    };
  }, [ready, playUrl]);

  // ---------------------------------------------
  // VIDEO EVENT BINDING
  // ---------------------------------------------
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !ready) return;

    const onPlay = () => push("play_start");
    const onPause = () => push("pause");
    const onEnded = () => push("ended");

    let lastTime = video.currentTime;

    const onSeeking = () => {
      const from = lastTime;
      const to = video.currentTime;
      push("seek_attempt", { from, to });
      lastTime = to;
    };

    const onRateChange = () => {
      push("speed_change_attempt", {
        to: video.playbackRate,
      });
    };

    const onTimeUpdate = () => {
      lastTime = video.currentTime;
    };

    video.addEventListener("play", onPlay);
    video.addEventListener("pause", onPause);
    video.addEventListener("ended", onEnded);
    video.addEventListener("seeking", onSeeking);
    video.addEventListener("ratechange", onRateChange);
    video.addEventListener("timeupdate", onTimeUpdate);

    return () => {
      video.removeEventListener("play", onPlay);
      video.removeEventListener("pause", onPause);
      video.removeEventListener("ended", onEnded);
      video.removeEventListener("seeking", onSeeking);
      video.removeEventListener("ratechange", onRateChange);
      video.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, [ready, push]);

  // ---------------------------------------------
  // SPEED UI CONTROL (policy)
  // ---------------------------------------------
  const maxRate = policy?.playback_rate?.max ?? 1.0;
  const allowRateControl = policy?.playback_rate?.ui_control !== false;

  const changeRate = useCallback(
    (rate: number) => {
      if (!videoRef.current) return;
      if (!allowRateControl) return;

      const clamped = Math.min(rate, maxRate);
      videoRef.current.playbackRate = clamped;
    },
    [allowRateControl, maxRate],
  );

  // ---------------------------------------------
  // RENDER
  // ---------------------------------------------
  if (!ready) {
    return (
      <div className="h-64 flex items-center justify-center text-sm text-gray-500">
        ?곸긽 濡쒕뵫 以?..
      </div>
    );
  }

  return (
    <div className="relative space-y-2">
      <div className="relative">
        <video
          ref={videoRef}
          controls
          playsInline
          className="w-full rounded-lg bg-black"
        />

        {policy?.watermark?.enabled && (
          <WatermarkOverlay
            fields={policy.watermark.fields}
            sessionId={policy?.session_id}
          />
        )}
      </div>

      {/* SPEED CONTROL */}
      {allowRateControl && (
        <div className="flex items-center gap-2 text-xs text-gray-600">
          <span>諛곗냽</span>
          {[0.5, 1, 1.25, 1.5, 2].map((r) => (
            <button
              key={r}
              disabled={r > maxRate}
              onClick={() => changeRate(r)}
              className={`px-2 py-1 rounded border ${
                r > maxRate
                  ? "opacity-30 cursor-not-allowed"
                  : "hover:bg-gray-100"
              }`}
            >
              {r}x
            </button>
          ))}
        </div>
      )}
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\player\WatermarkOverlay.tsx
====================

// src/features/media/playback/player/WatermarkOverlay.tsx

import { useMemo } from "react";

type Props = {
  enabled: boolean;
  text?: string;
  sessionId?: string | null;
};

export default function WatermarkOverlay({ enabled, text, sessionId }: Props) {
  const label = useMemo(() => {
    const base = text?.trim() || "臾대떒 諛고룷 湲덉?";
    const sid = sessionId ? ` 쨌 ${sessionId.slice(0, 8)}` : "";
    return `${base}${sid}`;
  }, [sessionId, text]);

  if (!enabled) return null;

  return (
    <div className="pointer-events-none absolute inset-0 select-none">
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="rounded bg-black/20 px-3 py-1 text-xs font-bold text-white/40">
          {label}
        </div>
      </div>
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\deviceId.ts
====================

// src/features/media/playback/utils/deviceId.ts

/**
 * device_id???뺤콉(湲곌린 ?쒗븳/?숈떆?묒냽)?먯꽌 留ㅼ슦 以묒슂.
 * ??token/policy/progress ??μ? 湲덉?吏留?
 * ??device_id??"湲곌린 ?앸퀎????????덉슜(?κ린 ?댁쁺???좊━)
 */
const KEY = "device_id_v1";

function randomId() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

export function getDeviceId(): string {
  try {
    const existing = localStorage.getItem(KEY);
    if (existing) return existing;

    const ua = typeof navigator !== "undefined" ? navigator.userAgent : "unknown";
    const id = `web:${ua.includes("Chrome") ? "chrome" : "browser"}:${randomId()}`;
    localStorage.setItem(KEY, id);
    return id;
  } catch {
    // localStorage 遺덇? ?섍꼍(?ы뙆由??꾨씪?대퉿 ?? ??硫붾え由??泥?
    return `web:volatile:${randomId()}`;
  }
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\resolvePlayUrl.ts
====================

// src/features/media/playback/utils/resolvePlayUrl.ts

function stripTrailingSlash(s: string) {
  return s.endsWith("/") ? s.slice(0, -1) : s;
}

export function resolvePlayUrl(playUrl: string): string {
  if (!playUrl) return playUrl;

  // ?대? ?덈? URL
  if (playUrl.startsWith("http://") || playUrl.startsWith("https://")) {
    return playUrl;
  }

  const cdn = (import.meta as any).env?.VITE_CDN_URL as string | undefined;
  const api = (import.meta as any).env?.VITE_API_URL as string | undefined;

  const base = cdn || api || "";
  if (!base) {
    // base ?놁쑝硫??곷?寃쎈줈 洹몃?濡?(dev?먯꽌 proxy ?곕뒗 寃쎌슦)
    return playUrl;
  }

  return `${stripTrailingSlash(base)}${playUrl.startsWith("/") ? "" : "/"}${playUrl}`;
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\time.ts
====================

// src/features/media/playback/utils/time.ts

export function nowEpochSeconds(): number {
  return Math.floor(Date.now() / 1000);
}


====================
FILE: 
====================



====================
FILE: C:\academyfront\src\features\videos\pages\VideoDetailPage.tsx
====================

// src/features/videos/pages/VideoDetailPage.tsx
// ?좑툘 愿由ъ옄???곸긽 ?곸꽭 ?섏씠吏
// ?좑툘 ?숈깮 ?ъ깮? media/playback/player/StudentVideoPlayer ?먯꽌 泥섎━??

import { useEffect, useState } from "react";
import { useParams, Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import PageContainer from "@/layouts/default/PageContainer";
import PageHeader from "@/shared/ui/PageHeader";

import api from "@/shared/api/axios";
import AdminVideoPlayer from "@/features/videos/components/AdminVideoPlayer";
import StudentWatchPanel from "@/features/videos/components/StudentWatchPanel";
import PermissionModal from "@/features/videos/components/PermissionModal";
import ToggleSwitch from "@/features/videos/components/ToggleSwitch";

// --------------------------------------------------
// URL RESOLVE (ADMIN PREVIEW ONLY)
// ?숈깮 ?ъ깮?먯꽌???ъ슜 ??
// --------------------------------------------------
function resolveUrl(url: string | null) {
  if (!url) return null;
  if (url.startsWith("http")) return url;

  const base = import.meta.env.VITE_API_URL ?? "http://localhost:8000";
  return `${base}${url}`;
}

// --------------------------------------------------
// PAGE
// --------------------------------------------------
export default function VideoDetailPage() {
  const params = useParams();
  const lectureId = Number(params.lectureId);
  const sessionId = Number(params.sessionId);
  const videoId = Number(params.videoId);

  const id = videoId;

  const [memo, setMemo] = useState("");
  const [open, setOpen] = useState(false);

  // 愿由ъ옄 ?뺤콉 ?곹깭
  const [allowSkip, setAllowSkip] = useState(false);
  const [maxSpeed, setMaxSpeed] = useState(1.0);
  const [showWatermark, setShowWatermark] = useState(true);
  const [dirty, setDirty] = useState(false);

  const qc = useQueryClient();

  // --------------------------------------------------
  // FETCH
  // --------------------------------------------------
  const { data, isLoading, error } = useQuery({
    queryKey: ["video-stats", id],
    queryFn: async () => {
      const res = await api.get(`/lectures/videos/${id}/stats/`);
      return res.data;
    },
    enabled: !!id,
  });

  const { data: session } = useQuery({
    queryKey: ["session", sessionId],
    queryFn: async () => {
      const res = await api.get(`/lectures/sessions/${sessionId}/`);
      return res.data;
    },
    enabled: !!sessionId,
  });

  // --------------------------------------------------
  // DERIVED
  // --------------------------------------------------
  const video = data?.video;
  const stats = data?.stats;
  const students = data?.students ?? [];

  const sessionTitle =
    session?.title || (session?.order ? `${session.order}李⑥떆` : "");

  // 愿由ъ옄 誘몃━蹂닿린??src
  const src =
    video?.source_type === "file"
      ? resolveUrl(video.file)
      : video?.source_type === "youtube"
      ? `https://www.youtube.com/embed/${video.youtube_id}`
      : video?.external_url || null;

  const avgProgress =
    stats?.avg_progress != null ? (stats.avg_progress * 100).toFixed(1) : "0.0";

  // --------------------------------------------------
  // INIT policy state
  // --------------------------------------------------
  useEffect(() => {
    if (!video) return;

    setAllowSkip(video.allow_skip ?? false);
    setMaxSpeed(video.max_speed ?? 1.0);
    setShowWatermark(video.show_watermark ?? true);

    setDirty(false);
  }, [video?.id]);

  // --------------------------------------------------
  // SAVE POLICY
  // --------------------------------------------------
  const policyMutation = useMutation({
    mutationFn: async () => {
      if (!video) return;

      await api.post(`/lectures/videos/${video.id}/set-policy/`, {
        allow_skip: allowSkip,
        max_speed: maxSpeed,
        show_watermark: showWatermark,
      });
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["video-stats", id] });
      setDirty(false);
    },
  });

  // --------------------------------------------------
  // SAFETY
  // --------------------------------------------------
  if (!id) return <PageContainer>?섎せ??URL</PageContainer>;
  if (isLoading) return <PageContainer>濡쒕뵫以?..</PageContainer>;
  if (error)
    return (
      <PageContainer>
        <div className="text-red-500">?먮윭 諛쒖깮</div>
      </PageContainer>
    );
  if (!video) return <PageContainer>?곸긽 ?놁쓬</PageContainer>;

  // --------------------------------------------------
  // UI
  // --------------------------------------------------
  return (
    <PageContainer>
      <PageHeader
        title={sessionTitle || video.title}
        actions={
          <Link
            to={`/lectures/${lectureId}/sessions/${sessionId}`}
            className="rounded border border-gray-300 px-3 py-1.5 text-sm"
          >
            異쒖꽍 ?붾㈃?쇰줈
          </Link>
        }
      />

      <div className="text-sm text-gray-600 mb-6">
        <span className="font-medium text-gray-700 mr-2">{video.title}</span>
        {video.source_type === "file" && <span>?뚯씪 ?곸긽</span>}
        {video.source_type === "youtube" && <span>?좏뒠釉??곸긽</span>}
        {video.source_type === "external" && <span>?몃? 留곹겕</span>}
      </div>

      <div className="flex gap-6">
        {/* LEFT */}
        <div className="flex flex-col gap-6 w-[750px]">

          {/* ADMIN VIDEO PREVIEW */}
          {src && (
            <div className="w-full">
              {video.source_type === "file" ? (
                <AdminVideoPlayer
                  src={src}
                  rule="free"
                  showWatermark={showWatermark}
                  watermarkImage="/watermark.png"
                  watermarkOpacity={0.12}
                  watermarkSize={200}
                />
              ) : (
                <div className="aspect-video w-full overflow-hidden rounded border bg-black">
                  <iframe src={src} className="w-full h-full" allowFullScreen />
                </div>
              )}
            </div>
          )}

          {/* POLICY PANEL */}
          <div className="rounded border bg-white p-4 text-sm space-y-3">
            <div className="font-semibold">?숈깮 ?쒖껌 ?뺤콉</div>

            <div className="flex items-center flex-wrap gap-6 text-xs">

              <label className="flex items-center gap-2">
                <span className="font-medium">?뚰꽣留덊겕</span>
                <ToggleSwitch
                  checked={showWatermark}
                  onChange={(v) => {
                    setShowWatermark(v);
                    setDirty(true);
                  }}
                />
              </label>

              <label className="flex items-center gap-2">
                <span className="font-medium">嫄대꼫?곌린</span>
                <ToggleSwitch
                  checked={allowSkip}
                  onChange={(v) => {
                    setAllowSkip(v);
                    setDirty(true);
                  }}
                />
              </label>

              <div className="flex items-center gap-2">
                <span className="font-medium">諛곗냽</span>
                <span className="font-bold">{maxSpeed.toFixed(2)}x</span>
              </div>

              <button
                onClick={() => policyMutation.mutate()}
                disabled={!dirty || policyMutation.isLoading}
                className={`ml-auto rounded px-4 py-1.5 text-xs font-semibold text-white ${
                  dirty
                    ? "bg-blue-600 hover:bg-blue-700"
                    : "bg-gray-400 cursor-not-allowed"
                }`}
              >
                {dirty ? "??? : "??λ맖"}
              </button>
            </div>
          </div>
        </div>

        {/* RIGHT */}
        <StudentWatchPanel
          students={students}
          onOpenPermission={() => setOpen(true)}
        />
      </div>

      <PermissionModal open={open} onClose={() => setOpen(false)} videoId={id} />
    </PageContainer>
  );
}


====================
FILE: C:\academyfront\src\features\videos\api\videos.ts
====================

// src/features/lectures/api/videos.ts

import api from "@/shared/api/axios";

// ------------------------
// Types
// ------------------------

export interface Video {
  id: number;
  session: number;
  title: string;
  youtube_id: string | null;
  external_url: string | null;
  file: string | null;
  duration: number | null;
  order: number;
  created_at: string;
  updated_at: string;

  source_type: "file" | "youtube" | "external" | "unknown";
  file_size: number | null;
}

export interface VideoDetail extends Video {}

export interface VideoStatsStudent {
  enrollment: number;

  student_id: number;
  student_name: string;

  parent_phone: string | null;
  student_phone: string | null;
  school: string | null;
  grade: number | null;

  attendance_status: string | null;
  progress: number;
  completed: boolean;

  rule: string | null;
  is_override: boolean;
  effective_rule: string | null;
}

export interface VideoStats {
  video: VideoDetail;
  stats: {
    total_students: number;
    completed_100: number;
    completed_90: number;
    avg_progress: number;
  };
  students: VideoStatsStudent[];
}

export interface VideoProgress {
  id: number;
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
  updated_at: string;
  student_name?: string;
}

// ------------------------
// List
// ------------------------

export async function fetchSessionVideos(sessionId: number): Promise<Video[]> {
  const res = await api.get("/lectures/videos/", {
    params: { session: sessionId },
  });
  return res.data.results ?? res.data;
}

// ------------------------
// Detail
// ------------------------

export async function fetchVideoDetail(videoId: number): Promise<VideoDetail> {
  const res = await api.get(`/lectures/videos/${videoId}/`);
  return res.data;
}

// ------------------------
// Stats
// ------------------------

export async function fetchVideoStats(videoId: number): Promise<VideoStats> {
  const res = await api.get(`/lectures/videos/${videoId}/stats/`);
  return res.data;
}

// ------------------------
// Create / URL
// ------------------------

export async function createVideoUrl(payload: {
  session: number;
  title: string;
  url: string;
}): Promise<Video> {
  const res = await api.post("/lectures/videos/add-url/", payload);
  return res.data;
}

// ------------------------
// Create / File
// ------------------------

export async function createVideoFile(payload: {
  session: number;
  title: string;
  file: File;
}): Promise<Video[]> {
  const form = new FormData();
  form.append("session", String(payload.session));
  form.append("files", payload.file);

  const res = await api.post("/lectures/videos/upload/", form, {
    headers: { "Content-Type": "multipart/form-data" },
  });

  return res.data;
}

// ------------------------
// Delete
// ------------------------

export async function deleteVideo(videoId: number): Promise<void> {
  await api.delete(`/lectures/videos/${videoId}/`);
}

// ------------------------
// Progress (?먮룞 吏꾨룄 ?낅뜲?댄듃)
// ------------------------

export async function updateVideoProgress(payload: {
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
}): Promise<VideoProgress> {
  const res = await api.post(
    "/lectures/video-progress/update_progress/",
    payload,
  );
  return res.data;
}


====================
FILE: C:\academy\apps\support\media\views.py
====================

import os
import time
from datetime import datetime
from uuid import uuid4

from django.conf import settings
from django.db import models, transaction
from django.http import FileResponse, Http404
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.permissions import IsAuthenticated

from libs.s3_client.presign import create_presigned_put_url
from libs.s3_client.client import head_object

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from .serializers import (
    VideoSerializer,
    VideoDetailSerializer,
    VideoPermissionSerializer,
    VideoProgressSerializer,
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)

from apps.shared.tasks.media import process_video_media

from .drm import create_playback_token, verify_playback_token
from .services.playback_session import issue_session, heartbeat_session, end_session, is_session_active
from .cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options


class VideoViewSet(ModelViewSet):
    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer
    parser_classes = [MultiPartParser, FormParser, JSONParser]
    permission_classes = [IsAuthenticated]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # --------------------------------------------------
    # Legacy local upload (?좎?)
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="upload")
    def upload(self, request):
        session_id = request.data.get("session")
        files = request.FILES.getlist("files")

        session = Session.objects.get(id=session_id)
        base_order = session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0

        created = []
        for idx, f in enumerate(files, start=1):
            created.append(
                Video.objects.create(
                    session=session,
                    title=os.path.splitext(f.name)[0],
                    file=f,
                    order=base_order + idx,
                    status=Video.Status.READY,
                )
            )

        return Response(VideoSerializer(created, many=True).data, status=201)

    # --------------------------------------------------
    # Presigned URL 諛쒓툒
    # --------------------------------------------------
    @action(detail=False, methods=["post"], url_path="presign")
    def presign(self, request):
        session_id = request.data.get("session")
        filename = request.data.get("filename")

        if not session_id or not filename:
            return Response({"detail": "session, filename required"}, status=status.HTTP_400_BAD_REQUEST)

        ext = filename.split(".")[-1]
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        upload_url = create_presigned_put_url(key=key, content_type="video/mp4")

        return Response({"upload_url": upload_url, "file_key": key})

    # --------------------------------------------------
    # ?낅줈???꾨즺 + S3 寃利?+ Worker ?몃━嫄?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="complete")
    def complete(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        file_key = request.data.get("file_key")

        if not all([session_id, title, file_key]):
            return Response({"detail": "session, title, file_key required"}, status=status.HTTP_400_BAD_REQUEST)

        exists, size = head_object(file_key)
        if not exists or size == 0:
            return Response({"detail": "S3 object not found"}, status=status.HTTP_409_CONFLICT)

        session = Session.objects.get(id=session_id)

        order = (session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0) + 1

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=file_key,
            order=order,
            status=Video.Status.UPLOADED,
        )

        transaction.on_commit(lambda: process_video_media.delay(video.id))

        return Response(VideoSerializer(video).data, status=201)

    # --------------------------------------------------
    # FAILED ?곸긽 ?ъ쿂由?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response({"detail": f"Cannot retry video in status {video.status}"}, status=status.HTTP_400_BAD_REQUEST)

        transaction.on_commit(lambda: process_video_media.delay(video.id))
        return Response({"detail": "Video reprocessing started"}, status=status.HTTP_202_ACCEPTED)

    # --------------------------------------------------
    # Download (legacy)
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="download")
    def download(self, request, pk=None):
        video = self.get_object()
        if not video.file:
            raise Http404
        return FileResponse(video.file.open("rb"), as_attachment=True)

    # --------------------------------------------------
    # Stats
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(lecture=lecture)
        progresses = {p.enrollment_id: p for p in VideoProgress.objects.filter(video=video)}
        perms = {p.enrollment_id: p for p in VideoPermission.objects.filter(video=video)}
        attendance = {a.enrollment_id: a.status for a in Attendance.objects.filter(session=video.session)}

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            students.append({
                "student_name": e.student.name,
                "progress": vp.progress if vp else 0,
                "completed": vp.completed if vp else False,
                "attendance_status": attendance.get(e.id),
                "rule": perm.rule if perm else "free",
            })

        return Response({"video": VideoDetailSerializer(video).data, "students": students})

    # =======================================================
    # Playback API (v1 + CDN Signed Cookie + ?뺤콉 override)
    # =======================================================

    def _get_student_for_user(self, request):
        # Student.user (OneToOne, related_name="student_profile") 媛 ?덉뼱????
        return getattr(request.user, "student_profile", None)

    def _check_access(self, *, video: Video, enrollment: Enrollment) -> tuple[bool, str | None]:
        if video.status != Video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(session=video.session, enrollment=enrollment).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()
        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        if rule == "once":
            vp = VideoProgress.objects.filter(video=video, enrollment=enrollment).first()
            if vp and vp.completed:
                return False, "already_completed_once"

        return True, None

    def _load_permission(self, *, video: Video, enrollment: Enrollment) -> VideoPermission | None:
        return VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

    def _effective_policy(self, *, video: Video, perm: VideoPermission | None) -> dict:
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)
            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if getattr(perm, "block_seek", False):
                allow_seek = False

            if getattr(perm, "block_speed_control", False):
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "playback_rate": {"max": max_rate, "ui_control": ui_speed_control},
            "watermark": {"enabled": watermark_enabled, "mode": "overlay", "fields": ["user_id"]},
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _public_play_url(self, video_id: int) -> str:
        cdn_base = getattr(settings, "CDN_HLS_BASE_URL", "").rstrip("/")
        path = f"/hls/videos/{video_id}/master.m3u8"
        return f"{cdn_base}{path}" if cdn_base else path

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int) -> None:
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, int(expires_at - int(time.time())))
        for k, v in cookies.items():
            response.set_cookie(
                key=k,
                value=v,
                max_age=max_age,
                expires=None,
                **opts,
            )

    @action(detail=True, methods=["post"], url_path="play")
    def play(self, request, pk=None):
        video = self.get_object()

        req = PlaybackStartRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        enrollment_id = req.validated_data["enrollment_id"]
        device_id = req.validated_data["device_id"]

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.select_related("student", "lecture").get(
                id=enrollment_id,
                student=student,
                status="ACTIVE",
            )
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        max_sessions = int(policy["concurrency"]["max_sessions"])
        max_devices = int(policy["concurrency"]["max_devices"])

        ok_sess, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=max_sessions,
            max_devices=max_devices,
        )
        if not ok_sess:
            return Response({"detail": err}, status=409)

        session_id = str(sess["session_id"])
        expires_at = int(sess["expires_at"])

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
        )

        token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        resp = PlaybackResponseSerializer({
            "token": token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })

        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="refresh")
    def refresh(self, request, pk=None):
        video = self.get_object()

        req = PlaybackRefreshRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        device_id = str(payload.get("device_id") or "")
        enrollment_id = int(payload.get("enrollment_id") or 0)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        new_token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        expires_at = int(time.time()) + ttl

        resp = PlaybackResponseSerializer({
            "token": new_token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })
        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="heartbeat")
    def heartbeat(self, request, pk=None):
        req = PlaybackHeartbeatRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        return Response({"status": "ok"}, status=200)

    @action(detail=True, methods=["post"], url_path="end")
    def end(self, request, pk=None):
        req = PlaybackEndRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        end_session(user_id=request.user.id, session_id=session_id)

        VideoPlaybackSession.objects.filter(session_id=session_id).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        response = Response({"status": "ended"}, status=200)

        path_prefix = self._hls_path_prefix_for_video(int(pk))
        opts = default_cookie_options(path_prefix=path_prefix)

        response.delete_cookie("CloudFront-Policy", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Signature", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Key-Pair-Id", domain=opts.get("domain"), path=opts.get("path"))
        return response

    # =======================================================
    # Events API (v1: audit-only)
    # POST /media/videos/{id}/events/
    # =======================================================

    def _epoch_to_dt(self, epoch: int | None) -> datetime:
        if not epoch:
            return timezone.now()
        try:
            return datetime.fromtimestamp(int(epoch), tz=timezone.get_current_timezone())
        except Exception:
            return timezone.now()

    def _evaluate_violation(self, *, event_type: str, payload: dict, policy: dict) -> tuple[bool, str]:
        """
        v1: ?먮떒留???? 李⑤떒/?쒖옱???섏? ?딅뒗??
        """
        if event_type == VideoPlaybackEvent.EventType.SEEK_ATTEMPT:
            if not bool(policy.get("allow_seek", False)):
                return True, "seek_not_allowed"

        if event_type == VideoPlaybackEvent.EventType.SPEED_CHANGE_ATTEMPT:
            pr = policy.get("playback_rate") or {}
            ui_control = bool(pr.get("ui_control", True))
            max_rate = float(pr.get("max", 1.0) or 1.0)

            to_rate = payload.get("to")
            try:
                to_rate = float(to_rate)
            except Exception:
                to_rate = None

            if not ui_control:
                return True, "speed_control_disabled"
            if to_rate is not None and to_rate > max_rate:
                return True, "speed_exceeds_max"

        return False, ""

    @action(detail=True, methods=["post"], url_path="events")
    def events(self, request, pk=None):
        """
        Batch ?대깽???섏쭛(媛먯궗 濡쒓렇).
        - token?쇰줈 video/enrollment/user/session??媛뺥븯寃??곌퀎
        - DB??payload + policy snapshot + violated ?먯젙 ???
        """
        video = self.get_object()

        req = PlaybackEventBatchRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        token = req.validated_data["token"]
        events = req.validated_data["events"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        enrollment_id = int(payload.get("enrollment_id") or 0)
        session_id = str(payload.get("session_id") or "")

        if not is_session_active(user_id=request.user.id, session_id=session_id):
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        rows: list[VideoPlaybackEvent] = []
        for ev in events:
            ev_type = ev.get("type")
            ev_payload = ev.get("payload") or {}
            occurred_at_epoch = ev.get("occurred_at")

            violated, reason = self._evaluate_violation(
                event_type=ev_type,
                payload=ev_payload,
                policy=policy,
            )

            rows.append(
                VideoPlaybackEvent(
                    video=video,
                    enrollment=enrollment,
                    session_id=session_id,
                    user_id=request.user.id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy,
                    violated=violated,
                    violation_reason=reason,
                    occurred_at=self._epoch_to_dt(occurred_at_epoch),
                )
            )

        if rows:
            VideoPlaybackEvent.objects.bulk_create(rows, batch_size=500)

        resp = PlaybackEventBatchResponseSerializer({"stored": len(rows)})
        return Response(resp.data, status=200)


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


====================
FILE: C:\academy\apps\support\media\urls.py
====================

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
)

router = DefaultRouter()

# ========================================================
# Video
# ========================================================

router.register(r"videos", VideoViewSet, basename="videos")
router.register(
    r"video-permissions",
    VideoPermissionViewSet,
    basename="video-permissions",
)
router.register(
    r"video-progress",
    VideoProgressViewSet,
    basename="video-progress",
)

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / ?곸꽭 Video API
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="media-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="media-video-stats-nested",
    ),
]


====================
FILE: C:\academy\apps\support\media\services\playback_session.py
====================

import time
import uuid
from typing import Dict, Any, Tuple

from libs.redis_client.client import redis_client


def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:sessions"  # zset (sid -> expires_at)


def _key_session(session_id: str) -> str:
    return f"media:playback:session:{session_id}"     # hash


def _key_user_devices(user_id: int) -> str:
    return f"media:playback:user:{user_id}:devices"   # set


def _cleanup_expired_sessions(user_id: int) -> None:
    key = _key_user_sessions(user_id)
    now = _now()

    expired = redis_client.zrangebyscore(key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)
    for sid in expired:
        pipe.zrem(key, sid)
        pipe.delete(_key_session(str(sid)))
    pipe.execute()


def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = redis_client.smembers(devices_key) or set()
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(_key_session(session_id), mapping={
        "user_id": str(user_id),
        "device_id": device_id,
        "expires_at": str(expires_at),
        "last_seen": str(now),
    })
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)
    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    sessions_key = _key_user_sessions(user_id)
    sid_key = _key_session(session_id)

    raw = redis_client.hget(sid_key, "expires_at")
    if not raw:
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(sid_key, mapping={"expires_at": str(new_expires_at), "last_seen": str(now)})
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)
    pipe.execute()
    return True


def end_session(*, user_id: int, session_id: str) -> None:
    sessions_key = _key_user_sessions(user_id)
    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False
    return int(score) > _now()


====================
FILE: C:\academy\apps\support\media\serializers.py
====================

from rest_framework import serializers

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


class VideoSerializer(serializers.ModelSerializer):
    source_type = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session_id",
            "title",
            "youtube_id",
            "external_url",
            "file",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = ["created_at", "updated_at"]
        ref_name = "MediaVideo"

    def get_source_type(self, obj):
        return obj.source_type


class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "MediaVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "MediaVideoProgress"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "MediaVideoDetail"


# ========================================================
# Playback API (v1)
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


class PlaybackSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = VideoPlaybackSession
        fields = "__all__"
        ref_name = "MediaVideoPlaybackSession"


# ========================================================
# Event collection (v1: audit-only)
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(choices=VideoPlaybackEvent.EventType.choices)
    occurred_at = serializers.IntegerField(required=False)  # epoch seconds
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


====================
FILE: C:\academy\apps\support\media\drm.py
====================

import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


====================
FILE: C:\academy\apps\support\media\cdn\cloudfront.py
====================

import base64
import json
from typing import Dict
from django.conf import settings


# =========================
# Public API
# =========================

def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    DEV/LOCAL:
      - CloudFront ?ъ슜 ??????鍮?dict 諛섑솚

    PROD:
      - CloudFront Signed Cookies ?앹꽦
    """
    if settings.DEBUG:
        return {}

    key_pair_id = _required("CLOUDFRONT_KEY_PAIR_ID")
    domain = _required("CLOUDFRONT_DOMAIN").rstrip("/")

    resource = f"https://{domain}{path_prefix}*"

    policy = {
        "Statement": [{
            "Resource": resource,
            "Condition": {
                "DateLessThan": {"AWS:EpochTime": int(expires_at)}
            }
        }]
    }

    policy_json = json.dumps(policy, separators=(",", ":")).encode("utf-8")

    from botocore.signers import CloudFrontSigner

    signer = CloudFrontSigner(key_pair_id, _rsa_signer)

    signed_policy = _b64_urlsafe(policy_json)
    signature = signer._sign(policy_json)

    return {
        "CloudFront-Policy": signed_policy,
        "CloudFront-Signature": _b64_urlsafe(signature),
        "CloudFront-Key-Pair-Id": key_pair_id,
    }


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    DEV: cookie ?ㅼ젙 ????
    PROD: CloudFront ?꾨찓??荑좏궎 ?ㅼ젙
    """
    if settings.DEBUG:
        return {}

    domain = _required("CLOUDFRONT_DOMAIN")

    secure = bool(getattr(settings, "SESSION_COOKIE_SECURE", False))

    return {
        "domain": domain,
        "path": path_prefix,
        "httponly": True,
        "secure": secure,
        "samesite": "Lax",
    }


# =========================
# Internal helpers
# =========================

def _required(name: str) -> str:
    v = getattr(settings, name, None)
    if not v:
        raise RuntimeError(f"Missing setting: {name}")
    return str(v)


def _load_private_key_pem() -> bytes:
    pem = _required("CLOUDFRONT_PRIVATE_KEY_PEM")
    pem = pem.replace("\\n", "\n")
    return pem.encode("utf-8")


def _rsa_signer(message: bytes) -> bytes:
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.primitives.asymmetric import padding

    key = load_pem_private_key(_load_private_key_pem(), password=None)
    return key.sign(message, padding.PKCS1v15(), hashes.SHA1())


def _b64_urlsafe(data: bytes) -> str:
    return (
        base64.b64encode(data)
        .decode("utf-8")
        .replace("+", "-")
        .replace("=", "_")
        .replace("/", "~")
    )


====================
FILE: C:\academy\apps\support\media\models.py
====================

from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (?곸긽 硫뷀??곗씠??
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "?낅줈???湲?
        UPLOADED = "UPLOADED", "?낅줈???꾨즺"
        PROCESSING = "PROCESSING", "泥섎━以?
        READY = "READY", "?ъ슜 媛??
        FAILED = "FAILED", "?ㅽ뙣"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # Legacy sources (?좎?)
    # ===============================
    youtube_id = models.CharField(max_length=100, blank=True)
    external_url = models.URLField(blank=True)
    file = models.FileField(upload_to="videos/%Y/%m/%d/", blank=True)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # ?몃꽕?쇱? Worker媛 ?앹꽦
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # 湲곕낯 ?ъ깮 ?뺤콉 (鍮꾨뵒???⑥쐞 default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Worker ?ㅽ뙣 ?ъ쑀 湲곕줉
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    class Meta:
        ordering = ["order", "id"]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        if self.file:
            return "file"
        if self.youtube_id:
            return "youtube"
        if self.external_url:
            return "external"
        return "unknown"


# ========================================================
# Video Permission (?섍컯?앸퀎 override + ?묎렐 洹쒖튃)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "臾댁젣??),
            ("once", "1???쒗븳"),
            ("blocked", "?쒗븳"),
        ],
        default="once",
    )

    # ?숈깮蹂??뺤콉 override (null?대㈃ Video 湲곕낯媛??ъ슜)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # 理쒖슦??李⑤떒 ?뚮옒洹?
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (?몄뀡 / 媛먯궗)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "?쒖꽦"
        ENDED = "ENDED", "醫낅즺"
        REVOKED = "REVOKED", "李⑤떒"
        EXPIRED = "EXPIRED", "留뚮즺"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "???④?"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "???몄텧"
        FOCUS_LOST = "FOCUS_LOST", "?ъ빱???댄깉"
        FOCUS_GAINED = "FOCUS_GAINED", "?ъ빱??蹂듦?"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "?먯깋 ?쒕룄"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "諛곗냽 蹂寃??쒕룄"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "?꾩껜?붾㈃ 吏꾩엯"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "?꾩껜?붾㈃ 醫낅즺"
        PLAYER_ERROR = "PLAYER_ERROR", "?뚮젅?댁뼱 ?ㅻ쪟"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"



































====================
FILE: C:\academy\apps\api\config\settings\base.py
====================

from pathlib import Path
from datetime import timedelta
import os

# ==================================================
# BASE
# ==================================================

BASE_DIR = Path(__file__).resolve().parents[3]

SECRET_KEY = "dev-secret-key"
DEBUG = True
ALLOWED_HOSTS = ["*"]

AUTH_USER_MODEL = "core.User"


# ==================================================
# INSTALLED APPS
# ==================================================

INSTALLED_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Common / Core
    "apps.api.common",
    "apps.core",

    # Domain Apps
    "apps.domains.students",
    "apps.domains.teachers",
    "apps.domains.staffs",
    "apps.domains.parents",

    "apps.domains.lectures",
    "apps.domains.enrollment",
    "apps.domains.attendance",
    "apps.domains.schedule",

    "apps.domains.interactions.materials",
    "apps.domains.interactions.questions",
    "apps.domains.interactions.counseling",
    "apps.domains.interactions.boards",

    "apps.domains.exams",
    "apps.domains.homework",
    "apps.domains.submissions",
    "apps.domains.results",

    "apps.domains.clinic",

    "apps.domains.ai.apps.AIDomainConfig",

    # support
    "apps.support.media",

    # REST
    "rest_framework",
    "rest_framework_simplejwt",
    "django_filters",

    # Swagger
    "drf_yasg",

    # CORS
    "corsheaders",
]

# ==================================================
# MIDDLEWARE
# ==================================================

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",

    # Tenant
    "apps.core.middleware.tenant.TenantMiddleware",
]

# ==================================================
# URL / WSGI / ASGI
# ==================================================

ROOT_URLCONF = "apps.api.config.urls"

WSGI_APPLICATION = "apps.api.config.wsgi.application"
ASGI_APPLICATION = "apps.api.config.asgi.application"

# ==================================================
# TEMPLATES
# ==================================================

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

# ==================================================
# DATABASE
# ==================================================

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "academy",
        "USER": "postgres",
        "PASSWORD": "kjkszpj123",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}

# ==================================================
# AUTH
# ==================================================

AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",
]

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"
    },
]

# ==================================================
# GLOBAL
# ==================================================

LANGUAGE_CODE = "ko-kr"
TIME_ZONE = "Asia/Seoul"

USE_I18N = True
USE_TZ = True

STATIC_URL = "/static/"
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "storage" / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# ==================================================
# DRF
# ==================================================

REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
}

# ==================================================
# JWT
# ==================================================

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(days=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=60),
    "AUTH_HEADER_TYPES": ("Bearer",),
}

# ==================================================
# CORS
# ==================================================

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# ==================================================
# CELERY / REDIS
# ==================================================

CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/1"

CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"

CELERY_TIMEZONE = TIME_ZONE

CELERY_TASK_ACKS_LATE = True
CELERY_TASK_REJECT_ON_WORKER_LOST = True
CELERY_WORKER_PREFETCH_MULTIPLIER = 1

# ==================================================
# VIDEO PLAYBACK / CDN
# ==================================================

CLOUDFRONT_DOMAIN = os.getenv("CLOUDFRONT_DOMAIN", "")
CLOUDFRONT_KEY_PAIR_ID = os.getenv("CLOUDFRONT_KEY_PAIR_ID", "")
CLOUDFRONT_PRIVATE_KEY_PEM = os.getenv("CLOUDFRONT_PRIVATE_KEY_PEM", "")

CDN_HLS_BASE_URL = os.getenv("CDN_HLS_BASE_URL", "")

VIDEO_PLAYBACK_TTL_SECONDS = int(os.getenv("VIDEO_PLAYBACK_TTL_SECONDS", "600"))
VIDEO_MAX_SESSIONS = int(os.getenv("VIDEO_MAX_SESSIONS", "1"))
VIDEO_MAX_DEVICES = int(os.getenv("VIDEO_MAX_DEVICES", "2"))

REQUIRED_ENV_VARS = [
    ("CLOUDFRONT_DOMAIN", CLOUDFRONT_DOMAIN),
    ("CLOUDFRONT_KEY_PAIR_ID", CLOUDFRONT_KEY_PAIR_ID),
    ("CLOUDFRONT_PRIVATE_KEY_PEM", CLOUDFRONT_PRIVATE_KEY_PEM),
    ("CDN_HLS_BASE_URL", CDN_HLS_BASE_URL),
]

# NOTE:
# 媛쒕컻/踰좏? ?④퀎?먯꽌???덉쇅瑜??섏?吏 ?딄퀬 ?곹깭留?湲곕줉?쒕떎.
# ?ㅼ젣 ?ъ깮 API?먯꽌留?VIDEO_PLAYBACK_ENABLED ?щ?瑜??뺤씤??李⑤떒?쒕떎.
VIDEO_PLAYBACK_CONFIG_MISSING = [
    name for name, value in REQUIRED_ENV_VARS if not value
]

VIDEO_PLAYBACK_ENABLED = not bool(VIDEO_PLAYBACK_CONFIG_MISSING)


====================
FILE: 
====================



====================
FILE: C:\academyfront\src\features\media\playback\api\playback.ts
====================

// src/features/media/playback/api/playback.ts

import api from "@/shared/api/axios";
import type { PlaybackStartResponse, PostEventsBody } from "./types";

/**
 * ??以묒슂
 * heartbeat/refresh/end ?붾뱶?ъ씤??寃쎈줈??"?덈? 異붿륫 湲덉?".
 * 諛깆뿏?쒖뿉???ㅼ젣 URL???뺤젙?????ш린留?梨꾩슦硫???
 */
export const PLAYBACK_ENDPOINTS = {
  // play??怨좎젙(?꾩젣)
  play: (videoId: number) => `/api/v1/media/videos/${videoId}/play/`,

  // ?꾨옒 3媛쒕뒗 諛깆뿏???ㅼ젣 寃쎈줈濡?梨꾩썙????(?꾩옱??placeholders)
  heartbeat: (videoId: number) => `/api/v1/media/videos/${videoId}/heartbeat/`,
  refresh: (videoId: number) => `/api/v1/media/videos/${videoId}/refresh/`,
  end: (videoId: number) => `/api/v1/media/videos/${videoId}/end/`,

  // events??怨좎젙(?꾩젣)
  events: (videoId: number) => `/api/v1/media/videos/${videoId}/events/`,
};

export async function playVideo(params: {
  videoId: number;
  enrollment_id: number;
  device_id: string;
}): Promise<PlaybackStartResponse> {
  const res = await api.post(PLAYBACK_ENDPOINTS.play(params.videoId), {
    enrollment_id: params.enrollment_id,
    device_id: params.device_id,
  });
  return res.data as PlaybackStartResponse;
}

export async function postPlaybackEvents(videoId: number, body: PostEventsBody) {
  // v1: ?ㅽ뙣?대룄 ?ъ떆???놁쓬 ???몄텧?먮뒗 catch ??踰꾨━硫???
  await api.post(PLAYBACK_ENDPOINTS.events(videoId), body);
}

/**
 * best-effort flush (visibilitychange / beforeunload)
 * - 媛?ν븯硫?sendBeacon
 * - ?꾨땲硫?fetch keepalive
 * - ?ㅽ뙣?대룄 臾댁떆
 */
export async function postPlaybackEventsBestEffort(
  videoId: number,
  body: PostEventsBody,
) {
  try {
    const url = PLAYBACK_ENDPOINTS.events(videoId);

    // sendBeacon ?ъ슜 媛????
    if (typeof navigator !== "undefined" && "sendBeacon" in navigator) {
      const blob = new Blob([JSON.stringify(body)], {
        type: "application/json",
      });
      // sendBeacon? boolean 諛섑솚, ?ㅽ뙣?대룄 ??
      (navigator as any).sendBeacon(url, blob);
      return;
    }

    // fetch keepalive
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      keepalive: true,
      credentials: "include",
    });
  } catch {
    // v1: drop
  }
}

export async function heartbeatSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.heartbeat(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}

export async function refreshSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}): Promise<PlaybackStartResponse | { token: string; expires_at: number }> {
  const res = await api.post(PLAYBACK_ENDPOINTS.refresh(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
  return res.data;
}

export async function endSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.end(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}


====================
FILE: C:\academyfront\src\features\media\playback\api\types.ts
====================

// src/features/media/playback/api/types.ts

export type PlaybackConcurrencyPolicy = {
  max_devices?: number;
  max_concurrent_sessions?: number;
};

export type PlaybackRatePolicy =
  | { max?: number }
  | { max: number; allowed?: number[] };

export type WatermarkPolicy =
  | { enabled?: boolean; text?: string }
  | { enabled: boolean; mode?: "overlay" | "burnin" };

export type PlaybackPolicy = {
  allow_seek?: boolean;
  playback_rate?: PlaybackRatePolicy | number | null;
  watermark?: WatermarkPolicy | null;
  concurrency?: PlaybackConcurrencyPolicy | null;
};

export type PlaybackStartResponse = {
  token: string;
  session_id: string;
  expires_at: number; // epoch seconds
  policy: PlaybackPolicy;
  play_url: string; // may be relative: /hls/...
};

export type PlaybackEventType =
  | "play_start"
  | "pause"
  | "ended"
  | "seek_attempt"
  | "speed_change_attempt"
  | "visibility_change";

export type PlaybackEvent = {
  type: PlaybackEventType;
  payload?: Record<string, any>;
  occurred_at: number; // epoch seconds
};

export type PostEventsBody = {
  token: string;
  events: PlaybackEvent[];
};


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackSession.ts
====================

// src/features/media/playback/hooks/usePlaybackSession.ts

import { useCallback, useEffect, useRef, useState } from "react";
import type { PlaybackPolicy, PlaybackStartResponse } from "../api/types";
import {
  playVideo,
  heartbeatSession,
  refreshSession,
  endSession,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type State = {
  token: string | null;
  sessionId: string | null;
  expiresAt: number | null;
  policy: PlaybackPolicy | null;
  playUrl: string | null; // raw play_url (may be relative)
};

type Args = {
  videoId: number;
  enrollmentId: number | null;
  deviceId: string;
  enabled: boolean;
};

export function usePlaybackSession({
  videoId,
  enrollmentId,
  deviceId,
  enabled,
}: Args) {
  const [state, setState] = useState<State>({
    token: null,
    sessionId: null,
    expiresAt: null,
    policy: null,
    playUrl: null,
  });

  const tokenRef = useRef<string | null>(null);
  const sessionRef = useRef<string | null>(null);
  const expiresRef = useRef<number | null>(null);

  const refreshInFlightRef = useRef(false);

  const setFromStart = useCallback((resp: PlaybackStartResponse) => {
    tokenRef.current = resp.token;
    sessionRef.current = resp.session_id;
    expiresRef.current = resp.expires_at;

    setState({
      token: resp.token,
      sessionId: resp.session_id,
      expiresAt: resp.expires_at,
      policy: resp.policy,
      playUrl: resp.play_url,
    });
  }, []);

  const start = useCallback(async () => {
    if (!enabled) return;
    if (!enrollmentId) return;

    const resp = await playVideo({
      videoId,
      enrollment_id: enrollmentId,
      device_id: deviceId,
    });

    setFromStart(resp);
  }, [deviceId, enabled, enrollmentId, setFromStart, videoId]);

  const heartbeat = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;

    if (!enabled || !token || !session_id) return;

    try {
      await heartbeatSession({ videoId, token, session_id });
    } catch {
      // v1: heartbeat ?ㅽ뙣濡?利됱떆 UX ?곹뼢 二쇱? ?딆쓬 (drop)
    }
  }, [enabled, videoId]);

  const refresh = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    const expiresAt = expiresRef.current;

    if (!enabled || !token || !session_id || !expiresAt) return;

    const now = nowEpochSeconds();
    const left = expiresAt - now;

    // 60珥??대궡 ?꾨컯 ??refresh
    if (left > 60) return;
    if (refreshInFlightRef.current) return;

    refreshInFlightRef.current = true;
    try {
      const resp = await refreshSession({ videoId, token, session_id });

      // refresh ?묐떟 ?ㅽ궎留덇? 2媛吏?????덉뼱 ?좎뿰 泥섎━
      if ((resp as any).session_id && (resp as any).play_url) {
        // full PlaybackStartResponse ?뺥깭
        setFromStart(resp as any);
      } else {
        // token + expires_at留?媛깆떊
        const nextToken = (resp as any).token;
        const nextExpires = (resp as any).expires_at;

        if (typeof nextToken === "string") tokenRef.current = nextToken;
        if (typeof nextExpires === "number") expiresRef.current = nextExpires;

        setState((prev) => ({
          ...prev,
          token: tokenRef.current,
          expiresAt: expiresRef.current,
        }));
      }
    } catch {
      // v1: drop
    } finally {
      refreshInFlightRef.current = false;
    }
  }, [enabled, setFromStart, videoId]);

  const end = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    if (!enabled || !token || !session_id) return;

    try {
      await endSession({ videoId, token, session_id });
    } catch {
      // v1: drop
    }
  }, [enabled, videoId]);

  // enabled ??start 1??
  useEffect(() => {
    if (!enabled) return;
    if (!enrollmentId) return;

    void start();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [enabled, enrollmentId, videoId]);

  // heartbeat 45珥?二쇨린
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void heartbeat();
      void refresh();
    }, 45000);

    return () => window.clearInterval(t);
  }, [enabled, heartbeat, refresh]);

  // unmount end 1??
  useEffect(() => {
    return () => {
      void end();
    };
  }, [end]);

  return {
    ...state,
    getToken: () => tokenRef.current,
    start,
    heartbeat,
    refresh,
    end,
  };
}


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackEvents.ts
====================

// src/features/media/playback/hooks/usePlaybackEvents.ts

import { useCallback, useEffect, useRef } from "react";
import type { PlaybackEvent } from "../api/types";
import {
  postPlaybackEvents,
  postPlaybackEventsBestEffort,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type Args = {
  videoId: number;
  getToken: () => string | null;
  enabled: boolean;
};

export function usePlaybackEvents({ videoId, getToken, enabled }: Args) {
  const queueRef = useRef<PlaybackEvent[]>([]);
  const flushingRef = useRef(false);

  const push = useCallback(
    (type: PlaybackEvent["type"], payload?: PlaybackEvent["payload"]) => {
      if (!enabled) return;

      queueRef.current.push({
        type,
        payload,
        occurred_at: nowEpochSeconds(),
      });

      if (queueRef.current.length >= 10) {
        void flush(false);
      }
    },
    [enabled],
  );

  const flush = useCallback(
    async (bestEffort: boolean) => {
      if (!enabled) return;
      if (flushingRef.current) return;

      const token = getToken();
      if (!token) return;

      const events = queueRef.current;
      if (!events.length) return;

      queueRef.current = [];
      flushingRef.current = true;

      try {
        const body = { token, events };
        if (bestEffort) {
          await postPlaybackEventsBestEffort(videoId, body);
        } else {
          await postPlaybackEvents(videoId, body);
        }
      } catch {
        // v1: ?ъ떆???놁쓬, drop
      } finally {
        flushingRef.current = false;
      }
    },
    [enabled, getToken, videoId],
  );

  // 5珥?二쇨린 flush
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void flush(false);
    }, 5000);

    return () => window.clearInterval(t);
  }, [enabled, flush]);

  // visibilitychange hidden ??best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      if (document.visibilityState === "hidden") {
        void flush(true);
      } else {
        push("visibility_change", { state: "visible" });
      }
    };

    document.addEventListener("visibilitychange", handler);
    return () => document.removeEventListener("visibilitychange", handler);
  }, [enabled, flush, push]);

  // beforeunload best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      void flush(true);
    };

    window.addEventListener("beforeunload", handler);
    return () => window.removeEventListener("beforeunload", handler);
  }, [enabled, flush]);

  return { push, flush };
}


====================
FILE: C:\academyfront\src\features\media\playback\player\StudentVideoPlayer.tsx
====================

import { useEffect, useRef, useState, useCallback } from "react";
import Hls from "hls.js";

import { usePlaybackEvents } from "@/features/media/playback/hooks/usePlaybackEvents";
import { usePlaybackSession } from "@/features/media/playback/hooks/usePlaybackSession";
import { resolvePlayUrl } from "@/features/media/playback/utils/resolvePlayUrl";
import { getDeviceId } from "@/features/media/playback/utils/deviceId";
import WatermarkOverlay from "@/features/media/playback/player/WatermarkOverlay";

type Props = {
  videoId: number;
  enrollmentId: number;
};

export default function StudentVideoPlayer({
  videoId,
  enrollmentId,
}: Props) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const hlsRef = useRef<Hls | null>(null);

  // playback session state
  const {
    start,
    refresh,
    heartbeat,
    end,
    token,
    playUrl,
    policy,
    expiresAt,
    ready,
  } = usePlaybackSession();

  // audit events
  const { push } = usePlaybackEvents({
    videoId,
    enabled: ready,
    getToken: () => token,
  });

  // ---------------------------------------------
  // START playback session on mount
  // ---------------------------------------------
  useEffect(() => {
    start({
      videoId,
      enrollmentId,
      deviceId: getDeviceId(),
    });

    return () => {
      end(); // best-effort
    };
  }, [videoId, enrollmentId, start, end]);

  // ---------------------------------------------
  // HEARTBEAT (30s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready) return;

    const t = window.setInterval(() => {
      heartbeat();
    }, 30_000);

    return () => window.clearInterval(t);
  }, [ready, heartbeat]);

  // ---------------------------------------------
  // REFRESH (expires_at - 60s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !expiresAt) return;

    const now = Date.now() / 1000;
    const delay = Math.max((expiresAt - 60 - now) * 1000, 5_000);

    const t = window.setTimeout(() => {
      refresh();
    }, delay);

    return () => window.clearTimeout(t);
  }, [ready, expiresAt, refresh]);

  // ---------------------------------------------
  // ATTACH VIDEO (HLS)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !playUrl || !videoRef.current) return;

    const video = videoRef.current;
    const src = resolvePlayUrl(playUrl);

    // Safari / iOS
    if (video.canPlayType("application/vnd.apple.mpegurl")) {
      video.src = src;
    } else if (Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: false,
      });

      hls.loadSource(src);
      hls.attachMedia(video);
      hlsRef.current = hls;
    }

    return () => {
      hlsRef.current?.destroy();
      hlsRef.current = null;
    };
  }, [ready, playUrl]);

  // ---------------------------------------------
  // VIDEO EVENT BINDING
  // ---------------------------------------------
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !ready) return;

    const onPlay = () => push("play_start");
    const onPause = () => push("pause");
    const onEnded = () => push("ended");

    let lastTime = video.currentTime;

    const onSeeking = () => {
      const from = lastTime;
      const to = video.currentTime;
      push("seek_attempt", { from, to });
      lastTime = to;
    };

    const onRateChange = () => {
      push("speed_change_attempt", {
        to: video.playbackRate,
      });
    };

    const onTimeUpdate = () => {
      lastTime = video.currentTime;
    };

    video.addEventListener("play", onPlay);
    video.addEventListener("pause", onPause);
    video.addEventListener("ended", onEnded);
    video.addEventListener("seeking", onSeeking);
    video.addEventListener("ratechange", onRateChange);
    video.addEventListener("timeupdate", onTimeUpdate);

    return () => {
      video.removeEventListener("play", onPlay);
      video.removeEventListener("pause", onPause);
      video.removeEventListener("ended", onEnded);
      video.removeEventListener("seeking", onSeeking);
      video.removeEventListener("ratechange", onRateChange);
      video.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, [ready, push]);

  // ---------------------------------------------
  // SPEED UI CONTROL (policy)
  // ---------------------------------------------
  const maxRate = policy?.playback_rate?.max ?? 1.0;
  const allowRateControl = policy?.playback_rate?.ui_control !== false;

  const changeRate = useCallback(
    (rate: number) => {
      if (!videoRef.current) return;
      if (!allowRateControl) return;

      const clamped = Math.min(rate, maxRate);
      videoRef.current.playbackRate = clamped;
    },
    [allowRateControl, maxRate],
  );

  // ---------------------------------------------
  // RENDER
  // ---------------------------------------------
  if (!ready) {
    return (
      <div className="h-64 flex items-center justify-center text-sm text-gray-500">
        ?곸긽 濡쒕뵫 以?..
      </div>
    );
  }

  return (
    <div className="relative space-y-2">
      <div className="relative">
        <video
          ref={videoRef}
          controls
          playsInline
          className="w-full rounded-lg bg-black"
        />

        {policy?.watermark?.enabled && (
          <WatermarkOverlay
            fields={policy.watermark.fields}
            sessionId={policy?.session_id}
          />
        )}
      </div>

      {/* SPEED CONTROL */}
      {allowRateControl && (
        <div className="flex items-center gap-2 text-xs text-gray-600">
          <span>諛곗냽</span>
          {[0.5, 1, 1.25, 1.5, 2].map((r) => (
            <button
              key={r}
              disabled={r > maxRate}
              onClick={() => changeRate(r)}
              className={`px-2 py-1 rounded border ${
                r > maxRate
                  ? "opacity-30 cursor-not-allowed"
                  : "hover:bg-gray-100"
              }`}
            >
              {r}x
            </button>
          ))}
        </div>
      )}
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\player\WatermarkOverlay.tsx
====================

// src/features/media/playback/player/WatermarkOverlay.tsx

import { useMemo } from "react";

type Props = {
  enabled: boolean;
  text?: string;
  sessionId?: string | null;
};

export default function WatermarkOverlay({ enabled, text, sessionId }: Props) {
  const label = useMemo(() => {
    const base = text?.trim() || "臾대떒 諛고룷 湲덉?";
    const sid = sessionId ? ` 쨌 ${sessionId.slice(0, 8)}` : "";
    return `${base}${sid}`;
  }, [sessionId, text]);

  if (!enabled) return null;

  return (
    <div className="pointer-events-none absolute inset-0 select-none">
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="rounded bg-black/20 px-3 py-1 text-xs font-bold text-white/40">
          {label}
        </div>
      </div>
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\deviceId.ts
====================

// src/features/media/playback/utils/deviceId.ts

/**
 * device_id???뺤콉(湲곌린 ?쒗븳/?숈떆?묒냽)?먯꽌 留ㅼ슦 以묒슂.
 * ??token/policy/progress ??μ? 湲덉?吏留?
 * ??device_id??"湲곌린 ?앸퀎????????덉슜(?κ린 ?댁쁺???좊━)
 */
const KEY = "device_id_v1";

function randomId() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

export function getDeviceId(): string {
  try {
    const existing = localStorage.getItem(KEY);
    if (existing) return existing;

    const ua = typeof navigator !== "undefined" ? navigator.userAgent : "unknown";
    const id = `web:${ua.includes("Chrome") ? "chrome" : "browser"}:${randomId()}`;
    localStorage.setItem(KEY, id);
    return id;
  } catch {
    // localStorage 遺덇? ?섍꼍(?ы뙆由??꾨씪?대퉿 ?? ??硫붾え由??泥?
    return `web:volatile:${randomId()}`;
  }
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\resolvePlayUrl.ts
====================

// src/features/media/playback/utils/resolvePlayUrl.ts

function stripTrailingSlash(s: string) {
  return s.endsWith("/") ? s.slice(0, -1) : s;
}

export function resolvePlayUrl(playUrl: string): string {
  if (!playUrl) return playUrl;

  // ?대? ?덈? URL
  if (playUrl.startsWith("http://") || playUrl.startsWith("https://")) {
    return playUrl;
  }

  const cdn = (import.meta as any).env?.VITE_CDN_URL as string | undefined;
  const api = (import.meta as any).env?.VITE_API_URL as string | undefined;

  const base = cdn || api || "";
  if (!base) {
    // base ?놁쑝硫??곷?寃쎈줈 洹몃?濡?(dev?먯꽌 proxy ?곕뒗 寃쎌슦)
    return playUrl;
  }

  return `${stripTrailingSlash(base)}${playUrl.startsWith("/") ? "" : "/"}${playUrl}`;
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\time.ts
====================

// src/features/media/playback/utils/time.ts

export function nowEpochSeconds(): number {
  return Math.floor(Date.now() / 1000);
}


====================
FILE: 
====================



====================
FILE: C:\academyfront\src\features\videos\pages\VideoDetailPage.tsx
====================

// src/features/videos/pages/VideoDetailPage.tsx
// ?좑툘 愿由ъ옄???곸긽 ?곸꽭 ?섏씠吏
// ?좑툘 ?숈깮 ?ъ깮? media/playback/player/StudentVideoPlayer ?먯꽌 泥섎━??

import { useEffect, useState } from "react";
import { useParams, Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import PageContainer from "@/layouts/default/PageContainer";
import PageHeader from "@/shared/ui/PageHeader";

import api from "@/shared/api/axios";
import AdminVideoPlayer from "@/features/videos/components/AdminVideoPlayer";
import StudentWatchPanel from "@/features/videos/components/StudentWatchPanel";
import PermissionModal from "@/features/videos/components/PermissionModal";
import ToggleSwitch from "@/features/videos/components/ToggleSwitch";

// --------------------------------------------------
// URL RESOLVE (ADMIN PREVIEW ONLY)
// ?숈깮 ?ъ깮?먯꽌???ъ슜 ??
// --------------------------------------------------
function resolveUrl(url: string | null) {
  if (!url) return null;
  if (url.startsWith("http")) return url;

  const base = import.meta.env.VITE_API_URL ?? "http://localhost:8000";
  return `${base}${url}`;
}

// --------------------------------------------------
// PAGE
// --------------------------------------------------
export default function VideoDetailPage() {
  const params = useParams();
  const lectureId = Number(params.lectureId);
  const sessionId = Number(params.sessionId);
  const videoId = Number(params.videoId);

  const id = videoId;

  const [memo, setMemo] = useState("");
  const [open, setOpen] = useState(false);

  // 愿由ъ옄 ?뺤콉 ?곹깭
  const [allowSkip, setAllowSkip] = useState(false);
  const [maxSpeed, setMaxSpeed] = useState(1.0);
  const [showWatermark, setShowWatermark] = useState(true);
  const [dirty, setDirty] = useState(false);

  const qc = useQueryClient();

  // --------------------------------------------------
  // FETCH
  // --------------------------------------------------
  const { data, isLoading, error } = useQuery({
    queryKey: ["video-stats", id],
    queryFn: async () => {
      const res = await api.get(`/lectures/videos/${id}/stats/`);
      return res.data;
    },
    enabled: !!id,
  });

  const { data: session } = useQuery({
    queryKey: ["session", sessionId],
    queryFn: async () => {
      const res = await api.get(`/lectures/sessions/${sessionId}/`);
      return res.data;
    },
    enabled: !!sessionId,
  });

  // --------------------------------------------------
  // DERIVED
  // --------------------------------------------------
  const video = data?.video;
  const stats = data?.stats;
  const students = data?.students ?? [];

  const sessionTitle =
    session?.title || (session?.order ? `${session.order}李⑥떆` : "");

  // 愿由ъ옄 誘몃━蹂닿린??src
  const src =
    video?.source_type === "file"
      ? resolveUrl(video.file)
      : video?.source_type === "youtube"
      ? `https://www.youtube.com/embed/${video.youtube_id}`
      : video?.external_url || null;

  const avgProgress =
    stats?.avg_progress != null ? (stats.avg_progress * 100).toFixed(1) : "0.0";

  // --------------------------------------------------
  // INIT policy state
  // --------------------------------------------------
  useEffect(() => {
    if (!video) return;

    setAllowSkip(video.allow_skip ?? false);
    setMaxSpeed(video.max_speed ?? 1.0);
    setShowWatermark(video.show_watermark ?? true);

    setDirty(false);
  }, [video?.id]);

  // --------------------------------------------------
  // SAVE POLICY
  // --------------------------------------------------
  const policyMutation = useMutation({
    mutationFn: async () => {
      if (!video) return;

      await api.post(`/lectures/videos/${video.id}/set-policy/`, {
        allow_skip: allowSkip,
        max_speed: maxSpeed,
        show_watermark: showWatermark,
      });
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["video-stats", id] });
      setDirty(false);
    },
  });

  // --------------------------------------------------
  // SAFETY
  // --------------------------------------------------
  if (!id) return <PageContainer>?섎せ??URL</PageContainer>;
  if (isLoading) return <PageContainer>濡쒕뵫以?..</PageContainer>;
  if (error)
    return (
      <PageContainer>
        <div className="text-red-500">?먮윭 諛쒖깮</div>
      </PageContainer>
    );
  if (!video) return <PageContainer>?곸긽 ?놁쓬</PageContainer>;

  // --------------------------------------------------
  // UI
  // --------------------------------------------------
  return (
    <PageContainer>
      <PageHeader
        title={sessionTitle || video.title}
        actions={
          <Link
            to={`/lectures/${lectureId}/sessions/${sessionId}`}
            className="rounded border border-gray-300 px-3 py-1.5 text-sm"
          >
            異쒖꽍 ?붾㈃?쇰줈
          </Link>
        }
      />

      <div className="text-sm text-gray-600 mb-6">
        <span className="font-medium text-gray-700 mr-2">{video.title}</span>
        {video.source_type === "file" && <span>?뚯씪 ?곸긽</span>}
        {video.source_type === "youtube" && <span>?좏뒠釉??곸긽</span>}
        {video.source_type === "external" && <span>?몃? 留곹겕</span>}
      </div>

      <div className="flex gap-6">
        {/* LEFT */}
        <div className="flex flex-col gap-6 w-[750px]">

          {/* ADMIN VIDEO PREVIEW */}
          {src && (
            <div className="w-full">
              {video.source_type === "file" ? (
                <AdminVideoPlayer
                  src={src}
                  rule="free"
                  showWatermark={showWatermark}
                  watermarkImage="/watermark.png"
                  watermarkOpacity={0.12}
                  watermarkSize={200}
                />
              ) : (
                <div className="aspect-video w-full overflow-hidden rounded border bg-black">
                  <iframe src={src} className="w-full h-full" allowFullScreen />
                </div>
              )}
            </div>
          )}

          {/* POLICY PANEL */}
          <div className="rounded border bg-white p-4 text-sm space-y-3">
            <div className="font-semibold">?숈깮 ?쒖껌 ?뺤콉</div>

            <div className="flex items-center flex-wrap gap-6 text-xs">

              <label className="flex items-center gap-2">
                <span className="font-medium">?뚰꽣留덊겕</span>
                <ToggleSwitch
                  checked={showWatermark}
                  onChange={(v) => {
                    setShowWatermark(v);
                    setDirty(true);
                  }}
                />
              </label>

              <label className="flex items-center gap-2">
                <span className="font-medium">嫄대꼫?곌린</span>
                <ToggleSwitch
                  checked={allowSkip}
                  onChange={(v) => {
                    setAllowSkip(v);
                    setDirty(true);
                  }}
                />
              </label>

              <div className="flex items-center gap-2">
                <span className="font-medium">諛곗냽</span>
                <span className="font-bold">{maxSpeed.toFixed(2)}x</span>
              </div>

              <button
                onClick={() => policyMutation.mutate()}
                disabled={!dirty || policyMutation.isLoading}
                className={`ml-auto rounded px-4 py-1.5 text-xs font-semibold text-white ${
                  dirty
                    ? "bg-blue-600 hover:bg-blue-700"
                    : "bg-gray-400 cursor-not-allowed"
                }`}
              >
                {dirty ? "??? : "??λ맖"}
              </button>
            </div>
          </div>
        </div>

        {/* RIGHT */}
        <StudentWatchPanel
          students={students}
          onOpenPermission={() => setOpen(true)}
        />
      </div>

      <PermissionModal open={open} onClose={() => setOpen(false)} videoId={id} />
    </PageContainer>
  );
}


====================
FILE: C:\academyfront\src\features\videos\api\videos.ts
====================

// src/features/lectures/api/videos.ts

import api from "@/shared/api/axios";

// ------------------------
// Types
// ------------------------

export interface Video {
  id: number;
  session: number;
  title: string;
  youtube_id: string | null;
  external_url: string | null;
  file: string | null;
  duration: number | null;
  order: number;
  created_at: string;
  updated_at: string;

  source_type: "file" | "youtube" | "external" | "unknown";
  file_size: number | null;
}

export interface VideoDetail extends Video {}

export interface VideoStatsStudent {
  enrollment: number;

  student_id: number;
  student_name: string;

  parent_phone: string | null;
  student_phone: string | null;
  school: string | null;
  grade: number | null;

  attendance_status: string | null;
  progress: number;
  completed: boolean;

  rule: string | null;
  is_override: boolean;
  effective_rule: string | null;
}

export interface VideoStats {
  video: VideoDetail;
  stats: {
    total_students: number;
    completed_100: number;
    completed_90: number;
    avg_progress: number;
  };
  students: VideoStatsStudent[];
}

export interface VideoProgress {
  id: number;
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
  updated_at: string;
  student_name?: string;
}

// ------------------------
// List
// ------------------------

export async function fetchSessionVideos(sessionId: number): Promise<Video[]> {
  const res = await api.get("/lectures/videos/", {
    params: { session: sessionId },
  });
  return res.data.results ?? res.data;
}

// ------------------------
// Detail
// ------------------------

export async function fetchVideoDetail(videoId: number): Promise<VideoDetail> {
  const res = await api.get(`/lectures/videos/${videoId}/`);
  return res.data;
}

// ------------------------
// Stats
// ------------------------

export async function fetchVideoStats(videoId: number): Promise<VideoStats> {
  const res = await api.get(`/lectures/videos/${videoId}/stats/`);
  return res.data;
}

// ------------------------
// Create / URL
// ------------------------

export async function createVideoUrl(payload: {
  session: number;
  title: string;
  url: string;
}): Promise<Video> {
  const res = await api.post("/lectures/videos/add-url/", payload);
  return res.data;
}

// ------------------------
// Create / File
// ------------------------

export async function createVideoFile(payload: {
  session: number;
  title: string;
  file: File;
}): Promise<Video[]> {
  const form = new FormData();
  form.append("session", String(payload.session));
  form.append("files", payload.file);

  const res = await api.post("/lectures/videos/upload/", form, {
    headers: { "Content-Type": "multipart/form-data" },
  });

  return res.data;
}

// ------------------------
// Delete
// ------------------------

export async function deleteVideo(videoId: number): Promise<void> {
  await api.delete(`/lectures/videos/${videoId}/`);
}

// ------------------------
// Progress (?먮룞 吏꾨룄 ?낅뜲?댄듃)
// ------------------------

export async function updateVideoProgress(payload: {
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
}): Promise<VideoProgress> {
  const res = await api.post(
    "/lectures/video-progress/update_progress/",
    payload,
  );
  return res.data;
}


====================
FILE: C:\academy\apps\support\media\views.py
====================

import os
import time
from datetime import datetime
from uuid import uuid4

from django.conf import settings
from django.db import models, transaction
from django.http import FileResponse, Http404
from django.utils import timezone

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.permissions import IsAuthenticated

from libs.s3_client.presign import create_presigned_put_url
from libs.s3_client.client import head_object

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)

from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment, SessionEnrollment
from apps.domains.attendance.models import Attendance

from .serializers import (
    VideoSerializer,
    VideoDetailSerializer,
    VideoPermissionSerializer,
    VideoProgressSerializer,
    PlaybackStartRequestSerializer,
    PlaybackRefreshRequestSerializer,
    PlaybackHeartbeatRequestSerializer,
    PlaybackEndRequestSerializer,
    PlaybackResponseSerializer,
    PlaybackEventBatchRequestSerializer,
    PlaybackEventBatchResponseSerializer,
)

from apps.shared.tasks.media import process_video_media

from .drm import create_playback_token, verify_playback_token
from .services.playback_session import issue_session, heartbeat_session, end_session, is_session_active
from .cdn.cloudfront import build_signed_cookies_for_path, default_cookie_options


class VideoViewSet(ModelViewSet):
    queryset = Video.objects.all().select_related("session", "session__lecture")
    serializer_class = VideoSerializer
    parser_classes = [MultiPartParser, FormParser, JSONParser]
    permission_classes = [IsAuthenticated]

    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ["session", "status"]
    search_fields = ["title"]

    # --------------------------------------------------
    # Legacy local upload (?좎?)
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="upload")
    def upload(self, request):
        session_id = request.data.get("session")
        files = request.FILES.getlist("files")

        session = Session.objects.get(id=session_id)
        base_order = session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0

        created = []
        for idx, f in enumerate(files, start=1):
            created.append(
                Video.objects.create(
                    session=session,
                    title=os.path.splitext(f.name)[0],
                    file=f,
                    order=base_order + idx,
                    status=Video.Status.READY,
                )
            )

        return Response(VideoSerializer(created, many=True).data, status=201)

    # --------------------------------------------------
    # Presigned URL 諛쒓툒
    # --------------------------------------------------
    @action(detail=False, methods=["post"], url_path="presign")
    def presign(self, request):
        session_id = request.data.get("session")
        filename = request.data.get("filename")

        if not session_id or not filename:
            return Response({"detail": "session, filename required"}, status=status.HTTP_400_BAD_REQUEST)

        ext = filename.split(".")[-1]
        key = f"videos/{session_id}/{uuid4()}.{ext}"

        upload_url = create_presigned_put_url(key=key, content_type="video/mp4")

        return Response({"upload_url": upload_url, "file_key": key})

    # --------------------------------------------------
    # ?낅줈???꾨즺 + S3 寃利?+ Worker ?몃━嫄?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=False, methods=["post"], url_path="complete")
    def complete(self, request):
        session_id = request.data.get("session")
        title = request.data.get("title")
        file_key = request.data.get("file_key")

        if not all([session_id, title, file_key]):
            return Response({"detail": "session, title, file_key required"}, status=status.HTTP_400_BAD_REQUEST)

        exists, size = head_object(file_key)
        if not exists or size == 0:
            return Response({"detail": "S3 object not found"}, status=status.HTTP_409_CONFLICT)

        session = Session.objects.get(id=session_id)

        order = (session.videos.aggregate(max_order=models.Max("order")).get("max_order") or 0) + 1

        video = Video.objects.create(
            session=session,
            title=title,
            file_key=file_key,
            order=order,
            status=Video.Status.UPLOADED,
        )

        transaction.on_commit(lambda: process_video_media.delay(video.id))

        return Response(VideoSerializer(video).data, status=201)

    # --------------------------------------------------
    # FAILED ?곸긽 ?ъ쿂由?
    # --------------------------------------------------
    @transaction.atomic
    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        video = self.get_object()

        if video.status not in (Video.Status.FAILED, Video.Status.UPLOADED):
            return Response({"detail": f"Cannot retry video in status {video.status}"}, status=status.HTTP_400_BAD_REQUEST)

        transaction.on_commit(lambda: process_video_media.delay(video.id))
        return Response({"detail": "Video reprocessing started"}, status=status.HTTP_202_ACCEPTED)

    # --------------------------------------------------
    # Download (legacy)
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="download")
    def download(self, request, pk=None):
        video = self.get_object()
        if not video.file:
            raise Http404
        return FileResponse(video.file.open("rb"), as_attachment=True)

    # --------------------------------------------------
    # Stats
    # --------------------------------------------------
    @action(detail=True, methods=["get"], url_path="stats")
    def stats(self, request, pk=None):
        video = self.get_object()
        lecture = video.session.lecture

        enrollments = Enrollment.objects.filter(lecture=lecture)
        progresses = {p.enrollment_id: p for p in VideoProgress.objects.filter(video=video)}
        perms = {p.enrollment_id: p for p in VideoPermission.objects.filter(video=video)}
        attendance = {a.enrollment_id: a.status for a in Attendance.objects.filter(session=video.session)}

        students = []
        for e in enrollments:
            vp = progresses.get(e.id)
            perm = perms.get(e.id)

            students.append({
                "student_name": e.student.name,
                "progress": vp.progress if vp else 0,
                "completed": vp.completed if vp else False,
                "attendance_status": attendance.get(e.id),
                "rule": perm.rule if perm else "free",
            })

        return Response({"video": VideoDetailSerializer(video).data, "students": students})

    # =======================================================
    # Playback API (v1 + CDN Signed Cookie + ?뺤콉 override)
    # =======================================================

    def _get_student_for_user(self, request):
        # Student.user (OneToOne, related_name="student_profile") 媛 ?덉뼱????
        return getattr(request.user, "student_profile", None)

    def _check_access(self, *, video: Video, enrollment: Enrollment) -> tuple[bool, str | None]:
        if video.status != Video.Status.READY:
            return False, "video_not_ready"

        if not SessionEnrollment.objects.filter(session=video.session, enrollment=enrollment).exists():
            return False, "no_session_access"

        perm = VideoPermission.objects.filter(video=video, enrollment=enrollment).first()
        rule = perm.rule if perm else "free"

        if rule == "blocked":
            return False, "blocked"

        if rule == "once":
            vp = VideoProgress.objects.filter(video=video, enrollment=enrollment).first()
            if vp and vp.completed:
                return False, "already_completed_once"

        return True, None

    def _load_permission(self, *, video: Video, enrollment: Enrollment) -> VideoPermission | None:
        return VideoPermission.objects.filter(video=video, enrollment=enrollment).first()

    def _effective_policy(self, *, video: Video, perm: VideoPermission | None) -> dict:
        allow_seek = bool(video.allow_skip)
        max_rate = float(video.max_speed or 1.0)
        watermark_enabled = bool(video.show_watermark)
        ui_speed_control = True

        if perm:
            if perm.allow_skip_override is not None:
                allow_seek = bool(perm.allow_skip_override)
            if perm.max_speed_override is not None:
                max_rate = float(perm.max_speed_override)

            if perm.show_watermark_override is not None:
                watermark_enabled = bool(perm.show_watermark_override)

            if getattr(perm, "block_seek", False):
                allow_seek = False

            if getattr(perm, "block_speed_control", False):
                ui_speed_control = False
                max_rate = 1.0

        return {
            "allow_seek": allow_seek,
            "playback_rate": {"max": max_rate, "ui_control": ui_speed_control},
            "watermark": {"enabled": watermark_enabled, "mode": "overlay", "fields": ["user_id"]},
            "concurrency": {
                "max_sessions": int(getattr(settings, "VIDEO_MAX_SESSIONS", 9999)),
                "max_devices": int(getattr(settings, "VIDEO_MAX_DEVICES", 9999)),
            },
        }

    def _hls_path_prefix_for_video(self, video_id: int) -> str:
        return f"/hls/videos/{video_id}/"

    def _public_play_url(self, video_id: int) -> str:
        cdn_base = getattr(settings, "CDN_HLS_BASE_URL", "").rstrip("/")
        path = f"/hls/videos/{video_id}/master.m3u8"
        return f"{cdn_base}{path}" if cdn_base else path

    def _set_signed_cookies(self, response: Response, *, video_id: int, expires_at: int) -> None:
        path_prefix = self._hls_path_prefix_for_video(video_id)
        cookies = build_signed_cookies_for_path(path_prefix=path_prefix, expires_at=expires_at)
        opts = default_cookie_options(path_prefix=path_prefix)

        max_age = max(0, int(expires_at - int(time.time())))
        for k, v in cookies.items():
            response.set_cookie(
                key=k,
                value=v,
                max_age=max_age,
                expires=None,
                **opts,
            )

    @action(detail=True, methods=["post"], url_path="play")
    def play(self, request, pk=None):
        video = self.get_object()

        req = PlaybackStartRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        enrollment_id = req.validated_data["enrollment_id"]
        device_id = req.validated_data["device_id"]

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.select_related("student", "lecture").get(
                id=enrollment_id,
                student=student,
                status="ACTIVE",
            )
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        max_sessions = int(policy["concurrency"]["max_sessions"])
        max_devices = int(policy["concurrency"]["max_devices"])

        ok_sess, sess, err = issue_session(
            user_id=request.user.id,
            device_id=device_id,
            ttl_seconds=ttl,
            max_sessions=max_sessions,
            max_devices=max_devices,
        )
        if not ok_sess:
            return Response({"detail": err}, status=409)

        session_id = str(sess["session_id"])
        expires_at = int(sess["expires_at"])

        VideoPlaybackSession.objects.create(
            video=video,
            enrollment=enrollment,
            session_id=session_id,
            device_id=device_id,
            status=VideoPlaybackSession.Status.ACTIVE,
        )

        token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        resp = PlaybackResponseSerializer({
            "token": token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })

        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="refresh")
    def refresh(self, request, pk=None):
        video = self.get_object()

        req = PlaybackRefreshRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        device_id = str(payload.get("device_id") or "")
        enrollment_id = int(payload.get("enrollment_id") or 0)

        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))
        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        new_token = create_playback_token(
            payload={
                "tenant_id": None,
                "video_id": video.id,
                "enrollment_id": enrollment.id,
                "user_id": request.user.id,
                "device_id": device_id,
                "session_id": session_id,
                "policy": policy,
            },
            ttl_seconds=ttl,
        )

        expires_at = int(time.time()) + ttl

        resp = PlaybackResponseSerializer({
            "token": new_token,
            "session_id": session_id,
            "expires_at": expires_at,
            "policy": policy,
            "play_url": self._public_play_url(video.id),
        })
        response = Response(resp.data, status=200)
        self._set_signed_cookies(response, video_id=video.id, expires_at=expires_at)
        return response

    @action(detail=True, methods=["post"], url_path="heartbeat")
    def heartbeat(self, request, pk=None):
        req = PlaybackHeartbeatRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        ttl = int(getattr(settings, "VIDEO_PLAYBACK_TTL_SECONDS", 600))

        ok_hb = heartbeat_session(user_id=request.user.id, session_id=session_id, ttl_seconds=ttl)
        if not ok_hb:
            return Response({"detail": "session_not_active"}, status=409)

        return Response({"status": "ok"}, status=200)

    @action(detail=True, methods=["post"], url_path="end")
    def end(self, request, pk=None):
        req = PlaybackEndRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)
        token = req.validated_data["token"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        session_id = str(payload.get("session_id") or "")
        end_session(user_id=request.user.id, session_id=session_id)

        VideoPlaybackSession.objects.filter(session_id=session_id).update(
            status=VideoPlaybackSession.Status.ENDED,
            ended_at=timezone.now(),
        )

        response = Response({"status": "ended"}, status=200)

        path_prefix = self._hls_path_prefix_for_video(int(pk))
        opts = default_cookie_options(path_prefix=path_prefix)

        response.delete_cookie("CloudFront-Policy", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Signature", domain=opts.get("domain"), path=opts.get("path"))
        response.delete_cookie("CloudFront-Key-Pair-Id", domain=opts.get("domain"), path=opts.get("path"))
        return response

    # =======================================================
    # Events API (v1: audit-only)
    # POST /media/videos/{id}/events/
    # =======================================================

    def _epoch_to_dt(self, epoch: int | None) -> datetime:
        if not epoch:
            return timezone.now()
        try:
            return datetime.fromtimestamp(int(epoch), tz=timezone.get_current_timezone())
        except Exception:
            return timezone.now()

    def _evaluate_violation(self, *, event_type: str, payload: dict, policy: dict) -> tuple[bool, str]:
        """
        v1: ?먮떒留???? 李⑤떒/?쒖옱???섏? ?딅뒗??
        """
        if event_type == VideoPlaybackEvent.EventType.SEEK_ATTEMPT:
            if not bool(policy.get("allow_seek", False)):
                return True, "seek_not_allowed"

        if event_type == VideoPlaybackEvent.EventType.SPEED_CHANGE_ATTEMPT:
            pr = policy.get("playback_rate") or {}
            ui_control = bool(pr.get("ui_control", True))
            max_rate = float(pr.get("max", 1.0) or 1.0)

            to_rate = payload.get("to")
            try:
                to_rate = float(to_rate)
            except Exception:
                to_rate = None

            if not ui_control:
                return True, "speed_control_disabled"
            if to_rate is not None and to_rate > max_rate:
                return True, "speed_exceeds_max"

        return False, ""

    @action(detail=True, methods=["post"], url_path="events")
    def events(self, request, pk=None):
        """
        Batch ?대깽???섏쭛(媛먯궗 濡쒓렇).
        - token?쇰줈 video/enrollment/user/session??媛뺥븯寃??곌퀎
        - DB??payload + policy snapshot + violated ?먯젙 ???
        """
        video = self.get_object()

        req = PlaybackEventBatchRequestSerializer(data=request.data)
        req.is_valid(raise_exception=True)

        token = req.validated_data["token"]
        events = req.validated_data["events"]

        ok, payload, err = verify_playback_token(token)
        if not ok:
            return Response({"detail": err}, status=401)

        if int(payload.get("video_id") or 0) != int(video.id):
            return Response({"detail": "video_mismatch"}, status=401)
        if int(payload.get("user_id") or 0) != int(request.user.id):
            return Response({"detail": "user_mismatch"}, status=401)

        enrollment_id = int(payload.get("enrollment_id") or 0)
        session_id = str(payload.get("session_id") or "")

        if not is_session_active(user_id=request.user.id, session_id=session_id):
            return Response({"detail": "session_not_active"}, status=409)

        student = self._get_student_for_user(request)
        if student is None:
            return Response({"detail": "student_profile_not_linked"}, status=403)

        try:
            enrollment = Enrollment.objects.get(id=enrollment_id, student=student, status="ACTIVE")
        except Enrollment.DoesNotExist:
            return Response({"detail": "enrollment_not_found"}, status=404)

        ok_access, reason = self._check_access(video=video, enrollment=enrollment)
        if not ok_access:
            return Response({"detail": reason}, status=403)

        perm = self._load_permission(video=video, enrollment=enrollment)
        policy = self._effective_policy(video=video, perm=perm)

        rows: list[VideoPlaybackEvent] = []
        for ev in events:
            ev_type = ev.get("type")
            ev_payload = ev.get("payload") or {}
            occurred_at_epoch = ev.get("occurred_at")

            violated, reason = self._evaluate_violation(
                event_type=ev_type,
                payload=ev_payload,
                policy=policy,
            )

            rows.append(
                VideoPlaybackEvent(
                    video=video,
                    enrollment=enrollment,
                    session_id=session_id,
                    user_id=request.user.id,
                    event_type=ev_type,
                    event_payload=ev_payload,
                    policy_snapshot=policy,
                    violated=violated,
                    violation_reason=reason,
                    occurred_at=self._epoch_to_dt(occurred_at_epoch),
                )
            )

        if rows:
            VideoPlaybackEvent.objects.bulk_create(rows, batch_size=500)

        resp = PlaybackEventBatchResponseSerializer({"stored": len(rows)})
        return Response(resp.data, status=200)


class VideoPermissionViewSet(ModelViewSet):
    queryset = VideoPermission.objects.all()
    serializer_class = VideoPermissionSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


class VideoProgressViewSet(ModelViewSet):
    queryset = VideoProgress.objects.all()
    serializer_class = VideoProgressSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["video", "enrollment"]
    permission_classes = [IsAuthenticated]


====================
FILE: C:\academy\apps\support\media\urls.py
====================

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    VideoViewSet,
    VideoPermissionViewSet,
    VideoProgressViewSet,
)

router = DefaultRouter()

# ========================================================
# Video
# ========================================================

router.register(r"videos", VideoViewSet, basename="videos")
router.register(
    r"video-permissions",
    VideoPermissionViewSet,
    basename="video-permissions",
)
router.register(
    r"video-progress",
    VideoProgressViewSet,
    basename="video-progress",
)

urlpatterns = [
    path("", include(router.urls)),
]

# ========================================================
# Nested / ?곸꽭 Video API
# ========================================================

video_detail = VideoViewSet.as_view({"get": "retrieve"})
video_stats = VideoViewSet.as_view({"get": "stats"})

urlpatterns += [
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/",
        video_detail,
        name="media-video-detail-nested",
    ),
    path(
        "lectures/<int:lecture_id>/sessions/<int:session_id>/videos/<int:pk>/stats/",
        video_stats,
        name="media-video-stats-nested",
    ),
]


====================
FILE: C:\academy\apps\support\media\services\playback_session.py
====================

import time
import uuid
from typing import Dict, Any, Tuple

from libs.redis_client.client import redis_client


def _now() -> int:
    return int(time.time())


def _key_user_sessions(user_id: int) -> str:
    return f"media:playback:user:{user_id}:sessions"  # zset (sid -> expires_at)


def _key_session(session_id: str) -> str:
    return f"media:playback:session:{session_id}"     # hash


def _key_user_devices(user_id: int) -> str:
    return f"media:playback:user:{user_id}:devices"   # set


def _cleanup_expired_sessions(user_id: int) -> None:
    key = _key_user_sessions(user_id)
    now = _now()

    expired = redis_client.zrangebyscore(key, 0, now)
    if not expired:
        return

    pipe = redis_client.pipeline(transaction=False)
    for sid in expired:
        pipe.zrem(key, sid)
        pipe.delete(_key_session(str(sid)))
    pipe.execute()


def issue_session(
    *,
    user_id: int,
    device_id: str,
    ttl_seconds: int,
    max_sessions: int,
    max_devices: int,
) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not device_id:
        return False, None, "device_id_required"

    _cleanup_expired_sessions(user_id)

    sessions_key = _key_user_sessions(user_id)
    devices_key = _key_user_devices(user_id)

    now = _now()
    expires_at = now + int(ttl_seconds)

    existing_devices = redis_client.smembers(devices_key) or set()
    if device_id not in existing_devices and len(existing_devices) >= int(max_devices):
        return False, None, "device_limit_exceeded"

    active_count = int(redis_client.zcard(sessions_key) or 0)
    if active_count >= int(max_sessions):
        return False, None, "concurrency_limit_exceeded"

    session_id = str(uuid.uuid4())

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: expires_at})
    pipe.expire(sessions_key, ttl_seconds + 60)

    pipe.hset(_key_session(session_id), mapping={
        "user_id": str(user_id),
        "device_id": device_id,
        "expires_at": str(expires_at),
        "last_seen": str(now),
    })
    pipe.expire(_key_session(session_id), ttl_seconds + 60)

    pipe.sadd(devices_key, device_id)
    pipe.expire(devices_key, ttl_seconds + 60)
    pipe.execute()

    return True, {"session_id": session_id, "expires_at": expires_at}, None


def heartbeat_session(*, user_id: int, session_id: str, ttl_seconds: int) -> bool:
    sessions_key = _key_user_sessions(user_id)
    sid_key = _key_session(session_id)

    raw = redis_client.hget(sid_key, "expires_at")
    if not raw:
        return False

    now = _now()
    new_expires_at = now + int(ttl_seconds)

    pipe = redis_client.pipeline(transaction=True)
    pipe.zadd(sessions_key, {session_id: new_expires_at})
    pipe.hset(sid_key, mapping={"expires_at": str(new_expires_at), "last_seen": str(now)})
    pipe.expire(sessions_key, ttl_seconds + 60)
    pipe.expire(sid_key, ttl_seconds + 60)
    pipe.execute()
    return True


def end_session(*, user_id: int, session_id: str) -> None:
    sessions_key = _key_user_sessions(user_id)
    pipe = redis_client.pipeline(transaction=False)
    pipe.zrem(sessions_key, session_id)
    pipe.delete(_key_session(session_id))
    pipe.execute()


def is_session_active(*, user_id: int, session_id: str) -> bool:
    sessions_key = _key_user_sessions(user_id)
    score = redis_client.zscore(sessions_key, session_id)
    if score is None:
        return False
    return int(score) > _now()


====================
FILE: C:\academy\apps\support\media\serializers.py
====================

from rest_framework import serializers

from .models import (
    Video,
    VideoPermission,
    VideoProgress,
    VideoPlaybackSession,
    VideoPlaybackEvent,
)


class VideoSerializer(serializers.ModelSerializer):
    source_type = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "id",
            "session_id",
            "title",
            "youtube_id",
            "external_url",
            "file",
            "file_key",
            "duration",
            "order",
            "status",
            "allow_skip",
            "max_speed",
            "show_watermark",
            "created_at",
            "updated_at",
            "source_type",
        ]
        read_only_fields = ["created_at", "updated_at"]
        ref_name = "MediaVideo"

    def get_source_type(self, obj):
        return obj.source_type


class VideoPermissionSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoPermission
        fields = "__all__"
        ref_name = "MediaVideoPermission"


class VideoProgressSerializer(serializers.ModelSerializer):
    student_name = serializers.CharField(
        source="enrollment.student.name",
        read_only=True,
    )

    class Meta:
        model = VideoProgress
        fields = "__all__"
        ref_name = "MediaVideoProgress"


class VideoDetailSerializer(VideoSerializer):
    class Meta(VideoSerializer.Meta):
        ref_name = "MediaVideoDetail"


# ========================================================
# Playback API (v1)
# ========================================================

class PlaybackStartRequestSerializer(serializers.Serializer):
    enrollment_id = serializers.IntegerField()
    device_id = serializers.CharField(max_length=128)


class PlaybackRefreshRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackHeartbeatRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackEndRequestSerializer(serializers.Serializer):
    token = serializers.CharField()


class PlaybackResponseSerializer(serializers.Serializer):
    token = serializers.CharField()
    session_id = serializers.CharField()
    expires_at = serializers.IntegerField()
    policy = serializers.JSONField()
    play_url = serializers.CharField()


class PlaybackSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = VideoPlaybackSession
        fields = "__all__"
        ref_name = "MediaVideoPlaybackSession"


# ========================================================
# Event collection (v1: audit-only)
# ========================================================

class PlaybackEventItemSerializer(serializers.Serializer):
    type = serializers.ChoiceField(choices=VideoPlaybackEvent.EventType.choices)
    occurred_at = serializers.IntegerField(required=False)  # epoch seconds
    payload = serializers.JSONField(required=False)


class PlaybackEventBatchRequestSerializer(serializers.Serializer):
    token = serializers.CharField()
    events = PlaybackEventItemSerializer(many=True)


class PlaybackEventBatchResponseSerializer(serializers.Serializer):
    stored = serializers.IntegerField()


====================
FILE: C:\academy\apps\support\media\drm.py
====================

import time
from typing import Any, Dict, Tuple

from django.core import signing


_SALT = "media.playback.token.v1"


def create_playback_token(*, payload: Dict[str, Any], ttl_seconds: int) -> str:
    now = int(time.time())
    data = dict(payload or {})
    data["iat"] = now
    data["exp"] = now + int(ttl_seconds)
    return signing.dumps(data, salt=_SALT, compress=True)


def verify_playback_token(token: str) -> Tuple[bool, Dict[str, Any] | None, str | None]:
    if not token:
        return False, None, "token_required"

    try:
        data = signing.loads(token, salt=_SALT)
    except signing.BadSignature:
        return False, None, "invalid_token"
    except Exception:
        return False, None, "token_decode_failed"

    try:
        exp = int(data.get("exp") or 0)
    except Exception:
        return False, None, "token_exp_invalid"

    if exp <= int(time.time()):
        return False, None, "token_expired"

    return True, data, None


====================
FILE: C:\academy\apps\support\media\cdn\cloudfront.py
====================

import base64
import json
from typing import Dict
from django.conf import settings


# =========================
# Public API
# =========================

def build_signed_cookies_for_path(*, path_prefix: str, expires_at: int) -> Dict[str, str]:
    """
    DEV/LOCAL:
      - CloudFront ?ъ슜 ??????鍮?dict 諛섑솚

    PROD:
      - CloudFront Signed Cookies ?앹꽦
    """
    if settings.DEBUG:
        return {}

    key_pair_id = _required("CLOUDFRONT_KEY_PAIR_ID")
    domain = _required("CLOUDFRONT_DOMAIN").rstrip("/")

    resource = f"https://{domain}{path_prefix}*"

    policy = {
        "Statement": [{
            "Resource": resource,
            "Condition": {
                "DateLessThan": {"AWS:EpochTime": int(expires_at)}
            }
        }]
    }

    policy_json = json.dumps(policy, separators=(",", ":")).encode("utf-8")

    from botocore.signers import CloudFrontSigner

    signer = CloudFrontSigner(key_pair_id, _rsa_signer)

    signed_policy = _b64_urlsafe(policy_json)
    signature = signer._sign(policy_json)

    return {
        "CloudFront-Policy": signed_policy,
        "CloudFront-Signature": _b64_urlsafe(signature),
        "CloudFront-Key-Pair-Id": key_pair_id,
    }


def default_cookie_options(*, path_prefix: str) -> dict:
    """
    DEV: cookie ?ㅼ젙 ????
    PROD: CloudFront ?꾨찓??荑좏궎 ?ㅼ젙
    """
    if settings.DEBUG:
        return {}

    domain = _required("CLOUDFRONT_DOMAIN")

    secure = bool(getattr(settings, "SESSION_COOKIE_SECURE", False))

    return {
        "domain": domain,
        "path": path_prefix,
        "httponly": True,
        "secure": secure,
        "samesite": "Lax",
    }


# =========================
# Internal helpers
# =========================

def _required(name: str) -> str:
    v = getattr(settings, name, None)
    if not v:
        raise RuntimeError(f"Missing setting: {name}")
    return str(v)


def _load_private_key_pem() -> bytes:
    pem = _required("CLOUDFRONT_PRIVATE_KEY_PEM")
    pem = pem.replace("\\n", "\n")
    return pem.encode("utf-8")


def _rsa_signer(message: bytes) -> bytes:
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.primitives.asymmetric import padding

    key = load_pem_private_key(_load_private_key_pem(), password=None)
    return key.sign(message, padding.PKCS1v15(), hashes.SHA1())


def _b64_urlsafe(data: bytes) -> str:
    return (
        base64.b64encode(data)
        .decode("utf-8")
        .replace("+", "-")
        .replace("=", "_")
        .replace("/", "~")
    )


====================
FILE: C:\academy\apps\support\media\models.py
====================

from django.db import models
from django.utils import timezone

from apps.api.common.models import TimestampModel
from apps.domains.lectures.models import Session
from apps.domains.enrollment.models import Enrollment


# ========================================================
# Video (?곸긽 硫뷀??곗씠??
# ========================================================

class Video(TimestampModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "?낅줈???湲?
        UPLOADED = "UPLOADED", "?낅줈???꾨즺"
        PROCESSING = "PROCESSING", "泥섎━以?
        READY = "READY", "?ъ슜 媛??
        FAILED = "FAILED", "?ㅽ뙣"

    session = models.ForeignKey(
        Session,
        on_delete=models.CASCADE,
        related_name="videos",
    )

    title = models.CharField(max_length=255)

    # ===============================
    # Legacy sources (?좎?)
    # ===============================
    youtube_id = models.CharField(max_length=100, blank=True)
    external_url = models.URLField(blank=True)
    file = models.FileField(upload_to="videos/%Y/%m/%d/", blank=True)

    # ===============================
    # SaaS upload (Source of Truth)
    # ===============================
    file_key = models.CharField(
        max_length=500,
        blank=True,
        help_text="S3 object key (presigned upload)",
    )

    duration = models.PositiveIntegerField(null=True, blank=True)
    order = models.PositiveIntegerField(default=1)

    # ?몃꽕?쇱? Worker媛 ?앹꽦
    thumbnail = models.ImageField(
        upload_to="thumbnails/",
        null=True,
        blank=True,
    )

    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )

    # --------------------------------------------------
    # 湲곕낯 ?ъ깮 ?뺤콉 (鍮꾨뵒???⑥쐞 default)
    # --------------------------------------------------
    allow_skip = models.BooleanField(default=False)
    max_speed = models.FloatField(default=1.0)
    show_watermark = models.BooleanField(default=True)

    # --------------------------------------------------
    # Worker ?ㅽ뙣 ?ъ쑀 湲곕줉
    # --------------------------------------------------
    error_reason = models.TextField(blank=True, null=True, default="")

    class Meta:
        ordering = ["order", "id"]

    def __str__(self):
        return f"[{self.status}] {self.title}"

    @property
    def source_type(self) -> str:
        if self.file_key:
            return "s3"
        if self.file:
            return "file"
        if self.youtube_id:
            return "youtube"
        if self.external_url:
            return "external"
        return "unknown"


# ========================================================
# Video Permission (?섍컯?앸퀎 override + ?묎렐 洹쒖튃)
# ========================================================

class VideoPermission(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="permissions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_permissions",
    )

    rule = models.CharField(
        max_length=20,
        choices=[
            ("free", "臾댁젣??),
            ("once", "1???쒗븳"),
            ("blocked", "?쒗븳"),
        ],
        default="once",
    )

    # ?숈깮蹂??뺤콉 override (null?대㈃ Video 湲곕낯媛??ъ슜)
    allow_skip_override = models.BooleanField(null=True, blank=True)
    max_speed_override = models.FloatField(null=True, blank=True)
    show_watermark_override = models.BooleanField(null=True, blank=True)

    # 理쒖슦??李⑤떒 ?뚮옒洹?
    block_speed_control = models.BooleanField(default=False)
    block_seek = models.BooleanField(default=False)

    is_override = models.BooleanField(default=False)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_permission",
            )
        ]

    def __str__(self):
        return f"{self.enrollment.student.name} {self.video.title} ({self.rule})"


# ========================================================
# Video Progress
# ========================================================

class VideoProgress(models.Model):
    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="progresses",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_progress",
    )

    progress = models.FloatField(default=0)
    last_position = models.IntegerField(default=0)
    completed = models.BooleanField(default=False)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["video", "enrollment"],
                name="unique_video_progress",
            )
        ]

    def __str__(self):
        return (
            f"{self.enrollment.student.name} - "
            f"{self.video.title} ({self.progress * 100:.1f}%)"
        )


# ========================================================
# Video Playback Session (?몄뀡 / 媛먯궗)
# ========================================================

class VideoPlaybackSession(TimestampModel):
    class Status(models.TextChoices):
        ACTIVE = "ACTIVE", "?쒖꽦"
        ENDED = "ENDED", "醫낅즺"
        REVOKED = "REVOKED", "李⑤떒"
        EXPIRED = "EXPIRED", "留뚮즺"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="playback_sessions",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    device_id = models.CharField(max_length=128, db_index=True)

    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.ACTIVE,
        db_index=True,
    )

    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session_id"],
                name="uniq_video_playback_session_id",
            )
        ]

    def __str__(self):
        return f"{self.video_id}/{self.enrollment_id} {self.session_id} {self.status}"


# ========================================================
# Video Playback Event (v1: Audit only)
# ========================================================

class VideoPlaybackEvent(TimestampModel):
    class EventType(models.TextChoices):
        VISIBILITY_HIDDEN = "VISIBILITY_HIDDEN", "???④?"
        VISIBILITY_VISIBLE = "VISIBILITY_VISIBLE", "???몄텧"
        FOCUS_LOST = "FOCUS_LOST", "?ъ빱???댄깉"
        FOCUS_GAINED = "FOCUS_GAINED", "?ъ빱??蹂듦?"
        SEEK_ATTEMPT = "SEEK_ATTEMPT", "?먯깋 ?쒕룄"
        SPEED_CHANGE_ATTEMPT = "SPEED_CHANGE_ATTEMPT", "諛곗냽 蹂寃??쒕룄"
        FULLSCREEN_ENTER = "FULLSCREEN_ENTER", "?꾩껜?붾㈃ 吏꾩엯"
        FULLSCREEN_EXIT = "FULLSCREEN_EXIT", "?꾩껜?붾㈃ 醫낅즺"
        PLAYER_ERROR = "PLAYER_ERROR", "?뚮젅?댁뼱 ?ㅻ쪟"

    video = models.ForeignKey(
        Video,
        on_delete=models.CASCADE,
        related_name="playback_events",
    )
    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="video_playback_events",
    )

    session_id = models.CharField(max_length=64, db_index=True)
    user_id = models.BigIntegerField(db_index=True)

    event_type = models.CharField(
        max_length=32,
        choices=EventType.choices,
        db_index=True,
    )

    event_payload = models.JSONField(default=dict, blank=True)
    policy_snapshot = models.JSONField(default=dict, blank=True)

    violated = models.BooleanField(default=False, db_index=True)
    violation_reason = models.CharField(max_length=64, blank=True, default="")

    occurred_at = models.DateTimeField(default=timezone.now)
    received_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["video", "enrollment", "session_id"]),
            models.Index(fields=["user_id", "session_id"]),
            models.Index(fields=["event_type", "received_at"]),
        ]
        ordering = ["-received_at", "-id"]

    def __str__(self):
        return f"{self.session_id} {self.event_type} v={self.violated}"


====================
FILE: C:\academy\apps\api\config\settings\base.py
====================

from pathlib import Path
from datetime import timedelta
import os

# ==================================================
# BASE
# ==================================================

BASE_DIR = Path(__file__).resolve().parents[3]

SECRET_KEY = "dev-secret-key"
DEBUG = True
ALLOWED_HOSTS = ["*"]

AUTH_USER_MODEL = "core.User"


# ==================================================
# INSTALLED APPS
# ==================================================

INSTALLED_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Common / Core
    "apps.api.common",
    "apps.core",

    # Domain Apps
    "apps.domains.students",
    "apps.domains.teachers",
    "apps.domains.staffs",
    "apps.domains.parents",

    "apps.domains.lectures",
    "apps.domains.enrollment",
    "apps.domains.attendance",
    "apps.domains.schedule",

    "apps.domains.interactions.materials",
    "apps.domains.interactions.questions",
    "apps.domains.interactions.counseling",
    "apps.domains.interactions.boards",

    "apps.domains.exams",
    "apps.domains.homework",
    "apps.domains.submissions",
    "apps.domains.results",

    "apps.domains.clinic",

    "apps.domains.ai.apps.AIDomainConfig",

    # support
    "apps.support.media",

    # REST
    "rest_framework",
    "rest_framework_simplejwt",
    "django_filters",

    # Swagger
    "drf_yasg",

    # CORS
    "corsheaders",
]

# ==================================================
# MIDDLEWARE
# ==================================================

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",

    # Tenant
    "apps.core.middleware.tenant.TenantMiddleware",
]

# ==================================================
# URL / WSGI / ASGI
# ==================================================

ROOT_URLCONF = "apps.api.config.urls"

WSGI_APPLICATION = "apps.api.config.wsgi.application"
ASGI_APPLICATION = "apps.api.config.asgi.application"

# ==================================================
# TEMPLATES
# ==================================================

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

# ==================================================
# DATABASE
# ==================================================

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "academy",
        "USER": "postgres",
        "PASSWORD": "kjkszpj123",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}

# ==================================================
# AUTH
# ==================================================

AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",
]

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"
    },
]

# ==================================================
# GLOBAL
# ==================================================

LANGUAGE_CODE = "ko-kr"
TIME_ZONE = "Asia/Seoul"

USE_I18N = True
USE_TZ = True

STATIC_URL = "/static/"
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "storage" / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# ==================================================
# DRF
# ==================================================

REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
}

# ==================================================
# JWT
# ==================================================

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(days=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=60),
    "AUTH_HEADER_TYPES": ("Bearer",),
}

# ==================================================
# CORS
# ==================================================

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# ==================================================
# CELERY / REDIS
# ==================================================

CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/1"

CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"

CELERY_TIMEZONE = TIME_ZONE

CELERY_TASK_ACKS_LATE = True
CELERY_TASK_REJECT_ON_WORKER_LOST = True
CELERY_WORKER_PREFETCH_MULTIPLIER = 1

# ==================================================
# VIDEO PLAYBACK / CDN
# ==================================================

CLOUDFRONT_DOMAIN = os.getenv("CLOUDFRONT_DOMAIN", "")
CLOUDFRONT_KEY_PAIR_ID = os.getenv("CLOUDFRONT_KEY_PAIR_ID", "")
CLOUDFRONT_PRIVATE_KEY_PEM = os.getenv("CLOUDFRONT_PRIVATE_KEY_PEM", "")

CDN_HLS_BASE_URL = os.getenv("CDN_HLS_BASE_URL", "")

VIDEO_PLAYBACK_TTL_SECONDS = int(os.getenv("VIDEO_PLAYBACK_TTL_SECONDS", "600"))
VIDEO_MAX_SESSIONS = int(os.getenv("VIDEO_MAX_SESSIONS", "1"))
VIDEO_MAX_DEVICES = int(os.getenv("VIDEO_MAX_DEVICES", "2"))

REQUIRED_ENV_VARS = [
    ("CLOUDFRONT_DOMAIN", CLOUDFRONT_DOMAIN),
    ("CLOUDFRONT_KEY_PAIR_ID", CLOUDFRONT_KEY_PAIR_ID),
    ("CLOUDFRONT_PRIVATE_KEY_PEM", CLOUDFRONT_PRIVATE_KEY_PEM),
    ("CDN_HLS_BASE_URL", CDN_HLS_BASE_URL),
]

# NOTE:
# 媛쒕컻/踰좏? ?④퀎?먯꽌???덉쇅瑜??섏?吏 ?딄퀬 ?곹깭留?湲곕줉?쒕떎.
# ?ㅼ젣 ?ъ깮 API?먯꽌留?VIDEO_PLAYBACK_ENABLED ?щ?瑜??뺤씤??李⑤떒?쒕떎.
VIDEO_PLAYBACK_CONFIG_MISSING = [
    name for name, value in REQUIRED_ENV_VARS if not value
]

VIDEO_PLAYBACK_ENABLED = not bool(VIDEO_PLAYBACK_CONFIG_MISSING)


====================
FILE: C:\academyfront\src\features\media\playback\api\playback.ts
====================

// src/features/media/playback/api/playback.ts

import api from "@/shared/api/axios";
import type { PlaybackStartResponse, PostEventsBody } from "./types";

/**
 * ??以묒슂
 * heartbeat/refresh/end ?붾뱶?ъ씤??寃쎈줈??"?덈? 異붿륫 湲덉?".
 * 諛깆뿏?쒖뿉???ㅼ젣 URL???뺤젙?????ш린留?梨꾩슦硫???
 */
export const PLAYBACK_ENDPOINTS = {
  // play??怨좎젙(?꾩젣)
  play: (videoId: number) => `/api/v1/media/videos/${videoId}/play/`,

  // ?꾨옒 3媛쒕뒗 諛깆뿏???ㅼ젣 寃쎈줈濡?梨꾩썙????(?꾩옱??placeholders)
  heartbeat: (videoId: number) => `/api/v1/media/videos/${videoId}/heartbeat/`,
  refresh: (videoId: number) => `/api/v1/media/videos/${videoId}/refresh/`,
  end: (videoId: number) => `/api/v1/media/videos/${videoId}/end/`,

  // events??怨좎젙(?꾩젣)
  events: (videoId: number) => `/api/v1/media/videos/${videoId}/events/`,
};

export async function playVideo(params: {
  videoId: number;
  enrollment_id: number;
  device_id: string;
}): Promise<PlaybackStartResponse> {
  const res = await api.post(PLAYBACK_ENDPOINTS.play(params.videoId), {
    enrollment_id: params.enrollment_id,
    device_id: params.device_id,
  });
  return res.data as PlaybackStartResponse;
}

export async function postPlaybackEvents(videoId: number, body: PostEventsBody) {
  // v1: ?ㅽ뙣?대룄 ?ъ떆???놁쓬 ???몄텧?먮뒗 catch ??踰꾨━硫???
  await api.post(PLAYBACK_ENDPOINTS.events(videoId), body);
}

/**
 * best-effort flush (visibilitychange / beforeunload)
 * - 媛?ν븯硫?sendBeacon
 * - ?꾨땲硫?fetch keepalive
 * - ?ㅽ뙣?대룄 臾댁떆
 */
export async function postPlaybackEventsBestEffort(
  videoId: number,
  body: PostEventsBody,
) {
  try {
    const url = PLAYBACK_ENDPOINTS.events(videoId);

    // sendBeacon ?ъ슜 媛????
    if (typeof navigator !== "undefined" && "sendBeacon" in navigator) {
      const blob = new Blob([JSON.stringify(body)], {
        type: "application/json",
      });
      // sendBeacon? boolean 諛섑솚, ?ㅽ뙣?대룄 ??
      (navigator as any).sendBeacon(url, blob);
      return;
    }

    // fetch keepalive
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      keepalive: true,
      credentials: "include",
    });
  } catch {
    // v1: drop
  }
}

export async function heartbeatSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.heartbeat(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}

export async function refreshSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}): Promise<PlaybackStartResponse | { token: string; expires_at: number }> {
  const res = await api.post(PLAYBACK_ENDPOINTS.refresh(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
  return res.data;
}

export async function endSession(params: {
  videoId: number;
  token: string;
  session_id: string;
}) {
  await api.post(PLAYBACK_ENDPOINTS.end(params.videoId), {
    token: params.token,
    session_id: params.session_id,
  });
}


====================
FILE: C:\academyfront\src\features\media\playback\api\types.ts
====================

// src/features/media/playback/api/types.ts

export type PlaybackConcurrencyPolicy = {
  max_devices?: number;
  max_concurrent_sessions?: number;
};

export type PlaybackRatePolicy =
  | { max?: number }
  | { max: number; allowed?: number[] };

export type WatermarkPolicy =
  | { enabled?: boolean; text?: string }
  | { enabled: boolean; mode?: "overlay" | "burnin" };

export type PlaybackPolicy = {
  allow_seek?: boolean;
  playback_rate?: PlaybackRatePolicy | number | null;
  watermark?: WatermarkPolicy | null;
  concurrency?: PlaybackConcurrencyPolicy | null;
};

export type PlaybackStartResponse = {
  token: string;
  session_id: string;
  expires_at: number; // epoch seconds
  policy: PlaybackPolicy;
  play_url: string; // may be relative: /hls/...
};

export type PlaybackEventType =
  | "play_start"
  | "pause"
  | "ended"
  | "seek_attempt"
  | "speed_change_attempt"
  | "visibility_change";

export type PlaybackEvent = {
  type: PlaybackEventType;
  payload?: Record<string, any>;
  occurred_at: number; // epoch seconds
};

export type PostEventsBody = {
  token: string;
  events: PlaybackEvent[];
};


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackSession.ts
====================

// src/features/media/playback/hooks/usePlaybackSession.ts

import { useCallback, useEffect, useRef, useState } from "react";
import type { PlaybackPolicy, PlaybackStartResponse } from "../api/types";
import {
  playVideo,
  heartbeatSession,
  refreshSession,
  endSession,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type State = {
  token: string | null;
  sessionId: string | null;
  expiresAt: number | null;
  policy: PlaybackPolicy | null;
  playUrl: string | null; // raw play_url (may be relative)
};

type Args = {
  videoId: number;
  enrollmentId: number | null;
  deviceId: string;
  enabled: boolean;
};

export function usePlaybackSession({
  videoId,
  enrollmentId,
  deviceId,
  enabled,
}: Args) {
  const [state, setState] = useState<State>({
    token: null,
    sessionId: null,
    expiresAt: null,
    policy: null,
    playUrl: null,
  });

  const tokenRef = useRef<string | null>(null);
  const sessionRef = useRef<string | null>(null);
  const expiresRef = useRef<number | null>(null);

  const refreshInFlightRef = useRef(false);

  const setFromStart = useCallback((resp: PlaybackStartResponse) => {
    tokenRef.current = resp.token;
    sessionRef.current = resp.session_id;
    expiresRef.current = resp.expires_at;

    setState({
      token: resp.token,
      sessionId: resp.session_id,
      expiresAt: resp.expires_at,
      policy: resp.policy,
      playUrl: resp.play_url,
    });
  }, []);

  const start = useCallback(async () => {
    if (!enabled) return;
    if (!enrollmentId) return;

    const resp = await playVideo({
      videoId,
      enrollment_id: enrollmentId,
      device_id: deviceId,
    });

    setFromStart(resp);
  }, [deviceId, enabled, enrollmentId, setFromStart, videoId]);

  const heartbeat = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;

    if (!enabled || !token || !session_id) return;

    try {
      await heartbeatSession({ videoId, token, session_id });
    } catch {
      // v1: heartbeat ?ㅽ뙣濡?利됱떆 UX ?곹뼢 二쇱? ?딆쓬 (drop)
    }
  }, [enabled, videoId]);

  const refresh = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    const expiresAt = expiresRef.current;

    if (!enabled || !token || !session_id || !expiresAt) return;

    const now = nowEpochSeconds();
    const left = expiresAt - now;

    // 60珥??대궡 ?꾨컯 ??refresh
    if (left > 60) return;
    if (refreshInFlightRef.current) return;

    refreshInFlightRef.current = true;
    try {
      const resp = await refreshSession({ videoId, token, session_id });

      // refresh ?묐떟 ?ㅽ궎留덇? 2媛吏?????덉뼱 ?좎뿰 泥섎━
      if ((resp as any).session_id && (resp as any).play_url) {
        // full PlaybackStartResponse ?뺥깭
        setFromStart(resp as any);
      } else {
        // token + expires_at留?媛깆떊
        const nextToken = (resp as any).token;
        const nextExpires = (resp as any).expires_at;

        if (typeof nextToken === "string") tokenRef.current = nextToken;
        if (typeof nextExpires === "number") expiresRef.current = nextExpires;

        setState((prev) => ({
          ...prev,
          token: tokenRef.current,
          expiresAt: expiresRef.current,
        }));
      }
    } catch {
      // v1: drop
    } finally {
      refreshInFlightRef.current = false;
    }
  }, [enabled, setFromStart, videoId]);

  const end = useCallback(async () => {
    const token = tokenRef.current;
    const session_id = sessionRef.current;
    if (!enabled || !token || !session_id) return;

    try {
      await endSession({ videoId, token, session_id });
    } catch {
      // v1: drop
    }
  }, [enabled, videoId]);

  // enabled ??start 1??
  useEffect(() => {
    if (!enabled) return;
    if (!enrollmentId) return;

    void start();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [enabled, enrollmentId, videoId]);

  // heartbeat 45珥?二쇨린
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void heartbeat();
      void refresh();
    }, 45000);

    return () => window.clearInterval(t);
  }, [enabled, heartbeat, refresh]);

  // unmount end 1??
  useEffect(() => {
    return () => {
      void end();
    };
  }, [end]);

  return {
    ...state,
    getToken: () => tokenRef.current,
    start,
    heartbeat,
    refresh,
    end,
  };
}


====================
FILE: C:\academyfront\src\features\media\playback\hooks\usePlaybackEvents.ts
====================

// src/features/media/playback/hooks/usePlaybackEvents.ts

import { useCallback, useEffect, useRef } from "react";
import type { PlaybackEvent } from "../api/types";
import {
  postPlaybackEvents,
  postPlaybackEventsBestEffort,
} from "../api/playback";
import { nowEpochSeconds } from "../utils/time";

type Args = {
  videoId: number;
  getToken: () => string | null;
  enabled: boolean;
};

export function usePlaybackEvents({ videoId, getToken, enabled }: Args) {
  const queueRef = useRef<PlaybackEvent[]>([]);
  const flushingRef = useRef(false);

  const push = useCallback(
    (type: PlaybackEvent["type"], payload?: PlaybackEvent["payload"]) => {
      if (!enabled) return;

      queueRef.current.push({
        type,
        payload,
        occurred_at: nowEpochSeconds(),
      });

      if (queueRef.current.length >= 10) {
        void flush(false);
      }
    },
    [enabled],
  );

  const flush = useCallback(
    async (bestEffort: boolean) => {
      if (!enabled) return;
      if (flushingRef.current) return;

      const token = getToken();
      if (!token) return;

      const events = queueRef.current;
      if (!events.length) return;

      queueRef.current = [];
      flushingRef.current = true;

      try {
        const body = { token, events };
        if (bestEffort) {
          await postPlaybackEventsBestEffort(videoId, body);
        } else {
          await postPlaybackEvents(videoId, body);
        }
      } catch {
        // v1: ?ъ떆???놁쓬, drop
      } finally {
        flushingRef.current = false;
      }
    },
    [enabled, getToken, videoId],
  );

  // 5珥?二쇨린 flush
  useEffect(() => {
    if (!enabled) return;

    const t = window.setInterval(() => {
      void flush(false);
    }, 5000);

    return () => window.clearInterval(t);
  }, [enabled, flush]);

  // visibilitychange hidden ??best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      if (document.visibilityState === "hidden") {
        void flush(true);
      } else {
        push("visibility_change", { state: "visible" });
      }
    };

    document.addEventListener("visibilitychange", handler);
    return () => document.removeEventListener("visibilitychange", handler);
  }, [enabled, flush, push]);

  // beforeunload best-effort flush
  useEffect(() => {
    if (!enabled) return;

    const handler = () => {
      void flush(true);
    };

    window.addEventListener("beforeunload", handler);
    return () => window.removeEventListener("beforeunload", handler);
  }, [enabled, flush]);

  return { push, flush };
}


====================
FILE: C:\academyfront\src\features\media\playback\player\StudentVideoPlayer.tsx
====================

import { useEffect, useRef, useState, useCallback } from "react";
import Hls from "hls.js";

import { usePlaybackEvents } from "@/features/media/playback/hooks/usePlaybackEvents";
import { usePlaybackSession } from "@/features/media/playback/hooks/usePlaybackSession";
import { resolvePlayUrl } from "@/features/media/playback/utils/resolvePlayUrl";
import { getDeviceId } from "@/features/media/playback/utils/deviceId";
import WatermarkOverlay from "@/features/media/playback/player/WatermarkOverlay";

type Props = {
  videoId: number;
  enrollmentId: number;
};

export default function StudentVideoPlayer({
  videoId,
  enrollmentId,
}: Props) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const hlsRef = useRef<Hls | null>(null);

  // playback session state
  const {
    start,
    refresh,
    heartbeat,
    end,
    token,
    playUrl,
    policy,
    expiresAt,
    ready,
  } = usePlaybackSession();

  // audit events
  const { push } = usePlaybackEvents({
    videoId,
    enabled: ready,
    getToken: () => token,
  });

  // ---------------------------------------------
  // START playback session on mount
  // ---------------------------------------------
  useEffect(() => {
    start({
      videoId,
      enrollmentId,
      deviceId: getDeviceId(),
    });

    return () => {
      end(); // best-effort
    };
  }, [videoId, enrollmentId, start, end]);

  // ---------------------------------------------
  // HEARTBEAT (30s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready) return;

    const t = window.setInterval(() => {
      heartbeat();
    }, 30_000);

    return () => window.clearInterval(t);
  }, [ready, heartbeat]);

  // ---------------------------------------------
  // REFRESH (expires_at - 60s)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !expiresAt) return;

    const now = Date.now() / 1000;
    const delay = Math.max((expiresAt - 60 - now) * 1000, 5_000);

    const t = window.setTimeout(() => {
      refresh();
    }, delay);

    return () => window.clearTimeout(t);
  }, [ready, expiresAt, refresh]);

  // ---------------------------------------------
  // ATTACH VIDEO (HLS)
  // ---------------------------------------------
  useEffect(() => {
    if (!ready || !playUrl || !videoRef.current) return;

    const video = videoRef.current;
    const src = resolvePlayUrl(playUrl);

    // Safari / iOS
    if (video.canPlayType("application/vnd.apple.mpegurl")) {
      video.src = src;
    } else if (Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: false,
      });

      hls.loadSource(src);
      hls.attachMedia(video);
      hlsRef.current = hls;
    }

    return () => {
      hlsRef.current?.destroy();
      hlsRef.current = null;
    };
  }, [ready, playUrl]);

  // ---------------------------------------------
  // VIDEO EVENT BINDING
  // ---------------------------------------------
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !ready) return;

    const onPlay = () => push("play_start");
    const onPause = () => push("pause");
    const onEnded = () => push("ended");

    let lastTime = video.currentTime;

    const onSeeking = () => {
      const from = lastTime;
      const to = video.currentTime;
      push("seek_attempt", { from, to });
      lastTime = to;
    };

    const onRateChange = () => {
      push("speed_change_attempt", {
        to: video.playbackRate,
      });
    };

    const onTimeUpdate = () => {
      lastTime = video.currentTime;
    };

    video.addEventListener("play", onPlay);
    video.addEventListener("pause", onPause);
    video.addEventListener("ended", onEnded);
    video.addEventListener("seeking", onSeeking);
    video.addEventListener("ratechange", onRateChange);
    video.addEventListener("timeupdate", onTimeUpdate);

    return () => {
      video.removeEventListener("play", onPlay);
      video.removeEventListener("pause", onPause);
      video.removeEventListener("ended", onEnded);
      video.removeEventListener("seeking", onSeeking);
      video.removeEventListener("ratechange", onRateChange);
      video.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, [ready, push]);

  // ---------------------------------------------
  // SPEED UI CONTROL (policy)
  // ---------------------------------------------
  const maxRate = policy?.playback_rate?.max ?? 1.0;
  const allowRateControl = policy?.playback_rate?.ui_control !== false;

  const changeRate = useCallback(
    (rate: number) => {
      if (!videoRef.current) return;
      if (!allowRateControl) return;

      const clamped = Math.min(rate, maxRate);
      videoRef.current.playbackRate = clamped;
    },
    [allowRateControl, maxRate],
  );

  // ---------------------------------------------
  // RENDER
  // ---------------------------------------------
  if (!ready) {
    return (
      <div className="h-64 flex items-center justify-center text-sm text-gray-500">
        ?곸긽 濡쒕뵫 以?..
      </div>
    );
  }

  return (
    <div className="relative space-y-2">
      <div className="relative">
        <video
          ref={videoRef}
          controls
          playsInline
          className="w-full rounded-lg bg-black"
        />

        {policy?.watermark?.enabled && (
          <WatermarkOverlay
            fields={policy.watermark.fields}
            sessionId={policy?.session_id}
          />
        )}
      </div>

      {/* SPEED CONTROL */}
      {allowRateControl && (
        <div className="flex items-center gap-2 text-xs text-gray-600">
          <span>諛곗냽</span>
          {[0.5, 1, 1.25, 1.5, 2].map((r) => (
            <button
              key={r}
              disabled={r > maxRate}
              onClick={() => changeRate(r)}
              className={`px-2 py-1 rounded border ${
                r > maxRate
                  ? "opacity-30 cursor-not-allowed"
                  : "hover:bg-gray-100"
              }`}
            >
              {r}x
            </button>
          ))}
        </div>
      )}
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\player\WatermarkOverlay.tsx
====================

// src/features/media/playback/player/WatermarkOverlay.tsx

import { useMemo } from "react";

type Props = {
  enabled: boolean;
  text?: string;
  sessionId?: string | null;
};

export default function WatermarkOverlay({ enabled, text, sessionId }: Props) {
  const label = useMemo(() => {
    const base = text?.trim() || "臾대떒 諛고룷 湲덉?";
    const sid = sessionId ? ` 쨌 ${sessionId.slice(0, 8)}` : "";
    return `${base}${sid}`;
  }, [sessionId, text]);

  if (!enabled) return null;

  return (
    <div className="pointer-events-none absolute inset-0 select-none">
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="rounded bg-black/20 px-3 py-1 text-xs font-bold text-white/40">
          {label}
        </div>
      </div>
    </div>
  );
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\deviceId.ts
====================

// src/features/media/playback/utils/deviceId.ts

/**
 * device_id???뺤콉(湲곌린 ?쒗븳/?숈떆?묒냽)?먯꽌 留ㅼ슦 以묒슂.
 * ??token/policy/progress ??μ? 湲덉?吏留?
 * ??device_id??"湲곌린 ?앸퀎????????덉슜(?κ린 ?댁쁺???좊━)
 */
const KEY = "device_id_v1";

function randomId() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

export function getDeviceId(): string {
  try {
    const existing = localStorage.getItem(KEY);
    if (existing) return existing;

    const ua = typeof navigator !== "undefined" ? navigator.userAgent : "unknown";
    const id = `web:${ua.includes("Chrome") ? "chrome" : "browser"}:${randomId()}`;
    localStorage.setItem(KEY, id);
    return id;
  } catch {
    // localStorage 遺덇? ?섍꼍(?ы뙆由??꾨씪?대퉿 ?? ??硫붾え由??泥?
    return `web:volatile:${randomId()}`;
  }
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\resolvePlayUrl.ts
====================

// src/features/media/playback/utils/resolvePlayUrl.ts

function stripTrailingSlash(s: string) {
  return s.endsWith("/") ? s.slice(0, -1) : s;
}

export function resolvePlayUrl(playUrl: string): string {
  if (!playUrl) return playUrl;

  // ?대? ?덈? URL
  if (playUrl.startsWith("http://") || playUrl.startsWith("https://")) {
    return playUrl;
  }

  const cdn = (import.meta as any).env?.VITE_CDN_URL as string | undefined;
  const api = (import.meta as any).env?.VITE_API_URL as string | undefined;

  const base = cdn || api || "";
  if (!base) {
    // base ?놁쑝硫??곷?寃쎈줈 洹몃?濡?(dev?먯꽌 proxy ?곕뒗 寃쎌슦)
    return playUrl;
  }

  return `${stripTrailingSlash(base)}${playUrl.startsWith("/") ? "" : "/"}${playUrl}`;
}


====================
FILE: C:\academyfront\src\features\media\playback\utils\time.ts
====================

// src/features/media/playback/utils/time.ts

export function nowEpochSeconds(): number {
  return Math.floor(Date.now() / 1000);
}


====================
FILE: C:\academyfront\src\features\videos\pages\VideoDetailPage.tsx
====================

// src/features/videos/pages/VideoDetailPage.tsx
// ?좑툘 愿由ъ옄???곸긽 ?곸꽭 ?섏씠吏
// ?좑툘 ?숈깮 ?ъ깮? media/playback/player/StudentVideoPlayer ?먯꽌 泥섎━??

import { useEffect, useState } from "react";
import { useParams, Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import PageContainer from "@/layouts/default/PageContainer";
import PageHeader from "@/shared/ui/PageHeader";

import api from "@/shared/api/axios";
import AdminVideoPlayer from "@/features/videos/components/AdminVideoPlayer";
import StudentWatchPanel from "@/features/videos/components/StudentWatchPanel";
import PermissionModal from "@/features/videos/components/PermissionModal";
import ToggleSwitch from "@/features/videos/components/ToggleSwitch";

// --------------------------------------------------
// URL RESOLVE (ADMIN PREVIEW ONLY)
// ?숈깮 ?ъ깮?먯꽌???ъ슜 ??
// --------------------------------------------------
function resolveUrl(url: string | null) {
  if (!url) return null;
  if (url.startsWith("http")) return url;

  const base = import.meta.env.VITE_API_URL ?? "http://localhost:8000";
  return `${base}${url}`;
}

// --------------------------------------------------
// PAGE
// --------------------------------------------------
export default function VideoDetailPage() {
  const params = useParams();
  const lectureId = Number(params.lectureId);
  const sessionId = Number(params.sessionId);
  const videoId = Number(params.videoId);

  const id = videoId;

  const [memo, setMemo] = useState("");
  const [open, setOpen] = useState(false);

  // 愿由ъ옄 ?뺤콉 ?곹깭
  const [allowSkip, setAllowSkip] = useState(false);
  const [maxSpeed, setMaxSpeed] = useState(1.0);
  const [showWatermark, setShowWatermark] = useState(true);
  const [dirty, setDirty] = useState(false);

  const qc = useQueryClient();

  // --------------------------------------------------
  // FETCH
  // --------------------------------------------------
  const { data, isLoading, error } = useQuery({
    queryKey: ["video-stats", id],
    queryFn: async () => {
      const res = await api.get(`/lectures/videos/${id}/stats/`);
      return res.data;
    },
    enabled: !!id,
  });

  const { data: session } = useQuery({
    queryKey: ["session", sessionId],
    queryFn: async () => {
      const res = await api.get(`/lectures/sessions/${sessionId}/`);
      return res.data;
    },
    enabled: !!sessionId,
  });

  // --------------------------------------------------
  // DERIVED
  // --------------------------------------------------
  const video = data?.video;
  const stats = data?.stats;
  const students = data?.students ?? [];

  const sessionTitle =
    session?.title || (session?.order ? `${session.order}李⑥떆` : "");

  // 愿由ъ옄 誘몃━蹂닿린??src
  const src =
    video?.source_type === "file"
      ? resolveUrl(video.file)
      : video?.source_type === "youtube"
      ? `https://www.youtube.com/embed/${video.youtube_id}`
      : video?.external_url || null;

  const avgProgress =
    stats?.avg_progress != null ? (stats.avg_progress * 100).toFixed(1) : "0.0";

  // --------------------------------------------------
  // INIT policy state
  // --------------------------------------------------
  useEffect(() => {
    if (!video) return;

    setAllowSkip(video.allow_skip ?? false);
    setMaxSpeed(video.max_speed ?? 1.0);
    setShowWatermark(video.show_watermark ?? true);

    setDirty(false);
  }, [video?.id]);

  // --------------------------------------------------
  // SAVE POLICY
  // --------------------------------------------------
  const policyMutation = useMutation({
    mutationFn: async () => {
      if (!video) return;

      await api.post(`/lectures/videos/${video.id}/set-policy/`, {
        allow_skip: allowSkip,
        max_speed: maxSpeed,
        show_watermark: showWatermark,
      });
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["video-stats", id] });
      setDirty(false);
    },
  });

  // --------------------------------------------------
  // SAFETY
  // --------------------------------------------------
  if (!id) return <PageContainer>?섎せ??URL</PageContainer>;
  if (isLoading) return <PageContainer>濡쒕뵫以?..</PageContainer>;
  if (error)
    return (
      <PageContainer>
        <div className="text-red-500">?먮윭 諛쒖깮</div>
      </PageContainer>
    );
  if (!video) return <PageContainer>?곸긽 ?놁쓬</PageContainer>;

  // --------------------------------------------------
  // UI
  // --------------------------------------------------
  return (
    <PageContainer>
      <PageHeader
        title={sessionTitle || video.title}
        actions={
          <Link
            to={`/lectures/${lectureId}/sessions/${sessionId}`}
            className="rounded border border-gray-300 px-3 py-1.5 text-sm"
          >
            異쒖꽍 ?붾㈃?쇰줈
          </Link>
        }
      />

      <div className="text-sm text-gray-600 mb-6">
        <span className="font-medium text-gray-700 mr-2">{video.title}</span>
        {video.source_type === "file" && <span>?뚯씪 ?곸긽</span>}
        {video.source_type === "youtube" && <span>?좏뒠釉??곸긽</span>}
        {video.source_type === "external" && <span>?몃? 留곹겕</span>}
      </div>

      <div className="flex gap-6">
        {/* LEFT */}
        <div className="flex flex-col gap-6 w-[750px]">

          {/* ADMIN VIDEO PREVIEW */}
          {src && (
            <div className="w-full">
              {video.source_type === "file" ? (
                <AdminVideoPlayer
                  src={src}
                  rule="free"
                  showWatermark={showWatermark}
                  watermarkImage="/watermark.png"
                  watermarkOpacity={0.12}
                  watermarkSize={200}
                />
              ) : (
                <div className="aspect-video w-full overflow-hidden rounded border bg-black">
                  <iframe src={src} className="w-full h-full" allowFullScreen />
                </div>
              )}
            </div>
          )}

          {/* POLICY PANEL */}
          <div className="rounded border bg-white p-4 text-sm space-y-3">
            <div className="font-semibold">?숈깮 ?쒖껌 ?뺤콉</div>

            <div className="flex items-center flex-wrap gap-6 text-xs">

              <label className="flex items-center gap-2">
                <span className="font-medium">?뚰꽣留덊겕</span>
                <ToggleSwitch
                  checked={showWatermark}
                  onChange={(v) => {
                    setShowWatermark(v);
                    setDirty(true);
                  }}
                />
              </label>

              <label className="flex items-center gap-2">
                <span className="font-medium">嫄대꼫?곌린</span>
                <ToggleSwitch
                  checked={allowSkip}
                  onChange={(v) => {
                    setAllowSkip(v);
                    setDirty(true);
                  }}
                />
              </label>

              <div className="flex items-center gap-2">
                <span className="font-medium">諛곗냽</span>
                <span className="font-bold">{maxSpeed.toFixed(2)}x</span>
              </div>

              <button
                onClick={() => policyMutation.mutate()}
                disabled={!dirty || policyMutation.isLoading}
                className={`ml-auto rounded px-4 py-1.5 text-xs font-semibold text-white ${
                  dirty
                    ? "bg-blue-600 hover:bg-blue-700"
                    : "bg-gray-400 cursor-not-allowed"
                }`}
              >
                {dirty ? "??? : "??λ맖"}
              </button>
            </div>
          </div>
        </div>

        {/* RIGHT */}
        <StudentWatchPanel
          students={students}
          onOpenPermission={() => setOpen(true)}
        />
      </div>

      <PermissionModal open={open} onClose={() => setOpen(false)} videoId={id} />
    </PageContainer>
  );
}


====================
FILE: C:\academyfront\src\features\videos\api\videos.ts
====================

// src/features/lectures/api/videos.ts

import api from "@/shared/api/axios";

// ------------------------
// Types
// ------------------------

export interface Video {
  id: number;
  session: number;
  title: string;
  youtube_id: string | null;
  external_url: string | null;
  file: string | null;
  duration: number | null;
  order: number;
  created_at: string;
  updated_at: string;

  source_type: "file" | "youtube" | "external" | "unknown";
  file_size: number | null;
}

export interface VideoDetail extends Video {}

export interface VideoStatsStudent {
  enrollment: number;

  student_id: number;
  student_name: string;

  parent_phone: string | null;
  student_phone: string | null;
  school: string | null;
  grade: number | null;

  attendance_status: string | null;
  progress: number;
  completed: boolean;

  rule: string | null;
  is_override: boolean;
  effective_rule: string | null;
}

export interface VideoStats {
  video: VideoDetail;
  stats: {
    total_students: number;
    completed_100: number;
    completed_90: number;
    avg_progress: number;
  };
  students: VideoStatsStudent[];
}

export interface VideoProgress {
  id: number;
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
  updated_at: string;
  student_name?: string;
}

// ------------------------
// List
// ------------------------

export async function fetchSessionVideos(sessionId: number): Promise<Video[]> {
  const res = await api.get("/lectures/videos/", {
    params: { session: sessionId },
  });
  return res.data.results ?? res.data;
}

// ------------------------
// Detail
// ------------------------

export async function fetchVideoDetail(videoId: number): Promise<VideoDetail> {
  const res = await api.get(`/lectures/videos/${videoId}/`);
  return res.data;
}

// ------------------------
// Stats
// ------------------------

export async function fetchVideoStats(videoId: number): Promise<VideoStats> {
  const res = await api.get(`/lectures/videos/${videoId}/stats/`);
  return res.data;
}

// ------------------------
// Create / URL
// ------------------------

export async function createVideoUrl(payload: {
  session: number;
  title: string;
  url: string;
}): Promise<Video> {
  const res = await api.post("/lectures/videos/add-url/", payload);
  return res.data;
}

// ------------------------
// Create / File
// ------------------------

export async function createVideoFile(payload: {
  session: number;
  title: string;
  file: File;
}): Promise<Video[]> {
  const form = new FormData();
  form.append("session", String(payload.session));
  form.append("files", payload.file);

  const res = await api.post("/lectures/videos/upload/", form, {
    headers: { "Content-Type": "multipart/form-data" },
  });

  return res.data;
}

// ------------------------
// Delete
// ------------------------

export async function deleteVideo(videoId: number): Promise<void> {
  await api.delete(`/lectures/videos/${videoId}/`);
}

// ------------------------
// Progress (?먮룞 吏꾨룄 ?낅뜲?댄듃)
// ------------------------

export async function updateVideoProgress(payload: {
  video: number;
  enrollment: number;
  progress: number;
  last_position: number;
  completed: boolean;
}): Promise<VideoProgress> {
  const res = await api.post(
    "/lectures/video-progress/update_progress/",
    payload,
  );
  return res.data;
}
